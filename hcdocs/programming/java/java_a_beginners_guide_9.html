<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>HC Docs</title>
        <style>
        body {
          font-family: sans-serif;
        }

        a {
          text-decoration: none;
          display: inline-block;
          color: #21c;
        }

        a:visited {
          color: #82a;
        }

        a.index {
          margin-bottom: 1rem;
        }

        h2, h3, h4 {
          margin-top: 2.75rem;
        }

        li {
          margin: 0.25rem 0;
        }

        pre {
          box-sizing: border-box;
          margin: 1rem;
          padding: 1rem;
          border: 1px solid #ccc;
          background-color: #ffefd5;
          border-radius: 0.8rem;
          overflow: auto;
          min-width: calc(100% - 2rem);
          font-size: 1rem;
        }

        code {
          padding: 0 0.2rem;
          color: #062;
          font-size: 1rem;
        }

        pre > code {
          padding: 0;
        }

        .hc-monospace {
          font-family: monospace;
        }

        .content {
          max-width: 820px;
          margin-left: auto;
          margin-right: auto;
        }

        table {
          border-collapse: collapse;
        }

        td {
          padding: 0.5rem 0.8rem;
          border: 1px solid #ccc;
        }
        </style>
    </head>
    <body>
      <div style="position: fixed; top: 0; padding: 0.5em; background-color: #fff;">
        <a href="javascript:history.back()">&#x1F519; bk</a>&nbsp;&nbsp;
        <a href="#top">&#x1F51D; top</a>&nbsp;&nbsp;
        <a href="index.html">&#x1F4C2; dir</a>&nbsp;&nbsp;
        <a href="../index.html">&#x23EB; up</a>
      </div>
      <div id="top">&nbsp;</div>
      <div class="content">


    <h3><a href="../../index.html">home</a> / <a href="../index.html">programming</a> / <a href="index.html">java</a></h3>
    
<h1>Java: A Beginner's Guide, 9th ed.</h1>

<h2>Contents</h2>

<ol>
  <li><a href="#ch01">Java Fundamentals</a></li>
  <li><a href="#ch02">Introducing Data Types and Operators</a></li>
  <li><a href="#ch03">Program Control Statements</a></li>
  <li><a href="#ch04">Introducing Classes, Objects, and Methods</a></li>
  <li><a href="#ch05">More Data Types and Operators</a></li>
  <li><a href="#ch06">A Closer Look at Methods and Classes</a></li>
  <li><a href="#ch07">Inheritance</a></li>
  <li><a href="#ch08">Packages and Interfaces <em>(skipped)</em></a></li>
  <li><a href="#ch09">Exception Handling <em>(skipped)</em></a></li>
  <li><a href="#ch10">Using I/O <em>(skipped)</em></a></li>
  <li><a href="#ch11">Multithreaded Programming <em>(skipped)</em></a></li>
  <li><a href="#ch12">Enumerations, Autoboxing, Annotations, and More <em>(skipped)</em></a></li>
  <li><a href="#ch13">Generics</a></li>
  <li><a href="#ch14">Lambda Expressions and Method References</a></li>
  <li><a href="#ch15">Modules</a></li>
  <li><a href="#ch16">Switch Expressions, Records, and Other Recently Added Features <em>(skipped)</em></a></li>
  <li><a href="#ch17">Introducing Swing <em>(skipped)</em></a></li>
</ol>

<h2 id="ch01">1. Java Fundamentals</h2>

<p>
  JDK 9 added the <strong>jlink</strong> tool and JDK 16 added <strong>jpackage</strong>. They create a complete run-time image that includes all the needed support for your program, including the JRE.
</p>

<p>
  <em>Encapsulation</em> is a mechanism that binds together code and the data it manipulates, keeping both safe from outside interference and misuse. <strong>Analogy</strong>: a self-contained black box.
</p>

<p>
  Java's basic unit of encapsulation is the <em>class</em>. <em>Objects</em> are instances of a class. A class may be seen as a set of plans that specify how to build an object.
</p>

<p>
  Code and data that constitute a class are called <em>members</em> of the class. Data is called <em>member variables</em> or <em>instance variables</em>. The code that operates on that data are called <em>methods</em>.
</p>

<p>
  <em>Polymorphism</em> (coming from Greek meaning "many forms") is the quality that allows one interface to access a general class of actions. The specific action depends on the nature of the situation. <strong>Analogy</strong>: the steering wheel of a vehicle. The steering wheel is the interface, and it is the same no matter what kind of actual steering mechanism is used (manual steering, power steering, rack-and-pinion steering).
</p>

<p>
  Another example of polymorphism is creating general code for stack routines that will work on multiple implementations of stacks (such as for integers, floating-point numbers, and strings).
</p>

<p>
  Polymorphism allows using the same interface to specify a general class of action. One way of thinking of its behavior is "one interface, multiple methods".
</p>

<p>
  <em>Inheritance</em> is the process by which one object can acquire the properties of another object (its parent). <strong>Example</strong>: A <code>RedDelicious</code> is part of the <code>Apple</code> class, which in turn, is part of the <code>Food</code> class.
</p>

<pre>
/*
  A simple Java program (save as Example.java)
*/

class Example {
  public static void main(String[] args) {
    System.out.println("Java drives the Web");
  }
}
</pre>

<p>
  In Java, the source file's name must match the main class inside it. Although in simple cases, not following this requirement will still produce executable code, there are cases where it is required.
</p>

<p>
  To compile and run the code above:
</p>

<pre>
javac Example.java
java Example
</pre>

<p>
  Since JDK 11, it's possible to run simple source files with <code>java Example.java</code>. However, in Ubuntu, there is no autocomplete for <code>.java</code> files. This can be circumvented by defining a bash alias: <code>alias j='java'</code>
</p>

<p>
  An <em>access modifier</em> determines how other parts of a program can access the members of the class. <strong>public</strong> members can be accessed by code outside the class in which it is declared. There is also <strong>private</strong> and <strong>protected</strong> (not described in this chapter).
</p>

<p>
  A <strong>static</strong> method can be called without requiring that an object of the class be created. Here, <strong>main()</strong> is called by the JVM before any objects are made, so it must be <strong>static</strong>.
</p>

<h3>Assigning a value to a variable</h3>

<pre>
class Example2 {
  public static void main(String[] args) {
    int myVar;
    myVar = 1024;

    System.out.println("myVar is " + myVar);  // note that we are concatenating a String and an int
  }
}
</pre>

<h3>The <code>if</code> statement</h3>

<pre>
if (a < b) System.out.println("a is less than b");
</pre>

<h3>The <code>for</code> loop</h3>

<pre>
int count;

for (count = 0; count < 5; count++) {
  System.out.println("count is " + count);
}
</pre>

<h3>Context-sensitive keywords</h3>

<p>
  <code>exports, module, open, opens, provides, requires, to, transitive, uses, with, record, sealed, non-sealed, permits, yield, var</code>
</p>

<p>
  An underscore by itself is considered a keyword.
</p>

<h3>Keywords that might accidentally be used</h3>

<p>
  <code>boolean, byte, char, double, enum, float, int, long, modlue, open, record, short, var</code>
</p>

<h2 id="ch02">2. Introducing Data Types and Operators</h2>

<p>
  Java is a strongly typed language (all operations are type-checked by the compiler).
</p>

<h3>Java's Primitive Types</h3>

<p>
  There are two general categories of built-in data types: object-oriented and non-object-oriented. Object-oriented types are defined by classes.
</p>

<p>
  There are eight primitive types (also called elemental or simple types): <code>boolean, byte, short, int, long, float, double, char</code>.
</p>

<h3>Characters</h3>

<p>
  A <code>char</code> is an unsigned 16-bit type with a range of 0 to 65,535.
</p>

<p>
  Character constants (literals) are enclosed in single quotes, such as <code>'a'</code>.
</p>

<h3>The Boolean Type</h3>

<p>
  The <code>boolean</code> type represents a truth value (with the reserved words <code>true</code> and <code>false</code>).
</p>

<p>
  With a Boolean <code>b</code>, the statement <code>if (b)</code> is enough; there is no need to write <code>if (b == true)</code>.
</p>

<h3>Number literals</h3>

<p>
  A whole number followed by <code>L</code> is a <code>long</code>. A floating-point number followed by <code>F</code> is a <code>float</code>.
</p>

<p>
  You can embed underscores into an integer or floating-point literal: <code>123_45_1234</code>
</p>

<h3>Literals in other number bases</h3>

<pre>
hex = 0xff;   // 255
oct = 011;    // 9
bin = 0b1100  // 12
</pre>

<h3>Character escape sequences</h3>

<p>
  <em>Escape sequences</em> (also called backslash character constants) are used in place of the characters they represent. For example: <code>\'</code>, <code>\n</code>, <code>\uxxxx</code> (where <code>xxxx</code> is a hexadecimal constant).
</p>

<p>
  A string literal is enclosed by double quotes. <strong>Warning</strong>: a <code>char</code> <code>'k'</code> is not the same thing as a string <code>"k"</code> consisting of the single character <code>'k'</code>.
</p>

<h3>The scope and lifetime of variables</h3>

<p>
  Variables may be declared within any block (denoted by opening and closing curly braces). Blocks define <em>scope</em>.
</p>

<p>
  The most common scopes are the <em>class scope</em> and <em>method scope</em>.
</p>

<p>
  A method's parameters are included within the method's scope. Variables declared within a block are called <em>local variables</em>.
</p>

<p>
  Scopes can be nested. Objects declared in the outer scope will be visible to code within the inner scope. However, the reverse is not true.
</p>

<pre>
class ScopeDemo {
  public static void main(String[] args) {
    int x;
    x = 10;
    if (x == 10) {  // start new scope
      int y = 20;
      System.out.println("At the start of if block, x and y are " + x + " " + y);
      x = y * 2;
      System.out.println("After reassigning x, it is " + x);
    }
    System.out.println("After exiting the if block, x is " + x);
  }
}
</pre>

<p>
  Variable names cannot shadow those in an outer scope. In other words, no variable declared within an inner scope can have the same name as a variable declared by an enclosing scope.
</p>

<h3>Increment operator behavior</h3>

<p>
  <code>++x</code> results in the increment happening before obtaining <code>x</code>'s value, and <code>x++</code> obtains <code>x</code>'s value before incrementing it.
</p>

<pre>
x = 10;
y = ++x;  // y = 11 and x = 11

x = 10;
y = x++;  // y = 10 and x = 11
</pre>

<h3>Logical operators</h3>

<p>
  The <code>&amp;&amp;</code> and <code>||</code> operators are short-circuiting. The formal names are <em>conditional-and</em> and <em>conditional-or</em> operators.
</p>

<h3>Type conversion in assignments</h3>

<p>
  When one type of data is assigned to another type of variable, an <em>automatic type conversion</em> takes place if the two types are compatible, and if the destination type is larger than the source type. A <em>widening conversion</em> takes place. For example, an automatic conversion from <code>byte</code> to <code>int</code> can be applied. Integers ane floating-point types may be mixed, so a <code>long</code> to <code>double</code> conversion is automatically performed.
</p>

<p>
  However, a <code>double</code> to <code>long</code> conversion is not a widening conversion, and is not automatically performed.
</p>

<p>
  There are no automatic conversions from numeric types to <code>char</code> or <code>boolean</code>. However, it is possible to assign an integer literal to <code>char</code>.
</p>

<h3>Casting incompatible types</h3>

<p>
  A <em>cast</em> is an instruction to the compiler to convert one type into another (an explicit type conversion). For example:
</p>

<pre>
double x, y;
int i;
x = 19;
y = 5;
i = (int) (x / y);
System.out.println(i);  // 3
</pre>

<p>
  The cast shown above is a <em>narrowing conversion</em>. Information may be lost in such conversions (the fractional part of <code>19 / 5</code> is lost). If a long's value is greater than the range of a short, high-order bits are removed.
</p>

<p>
  When an integer value needs to be assigned to a <code>char</code>, a cast may be performed:
</p>

<pre>
byte b = 88;
char ch;
ch = (char) b;
</pre>

<h3>Type conversion in expressions</h3>

<p>
  <em>Type promotion</em> occurs when two different types are mixed in an expression. Type promotions apply only to the values operated upon when an expression is evaluated. That is, a <code>byte</code> variable continues to be a byte even if its value is promoted in another expression. Mixing integers and floats promotes the integer to a float.
</p>

<p>
  <strong>Warning</strong>: <code>byte</code>s are promoted to <code>int</code>, so the result of a calculation of two bytes is an <code>int</code> that needs to be cast back to a <code>byte</code>.
</p>

<pre>
byte b = 10;
int i;

i = b * b;  // no cast needed
b = (byte) (b * b)  // cast needed
</pre>

<h2 id="ch03">3. Program Control Statements</h2>

<p>
  There are three categories of program control statements:
</p>

<table>
  <tr>
    <td>Selection statements</td>
    <td><code>if, switch</code></td>
  </tr>
  <tr>
    <td>Iteration statements</td>
    <td><code>for, while, do-while</code></td>
  </tr>
  <tr>
    <td>Jump statements</td>
    <td><code>break, continue, return</code></td>
  </tr>
</table>

<h3>Input characters from the keyboard</h3>

<p>
  <code>System.in.read()</code> waits until the user presses a key, then Enter, and returns the result (as an integer that needs to be cast to a <code>char</code>).
</p>

<pre>
class KeyboardIn {
  public static void main(String[] args) throws java.io.IOException {
    char ch;
    System.out.print("Press a key followed by Enter: ");
    ch = (char) System.in.read();
    System.out.println("You typed: " + ch);
  }
}
</pre>

<h3><code>if, else-if, else</code> ladder</h3>

<p>
  Branches of an <code>if</code> statement is written:
</p>

<pre>
if (condition)
  then-statement;
else if (condition-2)
  then-statement;
else if (condition-3)
  then-statement;
.
.
.
else
  statement;  // a default condition
</pre>

<h3>The traditional <code>switch</code> statement</h3>

<pre>
switch (expression) {
  case constant-1:
    statement-sequence
    break;
  case constant-1:
    statement-sequence
    break;
  .
  .
  .
  default:  // optional
    statement-sequence
}
</pre>

<p>
  The <em>expression</em> controlling the <code>switch</code> may be an integer, char, String, or variable.
</p>

<p>
  If <code>break</code> is omitted, all statements following the matching <code>case</code> will also be executed (until a <code>break</code> is encountered). The case without a <code>break</code> falls through to the next case.
</p>

<p>
  It is possible to "stack" cases:
</p>

<pre>
switch (i) {
  case 1:
  case 2:
  case 3:
    System.out.println("i is 1, 2, or 3");
    break;
  default:
    System.out.println("i is not 1, 2, or 3");
}
</pre>

<p>
  It is possible to nest <code>switch</code> statements. The constants of the inner and outer <code>switch</code>es may contain common values; there won't be conflicts.
</p>

<pre>
switch (ch1) {
  case 'A':
    switch(ch2) {
      case 'A':
        ...
        break;
    }
  break;
}
</pre>

<h3>Variations on the <code>for</code> loop</h3>

<p>
  Multiple loop control variables can be used:
</p>

<pre>
int i, j;

for (i=0, j=10; i < j; i++, j--) {
  // loop body
}
</pre>

<p>
  The initialization, condition, and iteration portions of the <code>for</code> loop may be left blank.
</p>

<p>
  It is also possible to create a <code>for</code> loop without a body:
</p>

<pre>
int i;
int sum = 0;
for (i = 1; i <= 5; sum += i++);
</pre>

<p>
  Loop control variables are commonly declared inside the <code>for</code> loop:
</p>

<pre>
for (int i = 1; i <= 5; i++) {
  // ...
}
</pre>

<h3>The <code>while</code> loop</h3>

<p>
  The general form of a <code>while</code> loop is: <code>while (condition) statement;</code>
</p>

<p>
  If the condition is not true, the loop code will not execute at all.
</p>

<h3>The <code>do-while</code> loop</h3>

<p>
  The <code>do-while</code> loop checks its condition at the bottom of the loop, so the body will always execute at least once.
</p>

<pre>
do {
  statements;
} while (condition)
</pre>

<h3>The labeled <code>break</code> and <code>continue</code> statement</h3>

<p>
  It is possible to break out of nested loops when blocks are labeled:
</p>

<pre>
for (int i = 1; i < 4; i++) {
one: {
  two: {
    three: {
        System.out.println("i is " + i);
        if (i == 1) break one;
      }
    }
  }
}
</pre>

<p>
  You cannot <code>break</code> to a label that is not defined for an enclosing block (it would be like a <code>GOTO</code> and it's not allowed).
</p>

<p>
  <code>continue</code> may also have a label added after it.
</p>

<h2 id="ch04">4. Introducing Classes, Objects, and Methods</h2>

<p>
  A class is a template that defines the form of an object. It is a set of plans that specify how to build an object. As a logical abstraction, it specifies the data and the code that will operate on that data. Classes construct objects. Objects are <em>instances</em> of a class.
</p>

<p>
  Methods and variables that constitute a class are called <em>members</em> Data members are also referred to as <em>instance variables</em>.
</p>

<h3>A class example: <code>Vehicle</code></h3>

<pre>
class Vehicle {
  int passengers;  // number of passengers the vehicle can carry
  int fuelcap;  // fuel capacity in gallons
  int mpg;  // fuel consumption in miles per gallon
}
</pre>

<p>
  To create an instance of <code>Vehicle</code>:
</p>

<pre>
Vehicle minivan = new Vehicle();
</pre>

<p>
  <strong>Note</strong>: <code>Vehicle.java</code> and <code>VehicleDemo.java</code> may be in separate files, and only <code>VehicleDemo.java</code> needs to be compiled.
</p>

<p>
  If using the <code>java</code> command for a single file, such as <code>java VehicleDemo.java</code>, the class with <code>main</code> must come first.
</p>

<h3>How objects are created</h3>

<p>
  The <code>new</code> operator dynamically allocates memory for an object and returns a <em>reference</em> to it (the address in memory of the new object).
</p>

<h3>Reference variables and assignment</h3>

<p>
  In assignment operations, object reference variables act differently than variables of primitive types, such as <code>int</code>.
</p>

<p>
  Primitive types are copied. However, assigning an existing reference value to another reference variable results in both variables referring to the same object.
</p>

<pre>
Vehicle car1 = new Vehicle();
Vehicle car2 = car1;
</pre>

<p>
  Above, <code>car1</code> and <code>car2</code> refer to the same <code>Vehicle</code>.
</p>

<p>
  Later, <code>car2</code> may be assigned to another <code>Vehicle</code>, and <code>car1</code> will remain unchanged.
</p>

<h3>Method example: <code>Vehicle</code></h3>

<pre>
class Vehicle {
  int passengers;  // number of passengers the vehicle can carry
  int fuelcap;  // fuel capacity in gallons
  int mpg;  // fuel consumption in miles per gallon

  void range() {
    System.out.println("Range is " + fuelcap * mpg);
  }
}
</pre>

<p>
  Inside a method, instance variables are referred to directly, without preceding them with an object name or the dot operator (<code>fuelcap * mpg</code>).
</p>

<h3>Parameters and arguments</h3>

<p>
  A value passed to a method is called an <em>argument</em>. Inside the method, the variable that receives the argument is called a <em>parameter</em>.
</p>

<h3>Example of a parameterized method</h3>

<pre>
double fuelNeeded(int miles) {
  return (double) miles / mpg;
}
</pre>

<h3>Constructors</h3>

<p>
  A <em>constructor</em> initializes an object when it is created. For example:
</p>

<pre>
class MyClass {
  int x;

  MyClass() {
    x = 10;
  }
}
</pre>

<p>
  The default constructor initializes numbers to <code>0</code>, Booleans to <code>false</code> and reference types to <code>null</code>.
</p>

<p>
  Constructors may be parameterized:
</p>

<pre>
class MyClass {
  int x;

  MyClass(int i) {
    x = i;
  }
}
</pre>

<p>
  For the <code>Vehicle</code> example, a new <code>Vehicle</code> may be created with: <code>Vehicle minivan = new Vehicle(7, 16, 21);</code>
</p>

<h3>The <code>this</code> keyword</h3>

<p>
  When a method is called, it is automatically passed an implicit argument that is a reference to the invoking object (the object on which the method is called). This reference is called <code>this</code>. Consider a program <code>Pwr</code> that computes the result of a number raised to an integer power:
</p>

<pre>
class Pwr {
  double b;
  int e;
  double val;

  Pwr(double base, int exp) {
    b = base;
    e = exp;

    val = 1;
    if (exp == 0) return;
    for ( ; exp > 0; exp--) {
      val *= base;
    }
  }

  double getVal() {
    return val;
  }
}
</pre>

<p>
  <code>return val;</code> could have been written <code>return this.val;</code>. Writing the statement without <code>this</code> is really just shorthand. Generally, Java programmers write the standard form.
</p>

<p>
  <code>this</code> can be used when a local name <em>hides</em> the instance variable (<code>this</code> "uncovers" the instance variables):
</p>

<pre>
Pwr(double b, int e) {
  this.b = b;
  this.e = e;
}
</pre>

<h2 id="ch05">5. More Data Types and Operators</h2>

<h3>Arrays</h3>

<p>
  An <em>array</em> is a collection of variables of the same type, referred to by a common name. They conveniently group together related variables.
</p>

<p>
  The element type of an array is also called its <em>base type</em>.
</p>

<p>
  The number of elements the array will hold is its <em>size</em>, or <em>length</em>. For example:
</p>

<pre>
int[] sample = new int[10];
</pre>

<p>
  An array may be initialized with a literal, making it unnecessary to use the <code>new</code> keyword:
</p>

<pre>
int[] nums = { 99, -10, 1002, -14, 978 };
</pre>

<p>
  Example: bubble sort
</p>

<pre>
public static void main(String[] args) {
  int[] nums = { 99, -10, 1001, 18, -239, 463 };
  int size = 6;

  int a, b, t;
  for (a = 1; a < size; a++) {
    for (b = size - 1; b >= a; b--) {
      if (nums[b-1] > nums[b]) {
        t = nums[b-1];
        nums[b-1] = nums[b];
        nums[b] = t;
      }
    }
  }
}
</pre>

<h3>Two-dimensional arrays</h3>

<p>
  A two-dimensional array is an array of one-dimensional arrays. For example:
</p>

<pre>
int[][] table = new int[10][20];
</pre>

<p>
  When allocating memory for a multidimensional array, you need to specify only the memory for the first (leftmost) dimension. The remaining memory is allocated separately. For example:
</p>

<pre>
int[][] table = new int[3][];
table[0] = new int[4];
table[1] = new int[5];
table[2] = new int[6];
</pre>

<p>
  Multidimensional arrays may also be initialized with a literal:
</p>

<pre>
int[][] sqrs = {
  { 1, 1 },
  { 2, 4 },
  { 3, 9 },
  { 4, 16 },
  { 5, 25 }
};
</pre>

<h3>Assigning array references</h3>

<p>
  Similar to objects, assigning one array reference variable to another does not create a copy; the newly assigned variable and the source variable will refer to the same array.
</p>

<p>
  <code>length</code> is an instance variable that says how many elements the array can hold. <code>length</code> is the capacity of the array, not the number of elements that are actually in use. Let <code>table</code> be a two-dimensional array:
</p>

<pre>
nums.length
table.length  // number of arrays stored in table
table[0].length  // length of the individual array in table
</pre>

<h3>A Queue class</h3>

<p>
  A queue may be <em>circular</em> (it reuses locations in the underlying array when elements are removed) or <em>noncircular</em> (locations are not reused and eventually becomes exhausted).
</p>

<pre>
class Queue {
  char[] q;  // queue elements
  int putloc, getloc;  // put and get indices

  Queue(int size) {
    q = new char[size];
    putloc = getloc = 0;
  }

  void put(char ch) {
    if (putloc == q.length) {
      System.out.println(" - Queue is full");
      return;
    }
    q[putloc++] = ch;
  }

  char get() {
    if (getloc == putloc) {
      System.out.println(" - Queue is empty");
      return (char) 0;
    }
    return q[getloc++];
  }
}
</pre>

<h3>The For-each style for loop</h3>

<p>
  A for-each loop (also called <em>enhanced for loop</em>) cycles through a collection of objects from start to finish:
</p>

<pre>
int[] nums = { 1, 2, 3, 4, 5 };
int sum = 0;

for (int x : nums) {
  sum += x;
}
</pre>

<p>
  Many types of collections can be cycled, but this book only considers arrays.
</p>

<p>
  <strong>Warning</strong>: for-each iteration is in a sense "read-only" because changing the iteration variable has no effect on the underlying collection (such as the array being cycled through).
</p>

<h3>Iterating over multidimensional arrays</h3>

<p>
  The outer iteration variable must reference a one-dimensional array:
</p>

<pre>
int[][] nums = new int[3][5];

// ... initialize nums

for (int[] row : nums) {
  for (int x : row) {
    System.out.println("Current value is " + x);
  }
}
</pre>

<h3>Strings</h3>

<p>
  In Java, strings are objects. They are not arrays of characters.
</p>

<h3>General string methods</h3>

<p>
  <code>equals, length, charAt, compareTo, indexOf, lastIndexOf</code>. Applying <code>==</code> to two strings checks if the two references refer to the same object. Equality of contents must use <code>equals()</code>.
</p>

<h3>Strings are immutable</h3>

<p>
  The contents of a <code>String</code> object cannot be changed after it is created.
</p>

<p>
  <code>String substring(int startIndex, int endIndex)</code> creates a new string. <code>endIndex</code> is not included, so it can be the string's <code>length</code>. The length of the substring is <code>endIndex - startIndex</code>.
</p>

<p>
  A modifiable string can be created with the <code>StringBuffer</code> class. It defines <code>setCharAt()</code>. There is also a <code>StringBuilder</code> class.
</p>

<p>
  A <em>text block</em> allows entering multiline string literals (tabs and double-quote characters can be entered directly). They must start with three double-quote characters followed by a newline, <code>"""</code>. The final three double-quote characters can be anywhere. Indentation in lines after the first is preserved.
</p>

<h3>Using type inference with local variables</h3>

<p>
  When initializing a variable, it's possible to write: <code>var n = 10.0;</code> instead of <code>double</code>. The type of an anonymous class cannot be denoted, and it's useful to be able to declare it as <code>var</code>.
</p>

<p>
  <code>var</code> can be used to declare an array (note that <code>[]</code> is not used on the left side):
</p>

<pre>
var myArray = new int[10];
</pre>

<p>
  <code>var</code> is only allowed when declaring local variables. It cannot be used to declare instance variables, parameters, or return types.
</p>

<p>
  When initializing an object, <code>var</code> can make the code shorter and easier to read:
</p>

<pre>
var fin = new FileInputStream("test.txt");
</pre>

<p>
  <code>var</code> cannot be used with an array initializer, such as <code>{ 1, 2, 3 }</code>. In addition, it cannot be used to declare the exception type caught by a <code>catch</code> statement. Neither lambda expressions nor method references can be used as initializers.
</p>

<p>
  Generally speaking, using the full syntax makes the intention of the code more explicit than when using <code>var</code>.
</p>

<h3>Bitwise operators</h3>

<p>
  Bitwise <em>AND</em> can be thought of as a way of turning bits off. For example, setting the 6th bit to 0 converts a lowercase letter to uppercase:
</p>

<pre>
ch = (char) ((int) ch & 65503);  // 0b1111111111011111
</pre>

<p>
  <em>AND</em> can also be used to check if a bit is on or off.
</p>

<p>
  Bitwise <em>OR</em> works to turn bits on.
</p>

<p>
  The <em>unsigned right shift</em>, <code>&gt;&gt;&gt;</code>, always brings in a 0 on the left. For this reason, it's also called the <em>zero-fill right shift</em>.
</p>

<h3>The ? operator</h3>

<p>
  <code>?</code> (often called <em>the ternary operator</em>) is used to replace <code>if-else</code> statements:
</p>

<pre>
condition ? exp-1 : exp-2  // if condition is true, exp-1 is evaluated, otherwise, exp-2 is evaluated

absval = val < 0 ? -val : val;
</pre>

<h2 id="ch06">6. A Closer Look at Methods and Classes</h2>

<h3>Controlling access to class members</h3>

<p>
  The <em>access modifiers</em> are: <strong>public</strong>, <strong>private</strong>, and <strong>protected</strong>. If no access modifier is used, the <em>default access setting</em> is assumed. If code is not broken down into packages, it is the same as <strong>public</strong>.
</p>

<p>
  The <strong>protected</strong> modifier is used in inheritance. A <strong>protected</strong> member is accessible within its package and to subclasses in other packages.
</p>

<h3>Behavior of wrapper classes (Integer, Double, Character)</h3>

<p>
  Code such as:
</p>

<pre>
class ModifyInteger {
  public static void main(String[] args) {
    Integer i = new Integer(12);
    System.out.println(i);
    modify(i);
    System.out.println(i);
  }

  static void modify(Integer n) {
    n = n + 1;
    System.out.println("modified n to " + n);
  }
}
</pre>

<p>
  will result in:
</p>

<pre>
12
modified to 13
12
</pre>

<p>
  What is happening is that the variable <code>n</code> is a reference to <code>i</code>, but in the assignment <code>n = n + 1;</code>, a new <code>Integer</code> is created and this local variable will refer to the new Integer. The original <code>i</code> remains unchanged when <code>modify</code> returns.
</p>

<p>
  In addition, <code>Integer</code> is immutable, and is now deprecated.
</p>

<p>
  In Java, there is only call-by-value. What happens with objects is that the object's reference is passed.
</p>

<p>
  Both methods and constructors may be overloaded. Often, constructors are overloaded to allow one object to initialize another:
</p>

<pre>
class Summation {
  int sum;

  Summation(int num) {
    sum = 0;
    for (int i = 1; i <= num; i++) {
      sum += i;
    }
  }

  Summation(Summation ob) {
    sum = ob.sum;
  }
}
</pre>

<p>
  In the example above, when creating a new Summation object, it is more efficient to copy the argument's sum than to recompute it.
</p>

<h3>The <code>static</code> declaration</h3>

<p>
  A <strong>static</strong> member can be accessed before any objects of its class are created, and without reference to any object. Both variables and methods may be static.
</p>

<p>
  Outside the class, a static member needs to be preceded by its class' name and the dot operator: <code>Math.sqrt()</code>.
</p>

<p>
  A static variable is effectively a <em>global variable</em>.
</p>

<p>
  Static methods have several restrictions:
</p>

<ul>
  <li>They can directly call only other static methods in their class</li>
  <li>They can directly access only static variables in their class</li>
  <li>They do not have a <code>this</code> reference</li>
</ul>

<h3>Static blocks</h3>

<p>
  A static block is executed once, when a class is first loaded. This behavior is useful to run some type of initialization before a class creates objects.
</p>

<pre>
class StaticBlockDemo {
  public static void main(String[] args) {
    StaticBlock sb1 = new StaticBlock("sb1");
    System.out.println("Sq. root of 2 in of sb1 is " + sb1.rootOf2);

    StaticBlock sb2 = new StaticBlock("sb2");
    System.out.println("Sq. root of 2 in of sb2 is " + sb2.rootOf2);
  }
}

class StaticBlock {
  static double rootOf2;

  static {
    System.out.println("Inside static block");
    rootOf2 = Math.sqrt(2.0);
  }

  StaticBlock(String msg) {
    System.out.println("Constructing with message " + msg);
  }
}
</pre>

<h3>Nested and inner classes</h3>

<p>
  A nested class does not exist independently of its enclosing class. The scope of a nested class is bounded by its outer class. It may be declared as a member of its enclosing class, and also even as a class local to a block.
</p>

<p>
  Nested classes may be static or non-static. A static nested class can only access other static members of the enclosing class. A non-static nested class is also called an <em>inner class</em>. It has access to all of the variables and methods of its outer class. An inner class can be used to provide a set of services that is needed only by its enclosing class.
</p>

<h3>Varargs: variable-length arguments</h3>

<p>
  A method that takes a variable number of arguments is called a <em>varargs method</em>:
</p>

<pre>
static void vaTest(int ... v) {  // implicitly declares v as int[]
  System.out.println("Number of args: " + v.length);
}

// the variable-length parameter must be the last parameter
int f(int a, int b, double c, int ... vals) {
  // ...
}
</pre>

<h2 id="ch07">7. Inheritance</h2>

<p>
  A class that is inherited is called a <em>superclass</em>, while the class that does the inheriting is the <em>subclass</em>. A subclass is a specialized version of a superclass. Only one superclass can be specified for a subclass. For example:
</p>

<pre>
class TwoDShape {
  double width;
  double height;
}

class Triangle extends TwoDShape {
  String style;
  // ...
}
</pre>

<p>
  Private members are not inherited.
</p>

<h3>Constructors and inheritance</h3>

<p>
  What constructor is responsible for building an object of the subclass?
</p>

<p>
  <em>Answer</em>: The constructor for the superclass constructs the superclass portion of the object, and the constructor for the subclass constructs the subclass part. (Their construction are separate). When both the superclass and subclass define constructors, both constructors must be executed. <code>super</code> is used to call the superclass constructor. <code>super</code> has another use, which is to access a member of the superclass that has been hidden by a member of a subclass (similar to how <code>this</code> is used). See below.
</p>

<p>
  <code>super(parameter-list);</code> calls the superclass' constructor. The <code>super()</code> call must always be the first statement executed inside a subclass constructor.
</p>

<pre>
class Triangle extends TwoDShape {
  private String style;

  Triangle(String s, double w, double h) {
    super(w, h);
    style = s;
  }
}
</pre>

<h3>Using super to access superclass members</h3>

<p>
  <code>super.member</code> is used to access methods and instance variables of the superclass. It is used when member names of a subclass hide members of the same name in the superclass.
</p>

<h3>When are constructors executed?</h3>

<p>
  Constructors complete their execution in order of derivation (from superclass to subclass). For example:
</p>

<pre>
class A {
  A() {
    System.out.println("Constructing A");
  }
}

class B extends A {
  B() {
    System.out.println("Constructing B");
  }
}
</pre>

<p>
  <code>Constructing A</code> will be printed first.
</p>

<h3>Superclass references and subclass objects</h3>

<p>
  A reference variable of a superclass can be assigned a reference to an object of any subclass derived from the superclass. In other words, a superclass reference can refer to a subclass object.
</p>

<p>
  <strong>Important</strong>: When a reference to a subclass object is assigned to a superclass reference variable, you will only have access to thos parts of the object defined by the superclass (a superclass has no knowledge of what a subclass adds to it).
</p>

<p>
  An important place where subclass references are assigned to superclass variables is when constructors are called in a class hierarchy (it is common for a class to define a constructor that takes an object of the class as a parameter--this allows the class to construct a copy of an object).
</p>

<pre>
class TwoDShape {
  double width, height;

  TwoDShape() {
    // a default constructor
  }

  TwoDShape(TwoDShape ob) {
    width = ob.width;
    height = ob.height;
  }
}

class Triangle extends TwoDShape {
  String style;
  Triangle() {
    super();
    style = "none";
  }

  Triangle(Triangle ob) {
    super(ob);
    style = ob.style;
  }
}
</pre>

<p>
  In the example above, it's perfectly acceptable to pass a reference to an object of a subclass of <code>TwoDShape</code> to the <code>TwoDShape()</code> constructor.
</p>

<h3>Method overriding</h3>

<p>
  When a method in a subclass has the same return type and signature as a method in its superclass, the method <em>overrides</em> the method in the superclass. To access the superclass version of an overridden method, use <code>super.method()</code>
</p>

<h3>Overridden methods support polymorphism and dynamic method dispatch</h3>

<p>
  <em>Dynamic method dispatch</em> is the mechanism by which a call to an overridden method is resolved at run time rather than at compile time.
</p>

<p>
  When an overridden method is called through a superclass reference, Java determines which version of that method to execute based upon the type of the object being referred to at the time the call occurs.
</p>

<p>
  In other words, it is the type of the object being referred to, not the type of the reference variable, that determines which version of an overridden method will be executed.
</p>

<h3>Using abstract classes</h3>

<p>
  The <code>abstract</code> modifier applies only to instance methods. It cannot be applied to static methods or to constructors. Subclasses must override abstract methods.
</p>

<p>
  A class that contains one or more abstract methods must also be declared <code>abstract</code>.
</p>

<p>
  If a subclass does not implement a superclass' abstract method, the subclass must also be declared <code>abstract</code>.
</p>

<h3>Using final</h3>

<p>
  A method declared <code>final</code> cannot be overridden. You can prevent a class from being inherited by declaring it <code>final</code> (note that since abstract classes are to be subclassed, it cannot be final). A data member that is <code>final</code> cannot be changed, so in effect, it becomes a named constant.
</p>

<p>
  <code>final</code> and <code>static</code> may be used together. <code>final</code> may also be used with method parameters and local variables to prevent them from being reassigned.
</p>

<h3>The <code>Object</code> class</h3>

<p>
  <code>Object</code> is an implicit superclass of all other classes. This means that a reference variable of type <code>Object</code> can refer to an object of any other class, and even any array, since arrays are implemented as classes.
</p>

<p>
  Some methods defined on <code>Object</code> (and as a result, available in every object) are:
</p>

<p>
  <code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait</code>
</p>

<p>
  <code>getClass()</code> returns <code>Class&lt;?&gt;</code>. This is a <em>generics</em> feature, which allows the type of data used by a class or method to be specified as a parameter.
</p>

<h2 id="ch08">8. Packages and Interfaces</h2>

<h3>SKIP to Ch. 13</h3>

<h2 id="ch13">13. Generics</h2>

<p>
  The term <em>generics</em> means <em>parameterized types</em>. It is possible to create classes, interfaces, and methods in which the type of data upon which they operate is specified as a parameter. They are called <em>generic classes</em> and <em>generic methods</em>.
</p>

<p>
  Prior to generics, <code>Object</code> references were widely used. However, casting from <code>Object</code> is not type-safe. Generics allows writing type-safe code.
</p>

<p>
  Example:
</p>

<pre>
class GenDemo {
  public static void main(String[] args) {
    Gen&lt;Integer&gt; iOb;
    iOb = new Get&lt;Integer&gt;(88);
    iOb.showType();
  }
}

class Gen&lt;T&gt; {
  T ob;

  Gen(T o) {
    ob = o;
  }

  T getOb() {
    return ob;
  }

  void showType() {
    System.out.println("T is of type" + ob.getClass().getName());
  }
}
</pre>

</div>
<br>
<hr>
<div style="padding-left: 0.5em; background-color: #fff;">
  <a href="javascript:history.back()">&#x1F519; Back</a>&nbsp;&nbsp;&nbsp;
  <a href="#top">&#x1F51D; Top</a>&nbsp;&nbsp;&nbsp;
  <a href="index.html">&#x1F4C2; Dir list</a>&nbsp;&nbsp;&nbsp;
  <a href="../index.html">&#x23EB; Up</a>&nbsp;&nbsp;&nbsp;
</div>
<br><br><br>
    </body>
</html>

