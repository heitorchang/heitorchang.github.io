<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>HC Docs</title>
        <style>
        body {
          font-family: sans-serif;
        }

        a {
          text-decoration: none;
          display: inline-block;
          color: #21c;
        }

        a:visited {
          color: #82a;
        }

        a.index {
          margin-bottom: 1rem;
        }

        h2, h3, h4 {
          margin-top: 2.75rem;
        }

        li {
          margin: 0.25rem 0;
        }

        pre {
          box-sizing: border-box;
          margin: 1rem;
          padding: 1rem;
          border: 1px solid #ccc;
          background-color: #ffefd5;
          border-radius: 0.8rem;
          overflow: auto;
          min-width: calc(100% - 2rem);
          font-size: 1rem;
        }

        code {
          padding: 0 0.2rem;
          color: #062;
          font-size: 1rem;
        }

        .hc-monospace {
          font-family: monospace;
        }

        .content {
          max-width: 820px;
          margin-left: auto;
          margin-right: auto;
        }

        table {
          border-collapse: collapse;
        }

        td {
          padding: 0.5rem 0.8rem;
          border: 1px solid #ccc;
        }
        </style>
    </head>
    <body>
      <div style="position: fixed; top: 0; padding: 0.5em; background-color: #fff;">
        <a href="javascript:history.back()">&#x1F519; bk</a>&nbsp;&nbsp;
        <a href="#top">&#x1F51D; top</a>&nbsp;&nbsp;
        <a href="index.html">&#x1F4C2; dir</a>&nbsp;&nbsp;
        <a href="../index.html">&#x23EB; up</a>
      </div>
      <div id="top">&nbsp;</div>
      <div class="content">


    <h3><a href="../../index.html">home</a> / <a href="../index.html">programming</a> / <a href="index.html">python</a></h3>
    
<h1>Python Distilled, &copy; 2022</h1>

<h2>Contents</h2>

<ol>
  <li><a href="#ch01">Python Basics</a></li>
  <li><a href="#ch02">Operators, Expressions, and Data Manipulation</a></li>
  <li><a href="#ch03">Program Structure and Control Flow</a></li>
  <li><a href="#ch04">Objects, Types, and Protocols</a></li>
  <li><a href="#ch05">Functions</a></li>
  <li><a href="#ch06">Generators</a></li>
  <li><a href="#ch07">Classes and Object-Oriented Programming</a></li>
  <li><a href="#ch08">Modules and Packages</a></li>
  <!--
  <li><a href="#ch09">Input and Output</a></li>
  <li><a href="#ch10">Built-in Functions and Standard Library</a></li>
  -->
</ol>


<h2 id="ch01">1. Python Basics</h2>

<p>
  This book assumes Python 3.8 or newer.
</p>

<p>
  The underscore <code>_</code> variable in interactive sessions holds the result of the last operation.
</p>

<h3>1.3 Primitives, variables, and expressions</h3>

<p>
  The main primitive types are <code>int, float, str, bool</code>.
</p>

<p>
  A variable is a name that refers to a value. A value represents an object. When a variable's value is a mutable object, assigning another variable's value as the other variable will result in both variables referring to the same object.
</p>

<h3>1.5 Conditionals and control flow</h3>

<p>
  <code>if, elif, else, while</code> are used for looping and conditional code execution.
</p>

<p>
  To assign a value in combination with a test (the <code>else</code> clause is required):
</p>

<pre>
maxval = a if a > b else b
</pre>

<h3>1.6 Text strings</h3>

<p>
  Although <code>str()</code> and <code>repr()</code> both create strings, <code>str()</code> is called when using <code>print()</code>, while <code>repr()</code> should create a string that you type into a program to exactly represent the value of that object.
</p>

<h3>1.11 Dictionaries</h3>

<p>
  A tuple may be used as an entry's key (a multipart key):
</p>

<pre>
prices[('IBM', '2020-01-15')] = 91.23
prices['IBM', '2020-01-15'] = 91.23  # without parentheses
</pre>

<h3>1.13 Functions</h3>

<p>
  Functions can access variables defined outside of a function as long as they are defined in the same file:
</p>

<pre>
debug = True
a = 1

def f(x):
    if debug:
        print("in debug")
        print(a)
    print(f"end f with {x}")

if __name__ == "__main__":
    f(123)
</pre>

<h3>1.14 Exceptions</h3>

<p>
  To perform actions no matter what happens in a <code>try</code> block, use <code>try-finally</code> or a <code>with</code> block.
</p>

<h3>1.15 Program termination</h3>

<p>
  To force a program to quit:
</p>

<pre>
raise SystemExit()
raise SystemExit("Unexpected error")
</pre>

<p>
  To perform specific actions:
</p>

<pre>
import atexit

conn = open_connection("abc.com")

def cleanup():
    print("Cleaning up...")

atexit.register(cleanup)
</pre>

<h3>1.17 Modules</h3>

<p>
  A <em>module</em> is a file with statements and definitions. To use this module in other files, use the <code>import</code> statement.
</p>

<h3>1.19 Packages</h3>

<p>
  A package is a hierarchical collection of modules. In the filesystem, it is a directory containing an <code>__init__.py</code> file, which may be empty.
</p>

<p>
  The filesystem location of a package may be found with <code>pkg.__file__</code>
</p>

<h2 id="ch02">2. Operators, Expressions, and Data Manipulation</h2>

<p>
  In numeric literals, underscores may be added as a visual separator between digits: <code>1_2443_02_1.33</code> is <code>12443021.33</code>
</p>

<p>
  The left hand side of an assignment represents a location where a value or reference to an object is stored (such as a variable's name, an object's attribute, or an index within a container such as a list or dict).
</p>

<p>
  The "assignment expression" operator (also called the "walrus operator"), <code>:=</code>, combines expression evaluation and assignment. It is usually used in <code>if</code> and <code>while</code> statements.
</p>

<pre>
while (line := file.readline()):
    print(line)
</pre>

<p>
  If using <code>None</code> as a keyword argument's default value, check for it with <code>arg is None</code>, because the value passed may be falsy and will appear as if the value was not passed.
</p>

<p>
  Unpacking a variable number of items:
</p>

<pre>
items = [1, 2, 3, 4, 5]
a, b, *extra = items  # a = 1, b = 2, extra = [3, 4, 5]
</pre>

<p>
  "Splatting" (expanding) an iterable:
</p>

<pre>
items = [1, 2, 3]
a = [10, *items, 11]  # a = [10, 1, 2, 3, 11]
</pre>

<p>
  Operations on references to mutable objects copy the reference. So if one of the values in a referenced object changes, it will be seen in all copies.
</p>

<p>
  For lists, the constructor <code>list()</code> makes a unique copy:
</p>

<pre>
a = [3, 4, 5]
c = [list(a) for _ in range(4)]
</pre>

<h3>2.14 List, Set, and Dictionary Comprehensions</h3>

<pre>
nums = [1, 2, 3, 4, 5]
squares = [n * n for n in nums]

squares_n_is_3_or_more = [n * n for n in nums if n >= 3]  # [9, 16, 25]
</pre>

<p>
  Within a comprehension, it's not possible to do exception handling. As a workaround, wrap exceptions with a function, and use this function in the comprehension.
</p>

<pre>
def to_int(x):
    try:
        return int(x)
    except ValueError:
        return None

values = ['1', '2', 'n/a']
data = [to_int(x) for x in values]
</pre>

<p>
  If the custom function is used in a conditional, it's possible to use an assignment expression to evaluate the function only once:
</p>

<pre>
data2 = [v for x in values if (v:=to_int(x)) is not None]  # parentheses needed to avoid a SyntaxError
</pre>

<h3>2.15 Generator Expressions</h3>

<p>
  A generator expression is an object that carries out the same computation as a list comprehension but produces the result iteratively. The syntax is the same, except that parentheses are used instead of square brackets.
</p>

<pre>
nums = [1, 2, 3]
squares = (x * x for x in nums)
next(squares)   # 1
next(squares)   # 4
next(squares)   # 9
next(squares)   # StopIteration
</pre>

<h2 id="ch03">Program Structure and Control Flow</h2>

<h3>3.3 Loops and Iteration</h3>

<p>
  In the statement <code>for i in s</code>, the variable <code>i</code> is called the <em>iteration variable</em>. The scope of the iteration variable is not private to the <code>for</code> statement. A previously defined variable with the same name will be overwritten. The iteration variable retains the last value after the loop has completed.
</p>

<p>
  It is possible to unpack elements produced by iteration:
</p>

<pre>
s = [(1, 2, 3), (4, 5, 6)]

for x, y, z in s:
    pass
</pre>

<h3>3.4 Exceptions</h3>

<p>
  It is good style to only catch exceptions from which your code can actually recover. If recovery is not possible, let the exception propagate.
</p>

<p>
  <code>raise</code> by itself re-raises the current exception.
</p>

<p>
  Multiple exception-handling blocks may be used:
</p>

<pre>
try:
    # do something
except TypeError as e:
    # handle e
except ValueError as e:
    # handle e
</pre>

<p>
  To handle multiple exception types in one block:
</p>

<pre>
try:
    # do something
except (TypeError, ValueError) as e:
    # handle e
</pre>

<p>
  An <code>else</code> block after the last <code>except</code> (and before <code>finally</code>) will be executed if the <code>try</code> block doesn't raise an exception.
</p>

<h3>3.4.1 The Exception Hierarchy</h3>

<p>
  Exceptions are organized into a hierarchy via inheritance. It may be easier to focus on general categories of errors. For example, instead of handling <code>IndexError</code> and <code>KeyError</code>, handle only <code>LookupError</code>.
</p>

<p>
  The most common categories of built-in exceptions are:
</p>

<table>
  <tr>
    <td><code>BaseException</code></td>
    <td>The root class for all exceptions</td>
  </tr>
  <tr>
    <td><code>Exception</code></td>
    <td>Base class for program-related errors</td>
  </tr>
  <tr>
    <td><code>ArithmeticError</code></td>
    <td>Math-related errors</td>
  </tr>
  <tr>
    <td><code>ImportError</code></td>
    <td>Import-related errors</td>
  </tr>
  <tr>
    <td><code>LookupError</code></td>
    <td>Container lookup errors</td>
  </tr>
  <tr>
    <td><code>OSError</code></td>
    <td>System-related errors (including files, network, and permissions). <code>IOError</code> and <code>EnvironmentError</code> are aliases</td>
  </tr>
  <tr>
    <td>ValueError</td>
    <td>Value-related errors, including Unicode</td>
  </tr>
  <tr>
    <td>UnicodeError</td>
    <td>Unicode string encoding-related errors</td>
  </tr>
</table>

<p>
  <code>SystemExit</code> is used to make a program terminate on purpose. As an argument, pass an integer exit code or a string message (in this case, <code>1</code> will be the exit code).
</p>

<h3>3.4.3 Defining New Exceptions</h3>

<p>
  To create a new exception, create a new class definition that inherits from <code>Exception</code>:
</p>

<pre>
class DeviceError(Exception):
    pass
</pre>

<p>
  To accept a custom number of arguments (it is important to assign a tuple containing the arguments to <code>self.args</code>:
</p>

<pre>
class DeviceError(Exception):
    def __init__(self, errno, msg):
        self.args = (errno, msg)
        self.errno = errno
        self.errmsg = msg
</pre>

<p>
  The constant <code>__debug__</code> is <code>True</code> if Python was not started with the <code>-O</code> option.
</p>

<h2 id="ch04">4. Objects, Types, and Protocols</h2>

<p>
  The type of an object is itself an object: the object's class. <code>type(type(x))</code> is <code>&lt;class 'type'&gt;</code>.
</p>

<p>
  To check if an object is of a certain type:
</p>

<code>
if isinstance(items, list):
    # do something

if isinstance(items, (list, tuple)):
    # do something
</code>

<p>
  A <em>subtype</em> is a type defined by inheritance.
</p>

<p>
  <code>isinstance</code> is the best way of checking an object's type. It iw aware of subtypes.
</p>

<h3>4.4 References and Copies</h3>

<p>
  When a program makes an assignment such as <code>b = a</code>, a new reference to <code>a</code> is created.
</p>

<p>
  For immutable objects such as numbers and strings, this assignment appears to create a copy of <code>a</code>, but this is not the case.
</p>

<p>
  For mutable objects, <code>a</code> and <code>b</code> end up referring to the same object. Changes made to one of the variables is reflected in the other.
</p>

<p>
  A list copy made with <code>list(a)</code> is a shallow copy. A new list is created, but it is populated with references to the items contained in the original object.
</p>

<p>
  To create a deep copy:
</p>

<pre>
import copy

a = [1, 2, [3, 4]]
b = copy.deepcopy(a)
</pre>

<p>
  <code>deepcopy()</code> is actively discouraged. It will fail with objects that involve system or runtime state (such as open files, network connections, threads, and generators).
</p>

<p>
  All objects are <em>first-class</em>. This means that anything that can be assigned to a name can be treated as data, referred to by variables, called (if it is callable), passed as arguments, returned from functions, and more.
</p>

<h3>4.8 Object Protocols and Data Abstraction</h3>

<p>
  <em>Special</em> (also called <em>magic</em> or <em>dunder</em>) methods are preceded and followed by double underscores: <code>__</code>.
</p>

<p>
  Categories of core interpreter features are called <em>protocols</em>.
</p>

<p>
  <code>NotImplemented</code> is an exception that should be used when a special method is unable to produce a value (example in section 4.11, Comparison Protocol).
</p>

<h3>4.9 Object Protocol</h3>

<p>
  Management of objects:
</p>

<p>
  <code>__new__, __init__, __del__, __repr__</code>
</p>

<p>
  The convention of defining <code>__repr__</code> is to return an expression string that can be evaluated to re-create the object using <code>eval()</code>.
</p>

<p>
  If re-creation is not possible (say for complex objects), return a string of the form <code>&lt;...message...&gt;</code>, such as <code>"&lt;_io.TextIOWrapper name='data.txt'&gt;</code>.
</p>

<h3>4.10 Number Protocol</h3>

<p>
  Special methods of the number protocol, such as <code>__add__, __radd__, __abs__</code>, provide mathematical operations.
</p>

<p>
  <strong>Note</strong>: There are no methods that can be used to define the behavior of <code>and, or, not</code>. Because they are short-circuiting, a regular function is unable to reproduce this behavior. They are deeply embedded in the implementation of Python.
</p>

<h3>4.11 Comparison Protocol</h3>

<p>
  The identity check, <code>is</code> cannot be redefined.
</p>

<p>
  Comparison methods can return any value (in addition to the usual Boolean).
</p>

<p>
  When adding comparison operators to a user-defined class, the <code>@total_ordering</code> class decorator from <code>functools</code> may be useful (it generates comparison methods based on minimally implementing <code>__eq__()</code> and one of the other comparisons, such as <code>__lt__()</code>).
</p>

<p>
  <code>__eq__()</code> should always be defined together with <code>__hash__()</code>. It is possible for two objects to have the same hash value, so <code>__eq__()</code> is used to resolve collisions.
</p>

<h3>4.12 Conversion Protocols</h3>

<p>
  Python does not implicitly perform type conversions. You must explicitly call <code>int()</code>, for example.
</p>

<h3>4.13 Container Protocol</h3>

<p>
  <code>__len__, __getitem__, __setitem__, __delitem__, __contains__</code>
</p>

<p>
  It is possible to have a multidimensional slice: <code>m[1:10, 3:20]</code>, used in NumPy.
</p>

<p>
  Ellipsis (<code>...</code>) denotes any number of trailing or leading dimensions in an extended slice: <code>m[..., 10:20]</code>
</p>

<h3>4.14 Iteration Protocol</h3>

<p>
  If an instance <code>obj</code> supports iteration, it provides a method <code>obj.__iter__()</code> that returns an iterator. In turn, an iterator <code>iter</code> implements a single method, <code>iter.__next__()</code>, that returns the next object or <code>StopIteration</code>.
</p>

<p>
  Optionally, <code>__reversed__()</code> provides a reversed iterator, to be used with <code>reversed()</code>.
</p>

<p>
  A common implementation technique for iteration is to use a generator function involving <code>yield</code>.
</p>

<pre>
class FRange:
    def __init__(self, start, stop, step):
        self.start = start
        self.stop = stop
        self.step = step

    def __iter__(self):
        x = self.start
        while x < self.stop:
            yield x
            x += self.step
</pre>

<p>
  Example usage:
</p>

<pre>
nums = FRange(0.0, 1.0, 0.1)

for x in nums:
    print(x)
</pre>

<h3>4.15 Attribute Protocol</h3>

<p>
  The methods <code>__getattribute__, __getattr__, __setattr__, __delattr__</code> read, write, and delete attributes of an object using the dot operator <code>.</code> and the <code>del</code> operator.
</p>

<p>
  Whenever an attribute is accessed, the <code>__getattribute__</code> method is invoked. If the attribute is located, it is returned. Otherwise, <code>__getattr__</code> is invoked. Its default behavior is to raise an <code>AttributeError</code> exception.
</p>

<h3>4.16 Function Protocol</h3>

<p>
  An object can emulate a function by providing the <code>__call__</code> method.
</p>

<h3>4.17 Context Manager Protocol</h3>

<p>
  The <code>with</code> statement allows a sequence of statements to execute under the control of an instance called a <em>context manager</em>.
</p>

<p>
  <code>__enter__</code> is called when entering a new context. <code>__exit__</code> is called when leaving a context.
</p>

<h2 id="ch05">5. Functions</h2>

<h3>5.2 Default Arguments</h3>

<p>
  When a function defines a parameter with a default value, that parameter and all others that follow it become optional. It is not possible to specify a parameter without a default value after any parameter with a default value.
</p>

<p>
  Avoid using mutable objects as default values because the default value is evaluated once when the function is defined. If using mutable default values, set the default value to <code>None</code> and add a check:
</p>

<pre>
def f(x, items=None):
    if items is None:
        items = []
    items.append(x)
    return items
</pre>

<p>
  It is possible to force the use of keyword arguments by listing parameters after a <code>*</code> argument or by including a single <code>*</code> in the definition:
</p>

<pre>
def read_data(filename, *, debug=False):
   pass
</pre>

<h3>5.6 Functions Accepting All Inputs</h3>

<p>
  By using both <code>*</code> (variadic arguments) and <code>**</code> (variadic keyword arguments), a function will accept any combination of arguments. Positional arguments are passed as a tuple, and keyword arguments are passed as a dictionary.
</p>

<h3>5.7 Positional-Only Arguments</h3>

<p>
  Arguments appearing before a slash, <code>/</code>, can only be specified by position. It's useful to prevent name clashes between parameter names and keyword arguments:
</p>

<pre>
def f(x, y, /):
    pass
</pre>

<h3>5.8 Names, Documentation Strings, and Type Hints</h3>

<p>
  The name of a function is accessible with <code>__name__</code>: <code>f.__name__</code>
</p>

<h3>5.9 Function Application and Parameter Passing</h3>

<p>
  Python passes supplied objects to a function "as is", without making copies. When references to mutable objects are passed, changes made inside the function are reflected in the object that is referred to.
</p>

<p>
  Such mutation of input values and changes of state to other parts of the program are called <em>side effects</em>. It is best to avoid side effects. Generally, functions with side effects return <code>None</code>.
</p>

<p>
  Reassigning a value to a name does not overwrite the previous object. The name just gets reassigned to a different object.
</p>

<h3>5.12 Scoping Rules</h3>

<p>
  Variable names never change their scope&mdash;they are either global variables or local variables, and this is determined at function definition time.
</p>

<pre>
x = 42
def f():
    print(x)

f()  # prints 42
</pre>

<p>
  However, if <code>x</code> is defined in <code>f()</code> after <code>print</code>, an <code>UnboundLocalError</code> exception is raised.
</p>

<pre>
x = 42
def f():
    print(x)
    x = 2  # adding this causes an error

f()  # UnboundLocalError
</pre>

<p>
  If <code>print</code> is removed, it looks like the global <code>x</code> changes, but in fact, <code>x</code> is local to <code>f</code>.
</p>

<p>
  To change the global variable, <code>global x</code> can be used, though it's considered poor style to do so. It is better to create a new class and mutate an instance or class variable.
</p>

<p>
  Variables in nested functions are bound using lexical scoping. Note that this is not a dynamic process. To reassign values of local variables defined in an outer function, use <code>nonlocal x</code>. Like <code>global</code>, <code>nonlocal</code> is not commonly used.
</p>

<h3>5.13 Recursion</h3>

<p>
  The functions <code>sys.getrecursionlimit()</code> and <code>sys.setrecursionlimit()</code> show and alter the maximum recursion depth.
</p>

<h3>5.14 The <code>lambda</code> Expression</h3>

<pre>
lambda arg1, arg2: expression
</pre>

<p>
  is an anonymous (unnamed) function. The body of the <code>lambda</code> must be a valid expression. Multiple statements or anything that is not an expression, such as <code>try</code> and <code>while</code>, cannot appear in a <code>lambda</code> expression.
</p>

<p>
  The value of free variables used in defining a lambda expression are retrieved at the time of evaluation (<em>late binding</em>).
</p>

<p>
  To capture the value of a variable at the time of definition, use a default argument:
</p>

<pre>
x = 2
f = lambda y, x=x: x * y
</pre>

<h3>5.15 Higher-Order Functions</h3>

<p>
  A <em>closure</em> is a function along with an environment containing all the variables needed to execute the function body. When a function is called, a new stack frame with new memory for local variables is created.
</p>

<h3>5.16 Argument Passing in Callback Functions</h3>

<p>
  One challenging problem with callback functions is passing arguments to the supplied function.
</p>

<p>
  One solution is to package up computation into a zero-argument <code>lambda</code> (sometimes called a <em>thunk</em>):
</p>

<pre>
import time

def after(seconds, func):
    time.sleep(seconds)
    func()

after(10, lambda: add(2, 3))
</pre>

<p>
  An alternative is using <code>functools</code>' <code>partial</code>:
</p>

<pre>
after(10, partial(add, 2, 3))
</pre>

<h3>5.18 Decorators</h3>

<pre>
@decorate
def func(x):
    pass
</pre>

<p>
  is shorthand for: <code>func = decorate(func)</code>
</p>

<p>
  When writing a decorator, it's considerd best practice to use the <code>functools</code>' <code>@wraps()</code> decorator, which copies various function metadata to the replacement function:
</p>

<pre>
from functools import wraps

def trace(func):
    @wraps(func)
    def call(*args, **kwargs):
        print("Calling", func.__name__)
        return func(*args, **kwargs)
    return call
</pre>

<p>
  When stacking decorators, the one closer to the function is applied first to the function:
</p>

<pre>
@decorator1
@decorator2
def func(x):
    pass
</pre>

<p>
  is <code>func = decorator1(decorator2(func))</code>
</p>

<p>
  <code>@classmethod, @staticmethod</code> need to be placed at the outermost level.
</p>

<p>
  To implement a decorator that accepts arguments:
</p>

<pre>
def trace(message):
    def decorate(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(message.format(func=func))
            return func(*args, **kwargs)
        return wrapper
    return decorate
</pre>

<p>
  The outer function is a kind of decorator factory:
</p>

<pre>
logged = trace("You called {func.__name__}")

@logged
def g(x):
    pass
</pre>

<p>
  <strong>Example</strong>: how to build a registry of event handlers:
</p>

<pre>
_event_handlers = []
def event_handler(event):
    def register_function(func):
        _event_handlers[event] = func
        return func
    return register_function

@event_handler("BUTTON")
def handle_button(msg):
    pass
</pre>

<h3>5.19 Map, Filter, and Reduce</h3>

<p>
  <code>map(function, *iterables), filter(function, iterable)</code> creates generators.
</p>

<p>
  <code>functools</code>' <code>reduce(two-argument function, iterable, optional initial value)</code> accumulates values left-to-right on the supplied iterable (also called a <em>left-fold operation</em>).
</p>

<h3>5.22 Dynamic Code Execution and Creation</h3>

<p>
  <code>exec(str [, globals [, locals]])</code> executes arbitrary code in <code>str</code>.
</p>

<p>
  <strong>Warning</strong>: changes to local variables have no effect. The dictionary of local and closure variables is not the actual data structure used to hold these variables.
</p>

<p>
  Dynamic code execution is used to create functions and methods.
</p>

<h3>5.23 Asynchronous Functions and <code>await</code></h3>

<p>
  <em>Async functions</em> (also called coroutines) and <em>awaitables</em> are used for asynchronous execution of code.
</p>

<p>
  An asynchronous function (or coroutine) is defined by prefacing a normal function definition with the <code>async</code> keyword:
</p>

<pre>
async def greeting(name):
    print(f"Hello, {name}")
</pre>

<p>
  To make such functions run, they must execute under the supervision of other code; for example, <code>asyncio</code>.
</p>

<pre>
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; asyncio.run(greeting('Guido'))
</pre>

<p>
  Async functions call other async functions using an <code>await</code> expression:
</p>

<pre>
async def make_greeting(name):
    return f"Hello, {name}"

async def main():
    for name in ['Paula', 'Tom', 'Lewis']:
        a = await make_greeting(name)
        print(a)
</pre>

<p>
  <strong>Warning</strong>: it is not possible to write code that calls an async function from a non-async function.
</p>

<p>
  An asynchronous context manager is defined with <code>__aenter__, __aexit__</code>. It is used via <code>async with</code>.
</p>

<h2 id="ch06">6. Generators</h2>

<h3>6.1 Generators and <code>yield</code></h3>

<p>
  If a function uses the <code>yield</code> keyword, it defines a <em>generator</em>. Their primary use is to produce values for use in iteration (such as a <code>for</code> loop).
</p>

<p>
  Another way to start iterating on a generator is to call <code>next()</code> on it:
</p>

<pre>
def countdown(n):
    print('Counting down from', n)
    while n > 0:
        yield n
        n -= 1

for x in countdown(10):
    print('T-minus', x)

c = countdown(10)
next(c)
</pre>

<p>
  <code>next()</code> is shorthand for invoking the <code>__next__()</code> method:
</p>

<pre>
c.__next__()
</pre>

<p>
  Using a <code>return</code> statement raises a <code>StopIteration</code> exception that terminates a loop. To capture the return value, you need to catch the <code>StopIteration</code>:
</p>

<pre>
try:
    next(f)
except StopIteration as e:
    value = e.value
</pre>

<p>
  Cleanup code must be in a <code>finally</code> block of <code>try-finally</code>:
</p>

<pre>
def countdown(n):
    print('Counting down from', n)
    try:
        while n > 0:
            yield n
            n -= 1
    finally:
        print('Only made it to', n)
</pre>

<p>
  Using a context manager (a <code>with</code> block) also guarantees that cleanup will happen when the generator terminates.
</p>

<h3>6.2 Restartable Generators</h3>

<p>
  Normally, a generator function executes only once. To allow for repeated iteration, define it in a class and make the <code>__iter__()</code> method a generator:
</p>

<pre>
class Countdown:
    def __init__(self, start):
        self.start = start

    def __iter__(self):
        n = self.start
        while n > 0:
            yield n
            n -= 1
</pre>

<p>
  Each time you iterate, a fresh generator is created by <code>__iter__()</code>.
</p>

<h3>6.3 Generator Delegation</h3>

<p>
  A generator using <code>yield</code> never executes by itself (calling a generator function is not enough to make it execute).
</p>

<p>
  <code>yield from</code> delegates the iteration process to an outer iteration:
</p>

<pre>
def countup(stop):
    n = 1
    while n <= stop:
        yield n
        n += 1

def countdown(start):
    n = start
    while n > 0:
        yield n
        n -= 1

def up_and_down(n):
    yield from countup(n)
    yield from countdown(n)

for x in up_and_down(5):
    print(x, end=' ')  # 1 2 3 4 5 5 4 3 2 1
</pre>

<p>
  <code>yield from</code> is useful when writing code that must recursively iterate through nested iterables.
</p>

<p>
  <strong>Example</strong>: flatten nested lists:
</p>

<pre>
def flatten(items):
    for i in items:
        if isinstance(i, list):
            yield from flatten(i)
        else:
            yield(i)

for x in flatten(a):
    print(x)
</pre>

<p>
  Generators are a useful abstraction to break down problems into small, well-defined tasks.
</p>

<h3>6.5 Enhanced Generators and <code>yield</code> Expressions</h3>

<p>
  The <code>yield</code> statement by itself can be used in the right-hand side of an assignment operator:
</p>

<pre>
def receiver():
    print('Ready to receive')
    while True:
        n = yield
        print('Got', n)
</pre>

<p>
  Such a function is called an <em>enhanced generator</em> or <em>generator-based coroutine</em>.
</p>

<p>
  Instead of producing values, enhanced generators executes in response to values sent to it.
</p>

<pre>
&gt;&gt;&gt; r = receiver()
&gt;&gt;&gt; r.send(None)  # advances to the first yield
Ready to receive
&gt;&gt;&gt; r.send(1)
Got 1
&gt;&gt;&gt; r.send(2)
Got 2
</pre>

<p>
  <code>r.close()</code> can be used to shut down the generator (it raises a <code>GeneratorExit</code> exception, and sending it more values will start raising <code>StopIteration</code>).
</p>

<p>
  To raise exceptions inside a generator, use <code>throw(exception_type [, exception_argument [, traceback]])</code>.
</p>

<h3>6.6 Applications of Enhanced Generators</h3>

<p>
  <code>contextlib</code>'s <code>contextmanager</code> uses <code>yield</code> to separate the <code>__enter__</code> and <code>__exit__</code> blocks of a regular context manager definition.
</p>

<p>
  Another application of extended generators is using functions to encapsulate a "worker" task. One might use a generator to set up a long-lived task. Accessing local variables in a generator is much faster than accessing attributes of classes and instances.
</p>

<h2 id="ch07">7. Classes and Object-Oriented Programming</h2>

<p>
  Use <code>type()</code> to view an object's type.
</p>

<p>
  To check if an object is of a certain type:
</p>

<code>
if isinstance(items, list):
    pass
</code>

<p>
  A <code>class</code> statement and block does not create any instances of that class. It is like a blueprint for creating instances.
</p>

<p>
  <code>vars(a)</code> returns a dictionary containing the instance variables.
</p>

<p>
  Methods are found on the class instead:
</p>

<pre>
&gt;&gt;&gt; type(a).inquiry
&lt;function Account.inquiry at ...&gt;
</pre>

<h3>7.4 Attribute Access</h3>

<p>
  There are only three basic operations that can be performed on an instance: getting, setting, and deleting an attribute.
</p>

<p>
  Instead of using the dot operator (<code>.</code>) to perform these operations, you can supply an attribute name to <code>getattr, setattr, delattr, hasattr</code>:
</p>

<pre>
a = Account('Guido', 1000.0)
getattr(a, 'owner')  # 'Guido'
setattr(a, 'balance', 1250.0)
delattr(a, 'deprecated_name')
</pre>

<p>
  <code>getattr()</code> takes an optional default value:
</p>

<pre>
getattr(s, 'balance', 'unknown')
</pre>

<p>
  Accessing a method as an attribute results in a <em>bound method</em>:
</p>

<pre>
w = a.withdraw
w(100)
</pre>

<h3>7.5 Scoping Rules</h3>

<p>
  There is no class-level scope in Python. Attributes and methods must be fully qualified; in other words, you use <code>self.balance</code>, not <code>balance</code>.
</p>

<h3>7.7 Inheritance</h3>

<p>
  <code>object</code> is a class that is the root of all Python objects.
</p>

<p>
  For a derived class to call the original implementation of a method, use <code>super()</code>:
</p>

<pre>
def inquiry(self):
    return multiplier * super().inquiry()
</pre>

<p>
  In a subclass' <code>__init__()</code>, the superclass' initialization must be explicitly called; otherwise, you'll end up with a half-initialized object that will most likely break.
</p>

<pre>
class BadAccount(Account):
    def __init__(self, owner, balance, multiplier):
        super().__init__(owner, balance)
        self.multiplier = multiplier
</pre>

<p>
  Avoid hardcoding class names. Use instead: <code>f'{type(self).__name__}'</code>.
</p>

<h3>7.8 Avoiding Inheritance via Composition</h3>

<p>
  Sometimes, it's better to include a class as part of a new class, rather than subclass that original class. Example: a Stack can have a list as an implementation detail, instead of subclassing <code>list</code>.
</p>

<p>
  <em>Dependency injection</em> is making a class depend on any object a user decides to pass in, provided it implements the required interface.
</p>

<h3>7.10 Dynamic Binding and Duck Typing</h3>

<p>
  Dynamic binding is the runtime mechanism that Python uses to find the attributes of objects. This behavior is also called <em>duck typing</em> (if it looks like a duck, quacks like a duck, and walks like a duck, then it's a duck).
</p>

<p>
  As an example, there are all sorts of objects that work with the <code>for</code> loop. But none of them inherit from a special <em>iterable</em> base class. They merely implement the methods required to perform iteration, and everything works.
</p>

<h3>7.11 The Danger of Inheriting from Built-in Types</h3>

<p>
  Do not subclass built-in types. They aren't implemented like normal classes&mdash;they're implemented in C. This means that the expected routing through magic methods doesn't happen.
</p>

<p>
  Instead, subclass from <code>UserDict, UserList, UserString</code>.
</p>

<h3>7.12 Class Variables and Methods</h3>

<p>
  Class variables are defined outside the normal <code>__init__()</code> method. It is possible to access a class variable from an instance (<code>a.num_accounts</code>).
</p>

<p>
  A <em>class method</em> is applied to the class itself, not instances. Decorate a method with <code>@classmethod</code>.
</p>

<p>
  The first argument of a class method is the class itself. By convention, it is named <code>cls</code>.
</p>

<p>
  A class method can be used as an alternative constructor:
</p>

<pre>
class Account:
    def __init__(self, owner, balance):
        pass

    @classmethod
    def from_xml(cls, data):
        doc = XML(data)
        return cls(doc.findtext('owner'), float(doc.findtext('amount')))
</pre>

<p>
  <code>cls()</code> is like calling <code>Account()</code>.
</p>

<h3>7.13 Static Methods</h3>

<p>
  Sometimes, a class is merely used as a namespace for functions declared as static methods using <code>@staticmethod</code>. A static method does not take <code>self</code> or <code>cls</code>. It is an ordinary function that happens to be defined inside a class.
</p>

<p>
  Normally, you just call the functions directly through the class: <code>Ops.add(1, 2)</code>.
</p>

<p>
  Instead of inheritance, customized behavior can be achieved with classes that only hold static methods. <strong>Example</strong>: <em>StandardPolicy</em> for bank accounts. This policy can be swapped.
</p>

<h3>7.15 Data Encapsulation and Private Attributes</h3>

<p>Using a single leading underscore (<code>_</code>) indicates internal implementation. Double leading underscores (<code>__</code>) will be automatically renamed to <code>_Classname__name</code> to avoid subclasses overwriting identical names in the superclass. This <em>name mangling</em> occurs only once when the class is defined.
</p>

<h3>7.17 Properties</h3>

<p>
  It is possible to place restrictions on an attribute if it is under the management of a <em>property</em>.
</p>

<p>
  A property is a special kind of attribute that intercepts attribute access and handles it via user-defined methods.
</p>

<p>
  The <code>@property</code> decorator is used to establish an attribute as a property. The <code>@owner.setter</code> decorator is used to optionally implement a method for setting the attribute value.
</p>

<pre>
@property
def owner(self):
    return self._owner

@owner.setter
def owner(self, value):
    # business logic
    self._owner = value
</pre>

<p>
  A critical feature of properties is that the associated name, <code>owner</code>, becomes "magical". Any use of that attribute automatically routes through the getter/setter methods that are implemented. Note that in <code>__init__()</code>, the assignment is <code>self.owner = owner</code>. The actual value needs to be stored under a different name, <code>_owner</code>. If <code>owner</code> were used, it would cause infinite recursion.
</p>

<p>
  Getting, setting, and deleting the attribute value is accomplished with <code>@attrname.getter, @attrname.setter, @attrname.deleter</code>. It is not necessary to implement all parts of a property.
</p>

<p>
  <strong>Example</strong>: Read-only computed data attributes:
</p>

<pre>
class Box:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    @property
    def perimeter(self):
        return (2 * self.width) + (2 * self.height)

    @property
    def area(self):
        return self.width * self.height

b = Box(4, 5)
print(b.area)  # 20
</pre>

<h3>7.18 Types, Interfaces, and Abstract Base Classes</h3>

<p>
  When you create an instance of a class, the type of that instance is the class itself.
</p>

<p>
  <code>issubclass(A, B)</code> returns <code>True</code> if <code>A</code> is a subclass of <code>B</code>.
</p>

<p>
  To circumvent a subclass not having implemented an expected function, it is common to define interfaces as <code>abstract base classes</code> (ABCs) using the <code>abc</code> module:
</p>

<pre>
from abc import ABC, abstractmethod

class Stream(ABC):
    @abstractmethod
    def receive(self):
        pass

    @abstractmethod
    def send(self, msg):
        pass
</pre>

<p>
  An abstract class cannot be instantiated directly. It is meant to be used as a superclass:
</p>

<pre>
class SocketStream(Stream):
    def read(self):
        pass
    ...
</pre>

<p>
  Calling <code>super().receive()</code> from a subclass is allowed.
</p>

<h3>7.19 Multiple Inheritance, Interfaces, and Mixins</h3>

<p>
  One possible use of multiple inheritance is to check type relations (to perform type checks).
</p>

<p>
  Another use of multiple inheritance is to define <em>mixin classes</em>. A mixin class is a class that modifies or extends the functionality of other classes.
</p>

<p>
  A mixin might use <code>super()</code> to delegate to a nonexistent parent class:
</p>

<pre>
class LoudMixin:
    def noise(self):
        return super().noise().upper()
</pre>

<p>
  They only work in combination with other classes that implement the missing functionality:
</p>

<pre>
class Duck:
    def noise(self):
        return 'Quack'

class LoudDuck(LoudMixin, Duck):
    pass

duck = LoudDuck()
duck.noise()  # 'QUACK'
</pre>

<p>
  Whenever you use inheritance, Python builds a linear chain of classes known as the <em>Method Resolution Order</em> (MRO). This is available as the <code>__mro__</code> attribute on a class. It specifies the search order for attribute lookup.
</p>

<p>
  It is possible to make a direct call to a parent: <code>Base.noise()</code>. However, they are not safe to use with multiple inheritance. It breaks the proper chain of method calls and causes confusion. Use <code>super()</code> in multiple inheritance.
</p>

<h3>7.20 Type-Based Dispatch</h3>

<p>
  A common solution to dispatching based on a specific type is using a dictionary:
</p>

<pre>
handlers = {
    Duck: handle_duck,
    Trombonist: handle_trombonist,
    Cyclist: handle_cyclist
}

def dispatch(obj):
    func = handlers.get(type(obj))
</pre>

<p>
  If inheritance needs to be supported, you need to traverse the MRO:
</p>

<pre>
def dispatch(obj):
    for t in type(obj).__mro__:
        func = handlers.get(t)
        if func:
            return func(obj)
    raise RuntimeError(f'No handler for {obj}')
</pre>

<p>
  A class-based approach is also possible:
</p>

<pre>
class Dispatcher:
    def handle(self, obj):
        for t in type(obj).__mro__:
            meth = getattr(self, f'handle_{t.__name__}', None)
            if meth:
                return meth(obj)
        raise RuntimeError(f'No handler for {obj}')

    def handle_Duck(self, obj):
        pass

    def handle_Trombonist(self, obj):
        pass

    def handle_Cyclist(self, obj):
        pass

d = Dispatcher()
d.handle(Duck())
</pre>

<h3>7.21 Class Decorators</h3>

<p>
  A class decorator is a function that takes a class as input and returns a class as output. It could perform extra processing steps such as adding the class to a registry or generating extra support code.
</p>

<p>
  A class decorator is a common alternative to mixins or multiple inheritance.
</p>

<p>
  Using the <code>@dataclass</code> decorador is a convenient way to define a data structure:
</p>

<pre>
from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int
</pre>

<h3>7.22 Supervised Inheritance</h3>

<p>
  A parent class can perform extra actions on behalf of its subclasses with <code>__init_subclass__(cls)</code>.
</p>

<p>
  Supervising inheritance with <code>__init_subclass__()</code> is one of Python's most powerful customization features (a lot of it is due to its implicit nature).
</p>

<h3>7.23 The Object Life Cycle and Memory Management</h3>

<p>
  The creation of an instance is carried out in two steps, with <code>__new__()</code> that creates the new instance and <code>__init__()</code> that initializes it.
</p>

<p>
  <code>__new__</code> should be defined with the <code>@staticmethod</code> decorator.
</p>

<p>
  To force garbage collection, import <code>gc</code> and call <code>gc.collect()</code>.
</p>

<h3>7.24 Weak References</h3>

<p>
  A weak reference is a way of creating a reference to an object without increasing its reference count:
</p>

<pre>
import weakref

a = Account('Guido', 1250.0)
a_ref = weakref.ref(a)

del a
a_ref  # &lt;weakref at 0x...; dead&gt;
</pre>

<p>
  To get the actual object, you need to call the weak reference as a function with no arguments.
</p>

<pre>
acct = a_ref()
</pre>

<p>
  Support for weak references requires instances to have a mutable <code>__weakref__</code> attribute. User-defined classes normally have such an attribute by default, but built-in types do not. A variant that adds <code>__weakref__</code> needs to be defined:
</p>

<pre>
class wdict(dict):
    __slots__ = ('__weakref__',)
</pre>

<h3>7.25 Internal Object Representation and Attribute Binding</h3>

<p>
  An instance's state is stored in a dictionary that's accessible as its <code>__dict__</code> attribute. Modifications to an instance are always reflected in <code>__dict__</code>, unless the attribute is being managed by a property.
</p>

<p>
  A class' <code>__dict__</code> is where you find its methods.
</p>

<p>
  <code>__bases__</code> is a tuple of base classes. It is only informational.
</p>

<h3>7.26 Proxies, Wrappers, and Delegation</h3>

<p>
  A proxy is an object that exposes the same interface as another object, but isn't related to the original object via inheritance.
</p>

<p>
  For example, a proxy can hold an internal reference to the other object. Methods are delegated via the <code>__getattr__()</code> method:
</p>

<pre>
class A:
    pass

class LoggedA:
    def __init__(self):
        self_a = A()

    def __getattr__(self, name):
        print("Accessing", name)
        return getattr(self_a, name)
</pre>

<p>
  However, this approach does not apply to operations mapped to special methods. Each special method you wish to support needs to be implemented.
</p>

<h3>7.27 Reducing Memory Use with <code>__slots__</code></h3>

<p>
  Slots is a definition hint that allows Python to make performance optimizations for memory use and execution speed.
</p>

<p>
  Only instance attributes may be stored in <code>__slots__</code>.
</p>

<p>
  When using inheritance, a subclass of a class that uses slots also needs to define its own slots (even if it doesn't add any).
</p>

<p>
  Slots cannot be used with multiple inheritance.
</p>

<h3>7.28 Descriptors</h3>

<p>
  Normally, attribute access corresponds to dictionary operations. If more control is needed, attribute access can be routed through user-defined <code>__get__, __set__, __delete__</code> functions.
</p>

<p>
  A property is actually implemented using a lower-level construct known as a <em>descriptor</em>.
</p>

<p>
  Descriptors can only be instantiated at the class level. They are class-level objects that manage access to an attribute.
</p>

<h3>7.30 Dynamic Class Creation</h3>

<p>
  <code>types.new_class()</code> allows the creation of a class without using the <code>class</code> statement. This way is preferred over code such as <code>Account = type('Account', (), methods)</code>
</p>

<h3>7.31 Metaclasses</h3>

<p>
  When you define a class in Python, the class definition itself becomes an object.
</p>

<p>
  The creation of a class object is controlled by a special kind of class called a <em>metaclass</em>. It's a class that creates instances of classes.
</p>

<p>
  This metaclass is a built-in class called <code>type</code>.
</p>

<p>
  To create a new metaclass, define a class that inherits from <code>type</code>.
</p>

<p>
  Metaclasses may be used to rewrite the contents of the class namespace prior to the creation of the class object (such as using <code>__slots__</code>). Also, you can alter the class definition environment (such as to prevent duplicating an attribute name).
</p>

<h2 id="ch08">Modules and Packages</h2>

<h3>8.1 Modules and the <code>import</code> Statement</h3>

<p>
  Any Python source file can be imported as a module:
</p>

<pre>
# my_module.py

a = 37

def func():
    pass

print('Loaded my_module.py')
</pre>

<pre>
import mymodule
</pre>

<p>
  The file to be imported needs to be placed in one of the directories found in <code>sys.path</code>.
</p>

<p>
  It is possible to selectively import a module:
</p>

<pre>
if platform == 'unix':
    import unixmodule as module
elif platform == 'windows':
    import windowsmodule as module
...
</pre>

<p>
  Modules are first-class objects in Python.
</p>

<p>
  Code for a module is loaded and executed only once. Re-importing will only bind the module name to the module object already created by the previous import.
</p>

<p>
  If the source code is modified, the new code will not be re-read in a new <code>import</code> execution.
</p>

<p>
  While in general, module imports should go at the top of a file, it may make sense to import large modules conditionally to avoid the expensive operation.
</p>

<p>
  There is <code>importlib.reload(modulename)</code> to reload <code>modulename</code>, which works like typing the new source code on top of the old. However, it is not recursive and existing instances do not get the updated class definition.
</p>

<p>
  The best course of action is to restart the Python interpreter process.
</p>

<h3>8.7 The Module Search Path</h3>

<p>
  When importing modules, the interpreter searches for directories in <code>sys.path</code>. It is possible to append directories or ZIP files to <code>sys.path</code>:
</p>

<pre>
sys.path.append('mymodules.zip')
</pre>

<p>
  On UNIX, setting the <code>PYTHONPATH</code> environment value also adds its directories to <code>sys.path</code>:
</p>

<pre>
env PYTHONPATH=/home/me/code:/home/me/libs python3
</pre>

<p>
  If you've made a directory of Python code, you can execute the directory if it contains a special <code>__main__.py</code> file:
</p>

<pre>
myapp/
  module1.py
  module2.py
  __main__.py

$ python3 myapp
</pre>

<p>
  When importing a package without an <code>__init__.py</code> file, it gets imported as a <em>namespace package</em>. In general, it's best to create <code>__init__.py</code> files.
</p>

<h3>8.10 Imports Within a Package</h3>

<p>
  A package-relative import looks like:
</p>

<pre>
# graphics/primitives/fill.py

from . import lines  # import graphics/primitives/lines.py
</pre>

<p>
  To import from other directories:
</p>

<pre>
# graphics/graph2d/plot2d.py

from ..primitive import lines
</pre>

<p>
  Relative imports can only be used from within a package.
</p>

<h3>8.11 Running a Package Submodule as a Script</h3>

<p>
  Code that's organized into a package has a different runtime environment than a simple script. It is not possible to run Python directly on a package source file.
</p>

<p>
  To run a submodule as a main script:
</p>

<pre>
python3 -m graphics.graph2d.plot2d
</pre>

<h3>8.12 Controlling the Package Namespace</h3>

<p>
  Importing only a top-level name does not make submodules accessible:
</p>

<pre>
import graphics
graphics.primitive.fill.floodfill()  # fails
</pre>

<p>
  The only file that imports is the <code>__init__.py</code> file.
</p>

<h3>8.13 Controlling Package Exports</h3>

<p>
  A submodule often declares an explicit list of exports by defining an <code>__all__</code> variable.
</p>

<h3>8.14 Package Data</h3>

<p>
  To read package data, use <code>pkgutil.get_data(package, resource)</code>:
</p>

<pre>
mycode/
  resources/
    data.json
  __init__.py
  code.py

# code.py
raw_data = pkgutil.get_data(__package__, 'resources/data.json')
text_data = raw_data.decode('utf-8')
data = json.loads(text_data)
</pre>

<p>
  In general, it's not a good idea to store lots of data in packages. Reserve package resources for configuration data and other assorted bits of stuff needed to make your package work.
</p>

<h3>8.17 Start With a Package</h3>

<p>
  It's tempting to start with a single file, <code>program.py</code>, but after it grows, it may be troublesome to organize it.
</p>

<p>
  Start with a program package, and begin working in <code>__main__.py</code> (running it with <code>python3 -m program</code>).
</p>

<pre>
program/
  __init__.py
  __main__.py
</pre>

</div>
<br>
<hr>
<div style="padding-left: 0.5em; background-color: #fff;">
  <a href="javascript:history.back()">&#x1F519; Back</a>&nbsp;&nbsp;&nbsp;
  <a href="#top">&#x1F51D; Top</a>&nbsp;&nbsp;&nbsp;
  <a href="index.html">&#x1F4C2; Dir list</a>&nbsp;&nbsp;&nbsp;
  <a href="../index.html">&#x23EB; Up</a>&nbsp;&nbsp;&nbsp;
</div>
<br><br><br>
    </body>
</html>

