<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>HC Docs</title>
        <style>
        body {
          font-family: sans-serif;
        }

        a {
          text-decoration: none;
          display: inline-block;
          color: #21c;
        }

        a:visited {
          color: #82a;
        }

        a.index {
          margin-bottom: 1rem;
        }

        h2, h3, h4 {
          margin-top: 2.75rem;
        }

        li {
          margin: 0.25rem 0;
        }

        pre {
          box-sizing: border-box;
          margin: 1rem;
          padding: 1rem;
          border: 1px solid #ccc;
          background-color: #ffefd5;
          border-radius: 0.8rem;
          overflow: auto;
          min-width: calc(100% - 2rem);
          font-size: 1rem;
        }

        code {
          padding: 0 0.2rem;
          color: #062;
          font-size: 1rem;
        }

        pre > code {
          padding: 0;
        }

        .hc-monospace {
          font-family: monospace;
        }

        .content {
          max-width: 820px;
          margin-left: auto;
          margin-right: auto;
        }

        table {
          border-collapse: collapse;
        }

        td {
          padding: 0.5rem 0.8rem;
          border: 1px solid #ccc;
        }
        </style>
    </head>
    <body>
      <div style="position: fixed; top: 0; padding: 0.5em; background-color: #fff;">
        <a href="javascript:history.back()">&#x1F519; bk</a>&nbsp;&nbsp;
        <a href="index.html">&#x1F4C2; dir</a>&nbsp;&nbsp;
        <a href="#top">&#x1F51D; top</a>&nbsp;&nbsp;
      </div>
      <div id="top">&nbsp;</div>
      <div class="content">


    <h3><a href="../../index.html">home</a> / <a href="../index.html">programming</a> / <a href="index.html">python</a></h3>
    
<h1>Fluent Python, 2nd ed. (Sep. 2025 reading)</h1>
<p>The idea this time is to read more quickly, by skimming the text but focusing on the code examples.</p>
<h2>Contents</h2>
<h3>Part I: Data Structures</h3>
<ol>
<li><a href="#ch1">The Python Data Model</a></li>
<li><a href="#ch2">An Array of Sequences</a></li>
<li><a href="#ch3">Dictionaries and Sets</a></li>
<li><a href="#ch4">Unicode Text Versus Bytes</a></li>
<li><a href="#ch5">Data Class Builders</a></li>
<li><a href="#ch6">Object References, Mutability, and Recycling</a></li>
</ol>
<h3>Part II: Functions as Objects</h3>
<ol start="7">
<li><a href="#ch7">Functions as First-Class Objects</a></li>
<li><a href="#ch8">Type Hints in Functions</a></li>
<li><a href="#ch9">Decorators and Closures</a></li>
<li><a href="#ch10">Design Patterns with First-Class Functions</a></li>
</ol>
<h3>Part III: Classes and Protocols</h3>
<ol start="11">
<li><a href="#ch11">A Pythonic Object</a></li>
<li><a href="#ch12">Special Methods for Sequences</a></li>
<li><a href="#ch13">Interfaces, Protocols, and ABCs (Abstract Base Classes)</a></li>
<li><a href="#ch14">Inheritance: For Better or for Worse</a></li>
<li><a href="#ch15">More About Type Hints</a></li>
<li><a href="#ch16">Operator Overloading</a></li>
</ol>
<h3>Part IV: Control Flow</h3>
<ol start="17">
<li><a href="#ch17">Iterators, Generators, and Classic Coroutines</a></li>
<li><a href="#ch18">with, match, and else Blocks</a></li>
<li><a href="#ch19">Concurrency Models in Python</a></li>
<li><a href="#ch20">Concurrent Executors</a></li>
<li><a href="#ch21">Asynchronous Programming</a></li>
</ol>
<h3>Part V: Metaprogramming</h3>
<ol start="22">
<li><a href="#ch22">Dynamic Attributes and Properties</a></li>
<li><a href="#ch23">Attribute Descriptors</a></li>
<li><a href="#ch24">Class Metaprogramming</a></li>
</ol>
<h2 id="ch1">Chapter 1. The Python Data Model</h2>
<p>The syntax <code>obj[key]</code> is supported by the <code>__getitem__</code> special method (also called <em>dunder methods</em>).</p>
<p><em>Example 1.1</em>. A Pythonic card deck (a sequence of playing cards)</p>
<pre><code>import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'clubs diamonds hearts spades'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                       for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]
</code></pre>
<p>Creating Cards and Decks, then accessing the elements of the deck:</p>
<pre><code>c = Card('7', 'hearts')
deck = FrenchDeck()
top_card = deck[0]
</code></pre>
<p>Sorting according to specific criteria:</p>
<pre><code>suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)

def spades_high(card):
    rank_value = FrenchDeck.ranks.index(card.rank)
    return rank_value * len(suit_values) + suit_values[card.suit]

for card in sorted(deck, key=spades_high):
    print(card)
</code></pre>
<p>So far, there's no way to shuffle the deck. <code>random.choice</code> could be used to draw cards one by one, but the <code>__setitem__</code> method must be implemented for a true shuffle.</p>
<p><em>Example 1.2</em>. A 2-D vector class</p>
<pre><code>class Vector:
      def __init__(self, x=0, y=0):
          self.x = x
          self.y = y

      # ...

      def __add__(self, other):
          x = self.x + other.x
          y = self.y + other.y
          return Vector(x, y)

      def __mul__(self, scalar):
          return Vector(self.x * scalar, self.y * scalar)
</code></pre>
<h4><code>__repr__</code> vs. <code>__str__</code></h4>
<p><code>__repr__</code> strings should be unambiguous and if possible, match the constructor call (<code>Vector(3, 4)</code>).</p>
<p><code>__str__</code> is called by <code>str(...)</code>.</p>
<h2 id="ch2">Chapter 2. An Array of Sequences</h2>
<p>Mutable sequences:</p>
<ul>
<li>list</li>
<li>bytearray</li>
<li>collections.deque</li>
</ul>
<p>Immutable sequences:</p>
<ul>
<li>tuple</li>
<li>str</li>
<li>bytes</li>
</ul>
<p><em>Example 2.2</em>. A list comprehension (listcomp)</p>
<pre><code>codes = [ord(symbol) for symbol in symbols]
</code></pre>
<p><em>Example 2.5</em>. Initializing a tuple with a generator expression (genexp)</p>
<pre><code>tuple(ord(symbol) for symbol in symbols)
</code></pre>
<p>A tuple can be seen as a <strong>record</strong>.</p>
<p><em>Example 2.9</em>. Using <code>match</code></p>
<pre><code>def handle_command(self, message):
    match message:
        case ['Beeper', frequency, times]:
            self.beep(frequency, times)
        case ['LED', ident, intensity]:
            # ...
        case ['LED', ident, red, green, blue]:
            #...
</code></pre>
<p>The following are compatible with sequence patterns: <code>list</code>, <code>memoryview</code>, <code>array.array</code>, <code>tuple</code>, <code>range</code>, <code>collections.deque</code></p>
<p>A <code>str</code> is not handled as a sequence, but rather, an atomic value.</p>
<p>A <em>slice</em> can be stored in a variable:</p>
<pre><code>SKU = slice(0, 6)
DESCRIPTION = slice(6, 40)

print(item[SKU], item[DESCRIPTION])
</code></pre>
<p><code>memoryview</code> is a shared-memory sequence type that does not copy bytes.</p>
<h2 id="ch3">Chapter 3. Dictionaries and Sets</h2>
<p><em>Example 3.1</em>. A dict comprehension (dictcomp)</p>
<pre><code>country_dial = {country: code for country, code in dial_codes}
</code></pre>
<p><em>Example 3.2</em>. Matching dicts</p>
<pre><code>def get_creators(record: dict) -&gt; list:
    match record:
        case {'type': 'book', 'api', 2, 'authors': [*names]}:
            return names
        case {'type': 'book'}:
            raise ValueError(f"Invalid 'book' record: {record!r}")
        case _:
            raise ValueError(f"Invalid record")
</code></pre>
<h4>Hashable objects</h4>
<p>An object is hashable if it has a hash code which never changes during its lifetimes. It needs a <code>__hash__()</code> and <code>__eq__()</code> method to be compared to other objects. Hashable objects which compare equal must have the same hash code.</p>
<p>If an object implements a custom <code>__eq__()</code> that takes into account its internal state, it will be hashable only if its <code>__hash__()</code> always returns the same hash code.</p>
<p>Get a value, but if a key is missing, fall back to a default: <code>d.get(key, default)</code></p>
<p>Get a value if a given key exists, but if not, set it to the "default" value: <code>d.setdefault(k, value)</code></p>
<p>The <code>__missing__</code> method is called when trying to get a missing key.</p>
<p><code>collections.Counter</code> is useful to find out the number of occurrences of values in a list.</p>
<p>Prefer extending <code>collections.UserDict</code> instead of <code>dict</code> (there are methods that are inheritable, instead of overriding <code>dict</code> methods).</p>
<h2 id="ch4">Chapter 4. Unicode Text Versus Bytes</h2>
<h3>Byte essentials</h3>
<p>An item in <code>bytes</code> or <code>bytearray</code> is an integer from <code>0</code> to <code>255</code>.</p>
<pre><code>cafe = bytes('caf√©', encoding='utf-8')  # b'caf\xc3\xa9'
</code></pre>
<h4>The Unicode sandwich (current best practice for text processing)</h4>
<ul>
<li>bytes to str (decode bytes on input)</li>
<li>100% str (process text only)</li>
<li>str to bytes (encode text on output)</li>
</ul>
<h4>Remove all diacritics from a <code>str</code></h4>
<pre><code>import unicodedata
import string


def shave_marks(txt):
    norm_txt = unicodedata.normalize('NFD', txt)
    shaved = ''.join(c for c in norm_txt if not unicodedata.combining(c))
    return unicodedata.normalize('NFC', shaved)
</code></pre>
<p><code>pyuca</code> is an implementation of the Unicode Collation Algorithm, which can be used to correctly sort strings with accents.</p>
<h2 id="ch5">Chapter 5. Data Class Builders</h2>
<p><code>collections.namedtuple</code> is the simplest way of creating a data class.</p>
<p><code>@dataclasses.dataclass</code> is a decorator that allows more customizaion.</p>
<p>However, type hints are mandatory with <code>@dataclass</code>.</p>
<p><em>Example 5.12</em>. A class decorated with <code>@dataclass</code></p>
<pre><code>from dataclasses import dataclass

@dataclass
class DemoDataClass:
    a: int
    b: float = 1.1
    c = 'spam
</code></pre>
<p>Dataclass instances are mutable.</p>
<p>It is possible to pattern match class instances: <code>case float(): ...</code> Remember to add the <code>()</code></p>
<h2 id="ch6">Chapter 6. Object References, Mutability, and Recycling</h2>
<p>Variables should be compared to labels, not boxes. It's also helpful to think of variable "binding" instead of assignment, which implies a direction and is not consistently well defined.</p>
<p><code>copy.deepcopy</code> allows making deep copies of objects (assignment is shallow by default).</p>
<p>Parameter passing is <em>call by sharing</em>. A copy of each reference is made. It is not possible to change the identity of a parameter, but mutable objects that are passed can be changed.</p>
<p>Defensive programming:</p>
<pre><code># Bus example
def __init__(self, passengers=None):
    if passengers is None:
        self.passengers = []
    else:
        self.passengers = list(passengers)
</code></pre>
<p><code>del</code> deletes references, not objects.</p>
<h2 id="ch7">Chapter 7. Functions as First-Class Objects</h2>
<p><code>reduce</code> is found in <code>functools.reduce</code>. <code>add</code> is <code>operator.add</code>.</p>
<p><code>all(iterable)</code> and <code>any(iterable)</code> check <code>iterable</code>.</p>
<p><code>lambda</code> must be an expression: <code>sorted(fruits, key=lambda word: word[::-1])</code> sorts by their reversed spelling.</p>
<p><code>operator.attrgetter</code> and <code>operator.itemgetter</code> can also be used as the sort <code>key</code>:</p>
<pre><code>for city in sorted(metro_data, key=itemgetter(1)): ...

for city in sorted(metro_areas, key=attrgetter('coord.lat')): ...
</code></pre>
<p>Freeze arguments with <code>functools.partial</code>.</p>
<h2 id="ch8">Chapter 8. Type Hints in Functions</h2>
<p>(Examples given are passed to <code>mypy</code> in the command line).</p>
<p>To reformat code, use <code>blue</code>.</p>
<p><code>Protocol</code> enables static duck typing.</p>
<p>Mypy has a magic <code>reveal_type()</code> function.</p>
<h2 id="ch9">Chapter 9. Decorators and Closures</h2>
<p>A decorator is a callable that takes another function as an argument (the decorated function).</p>
<pre><code>@decorate
def target():
    pass

# is the same as

def target():
    pass

target = decorate(target)
</code></pre>
<p>Decorators can be stacked. The one closest to the decorated function runs first:</p>
<pre><code>@alpha
@beta
def my_fn():
    # ...

# is the same as

my_fn = alpha(beta(my_fn))
</code></pre>
<p>Generally speaking, decorators are:</p>
<ul>
<li>a function or another callable</li>
<li>may replace the decorated function with a different one</li>
<li>executes immediately when a module is loaded (import time)</li>
</ul>
<p>A closure (let's say, <code>f</code>) is a function with an extended scope that includes variables that existed in a scope outside of <code>f</code>. In other words, <code>f</code> can access nonglobal variables that are defined outside of its body (called free variables).</p>
<h3>Decorators in the Standard Library</h3>
<p>Memoization is possible with <code>functools.cache</code>. (An optimization technique that saves the results of previous calls of a function, avoiding repeat computations).</p>
<p><em>Example 9.20</em>. Using <code>@singledispatch</code> to create a generic function</p>
<p><em>Example 9.21</em> <code>registration.py</code> module, with <code>register</code> decorator</p>
<h2 id="ch10">Chapter 10. Design Patterns with First-Class Functions</h2>
<p><strong>Strategy pattern</strong>: Online store with different discount rules</p>
<p><strong>Command pattern</strong>: Document editor with open, paste, and macro commands</p>
<h2 id="ch11">Chapter 11. A Pythonic Object</h2>
<p>Vector class</p>
<p><code>@classmethod</code> and <code>@staticmethod</code></p>
<h2 id="ch12">Chapter 12. Special Methods for Sequences</h2>
<p><code>__getitem__</code>, <code>__getattr__</code>, <code>__setattr__</code>, <code>__hash__</code>, <code>__eq__</code></p>
<h2 id="ch13">Chapter 13. Interfaces, Protocols, and ABCs</h2>
<p>Duck typing, Goose typing, Static typing, and Static duck typing</p>
<p><strong>Dynamic protocol</strong>: the informal protocols that Python always had. Implicit and defined by convention</p>
<p><strong>Static protocol</strong>: for structural subtyping (static duck typing). A subclass of <code>typing.Protocol</code>.</p>
<p>Abstract Base Classes (ABCs) are used to define interfaces for explicit type checking at runtime.</p>
<h2 id="ch14">Chapter 14. Inheritance: For Better or for Worse</h2>
<p>Invoking an overridden <code>__init__</code> method:</p>
<pre><code>def __init__(self, a, b):
    super().__init__(a, b)
    # ...
</code></pre>
<p>Override <code>UserDict</code>, <code>UserList</code>, and <code>UserString</code> instead of the basic types (dict, list, str).</p>
<p><code>__mro__</code>: a class attribute holding a tuple of references to the superclasses in method resolution order.</p>
<h2 id="ch15">Chapter 15. More About Type Hints</h2>
<p><code>@typing.overload</code> decorator</p>
<p>Runtime checking of JSON structures: use <code>pydantic</code></p>
<p>Type Variance: covariant, contravariant types</p>
<h2 id="ch16">Chapter 16. Operator Overloading</h2>
<p>Define dunder methods like <code>__add__</code>.</p>
<h2 id="ch17">Chapter 17. Iterators, Generators, and Classic Coroutines</h2>



</div>
<br>
<hr>
<div style="padding-left: 0.5em; background-color: #fff;">
  <a href="javascript:history.back()">&#x1F519; Back</a>&nbsp;&nbsp;&nbsp;
  <a href="index.html">&#x1F4C2; Dir list</a>&nbsp;&nbsp;&nbsp;
  <a href="#top">&#x1F51D; Top</a>&nbsp;&nbsp;&nbsp;
</div>
<br><br><br>
    </body>
</html>

