<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>HC Docs</title>
        <style>
        body {
          font-family: sans-serif;
        }

        a {
          text-decoration: none;
          display: inline-block;
        }

        a.index {
          margin-bottom: 1rem;
        }

        h2, h3, h4 {
          margin-top: 2.5rem;
        }

        pre {
          display: block;
          margin: 1rem;
          padding: 1rem;
          border: 1px solid #ccc;
          background-color: #eee;
          border-radius: 0.8rem;
        }

        code {
          background-color: #e3f3ff;
          color: #031;
          font-size: 115%;
          padding: 0.2rem;
        }

        .hc-monospace {
          font-family: monospace;
          font-size: 115%;
        }

        </style>
    </head>
    <body>
      <p>
        <a href="javascript:history.back()">&#x1F519; Back</a>&nbsp;&nbsp;&nbsp;
        <a href="index.html">&#x1F4C2; Directory list</a>&nbsp;&nbsp;&nbsp;
        <a href="../index.html">&#x1F51D; Up one level</a>&nbsp;&nbsp;&nbsp;
      </p>


    <body>
    <h3><a href="../../index.html">home</a>/<a href="../index.html">programming</a>/<a href="index.html">book-notes</a></h3>
    
<h1>Practices of the Python Pro, &copy; 2020</h1>

<ul>
  <li><a href="#ch1">Ch. 1 The bigger picture</a></li>
  <li><a href="#ch2">Ch. 2 Separation of concerns</a></li>
  <li><a href="#ch3">Ch. 3 Abstraction and encapsulation</a></li>
  <li><a href="#ch4">Ch. 4 Designing for high performance</a></li>
  <li><a href="#ch5">Ch. 5 Testing your software</a></li>
  <li><a href="#ch6">Ch. 6 Separation of concerns in practice</a></li>
  <li><a href="#ch7">Ch. 7 Extensibility and flexibility</a></li>
  <li><a href="#ch8">Ch. 8 The rules and exceptions of inheritance</a></li>
  <li><a href="#ch9">Ch. 9 Keeping things lightweight</a></li>
  <li><a href="#ch10">Ch. 10 Achieving loose coupling</a></li>
  <li><a href="#ch11">Ch. 11 Onward and upward</a></li>
</ul>


<h4 id="ch1">1.4.1 Considerations in software design (p. 9)</h4>

<p>
  Users assess these features:
  <ul>
    <li>Speed</li>
    <li>Integrity (data is not corrupted)</li>
    <li>Resources are used efficiently</li>
    <li>Security is strong</li>
  </ul>
</p>

<p>
  A developer should focus on:
  <ul>
    <lI>Loose coupling: components are not intricately dependent on one another</lI>
    <li>Intuitability: other developers can discover the nature of the software and how it works by reading it</li>
    <li>Flexibility: the software can be easily adapted</li>
    <lI>Extensibility: new aspects of the software may be added without inadvertently affecting other parts</lI>
  </ul>
</p>

<h4>1.4.2 Organically grown software (p. 10)</h4>

<p>
  <em>Refactoring</em> code is the process of updating it so it's better designed and reflects the latest best practices.
</p>

<p>
  The steps in an e-commerce site may be separated into several services:
  <ul>
    <li>Trigger order
      <ul>
        <li>inventory service</li>
        <li>pricing service</li>
        <li>shipping service</li>
      </ul>
    </li>

    <li>Purchase
      <ul>
        <li>payment service</li>
      </ul>
    </li>

    <li>Send to fulfillment
      <ul>
        <li>fulfillment service</li>
      </ul>
    </li>
  </ul>
</p>

<h4>1.5 When to invest in design (p. 11)</h4>

<p>
  A <em>framework</em> is a large collection of libraries that act as a guide to some goal. It should provide building blocks that allow for flexibility and extensibility.
</p>

<p>
  Examples:
  <ul>
    <li>requests</li>
    <li>Django</li>
    <li>Pandas</li>
  </ul>
</p>

<h4>1.7.1 Presence of mind (p. 13)</h4>

<p>
  The <em>REPL</em> (read-eval-print loop) is valuable for exploratory work.
</p>

<h4 id="ch2">2 Separation of concerns (p. 19)</h4>

<p>
  Clear code should be separated into small, manageable pieces by <em>concern</em>.
</p>

<p>
  A <em>concern</em> is a distinct behavior or piece of knowledge the software deals with.
</p>

<h4>2.1 Namespacing (p. 20)</h4>

<p>
  A <em>variable</em> is a name that refers to a value, and they belong to <em>namespaces</em>. When loading the Python interpreter, the initial namespace is the <em>built-in</em> namespace.
</p>

<p>
  Creating a Python module automatically creates an additional namespace for that module. For example, a file named <code>sales_tax.py</code> creates the <code>sales_tax</code> namespace.
</p>

<h4>2.2.2 Classes (p. 32)</h4>

<p>
  A <em>class</em> is a template of closely related behaviors and data. <em>Instances</em> of classes are objects that have the behavior and data defined in the class.
</p>

<p>
  The <em>state</em> (<em>attributes</em>) of the object is the data, and its behaviors are called <em>methods</em>. They are special functions that receive the object instance as an implicit argument (by convention, named <code>self</code>). Together, the attributes and methods are <em>members</em> of a class.
</p>

<p>
  A class' <em>constructor</em> is a special method that creates an instance. In Python, <code>__init__</code> is used.
</p>

<h4>(p. 35)</h4>

<p>
  Instead of passing data around as arguments to functions, one can store these values in attributes:
</p>

<pre>
def __init__(self):
    self.computer_choice = None
    self.human_choice = None

def get_computer_choice(self):
    self.computer_choice = random.choice(OPTIONS)

def print_choices(self):
    print("Your choice and the computer's are:", self.human_choice, self.computer_choice)
</pre>

<p>
  When a class' methods and attributes are closely related, it's said to have high <em>cohesion</em>.
</p>

<p>
  Loose coupling between components (little interdependence) is preferred because making changes to one should not affect the other at all (or very little).
</p>

<h4>(p. 38)</h4>

<p>
  <em>Packages</em> add further structure by grouping together related modules. In Python, a package is nothing more than a directory that contains modules.
</p>

<p>
  An <code>__init__.py</code> file should be placed in a directory for it to be considered a package. Although there's <em>namespace package</em> behavior that works without <code>__init__.py</code>, many tools won't work without it.
</p>

<h4 id="ch3">3.1 What is abstraction? (p. 42)</h4>

<p>
  <em>Abstraction</em> is the process of taking something concrete and stripping it of specifics.
</p>

<h4>3.1.2 Abstraction is like an onion (p. 43)</h4>

<p>
  Writing and reading code in large systems is like peeling an onion.
</p>

<ul>
  <li>E-commerce system
    <ul>
      <li>Credit card processing
        <ul>
          <li>HTTP calls
            <ul>
              <li>Database operations</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4>3.1.4 Decomposition enables abstraction (p. 46)</h4>

<p>
  An e-commerce system may be broken down into:
</p>

<ul>
  <li>Catalog</li>
  <li>Shopping cart
    <ul>
      <li>Calculate tax</li>
      <li>Calculate shipping</li>
      <li>Apply discount</li>
    </ul>
  </li>
  <li>Payment processing</li>
</ul>

<h4>3.2 Encapsulation (p. 47)</h4>

<p>
  <em>Encapsulation</em> groups together related functions and data into a larger construct. This construct acts as a barrier or capsule to the outside world.
</p>

<p>
  Most often, encapsulation in Python is done with a class. However, modules are also a form of encapsulation.
</p>

<p>
  The largest encapsulation available in Python is a package.
</p>

<h4>3.2.2 Expectations of privacy in Python (p. 48)</h4>

<p>
  In a stricter language, classes can have public and private methods. Public methods and attributes act as the class' <em>interface</em>, which is how other classes interact with it.
</p>

<p>
  Python does not implement public and private access. Instead, by convention, names starting with an underscore (_) are to be taken as private.
</p>

<h4>3.3 Try it out (p. 48)</h4>

<iframe width="800" height="400" src="practices-py-pro/greeter.py.txt"></iframe>

<p>
  However, <code>day</code> and <code>part_of_day</code> can be extracted out of the <code>Greeter</code> class because they are independent of whatever store they happened to be called from.
</p>

<p>
  Once these two functions are made independent, they may easily be used by other modules as well.
</p>

<h4>3.5 Typing, inheritance, and polymorphism (p. 54)</h4>

<p>
  <em>Polymorphism</em> is a language feature where objects of different types provide specialized behavior via a consistent method name.
</p>

<p>
  In the beginning, systems were often modeled as cascades of inherited classes. A major downside of this approach is that code became rigid and hard to update. Making one change could lead to a massive ripple of changes all the way up or down the tree.
</p>

<p>
  Recently, the preference has shifted to composing behaviors into an object.
</p>

<h4>(p. 55)</h4>

<p>
  Instead of building an inheritance tree of Mammal &gt; Quadruped &gt; Canine &gt; Dog, it is possible to assign <em>traits</em> to the Dog class. For example, it is a Quadruped, but not a Biped.
</p>

<p>
  Composition is done through a language feature called an <em>interface</em>. They are formal definitions of methods and data that a class must implement.
</p>

<p>
  Python lacks interfaces, but allows <em>multiple inheritance</em>. In this context, an "interface" would often be called a <em>mixin</em>. For example, a Dog may inherit a <code>RollOverMixin</code>.
</p>

<h4>3.6.1 Square pegs in round holes (p. 56)</h4>

<p>
  If the interface to a third-party package causes friction, an <em>adapter</em> may be written as an abstraction around that interface
</p>

<h4 id="ch4">4 Designing for high performance (p. 58)</h4>

<p>
  Software that performs at an acceptable level (uses resources efficiently and responds within a desirable time frame) is said to be <em>performant</em>.
</p>

<p>
  Software has <em>time complexity</em> and <em>space complexity</em>.
</p>

<h4>4.1.1 Complexity is a little ... complex (p. 59)</h4>

<p>
  Big O notation signifies the worst-case performance of a given piece of code.
</p>

<h4>4.2.3 Space complexity of operations on data types (p. 65)</h4>

<p>
  <em>Generators</em> are constructs that produce a single value at a time, pausing until the next value is requested. In this way, it avoids storing all values it produces in memory all at once.
</p>

<iframe width="800" height="400" src="practices-py-pro/range.py.txt"></iframe>

<h4>4.4.1 timeit (p. 72)</h4>

<pre>
from timeit import timeit

setup = 'from datetime import datetime'
statement = 'datetime.now()'
result = timeit(setup=setup, stmt=statement)
print(f"Took an average of {result} ms")
</pre>

<h4>4.4.2 CPU profiling (p. 73)</h4>

<p>
  Use the <code>cProfile</code> or <code>profile</code> module:
</p>

<p>
  <code>python -m cProfile --sort cumtime cpu_profiling.py.txt</code>
</p>

<h4 id="ch5">5.1.2 The anatomy of a functional test (p. 78)</h4>

<p>
  Testing that some code produces the right output for a given input is <em>functional testing</em> because it makes sure that the code <em>functions</em> correctly.
</p>

<ul>
  <li>Prepare the inputs to the code</li>
  <li>Identify the expected output</li>
  <li>Obtain the actual output</li>
  <li>Compare the actual and expected outputs to see if they match</li>
</ul>

<p>
  Examples:
  <ul>
    <li>Given the list of integers <code>[1, 2, 3, 4]</code>, the expected output of <code>calculate_mean</code> is <code>2.5</code>. Verify that the actual output matches this expectation.</li>
    <li>Given I visit the page for product <code>53-DE-232</code> and click on <em>Add to cart</em>, I expect to see it in my cart.</li>
  </ul>
</p>

<h4>5.2.1 Manual testing (p. 80)</h4>

<p>
  <em>Manual testing</em> is the practice of running your application, giving it some inputs, and checking whether it does what you expect. You might miss something if you rely too much on manual testing.
</p>

<h4>5.2.3 Acceptance testing (p.80)</h4>

<p>
  <em>Acceptance testing</em> verifies the high-level requirements of a system. Software that passes these tests is <em>acceptable</em>.
</p>

<p>
  <em>End-to-end testing</em> makes sure a set of actions can be carried out (from one end to the other) with the appropriate data flowing through where needed.
</p>

<p>
  Cucumber.io is a library that enables you to describe end-to-end tests in natural language.
</p>

<p>
  BDD (Behavior-Driven Development) allows you to collaborate with others on end-to-end testing.
</p>

<h4>5.2.4 Unit testing (p. 82)</h4>

<p>
  <em>Unit tests</em> make sure all the little bits of your software are working. A <em>unit</em> of code is the smallest piece that can be isolated for testing. However, classes may be treated as units, even though they contain pieces that could have been isolated.
</p>

<p>
  Consider all kinds of use cases when writing tests, including empty and invalid input, to ensure the code handles all of them gracefully.
</p>

<h4>5.2.5 Integration testing (p. 83)</h4>

<p>
  <em>Integration testing</em> focuses on making sure a number of units all work in tandem to produce the right behavior.
</p>

<p>
  End-to-end workflow tests are usually framed from the point of view of a user, while integration tests focus more on the behavior of the code. They're at different levels of abstraction.
</p>

<h4>5.2.6 The testing pyramid (p. 84)</h4>

<p>
  <img src="practices-py-pro/testing_pyramid.png" alt="pyramid">
</p>

<h4>5.2.7 Regression testing (p. 85)</h4>

<p>
  A <em>regression</em> is a change in behavior you tested caused by a change in the code. It's a shift to an undesirable or unexpected state and is usually a bad thing.
</p>

<p>
  <em>Regression testing</em> is the practice of running your existing suite of tests after each code change.
</p>

<p>
  Test suites (collection of tests) may be run in a <em>continuous integration</em> (CI) environment.
</p>

<h4>5.3 Statements of fact (p. 86)</h4>

<p>
  <em>Assertions</em> are statements of fact. For example, if the sky is clear, you can see the sun every morning.
</p>

<pre>
assert 1.0 == calculate_mean([100, 200, 3500])
# raises an AssertionError
</pre>

<h4>5.4 Unit testing with unittest (p. 86)</h4>

<p>
  <code>unittest</code> is Python's built-in testing framework. It can be used to group many tests for a class, or many tests for a single method. It may also be used for integration testing.
</p>

<p>
  Running <code>python -m unittest</code> will cause the test runner to:
  <ol>
    <li>Look in the current directory and subdirectories for modules named <code>test_*</code> or <code>*_test</code></li>
    <li>Look in these modules for classes that inherit from <code>unittest.TestCase</code></li>
    <li>Look in these classes for methods that start with <code>test_</code></li>
  </ol>
</p>

<p>
  There's no right way to organize the tests. Some people put tests as close to the relevant code as possible, while others use a separate <span class="hc-monospace">tests/</span> directory.
</p>

<h4>5.4.3 Writing your first test with unittest (p. 87)</h4>

<p>
  The following class will be used for practicing how to write tests:
</p>

<iframe width="800" height="400" src="practices-py-pro/product.py.txt"></iframe>

<p>
  This class represents a product for purchase in an e-commerce system. Below is a unittest for it:
</p>

<iframe width="800" height="400" src="practices-py-pro/test_product.py.txt"></iframe>

<p>
  The test is run in the console with <code>python -m unittest</code>
</p>

<h4>5.4.4 Writing your first integration test with unittest (p. 90)</h4>

<iframe width="800" height="400" src="practices-py-pro/cart.py.txt"></iframe>

<iframe width="800" height="400" src="practices-py-pro/test_cart.py.txt"></iframe>

<h4>5.4.5 Test doubles (p. 92)</h4>

<p>
  Code often interacts with other systems, such as databases and APIs. Since the code can do destructive operations, tests should not affect the real thing.
</p>

<p>
  <em>Test doubles</em> replace the real thing:
  <ul>
    <li><em>Faking</em>: using a system that behaves like the real one, but avoids destructive or expensive actions</li>
    <li><em>Stubbing</em>: using a predetermined value as a response instead of requesting a real one</li>
    <li><em>Mocking</em>: using a system with the same interface as the real one, but that also records interactions for later inspection and assertions</li>
  </ul>
</p>

<p>
  Consider this code that requests tax information:
</p>

<iframe width="800" height="400" src="practices-py-pro/tax.py.txt"></iframe>

<p>
  A unit test with mocking could look like:
</p>

<iframe width="800" height="400" src="practices-py-pro/test_tax.py.txt"></iframe>

<h4>5.5.1 Test organization with pytest (p. 97)</h4>

<p>
  pytest also discovers tests automatically. However, test classes must be named <code>Test*</code> and don't need to inherit from a base class.
</p>

<p>
  Instead of <code>assertEqual(expected, actual)</code>, pytest uses <code>assert expected == actual</code>
</p>

<p>
  Run pytest in the console with <code>pytest</code>
</p>

<h4>5.6.2 Load testing (p. 100)</h4>

<p>
  <em>Load testing</em> is a type of performance testing, to see how far your application can be pushed until it falls over or no longer performs acceptably. Load testing falls somewhere above integration testing in the testing pyramid.
</p>

<h4>5.7.2 TDD is a philosophy (p. 100)</h4>

<p>
  If you find testing some aspect of a function's behavior is awkward or difficult, try to determine if it's because the code's concerns aren't well separated or if it's inherently awkward to test.
</p>

<p>
  Don't refactor code to make testing easier or coverage stronger. Do it to make testing easier and code more coherent.
</p>

<h3>Project: Bark (bookmarks manager)</h3>

<p>
  Files for this project are in <a href="practices-py-pro/bark/index.html">the bark directory (click here).</a>
</p>

<h4 id="ch6">6.3.2 The business logic layer (p. 115)</h4>

<p>
  Using the <em>command pattern</em>, the logic of each action is encapsulated and triggered via an <code>execute</code> method, thus decoupling the actions from the presentation layer.
</p>

<h4 id="ch7">7.1 What is extensible code? (p. 127)</h4>

<p>
  Code is <em>extensible</em> if adding new behaviors to it has little or no impact on existing behaviors. Plugin systems are implementations of extensibility.
</p>

<h4>7.1.1 Adding new behaviors (p. 128)</h4>

<p>
  Duplicating some code and updating the new copy is perfectly valid. By seeing how the new version differs, it is easier to refactor back into a single, multipurpose version later. Deduplicating code without a thorough understanding of all the ways it's being used might make the code inflexible to future changes.
</p>

<h3>7.2 Solutions for rigidity (p. 133)</h3>

<h4>7.2.1 Letting go: inversion of control (p. 133)</h4>

<p>
  Composition provides benefits over inheritance by allowing objects to reuse behaviors without confining them to a particular inheritance hierarchy.
</p>

<p>
  Consider this code:
</p>

<pre>
class Tire:
    pass

class Frame:
    pass

class Bicycle:
    def __init__(self):
        self.front_tire = Tire()
        self.back_tire = Tire()
        self.frame = Frame()
</pre>

<p>
  It is well encapsulated and abstracted, and adding new parts is straightforward. However, changing or upgrading the parts dynamically is hard because the structure is hardcoded into the initialization.
</p>

<p>
  <code>Bicycle</code> depends on <code>Tire</code> and <code>Frame</code>. For example, using a <code>CarbonFiberFrame</code> will require changing the constructor.
</p>

<p>
  <em>Inversion of control</em> says that instead of creating instances of dependencies in the class, you pass in existing instances for the class to make use of.
</p>

<p>
  <em>Control</em> of dependency creation is <em>inverted</em> by giving the control to whatever code is creating the <code>Bicycle</code>.
</p>

<p>
  <img src="practices-py-pro/inversion_of_control.png" alt="inversion">
</p>

<pre>
class Tire:
    pass

class Frame:
    pass

class Bicycle:
    def __init__(self, front_tire, back_tire, frame_type):
        self.front_tire = front_tire
        self.back_tire = back_tire
        self.frame = frame

if __name__ == '__main__':
    bike = Bicycle(Tire(), Tire(), Frame())
    # ride bike
</pre>

<h4>7.2.2 The devil's in the details: Relying on interfaces (p. 136)</h4>

<p>
  By sharing agreed-upon interfaces between high- and low-level code will give you the freedom to swap implementations in and out.
</p>


<h4>7.2.3 Fighting entropy: The robustness principle (p. 137)</h4>

<p>
  The <em>robustness principle</em>, also known as Postel's Law, says to "be conservative in what you do, and be liberal in what you accept from others."
</p>

<p>
  For example, map a large range of input into a smaller range to direct the flow of information toward a more limited, expected range.
</p>

<h4 id="ch8">8.1.2 The challenges of hierarches (p. 144)</h4>

<p>
  Object-oriented programming is all about the separation, encapsulation, and classification of information and behaviors.
</p>

<p>
  <em>Parent</em> and <em>child</em> classes will be called <em>superclasses</em> and <em>subclasses</em> in this book.
</p>

<h4>8.2.1 What is inheritance for, really? (p. 146)</h4>

<p>
  Inheritance is for <em>specialization of behavior</em>. Subclasses should be treated as <em>special cases</em> of their superclass.
</p>

<table style="border-spacing: 0.8rem;">
  <tr>
    <td>B inherits from A</td>
    <td>B is-a A</td>
  </tr>
  <tr>
    <td>C uses an instance of D</td>
    <td>C has-a D</td>
  </tr>
</table>

<h4>8.2.2 Substitutability (p. 147)</h4>

<p>
  The <em>Liskov substitution principle</em> states that in a program, any instance of a class must be replaceable by an instance of one of its subclasses without affecting the correctness of the program (the program remains error-free and achieves the same basic outcomes).
</p>

<p>
  If a subclass' constructor requires a new argument, substitutability is violated. For example, a <code>Snail</code> class that inherits from <code>Slug</code> whose constructor requires the size of the shell.
</p>

<p>
  One way around this is to use composition: a <code>Snail</code> has-a <code>Shell</code>.
</p>

<p>
  If a subclass changes any method signatures or raises an exception as part of its specialization, it may not fulfill the role of the superclass.
</p>

<h4>8.2.3 The ideal use case for inheritance (p. 148)</h4>

<p>
  Sandi Metz, a Ruby programmer who came from the Smalltalk community, laid out these rules for when to use inheritance:
  <ul>
    <li>The problem you're solving has a shallow, narrow hierarchy.</li>
    <li>Subclasses are at the leaves of the object graph. They don't make use of other objects.</li>
    <li>Subclasses use or specialize <em>all</em> the behavior of their superclass.</li>
  </ul>
</p>

<p>
  A <em>shallow</em> hierarchy means that it is not deeply nested. A <em>narrow</em> hierarchy means that a superclass does not have too many subclasses.
</p>

<p>
  A <code>Bird</code> class is a good example of a class that should use composition for flying, because some birds like penguins can't fly. Code that expects all Birds to fly won't work.
</p>

<h4>8.3.1 Type inspection (p. 150)</h4>

<p>
  Python has the built-in <code>type()</code> function to tell which class a given object is an instance of. <code>isinstance()</code> is a predicate that checks if an object is an instance of a given class.
</p>

<pre>
&gt;&gt;&gt; type(42)
&lt;class 'int'&gt;

&gt;&gt;&gt; isinstance(42, int)
True
</pre>

<p>
  <code>issubclass(FancyTire, Tire)</code> is <code>True</code>. Note that a class is a subclass of itself, so passing the same class will return <code>True</code>.
</p>

<h4>8.3.2 Superclass access (p. 151)</h4>

<p>
  The <code>super()</code> function forwards any method or attribute access to the superclass.
</p>

<pre>
class CorruptTeller(Teller):
    def deposit(self, amount, account):
        super().deposit(amount * 0.99, account)
</pre>

<h4>Multiple inheritance and method resolution order (p. 152)</h4>

<p>
  The <em>method resolution order</em> determines the list of classes Python will search for the desired method. The steps are:
  <ol>
    <li>Generate a depth-first ordering of the superclasses, from left to right.</li>
    <li>Remove any duplicates.</li>
    <li>Move each class so that it appears after all of its subclasses.</li>
  </ol>
</p>

<p>
  A class has an <code>__mro__</code> attribute that returns its MRO. For example, <code>Tiger.__mro__</code>
</p>

<h4>8.3.4 Abstract base classes (p. 155)</h4>

<p>
  With <em>abstract base classes</em>, you will use something that looks like inheritance but achieves something that's effectively an interface.
</p>

<p>
  An abstract base class outlines which methods and attributes its subclasses <em>must</em> implement.
</p>

<p>
  The <code>abc</code> module has the <code>ABC</code> class. You can inherit from the <code>ABC</code> class to indicate that your class is an abstract base class.
</p>

<p>
  Abstract methods should be marked with the <code>@abstractmethod</code> decorator.
</p>

<pre>
from abc import ABC, abstractmethod


class Predator(ABC):
    @abstractmethod
    def eat(self, prey):
        pass

class Bear(Predator):
    def eat(self, prey):
        print(f'Maul {prey}')
</pre>

<h4 id="ch9">9.1.3 Code complexity (p. 162)</h4>

<p>
  Code <em>complexity</em> is a quantitative measurement of the characteristics of your code, not just a subjective measure of how confusing it may be.
</p>

<p>
  A common measure of code complexity is <em>cyclomatic</em> complexity. It involves determining the number of execution paths through a function or method (conditionals and loops).
</p>

<p>
  Counting the nodes and edges of a graph of the <em>control flow</em> (the execution path) of a function will give you its cyclomatic complexity.
</p>

<p>
  Nodes in the control flow graph are:
  <ul>
    <li>The "start"</li>
    <li><code>if/elif/else</code> conditions</li>
    <li><code>for/while</code> loops</li>
    <li>The "end" of a loop</li>
    <li><code>return</code> statements</li>
  </ul>
</p>

<p>
  The formula for cyclomatic complexity, <em>M</em>, is:
</p>

<p>
  <em>M = E - N + 2</em>
</p>

<p>
  where <em>E</em> is the number of edges and <em>N</em> is the number of nodes.
</p>

<p>
  Complexity should ideally be 10 or less.
</p>

<p>
  Tools such as <strong>SonarQube</strong> and <strong>Radon</strong> do the work of measuring complexity for you.
</p>

<h4>9.2.1 Extracting configuration (p. 166)</h4>

<p>
  Replace <code>if/elif/else</code> branches with a <code>dict</code> that map values to the needed values.
</p>

<p>
  Use functions to manipulate the raw value of <code>food</code>.
</p>

<iframe width="800" height="400" src="practices-py-pro/food_endpoints.py.txt"></iframe>

<p>
  Getting the right formatting function can be extracted into its own function:
</p>

<iframe width="800" height="400" src="practices-py-pro/food_endpoints2.py.txt"></iframe>

<h4>9.3.1 Initialization complexity (p. 171)</h4>

<p>
  Getters and setters are generally discouraged in Python because the can clutter up a class.
</p>

<p>
  The <code>@property</code> decorator can be used in Python to signify that a method on a class should be accessible as an attribute. <strong>Note</strong>: Methods can be used as properties only if <code>self</code> is their only argument, because when you access the attribute, you can't pass any arguments to it.
</p>

<h4>9.3.2 Extracting classes and forwarding calls (p. 173)</h4>

<p>
  <em>Forwarding</em> is to continue providing previously existing functionality while a new implementation is being built.
</p>

<p>
  Supposing we want several formatting options for the author of a book, an <code>Author</code> class may be extracted to contain these methods.
</p>

<p>
  When planning to remove code, warn the clients:
</p>

<pre>
import warnings

warnings.warn('Do not use this anymore!', DeprecationWarning)
</pre>

<h4 id="ch10">10.1 Defining coupling (p. 177)</h4>

<p>
  Coupling can be thought of as the connective tissue between different areas of your code. Alternatively, a kind of mesh that runs throughout your code.
</p>

<p>
  Tight coupling is not inherently <em>bad</em>.
</p>

<h4>10.1.2 Tight coupling (p. 178)</h4>

<p>
  Coupling between two pieces of code is <em>tight</em> when they are interconnected. Interconnections include:
  <ul>
    <li>a class storing another object as an attribute</li>
    <li>a class whose methods call functions from another module</li>
    <lI>a method that does a lot of procedural work using methods from another object</lI>
  </ul>
</p>

<p>
  When an entity needs to carry a lot of knowledge from another entity, they're tightly coupled.
</p>

<h4>10.1.3 Loose coupling (p. 181)</h4>

<p>
  <em>Loose coupling</em> is the ability of two pieces of code to interact to accomplish a task without either relying heavily on the details of the other. They often implement and use interfaces.
</p>

<p>
  Intercommunication between pieces of code is done with <em>messages</em> (questions you ask of an object or the things you tell it to do).
</p>

<h4>10.2 Recognizing coupling (p. 184)</h4>

<p>
  Three forms of coupling are described below:
</p>

<h4>10.2.1 Feature envy (p. 184)</h4>

<p>
  Code has <em>Feature envy</em> when it performs several tasks using mainly features from another area. For example, a main procedure that wants to be the search module because it uses all its features explicitly.
</p>

<p>
  One way to remove feature envy is to roll up multiple functionalities into a single entry point.
</p>

<h4>10.2.2 Shotgun surgery (p. 184)</h4>

<p>
  <em>Shotgun surgery</em>.is having to make changes far and wide after making a single change in order to keep code working. To minimize this unwanted work, separate concerns better and practice good encapsulation and abstraction.
</p>

<h4>10.2.3 Leaky abstractions (p. 185)</h4>

<p>
  A <em>leaky abstraction</em> is one that doesn't sufficiently hide its details. It ultimately asks the client to have some knowledge of what lies beneath it.
</p>

<p>
  An example of a leaky abstraction is the <code>requests</code> package exposing the HTTP error code when something goes wrong. It is useful for error handling, so it's a tradeoff between completely abstracting an error scenario and handing some control back to the calling code.
</p>

<h4 id="ch11">11.1 What now? (p. 199)</h4>

<p>
  A <em>mind map</em> is a visual, hierarchical structure that starts from a central node (an overall concept) and branches out to subtopics or related topics.
</p>

<p>
  <img src="practices-py-pro/mind_map.png" alt="mind map">
</p>

<br>
<hr>
<a href="javascript:history.back()">&#x1F519; Back</a>&nbsp;&nbsp;&nbsp;
<a href="index.html">&#x1F4C2; Directory list</a>&nbsp;&nbsp;&nbsp;
<a href="../index.html">&#x1F51D; Up one level</a>&nbsp;&nbsp;&nbsp;
    </body>
</html>

