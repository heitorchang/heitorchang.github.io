<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Capítulo 5: Condicionais e recursividade - Pense Python</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Cap\u00edtulo 5: Condicionais e recursividade";
    var mkdocs_page_input_path = "05-cond-recur.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Pense Python</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Pense em Python</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../00-prefacio/">Prefácio</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../01-jornada/">Capítulo 1: A jornada do programa</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../02-vars-expr-instr/">Capítulo 2: Variáveis, expressões e instruções</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../03-funcoes/">Capítulo 3: Funções</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../04-caso-interface/">Capítulo 4: Estudo de caso: projeto de interface</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Capítulo 5: Condicionais e recursividade</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#51-divisao-pelo-piso-e-modulo">5.1 - Divisão pelo piso e módulo</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#52-expressoes-booleanas">5.2 - Expressões booleanas</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#53-operadores-logicos">5.3 - Operadores lógicos</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#54-execucao-condicional">5.4 - Execução condicional</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#55-execucao-alternativa">5.5 - Execução alternativa</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#56-condicionais-encadeadas">5.6 - Condicionais encadeadas</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#57-condicionais-aninhadas">5.7 - Condicionais aninhadas</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#58-recursividade">5.8 - Recursividade</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#59-diagramas-da-pilha-para-funcoes-recursivas">5.9 - Diagramas da pilha para funções recursivas</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#510-recursividade-infinita">5.10 - Recursividade infinita</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#511-entrada-de-teclado">5.11 - Entrada de teclado</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#512-depuracao">5.12 - Depuração</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#513-glossario">5.13 - Glossário</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#514-exercicios">5.14 - Exercícios</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-51">Exercício 5.1</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-52">Exercício 5.2</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-53">Exercício 5.3</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-54">Exercício 5.4</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-55">Exercício 5.5</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-56">Exercício 5.6</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../06-funcoes-result/">Capítulo 6: Funções com resultado</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../07-iteracao/">Capítulo 7: Iteração</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../08-strings/">Capítulo 8: Strings</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../09-caso-palavras/">Capítulo 9: Estudo de caso: jogos de palavras</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../10-listas/">Capítulo 10: Listas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../11-dicionarios/">Capítulo 11: Dicionários</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../12-tuplas/">Capítulo 12: Tuplas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../13-caso-estruturas/">Capítulo 13: Estudo de caso: seleção de estrutura de dados</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../14-arquivos/">Capítulo 14: Arquivos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../15-classes-objetos/">Capítulo 15: Classes e objetos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../16-classes-funcoes/">Capítulo 16: Classes e funções</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../17-classes-metodos/">Capítulo 17: Classes e métodos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../18-heranca/">Capítulo 18: Herança</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../19-extra/">Capítulo 19: Extra</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../A-depuracao/">Apêndice A: Depuração</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../B-analise-algorit/">Apêndice B: Análise de algoritmos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../C-colofao-autor/">Colofão</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Pense Python</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Capítulo 5: Condicionais e recursividade</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="capitulo-5-condicionais-e-recursividade">Capítulo 5: Condicionais e recursividade</h1>
<p>O tópico principal deste capítulo é a instrução if, que executa códigos diferentes dependendo do estado do programa. Mas primeiro quero apresentar dois novos operadores: divisão pelo piso e módulo.</p>
<h2 id="51-divisao-pelo-piso-e-modulo">5.1 - Divisão pelo piso e módulo</h2>
<p>O operador de divisão pelo piso, //, divide dois números e arredonda o resultado para um número inteiro para baixo. Por exemplo, suponha que o tempo de execução de um filme seja de 105 minutos. Você pode querer saber a quanto isso corresponde em horas. A divisão convencional devolve um número de ponto flutuante:</p>
<pre><code class="language-python">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; minutes / 60
1.75
</code></pre>
<p>Mas não é comum escrever horas com pontos decimais. A divisão pelo piso devolve o número inteiro de horas, ignorando a parte fracionária:</p>
<pre><code class="language-python">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; hours = minutes // 60
&gt;&gt;&gt; hours
1
</code></pre>
<p>Para obter o resto, você pode subtrair uma hora em minutos:</p>
<pre><code class="language-python">&gt;&gt;&gt; remainder = minutes - hours * 60
&gt;&gt;&gt; remainder
45
</code></pre>
<p>Uma alternativa é usar o operador módulo, %, que divide dois números e devolve o resto:</p>
<pre><code class="language-python">&gt;&gt;&gt; remainder = minutes % 60
&gt;&gt;&gt; remainder
45
</code></pre>
<p>O operador módulo é mais útil do que parece. Por exemplo, é possível verificar se um número é divisível por outro – se x % y for zero, então x é divisível por y.</p>
<p>Além disso, você pode extrair o dígito ou dígitos mais à direita de um número. Por exemplo, x % 10 produz o dígito mais à direita de x (na base 10). Da mesma forma x % 100 produz os dois últimos dígitos.</p>
<p>Se estiver usando o Python 2, a divisão funciona de forma diferente. O operador de divisão, /, executa a divisão pelo piso se ambos os operandos forem números inteiros e faz a divisão de ponto flutuante se pelo menos um dos operandos for do tipo float.</p>
<h2 id="52-expressoes-booleanas">5.2 - Expressões booleanas</h2>
<p>Uma expressão booleana é uma expressão que pode ser verdadeira ou falsa. Os exemplos seguintes usam o operador ==, que compara dois operandos e produz True se forem iguais e False se não forem:</p>
<pre><code class="language-python">&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
</code></pre>
<p>True e False são valores especiais que pertencem ao tipo bool; não são strings:</p>
<pre><code class="language-python">&gt;&gt;&gt; type(True)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;
</code></pre>
<p>O operador == é um dos operadores relacionais; os outros são:</p>
<pre><code class="language-python">x != y                # x não é igual a y
x &gt; y                 # x é maior que y
x &lt; y                 # x é menor que y
x &gt;= y                # x é maior ou igual a y
x &lt;= y                # x é menor ou igual a y
</code></pre>
<p>Embora essas operações provavelmente sejam familiares para você, os símbolos do Python são diferentes dos símbolos matemáticos. Um erro comum é usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = é um operador de atribuição e == é um operador relacional. Não existe =&lt; ou =&gt;.</p>
<h2 id="53-operadores-logicos">5.3 - Operadores lógicos</h2>
<p>Há três operadores lógicos: and, or e not. A semântica (significado) destes operadores é semelhante ao seu significado em inglês. Por exemplo, x&gt; 0 and x &lt;10 só é verdade se x for maior que 0 e menor que 10.</p>
<p>n%2 == 0 or n%3 == 0 é verdadeiro se uma ou as duas condição(ões) for(em) verdadeira(s), isto é, se o número for divisível por 2 ou 3.</p>
<p>Finalmente, o operador not nega uma expressão booleana, então not (x &gt; y) é verdade se x &gt; y for falso, isto é, se x for menor que ou igual a y.</p>
<p>Falando estritamente, os operandos dos operadores lógicos devem ser expressões booleanas, mas o Python não é muito estrito. Qualquer número que não seja zero é interpretado como True:</p>
<pre><code class="language-python">&gt;&gt;&gt; 42 and True
True
</code></pre>
<p>Esta flexibilidade tem sua utilidade, mas há algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evitá-la (a menos que saiba o que está fazendo).</p>
<h2 id="54-execucao-condicional">5.4 - Execução condicional</h2>
<p>Para escrever programas úteis, quase sempre precisamos da capacidade de verificar condições e mudar o comportamento do programa de acordo com elas. Instruções condicionais nos dão esta capacidade. A forma mais simples é a instrução if:</p>
<pre><code class="language-python">if x &gt; 0:
    print('x is positive')
</code></pre>
<p>A expressão booleana depois do if é chamada de condição. Se for verdadeira, a instrução endentada é executada. Se não, nada acontece.</p>
<p>Instruções if têm a mesma estrutura que definições de função: um cabeçalho seguido de um corpo endentado. Instruções como essa são chamadas de instruções compostas.</p>
<p>Não há limite para o número de instruções que podem aparecer no corpo, mas deve haver pelo menos uma. Ocasionalmente, é útil ter um corpo sem instruções (normalmente como um espaço reservado para código que ainda não foi escrito). Neste caso, você pode usar a instrução pass, que não faz nada.</p>
<pre><code class="language-python">if x &lt; 0:
    pass          # A FAZER: lidar com valores negativos!
</code></pre>
<h2 id="55-execucao-alternativa">5.5 - Execução alternativa</h2>
<p>Uma segunda forma da instrução if é a “execução alternativa”, na qual há duas possibilidades e a condição determina qual será executada. A sintaxe pode ser algo assim:</p>
<pre><code class="language-python">if x % 2 == 0:
    print('x is even')
else:
    print('x is odd')
</code></pre>
<p>Se o resto quando x for dividido por 2 for 0, então sabemos que x é par e o programa exibe uma mensagem adequada. Se a condição for falsa, o segundo conjunto de instruções é executado. Como a condição deve ser verdadeira ou falsa, exatamente uma das alternativas será executada. As alternativas são chamadas de ramos (branches), porque são ramos no fluxo da execução.</p>
<h2 id="56-condicionais-encadeadas">5.6 - Condicionais encadeadas</h2>
<p>Às vezes, há mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma operação de computação é uma condicional encadeada:</p>
<pre><code class="language-python">if x &lt; y:
    print('x is less than y')
elif x &gt; y:
    print('x is greater than y')
else:
    print('x and y are equal')
</code></pre>
<p>elif é uma abreviatura de “else if”. Novamente, exatamente um ramo será executado. Não há nenhum limite para o número de instruções elif. Se houver uma cláusula else, ela deve estar no fim, mas não é preciso haver uma.</p>
<pre><code class="language-python">if choice == 'a':
    draw_a()
elif choice == 'b':
    draw_b()
elif choice == 'c':
    draw_c()
</code></pre>
<p>Cada condição é verificada em ordem. Se a primeira for falsa, a próxima é verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente é executado e a instrução é encerrada. Mesmo se mais de uma condição for verdade, só o primeiro ramo verdadeiro é executado.</p>
<h2 id="57-condicionais-aninhadas">5.7 - Condicionais aninhadas</h2>
<p>Uma condicional também pode ser aninhada dentro de outra. Poderíamos ter escrito o exemplo na seção anterior desta forma:</p>
<pre><code class="language-python">if x == y:
    print('x and y are equal')
else:
    if x &lt; y:
        print('x is less than y')
    else:
        print('x is greater than y')
</code></pre>
<p>A condicional exterior contém dois ramos. O primeiro ramo contém uma instrução simples. O segundo ramo contém outra instrução if, que tem outros dois ramos próprios. Esses dois ramos são instruções simples, embora pudessem ser instruções condicionais também.</p>
<p>Embora a endentação das instruções evidencie a estrutura das condicionais, condicionais aninhadas são difíceis de ler rapidamente. É uma boa ideia evitá-las quando for possível.</p>
<p>Operadores lógicos muitas vezes oferecem uma forma de simplificar instruções condicionais aninhadas. Por exemplo, podemos reescrever o seguinte código usando uma única condicional:</p>
<pre><code class="language-python">if 0 &lt; x:
    if x &lt; 10:
        print('x is a positive single-digit number.')
</code></pre>
<p>A instrução print só é executada se a colocarmos depois de ambas as condicionais, então podemos obter o mesmo efeito com o operador and:</p>
<pre><code class="language-python">if 0 &lt; x and x &lt; 10:
    print('x is a positive single-digit number.')
</code></pre>
<p>Para este tipo de condição, o Python oferece uma opção mais concisa:</p>
<pre><code class="language-python">if 0 &lt; x &lt; 10:
    print('x is a positive single-digit number.')
</code></pre>
<h2 id="58-recursividade">5.8 - Recursividade</h2>
<p>É legal para uma função chamar outra; também é legal para uma função chamar a si própria. Pode não ser óbvio porque isso é uma coisa boa, mas na verdade é uma das coisas mais mágicas que um programa pode fazer. Por exemplo, veja a seguinte função:</p>
<pre><code class="language-python">def countdown(n):
    if n &lt;= 0:
        print('Blastoff!')
    else:
        print(n)
        countdown(n-1)
</code></pre>
<p>Se n for 0 ou negativo, a palavra “Blastoff!” é exibida, senão a saída é n e então a função countdown é chamada – por si mesma – passando n-1 como argumento.</p>
<p>O que acontece se chamarmos esta função assim?</p>
<pre><code class="language-python">&gt;&gt;&gt; countdown(3)
</code></pre>
<p>A execução de countdown inicia com n=3 e como n é maior que 0, ela produz o valor 3 e então chama a si mesma...</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;A execução de countdown inicia com n=2 e como n é maior que 0, ela produz o valor 2 e então chama a si mesma...</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A execução de countdown inicia com n=1 e como n é maior que 0, ela produz o valor 1 e então chama a si mesma...</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A execução de countdown inicia com n=0 e como n não é maior que 0, ela produz a palavra “Blastoff!” e então retorna.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O countdown que recebeu n=1 retorna.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;O countdown que recebeu n=2 retorna.</p>
<p>O countdown que recebeu n=3 retorna.</p>
<p>E então você está de volta ao <code>__main__</code>. Então a saída completa será assim:</p>
<pre><code class="language-python">3
2
1
Blastoff!
</code></pre>
<p>Uma função que chama a si mesma é dita recursiva; o processo para executá-la é a recursividade.</p>
<p>Como em outro exemplo, podemos escrever uma função que exiba uma string n vezes:</p>
<pre><code class="language-python">def print_n(s, n):
    if n &lt;= 0:
        return
    print(s)
    print_n(s, n-1)
</code></pre>
<p>Se <code>n &lt;= 0</code> a instrução <code>return</code> causa a saída da função. O fluxo de execução volta imediatamente a quem fez a chamada, e as linhas restantes da função não são executadas.</p>
<p>O resto da função é similar à countdown: ela mostra s e então chama a si mesma para mostrar s mais n-1 vezes. Então o número de linhas da saída é 1 + (n - 1), até chegar a n.</p>
<p>Para exemplos simples como esse, provavelmente é mais fácil usar um loop for. Mais adiante veremos exemplos que são difíceis de escrever com um loop for e fáceis de escrever com recursividade, então é bom começar cedo.</p>
<h2 id="59-diagramas-da-pilha-para-funcoes-recursivas">5.9 - Diagramas da pilha para funções recursivas</h2>
<p>Em “Diagrama da pilha”, na página 55, usamos um diagrama da pilha para representar o estado de um programa durante uma chamada de função. O mesmo tipo de diagrama pode ajudar a interpretar uma função recursiva.</p>
<p>Cada vez que uma função é chamada, o Python cria um frame para conter as variáveis locais e parâmetros da função. Para uma função recursiva, pode haver mais de um frame na pilha ao mesmo tempo.</p>
<p>A Figura 5.1 mostra um diagrama da pilha para <code>countdown</code> chamado com n = 3.</p>
<p><img alt="Figura 5.1 – Diagrama da pilha." src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0501.png" />
<br><em>Figura 5.1 – Diagrama da pilha.</em></p>
<p>Como de hábito, o topo da pilha é o frame de <code>__main__</code>. Está vazio porque não criamos nenhuma variável em <code>__main__</code> nem passamos argumentos a ela.</p>
<p>Os quatro frames do countdown têm valores diferentes para o parâmetro <code>n</code>. O fundo da pilha, onde <code>n = 0</code>, é chamado caso-base. Ele não faz uma chamada recursiva, então não há mais frames.</p>
<p>Como exercício, desenhe um diagrama da pilha para <code>print_n</code> chamado com <code>s = 'Hello'</code> e <code>n = 2</code>. Então escreva uma função chamada <code>do_n</code> que tome um objeto de função e um número <code>n</code> como argumentos e que chame a respectiva função <code>n</code> vezes.</p>
<h2 id="510-recursividade-infinita">5.10 - Recursividade infinita</h2>
<p>Se a recursividade nunca atingir um caso-base, continua fazendo chamadas recursivas para sempre, e o programa nunca termina. Isso é conhecido como recursividade infinita e geralmente não é uma boa ideia. Aqui está um programa mínimo com recursividade infinita:</p>
<pre><code class="language-python">def recurse():
    recurse()
</code></pre>
<p>Na maior parte dos ambientes de programação, um programa com recursividade infinita não é realmente executado para sempre. O Python exibe uma mensagem de erro quando a profundidade máxima de recursividade é atingida:</p>
<pre><code class="language-python">  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
                  .
                  .
                  .
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
RuntimeError: Maximum recursion depth exceeded
</code></pre>
<p>Este traceback é um pouco maior que o que vimos no capítulo anterior. Quando o erro ocorre, há mil frames de recurse na pilha!</p>
<p>Se você escrever em recursividade infinita por engano, confira se a sua função tem um caso-base que não faz uma chamada recursiva. E se houver um caso-base, verifique se você vai mesmo atingi-lo.</p>
<h2 id="511-entrada-de-teclado">5.11 - Entrada de teclado</h2>
<p>Os programas que escrevemos até agora não aceitam entradas do usuário. Eles sempre fazem a mesma coisa cada vez.</p>
<p>O Python fornece uma função integrada chamada <code>input</code> que interrompe o programa e espera que o usuário digite algo. Quando o usuário pressionar Return ou Enter, o programa volta a ser executado e input retorna o que o usuário digitou como uma string. No Python 2, a mesma função é chamada <code>raw_input</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; text = input()
What are you waiting for?
&gt;&gt;&gt; text
What are you waiting for?
</code></pre>
<p>Antes de receber entradas do usuário, é uma boa ideia exibir um prompt dizendo ao usuário o que ele deve digitar. input pode ter um prompt como argumento:</p>
<pre><code class="language-python">&gt;&gt;&gt; name = input('What...is your name?\\n')
What...is your name?
Arthur, King of the Britons!
&gt;&gt;&gt; name
Arthur, King of the Britons!
</code></pre>
<p>A sequência <code>\n</code> no final do prompt representa um newline, que é um caractere especial de quebra de linha. É por isso que a entrada do usuário aparece abaixo do prompt.</p>
<p>Se esperar que o usuário digite um número inteiro, você pode tentar converter o valor de retorno para int:</p>
<pre><code class="language-python">&gt;&gt;&gt; prompt = 'What...is the airspeed velocity of an unladen swallow?\\n'
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
42
&gt;&gt;&gt; int(speed)
42
</code></pre>
<p>Mas se o usuário digitar algo além de uma série de dígitos, você recebe um erro:</p>
<pre><code class="language-python">&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
&gt;&gt;&gt; int(speed)
ValueError: invalid literal for int() with base 10
</code></pre>
<p>Veremos como tratar este tipo de erro mais adiante.</p>
<h2 id="512-depuracao">5.12 - Depuração</h2>
<p>Quando um erro de sintaxe ou de tempo de execução ocorre, a mensagem de erro contém muita informação, às vezes, até demais. As partes mais úteis são normalmente:</p>
<ul>
<li>
<p>que tipo de erro foi;</p>
</li>
<li>
<p>onde ocorreu.</p>
</li>
</ul>
<p>Erros de sintaxe são normalmente fáceis de encontrar, mas há algumas pegadinhas. Erros de whitespace podem ser complicados porque os espaços e tabulações são invisíveis e estamos acostumados a ignorá-los.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; y = 6
  File &quot;&lt;stdin&gt;&quot;, line 1
    y = 6
    ^
IndentationError: unexpected indent
</code></pre>
<p>Neste exemplo, o problema é que a segunda linha está endentada por um espaço. Mas a mensagem de erro aponta para y, o que pode ser capcioso. Em geral, mensagens de erro indicam onde o problema foi descoberto, mas o erro real pode estar em outra parte do código, às vezes, em uma linha anterior.</p>
<p>O mesmo acontece com erros em tempo de execução. Suponha que você esteja tentando calcular a proporção de sinal a ruído em decibéis. A fórmula é SNRdb = 10 log10 (Psignal/Pnoise). No Python, você poderia escrever algo assim:</p>
<pre><code class="language-python">import math
signal_power = 9
noise_power = 10
ratio = signal_power // noise_power
decibels = 10 * math.log10(ratio)
print(decibels)
</code></pre>
<p>Ao executar este programa, você recebe uma exceção:</p>
<pre><code class="language-python">Traceback (most recent call last):
  File &quot;snr.py&quot;, line 5, in ?
    decibels = 10 * math.log10(ratio)
ValueError: math domain error
</code></pre>
<p>A mensagem de erro indica a linha 5, mas não há nada de errado com esta linha. Uma opção para encontrar o verdadeiro erro é exibir o valor de ratio, que acaba sendo 0. O problema está na linha 4, que usa a divisão pelo piso em vez da divisão de ponto flutuante.</p>
<p>É preciso ler as mensagens de erro com atenção, mas não assumir que tudo que dizem esteja correto.</p>
<h2 id="513-glossario">5.13 - Glossário</h2>
<dl>
<dt><a id="glos:divisão pelo piso" href="#termo:divisão pelo piso">divisão pelo piso</a></dt>
<dd>Um operador, denotado por //, que divide dois números e arredonda o resultado para baixo (em direção ao zero), a um número inteiro.</dd>

<dt><a id="glos:operador módulo" href="#termo:operador módulo">operador módulo</a></dt>
<dd>Um operador, denotado com um sinal de percentagem (%), que funciona com números inteiros e devolve o resto quando um número é dividido por outro.</dd>

<dt><a id="glos:expressão booleana" href="#termo:expressão booleana">expressão booleana</a></dt>
<dd>Uma expressão cujo valor é True (verdadeiro) ou False (falso).</dd>

<dt><a id="glos:operador relacional" href="#termo:operador relacional">operador relacional</a></dt>
<dd>Um destes operadores, que compara seus operandos: `==`, `!=`, `>`, `<`, `>=` e `<=`.</dd>

<dt><a id="glos:operador lógico" href="#termo:operador lógico">operador lógico</a></dt>
<dd>Um destes operadores, que combina expressões booleanas: and (e), or (ou) e not (não).</dd>

<dt><a id="glos:instrução condicional" href="#termo:instrução condicional">instrução condicional</a></dt>
<dd>Uma instrução que controla o fluxo de execução, dependendo de alguma condição.</dd>

<dt><a id="glos:condição" href="#termo:condição">condição</a></dt>
<dd>A expressão booleana em uma instrução condicional que determina qual ramo deve ser executado.</dd>

<dt><a id="glos:instrução composta" href="#termo:instrução composta">instrução composta</a></dt>
<dd>Uma instrução composta de um cabeçalho e um corpo. O cabeçalho termina em dois pontos (:). O corpo é endentado em relação ao cabeçalho.</dd>

<dt><a id="glos:ramo" href="#termo:ramo">ramo</a></dt>
<dd>Uma das sequências alternativas de instruções em uma instrução condicional.</dd>

<dt><a id="glos:condicional encadeada" href="#termo:condicional encadeada">condicional encadeada</a></dt>
<dd>Uma instrução condicional com uma série de ramos alternativos.</dd>

<dt><a id="glos:condicional aninhada" href="#termo:condicional aninhada">condicional aninhada</a></dt>
<dd>Uma instrução condicional que aparece em um dos ramos de outra instrução condicional.</dd>

<dt><a id="glos:instrução de retorno" href="#termo:instrução de retorno">instrução de retorno</a></dt>
<dd>Uma instrução que faz uma função terminar imediatamente e voltar a quem a chamou.</dd>

<dt><a id="glos:recursividade" href="#termo:recursividade">recursividade</a></dt>
<dd>O processo de chamar a função que está sendo executada no momento.</dd>

<dt><a id="glos:caso-base" href="#termo:caso-base">caso-base</a></dt>
<dd>Um ramo condicional em uma função recursiva que não faz uma chamada recursiva.</dd>

<dt><a id="glos:recursividade infinita" href="#termo:recursividade infinita">recursividade infinita</a></dt>
<dd>Recursividade que não tem um caso-base, ou nunca o atinge. A recursividade infinita eventualmente causa um erro em tempo de execução.</dd>

</dl>

<h2 id="514-exercicios">5.14 - Exercícios</h2>
<h3 id="exercicio-51">Exercício 5.1</h3>
<p>O módulo time fornece uma função, também chamada time, que devolve a Hora Média de Greenwich na “época”, que é um momento arbitrário usado como ponto de referência. Em sistemas UNIX, a época é primeiro de janeiro de 1970.</p>
<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
1437746094.5735958
</code></pre>
<p>Escreva um script que leia a hora atual e a converta em um tempo em horas, minutos e segundos, mais o número de dias desde a época.</p>
<h3 id="exercicio-52">Exercício 5.2</h3>
<p>O último teorema de Fermat diz que não existem números inteiros a, b e c tais que <code>a**n + b**n == c**n</code> para quaisquer valores de n maiores que 2.</p>
<ol>
<li>
<p>Escreva uma função chamada check_fermat que receba quatro parâmetros – a, b, c e n – e verifique se o teorema de Fermat se mantém. Se n for maior que 2 e <code>a**n + b**n == c**n</code> o programa deve imprimir, “Holy smokes, Fermat was wrong!” Senão o programa deve exibir “No, that doesn’t work.”</p>
</li>
<li>
<p>Escreva uma função que peça ao usuário para digitar valores para a, b, c e n, os converta em números inteiros e use check_fermat para verificar se violam o teorema de Fermat.</p>
</li>
</ol>
<h3 id="exercicio-53">Exercício 5.3</h3>
<p>Se você tiver três gravetos, pode ser que consiga arranjá-los em um triângulo ou não. Por exemplo, se um dos gravetos tiver 12 polegadas de comprimento e outros dois tiverem uma polegada de comprimento, não será possível fazer com que os gravetos curtos se encontrem no meio. Há um teste simples para ver se é possível formar um triângulo para quaisquer três comprimentos:</p>
<p>Se algum dos três comprimentos for maior que a soma dos outros dois, então você não pode formar um triângulo. Senão, você pode. (Se a soma de dois comprimentos igualar o terceiro, eles formam um triângulo chamado “degenerado”.)</p>
<ol>
<li>
<p>Escreva uma função chamada <code>is_triangle</code> que receba três números inteiros como argumentos, e que imprima “Yes” ou “No”, dependendo da possibilidade de formar ou não um triângulo de gravetos com os comprimentos dados.</p>
</li>
<li>
<p>Escreva uma função que peça ao usuário para digitar três comprimentos de gravetos, os converta em números inteiros e use <code>is_triangle</code> para verificar se os gravetos com os comprimentos dados podem formar um triângulo.</p>
</li>
</ol>
<h3 id="exercicio-54">Exercício 5.4</h3>
<p>Qual é a saída do seguinte programa? Desenhe um diagrama da pilha que mostre o estado do programa quando exibir o resultado.</p>
<pre><code class="language-python">def recurse(n, s):
    if n == 0:
        print(s)
    else:
        recurse(n-1, n+s)

recurse(3, 0)
</code></pre>
<ol>
<li>
<p>O que aconteceria se você chamasse esta função desta forma: recurse(-1, 0)?</p>
</li>
<li>
<p>Escreva uma docstring que explique tudo o que alguém precisaria saber para usar esta função (e mais nada).</p>
</li>
</ol>
<p>Os seguintes exercícios usam o módulo turtle, descrito no Capítulo 4:</p>
<h3 id="exercicio-55">Exercício 5.5</h3>
<p>Leia a próxima função e veja se consegue compreender o que ela faz (veja os exemplos no Capítulo 4). Então execute-a e veja se acertou.</p>
<pre><code class="language-python">def draw(t, length, n):
    if n == 0:
        return
    angle = 50
    t.fd(length * n)
    t.lt(angle)
    draw(t, length, n-1)
    t.rt(2 * angle)
    draw(t, length, n-1)
    t.lt(angle)
    t.bk(length * n)
</code></pre>
<h3 id="exercicio-56">Exercício 5.6</h3>
<p><img alt="Figura 5.2 – Uma curva de Koch." src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0502.png" />
<br><em>Figura 5.2 – Uma curva de Koch.</em></p>
<p>A curva de Koch é um fractal que parece com o da Figura 5.2. Para desenhar uma curva de Koch com o comprimento x, tudo o que você tem que fazer é:</p>
<ol>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 60 graus à esquerda.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 120 graus à direita.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 60 graus à esquerda.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
</ol>
<p>A exceção é se x for menor que 3: neste caso, você pode desenhar apenas uma linha reta com o comprimento x.</p>
<ol>
<li>
<p>Escreva uma função chamada koch que receba um turtle e um comprimento como parâmetros, e use o turtle para desenhar uma curva de Koch com o comprimento dado.</p>
</li>
<li>
<p>Escreva uma função chamada snowflake que desenhe três curvas de Koch para fazer o traçado de um floco de neve.</p>
</li>
</ol>
<p>Solução: http://thinkpython2.com/code/koch.py.</p>
<ol>
<li>A curva de Koch pode ser generalizada de vários modos. Veja exemplos em http://en.wikipedia.org/wiki/Koch_snowflake e implemente o seu favorito.</li>
</ol>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../06-funcoes-result/" class="btn btn-neutral float-right" title="Capítulo 6: Funções com resultado">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../04-caso-interface/" class="btn btn-neutral" title="Capítulo 4: Estudo de caso: projeto de interface"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../04-caso-interface/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../06-funcoes-result/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
