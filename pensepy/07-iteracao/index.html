<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Capítulo 7: Iteração - Pense Python</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Cap\u00edtulo 7: Itera\u00e7\u00e3o";
    var mkdocs_page_input_path = "07-iteracao.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Pense Python</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Pense em Python</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../00-prefacio/">Prefácio</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../01-jornada/">Capítulo 1: A jornada do programa</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../02-vars-expr-instr/">Capítulo 2: Variáveis, expressões e instruções</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../03-funcoes/">Capítulo 3: Funções</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../04-caso-interface/">Capítulo 4: Estudo de caso: projeto de interface</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../05-cond-recur/">Capítulo 5: Condicionais e recursividade</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../06-funcoes-result/">Capítulo 6: Funções com resultado</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Capítulo 7: Iteração</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#71-reatribuicao">7.1 - Reatribuição</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#72-atualizacao-de-variaveis">7.2 - Atualização de variáveis</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#73-instrucao-while">7.3 - Instrução while</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#74-break">7.4 - break</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#75-raizes-quadradas">7.5 - Raízes quadradas</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#76-algoritmos">7.6 - Algoritmos</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#77-depuracao">7.7 - Depuração</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#78-glossario">7.8 - Glossário</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#79-exercicios">7.9 - Exercícios</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-71">Exercício 7.1</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-72">Exercício 7.2</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#exercicio-73">Exercício 7.3</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../08-strings/">Capítulo 8: Strings</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../09-caso-palavras/">Capítulo 9: Estudo de caso: jogos de palavras</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../10-listas/">Capítulo 10: Listas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../11-dicionarios/">Capítulo 11: Dicionários</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../12-tuplas/">Capítulo 12: Tuplas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../13-caso-estruturas/">Capítulo 13: Estudo de caso: seleção de estrutura de dados</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../14-arquivos/">Capítulo 14: Arquivos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../15-classes-objetos/">Capítulo 15: Classes e objetos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../16-classes-funcoes/">Capítulo 16: Classes e funções</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../17-classes-metodos/">Capítulo 17: Classes e métodos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../18-heranca/">Capítulo 18: Herança</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../19-extra/">Capítulo 19: Extra</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../A-depuracao/">Apêndice A: Depuração</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../B-analise-algorit/">Apêndice B: Análise de algoritmos</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../C-colofao-autor/">Colofão</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Pense Python</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Capítulo 7: Iteração</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="capitulo-7-iteracao">Capítulo 7: Iteração</h1>
<p>Este capítulo é sobre a iteração, a capacidade de executar um bloco de instruções repetidamente. Vimos um tipo de iteração, usando a recursividade, em “Recursividade”, na página 81. Vimos outro tipo, usando um loop for, em “Repetição simples”, na página 65. Neste capítulo veremos ainda outro tipo, usando a instrução while. Porém, primeiro quero falar um pouco mais sobre a atribuição de variáveis.</p>
<h2 id="71-reatribuicao">7.1 - Reatribuição</h2>
<p>Pode ser que você já tenha descoberto que é permitido fazer mais de uma atribuição para a mesma variável. Uma nova atribuição faz uma variável existente referir-se a um novo valor (e deixar de referir-se ao valor anterior).</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; x
5
&gt;&gt;&gt; x = 7
&gt;&gt;&gt; x
7
</code></pre>
<p>A primeira vez que exibimos x, seu valor é 5; na segunda vez, seu valor é 7.</p>
<p>A Figura 7.1 mostra que a reatribuição parece um diagrama de estado.</p>
<p>Neste ponto quero tratar de uma fonte comum de confusão. Como o Python usa o sinal de igual (=) para atribuição, é tentador interpretar uma afirmação como a = b como uma proposição matemática de igualdade; isto é, a declaração de que a e b são iguais. Mas esta é uma interpretação equivocada.</p>
<p>Em primeiro lugar, a igualdade é uma relação simétrica e a atribuição não é. Por exemplo, na matemática, se a=7 então 7=a. Mas no Python, a instrução a = 7 é legal e 7 = a não é.</p>
<p>Além disso, na matemática, uma proposição de igualdade é verdadeira ou falsa para sempre. Se a=b agora, então a sempre será igual a b. No Python, uma instrução de atribuição pode tornar duas variáveis iguais, mas elas não precisam se manter assim:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = a    # a e b agora são iguais
&gt;&gt;&gt; a = 3    # a e b não são mais iguais
&gt;&gt;&gt; b
5
</code></pre>
<p>A terceira linha modifica o valor de a, mas não muda o valor de b, então elas já não são iguais.</p>
<p>A reatribuição de variáveis muitas vezes é útil, mas você deve usá-la com prudência. Se os valores das variáveis mudarem frequentemente, isso pode dificultar a leitura e depuração do código.</p>
<pre><code class="language-python">Figura 7.1 – Diagrama de estado.
</code></pre>
<p><img alt="Figura 7.1 – Diagrama de estado da variável x." src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0701.png" />
<br><em>Figura 7.1 – Diagrama de estado da variável x.</em></p>
<h2 id="72-atualizacao-de-variaveis">7.2 - Atualização de variáveis</h2>
<p>Um tipo comum de reatribuição é uma atualização, onde o novo valor da variável depende do velho.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = x + 1
</code></pre>
<p>Isso significa “pegue o valor atual de x, acrescente um, e então atualize x para o novo valor”.</p>
<p>Se você tentar atualizar uma variável que não existe, recebe um erro porque o Python avalia o lado direito antes de atribuir um valor a x:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = x + 1
NameError: name 'x' is not defined
</code></pre>
<p>Antes de poder atualizar uma variável é preciso inicializá-la, normalmente com uma atribuição simples:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 0
&gt;&gt;&gt; x = x + 1
</code></pre>
<p>Atualizar uma variável acrescentando 1 chama-se incremento; subtrair 1 chama-se decremento.</p>
<h2 id="73-instrucao-while">7.3 - Instrução while</h2>
<p>Os computadores muitas vezes são usados para automatizar tarefas repetitivas. A repetição de tarefas idênticas ou semelhantes sem fazer erros é algo que os computadores fazem bem e as pessoas não. Em um programa de computador, a repetição também é chamada de iteração.</p>
<p>Já vimos duas funções, <code>countdown</code> e <code>print_n</code>, que se repetem usando recursividade. Como a iteração é bem comum, o Python fornece recursos de linguagem para facilitá-la. Um deles é a instrução <code>for</code> que vimos em “Repetição simples”, na página 65. Voltaremos a isso mais adiante.</p>
<p>Outra é a instrução <code>while</code>. Aqui está uma versão de countdown que usa a instrução <code>while</code>:</p>
<pre><code class="language-python">def countdown(n):
    while n &gt; 0:
        print(n)
        n = n - 1
    print('Blastoff!')
</code></pre>
<p>Você até pode ler a instrução <code>while</code> como se fosse uma tradução do inglês. Significa “Enquanto <code>n</code> for maior que 0, mostre o valor de <code>n</code> e então decremente <code>n</code>. Quando chegar a 0, mostre a palavra Blastoff!”</p>
<p>Mais formalmente, aqui está o fluxo de execução para uma instrução while:</p>
<ol>
<li>
<p>Determine se a condição é verdadeira ou falsa.</p>
</li>
<li>
<p>Se for falsa, saia da instrução while e continue a execução da próxima instrução.</p>
</li>
<li>
<p>Se a condição for verdadeira, execute o corpo e então volte ao passo 1.</p>
</li>
</ol>
<p>Este tipo de fluxo chama-se loop (laço), porque o terceiro passo faz um loop de volta ao topo.</p>
<p>O corpo do loop deve mudar o valor de uma ou mais variáveis para que, a certa altura, a condição fique falsa e o loop termine. Senão o loop vai se repetir para sempre, o que é chamado de loop infinito. Uma fonte infindável de divertimento para cientistas da computação é a observação das instruções no xampu, “Faça espuma, enxágue, repita”, que são parte de um loop infinito.</p>
<p>No caso de countdown, podemos provar que o loop termina: se <code>n</code> for zero ou negativo, o loop nunca é executado. Senão, <code>n</code> fica cada vez menor ao passar pelo loop, até eventualmente chegar a 0.</p>
<p>Para alguns outros loops, não é tão fácil perceber isso. Por exemplo:</p>
<pre><code class="language-python">def sequence(n):
    while n != 1:
        print(n)
        if n % 2 == 0:        # n é par
            n = n / 2
        else:                 # n é ímpar
            n = n * 3 + 1
</code></pre>
<p>A condição deste loop é <code>n != 1</code>, então o loop continuará até que <code>n</code> seja 1, o que torna a condição falsa.</p>
<p>Cada vez que passa pelo loop, o programa produz o valor de <code>n</code> e então verifica se é par ou ímpar. Se for par, <code>n</code> é dividido por 2. Se for ímpar, o valor de <code>n</code> é substituído por <code>n * 3 + 1</code>. Por exemplo, se o argumento passado a sequence for 3, os valores resultantes de <code>n</code> são 3, 10, 5, 16, 8, 4, 2, 1.</p>
<p>Como <code>n</code> às vezes aumenta e às vezes diminui, não há nenhuma prova óbvia de que <code>n</code> chegará eventualmente a 1, ou que o programa terminará. Para alguns valores de <code>n</code>, podemos provar o término. Por exemplo, se o valor inicial for uma potência de dois, <code>n</code> será par cada vez que passar pelo loop até que chegue a 1. O exemplo anterior termina com uma sequência assim, que inicia com 16.</p>
<p>A questão difícil é se podemos provar que este programa termina para todos os valores positivos de <code>n</code>. Por enquanto, ninguém foi capaz de comprovar ou refutar isso! (Veja http://en.wikipedia.org/wiki/Collatz_conjecture.)</p>
<p>Como um exercício, reescreva a função print_n de “Recursividade”, na página 81, usando a iteração em vez da recursividade.</p>
<h2 id="74-break">7.4 - break</h2>
<p>Às vezes você não sabe que está na hora de terminar um loop até que já esteja na metade do corpo. Neste caso pode usar a instrução break para sair do loop.</p>
<p>Por exemplo, suponha que você quer receber uma entrada do usuário até que este digite done. Você pode escrever:</p>
<pre><code class="language-python">while True:
    line = input('&gt; ')
    if line == 'done':
        break
    print(line)
print('Done!')
</code></pre>
<p>A condição do loop é True, que sempre é verdade, então o loop roda até que chegue à instrução de interrupção.</p>
<p>Cada vez que passa pelo loop, o programa apresenta ao usuário um colchete angular. Se o usuário digitar done, a instrução break sai do loop. Senão, o programa ecoa o que quer que o usuário digite e volta ao topo do loop. Aqui está uma amostra de execução:</p>
<pre><code class="language-python">&gt; not done
not done
&gt; done
Done!
</code></pre>
<p>Esta forma de escrever loops while é comum porque podemos verificar a condição em qualquer lugar do loop (não somente no topo) e podemos exprimir a condição de parada afirmativamente (“pare quando isto acontecer”) em vez de negativamente (“continue a seguir até que isto aconteça”).</p>
<h2 id="75-raizes-quadradas">7.5 - Raízes quadradas</h2>
<p>Loops muitas vezes são usados em programas que calculam resultados numéricos, começando com uma resposta aproximada e melhorando-a iterativamente.</p>
<p>Por exemplo, uma forma de calcular raízes quadradas é o método de Newton. Suponha que você queira saber a raiz quadrada de a. Se começar com quase qualquer estimativa, x, é possível calcular uma estimativa melhor com a seguinte fórmula:</p>
<p><img alt="Fórmula – Raiz quadrada pelo método de Newton." src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p79f1.png" /></p>
<pre><code class="language-python">Por exemplo, se a for 4 e x for 3:
&gt;&gt;&gt; a = 4
&gt;&gt;&gt; x = 3
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.16666666667
</code></pre>
<p>O resultado é mais próximo à resposta correta (<img alt="Fórmula – Raiz quadrada de 4." src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p79f2.png" /> = 2). Se repetirmos o processo com a nova estimativa, chegamos ainda mais perto:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00641025641
</code></pre>
<p>Depois de algumas atualizações, a estimativa é quase exata:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00001024003
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.00000000003
</code></pre>
<p>Em geral, não sabemos com antecedência quantos passos são necessários para chegar à resposta correta, mas sabemos quando chegamos lá porque a estimativa para de mudar:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
&gt;&gt;&gt; x = y
&gt;&gt;&gt; y = (x + a/x) / 2
&gt;&gt;&gt; y
2.0
</code></pre>
<p>Quando y == x, podemos parar. Aqui está um loop que começa com uma estimativa inicial, x, e a melhora até que deixe de mudar:</p>
<pre><code class="language-python">while True:
    print(x)
    y = (x + a/x) / 2
    if y == x:
        break
    x = y
</code></pre>
<p>Para a maior parte de valores de <code>a</code> funciona bem, mas pode ser perigoso testar a igualdade de um float. Os valores de ponto flutuante são aproximadamente corretos: a maioria dos números racionais, como 1/3, e números irracionais, como <img alt="Fórmula – Raiz quadrada de 2." src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p80f1.png" />, não podem ser representados exatamente com um float.</p>
<p>Em vez de verificar se <code>x</code> e <code>y</code> são exatamente iguais, é mais seguro usar a função integrada <code>abs</code> para calcular o valor absoluto ou magnitude da diferença entre eles:</p>
<pre><code class="language-python">if abs(y-x) &lt; epsilon:
    break
</code></pre>
<p>Onde <code>epsilon</code> tem um valor como 0.0000001, que determina a proximidade desejada entre <code>x</code> e <code>y</code>.</p>
<h2 id="76-algoritmos">7.6 - Algoritmos</h2>
<p>O método de Newton é um exemplo de um algoritmo: um processo mecânico para resolver uma categoria de problemas (neste caso, calcular raízes quadradas).</p>
<p>Para entender o que é um algoritmo, pode ser útil começar com algo que não é um algoritmo. Quando aprendeu a multiplicar números de um dígito, você provavelmente memorizou a tabuada. Ou seja, você memorizou 100 soluções específicas. Este tipo de conhecimento não é algorítmico.</p>
<p>No entanto, se você foi “preguiçoso”, poderia ter aprendido alguns truques. Por exemplo, para encontrar o produto de <code>n</code> e 9, pode escrever <code>n-1</code> como o primeiro dígito e <code>10-n</code> como o segundo dígito. Este truque é uma solução geral para multiplicar qualquer número de dígito único por 9. Isto é um algoritmo!</p>
<p>De forma semelhante, as técnicas que aprendeu, como o transporte na adição, o empréstimo na subtração e a divisão longa são todos algoritmos. Uma das características de algoritmos é que eles não exigem inteligência para serem executados. São processos mecânicos, nos quais cada passo segue a partir do último, de acordo com um conjunto de regras simples.</p>
<p>A execução de algoritmos é maçante, mas projetá-los é interessante, intelectualmente desafiador e uma parte central da Ciência da Computação.</p>
<p>Algumas coisas que as pessoas fazem naturalmente, sem dificuldade ou pensamento consciente, são as mais difíceis para exprimir algoritmicamente. A compreensão de linguagem natural é um bom exemplo. Todos nós o fazemos, mas por enquanto ninguém foi capaz de explicar como o fazemos, pelo menos não na forma de um algoritmo.</p>
<h2 id="77-depuracao">7.7 - Depuração</h2>
<p>Ao começar a escrever programas maiores, pode ser que você passe mais tempo depurando. Mais código significa mais possibilidades fazer erros e mais lugares para esconder defeitos.</p>
<p>Uma forma de cortar o tempo de depuração é “depurar por bisseção”. Por exemplo, se há 100 linhas no seu programa e você as verifica uma a uma, seriam 100 passos a tomar.</p>
<p>Em vez disso, tente quebrar o problema pela metade. Olhe para o meio do programa, ou perto disso, para um valor intermediário que possa verificar. Acrescente uma instrução print (ou outra coisa que tenha um efeito verificável) e execute o programa.</p>
<p>Se a verificação do ponto central for incorreta, deve haver um problema na primeira metade do programa. Se for correta, o problema está na segunda metade.</p>
<p>Cada vez que executar uma verificação assim, divida ao meio o número de linhas a serem verificadas. Depois de seis passos (que é menos de 100), você teria menos de uma ou duas linhas do código para verificar, pelo menos em teoria.</p>
<p>Na prática, nem sempre é claro o que representa o “meio do programa” e nem sempre é possível verificá-lo. Não faz sentido contar linhas e encontrar o ponto central exato. Em vez disso, pense em lugares no programa onde poderia haver erros e lugares onde é fácil inserir um ponto de verificação. Então escolha um lugar onde as possibilidades são basicamente as mesmas de que o defeito esteja antes ou depois da verificação.</p>
<h2 id="78-glossario">7.8 - Glossário</h2>
<dl>
<dt><a id="glos:reatribuição" href="#termo:reatribuição">reatribuição</a></dt>
<dd>Atribuir um novo valor a uma variável que já existe.</dd>

<dt><a id="glos:atualização" href="#termo:atualização">atualização</a></dt>
<dd>Uma atribuição onde o novo valor da variável dependa do velho.</dd>

<dt><a id="glos:inicialização" href="#termo:inicialização">inicialização</a></dt>
<dd>Uma atribuição que dá um valor inicial a uma variável que será atualizada.</dd>

<dt><a id="glos:incremento" href="#termo:incremento">incremento</a></dt>
<dd>Uma atualização que aumenta o valor de uma variável (normalmente por uma unidade).</dd>

<dt><a id="glos:decremento" href="#termo:decremento">decremento</a></dt>
<dd>Uma atualização que reduz o valor de uma variável.</dd>

<dt><a id="glos:iteração" href="#termo:iteração">iteração</a></dt>
<dd>Execução repetida de um grupo de instruções, usando uma chamada da função recursiva ou um loop.</dd>

<dt><a id="glos:loop infinito" href="#termo:loop infinito">loop infinito</a></dt>
<dd>Um loop no qual a condição de término nunca é satisfeita.</dd>

<dt><a id="glos:algoritmo" href="#termo:algoritmo">algoritmo</a></dt>
<dd>Um processo geral para resolver uma categoria de problemas.</dd>

</dl>

<h2 id="79-exercicios">7.9 - Exercícios</h2>
<h3 id="exercicio-71">Exercício 7.1</h3>
<p>Copie o loop de “Raízes quadradas”, na página 111, e encapsule-o em uma função chamada <code>mysqrt</code> que receba a como parâmetro, escolha um valor razoável de x e devolva uma estimativa da raiz quadrada de a.</p>
<p>Para testar, escreva uma função denominada <code>test_square_root</code>, que exibe uma tabela como esta:</p>
<pre><code class="language-python">a   mysqrt(a)     math.sqrt(a)  diff
-   ---------     ------------  ----
1.0 1.0           1.0           0.0
2.0 1.41421356237 1.41421356237 2.22044604925e-16
3.0 1.73205080757 1.73205080757 0.0
4.0 2.0           2.0           0.0
5.0 2.2360679775  2.2360679775  0.0
6.0 2.44948974278 2.44948974278 0.0
7.0 2.64575131106 2.64575131106 0.0
8.0 2.82842712475 2.82842712475 4.4408920985e-16
9.0 3.0           3.0           0.0
</code></pre>
<p>A primeira coluna é um número, <code>a</code>; a segunda coluna é a raiz quadrada de a calculada com <code>mysqrt</code>; a terceira coluna é a raiz quadrada calculada por <code>math.sqrt</code>; a quarta coluna é o valor absoluto da diferença entre as duas estimativas.</p>
<h3 id="exercicio-72">Exercício 7.2</h3>
<p>A função integrada <code>eval</code> toma uma string e a avalia, usando o interpretador do Python. Por exemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; eval('1 + 2 * 3')
7
&gt;&gt;&gt; import math
&gt;&gt;&gt; eval('math.sqrt(5)')
2.2360679774997898
&gt;&gt;&gt; eval('type(math.pi)')
&lt;class 'float'&gt;
</code></pre>
<p>Escreva uma função chamada <code>eval_loop</code> que iterativamente peça uma entrada ao usuário, a avalie usando <code>eval</code> e exiba o resultado.</p>
<p>Ela deve continuar até que o usuário digite <code>done</code>; então deverá exibir o valor da última expressão avaliada.</p>
<h3 id="exercicio-73">Exercício 7.3</h3>
<p>O matemático Srinivasa Ramanujan encontrou uma série infinita que pode ser usada para gerar uma aproximação numérica de 1/π:</p>
<p><img alt="Fórmula – Aproximação de π pela série de Ramanujan." src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/p83f1.png" /></p>
<p>Escreva uma função chamada <code>estimate_pi</code> que use esta fórmula para computar e devolver uma estimativa de π. Você deve usar o loop <code>while</code> para calcular os termos da adição até que o último termo seja menor que 1e-15 (que é a notação do Python para <code>10 ** 15</code>). Você pode verificar o resultado comparando-o com <code>math.pi</code>.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../08-strings/" class="btn btn-neutral float-right" title="Capítulo 8: Strings">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../06-funcoes-result/" class="btn btn-neutral" title="Capítulo 6: Funções com resultado"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../06-funcoes-result/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../08-strings/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
