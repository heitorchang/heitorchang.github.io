{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pense em Python Pense como um cientista da computa\u00e7\u00e3o Este livro ensina programa\u00e7\u00e3o para quem nunca programou, usando Python 3 nos exemplos. \u00c9 aplicado no Olin College, IBMEC e outras faculdades de engenharia de primeira linha. DICA : Voc\u00ea pode comprar um exemplar impresso de Pense em Python no site da Editora Novatec ou em livrarias. ISBN: 978-85-7522-508-0 . Pense em Python \u00e9 uma tradu\u00e7\u00e3o do livro Think Python (2\u00aa edi\u00e7\u00e3o), de Allen B. Downey , traduzido e publicado no Brasil pela Editora Novatec sob licen\u00e7a da O'Reilly Media. Sum\u00e1rio Pref\u00e1cio A jornada do programa Vari\u00e1veis, express\u00f5es e instru\u00e7\u00f5es Fun\u00e7\u00f5es Estudo de caso: projeto de interface Condicionais e recursividade Fun\u00e7\u00f5es com resultado Itera\u00e7\u00e3o Strings Estudo de caso: jogos de palavras Listas Dicion\u00e1rios Tuplas Estudo de caso: sele\u00e7\u00e3o de estrutura de dados Arquivos Classes e objetos Classes e fun\u00e7\u00f5es Classes e m\u00e9todos Heran\u00e7a Extra Ap\u00eandice A: Depura\u00e7\u00e3o Ap\u00eandice B: An\u00e1lise de algoritmos Colof\u00e3o / Sobre o Autor Cr\u00e9ditos da edi\u00e7\u00e3o brasileira Editor: Rubens Prates Tradu\u00e7\u00e3o: Sheila Gomes Revis\u00e3o Gramatical: Smirna Cavalheiro Editora\u00e7\u00e3o Eletr\u00f4nica: Carolina Kuwabata Assistente Editorial: Priscila A. Yoshimatsu Hist\u00f3rico Allen Downey publicou o original em ingl\u00eas sob uma licen\u00e7a Creative Commons Atribui\u00e7\u00e3o-N\u00e3oComercial CC BY-NC 3.0 . A Novatec oferece \u00e0 comunidade esta tradu\u00e7\u00e3o nos termos da mesma licen\u00e7a do original, CC BY-NC 3.0 , atendendo ao desejo do autor oferecer seu trabalho atrav\u00e9s de uma licen\u00e7a livre. Esta vers\u00e3o digital de Pense em Python em portugu\u00eas foi gerada por Luciano Ramalho da ThoughtWorks a partir de arquivos cedidos por Rubens Prates da Editora Novatec .","title":"Pense em Python"},{"location":"#pense-em-python","text":"","title":"Pense em Python"},{"location":"#pense-como-um-cientista-da-computacao","text":"Este livro ensina programa\u00e7\u00e3o para quem nunca programou, usando Python 3 nos exemplos. \u00c9 aplicado no Olin College, IBMEC e outras faculdades de engenharia de primeira linha. DICA : Voc\u00ea pode comprar um exemplar impresso de Pense em Python no site da Editora Novatec ou em livrarias. ISBN: 978-85-7522-508-0 . Pense em Python \u00e9 uma tradu\u00e7\u00e3o do livro Think Python (2\u00aa edi\u00e7\u00e3o), de Allen B. Downey , traduzido e publicado no Brasil pela Editora Novatec sob licen\u00e7a da O'Reilly Media.","title":"Pense como um cientista da computa\u00e7\u00e3o"},{"location":"#sumario","text":"Pref\u00e1cio A jornada do programa Vari\u00e1veis, express\u00f5es e instru\u00e7\u00f5es Fun\u00e7\u00f5es Estudo de caso: projeto de interface Condicionais e recursividade Fun\u00e7\u00f5es com resultado Itera\u00e7\u00e3o Strings Estudo de caso: jogos de palavras Listas Dicion\u00e1rios Tuplas Estudo de caso: sele\u00e7\u00e3o de estrutura de dados Arquivos Classes e objetos Classes e fun\u00e7\u00f5es Classes e m\u00e9todos Heran\u00e7a Extra Ap\u00eandice A: Depura\u00e7\u00e3o Ap\u00eandice B: An\u00e1lise de algoritmos Colof\u00e3o / Sobre o Autor","title":"Sum\u00e1rio"},{"location":"#creditos-da-edicao-brasileira","text":"Editor: Rubens Prates Tradu\u00e7\u00e3o: Sheila Gomes Revis\u00e3o Gramatical: Smirna Cavalheiro Editora\u00e7\u00e3o Eletr\u00f4nica: Carolina Kuwabata Assistente Editorial: Priscila A. Yoshimatsu","title":"Cr\u00e9ditos da edi\u00e7\u00e3o brasileira"},{"location":"#historico","text":"Allen Downey publicou o original em ingl\u00eas sob uma licen\u00e7a Creative Commons Atribui\u00e7\u00e3o-N\u00e3oComercial CC BY-NC 3.0 . A Novatec oferece \u00e0 comunidade esta tradu\u00e7\u00e3o nos termos da mesma licen\u00e7a do original, CC BY-NC 3.0 , atendendo ao desejo do autor oferecer seu trabalho atrav\u00e9s de uma licen\u00e7a livre. Esta vers\u00e3o digital de Pense em Python em portugu\u00eas foi gerada por Luciano Ramalho da ThoughtWorks a partir de arquivos cedidos por Rubens Prates da Editora Novatec .","title":"Hist\u00f3rico"},{"location":"00-prefacio/","text":"Pref\u00e1cio A estranha hist\u00f3ria deste livro Em janeiro de 1999 eu me preparava para dar aula a uma turma de programa\u00e7\u00e3o introdut\u00f3ria em Java. J\u00e1 tinha dado esse curso tr\u00eas vezes e estava ficando frustrado. O \u00edndice de aprova\u00e7\u00e3o era muito baixo e mesmo entre os alunos aprovados, o n\u00edvel geral das notas era baixo demais. Um dos problemas que eu via eram os livros. Eram muito grandes, com detalhes desnecess\u00e1rios sobre o Java, e n\u00e3o havia orienta\u00e7\u00e3o de alto n\u00edvel sobre como programar. E todos eles sofriam do efeito al\u00e7ap\u00e3o: no in\u00edcio era f\u00e1cil, os alunos iam aprendendo aos poucos, e l\u00e1 pelo Cap\u00edtulo 5, perdiam o ch\u00e3o. Era muito material novo, muito r\u00e1pido, e eles acabavam engatinhando no resto do semestre. Duas semanas antes do primeiro dia de aula, eu decidi escrever meu pr\u00f3prio livro. Meus objetivos eram: que o livro fosse curto. Era melhor os alunos lerem 10 p\u00e1ginas que n\u00e3o lerem 50. abordar o vocabul\u00e1rio com cuidado. Tentei minimizar o jarg\u00e3o e definir cada termo no momento do primeiro uso. construir o aprendizado passo a passo. Para evitar al\u00e7ap\u00f5es, dividi os t\u00f3picos mais dif\u00edceis e em uma s\u00e9rie de etapas menores. que o conte\u00fado fosse concentrado em programar mesmo, n\u00e3o na linguagem de programa\u00e7\u00e3o. Selecionei um subconjunto m\u00ednimo \u00fatil do Java e omiti o resto. Eu precisava de um t\u00edtulo, ent\u00e3o, por capricho, decidi cham\u00e1-lo de Pense como um cientista da computa\u00e7\u00e3o . A minha primeira vers\u00e3o era apenas um esbo\u00e7o, mas funcionou. Os alunos liam e entendiam o suficiente para podermos usar o tempo de aula para os t\u00f3picos dif\u00edceis, interessantes e (o mais importante) para permitir que os alunos praticassem. Lancei o livro sob uma Licen\u00e7a de Documenta\u00e7\u00e3o Livre GNU, que permite aos usu\u00e1rios copiar, modificar e distribuir o livro. E o que aconteceu em seguida foi legal. Jeff Elkner, um professor de ensino m\u00e9dio na Virg\u00ednia adotou meu livro e o traduziu para Python. Ele me enviou uma c\u00f3pia de sua tradu\u00e7\u00e3o e tive a experi\u00eancia excepcional de aprender Python lendo o meu pr\u00f3prio livro. Com a editora Green Tea, publiquei a primeira vers\u00e3o em Python em 2001. Em 2003 comecei a trabalhar no Olin College e a ensinar Python pela primeira vez na vida. O contraste com o Java era not\u00e1vel. Os estudantes tinham menos dificuldades, aprendiam mais, trabalhavam em projetos mais interessantes e geralmente se divertiam muito mais. Desde ent\u00e3o continuei a desenvolver o livro, corrigindo erros, melhorando alguns exemplos e acrescentando material, especialmente exerc\u00edcios. O resultado est\u00e1 aqui, agora com o t\u00edtulo menos grandioso de Pense em Python . Fiz algumas altera\u00e7\u00f5es: Acrescentei uma se\u00e7\u00e3o sobre depura\u00e7\u00e3o (debugging) no fim de cada cap\u00edtulo. Essas se\u00e7\u00f5es apresentam t\u00e9cnicas gerais para encontrar e evitar bugs (erros de programa\u00e7\u00e3o) e avisos sobre armadilhas do Python. Acrescentei exerc\u00edcios, incluindo testes curtos de compreens\u00e3o e alguns projetos substanciais. A maior parte dos exerc\u00edcios tem um link para a minha solu\u00e7\u00e3o. Acrescentei uma s\u00e9rie de estudos de caso \u2013 exemplos mais longos com exerc\u00edcios, solu\u00e7\u00f5es e discuss\u00f5es. Expandi a discuss\u00e3o sobre planos de desenvolvimento de programas e padr\u00f5es de design b\u00e1sicos. Acrescentei ap\u00eandices sobre depura\u00e7\u00e3o e an\u00e1lise de algoritmos. Esta edi\u00e7\u00e3o de Pense em Python tem as seguintes novidades: O livro e todo o c\u00f3digo de apoio foram atualizados para o Python 3. Acrescentei algumas se\u00e7\u00f5es e mais detalhes sobre a web, para ajudar os principiantes a executar o Python em um navegador, e n\u00e3o ter que lidar com a instala\u00e7\u00e3o do programa at\u00e9 que seja necess\u00e1rio. Para \u201cM\u00f3dulo turtle\u201d troquei meu pr\u00f3prio pacote gr\u00e1fico turtle, chamado Swampy, para um m\u00f3dulo Python mais padronizado, turtle, que \u00e9 mais f\u00e1cil de instalar e mais eficiente. Acrescentei um novo cap\u00edtulo chamado \u201cExtra\u201d , que introduz alguns recursos adicionais do Python, n\u00e3o estritamente necess\u00e1rios, mas \u00e0s vezes pr\u00e1ticos. Espero que goste de trabalhar com este livro, e que ele o ajude a aprender a programar e pensar, pelo menos um pouquinho, como um cientista da computa\u00e7\u00e3o. Allen B. Downey Olin College Conven\u00e7\u00f5es usadas neste livro As seguintes conven\u00e7\u00f5es tipogr\u00e1ficas s\u00e3o usadas neste livro: It\u00e1lico Indica novos termos, URLs, endere\u00e7os de email, nomes de arquivo e extens\u00f5es de arquivo. Negrito Indica termos definidos no gloss\u00e1rio no final de cap\u00edtulo. Monoespa\u00e7ado Usada para c\u00f3digo de programa, bem como dentro de par\u00e1grafos para referir-se a elementos do programa, como nomes de vari\u00e1veis ou de fun\u00e7\u00f5es, bancos de dados, tipos de dados, vari\u00e1veis de ambiente, instru\u00e7\u00f5es e palavras-chave. Monoespa\u00e7ado negrito Exibe comandos ou outros textos que devem ser digitados literalmente pelo usu\u00e1rio. Monoespa\u00e7ado it\u00e1lico Exibe textos que devem ser substitu\u00eddos por valores fornecidos pelos usu\u00e1rios ou por valores determinados pelo contexto. Uso do c\u00f3digo dos exemplos (de acordo com a pol\u00edtica da O'Reilly) H\u00e1 material suplementar (exemplos de c\u00f3digo, exerc\u00edcios etc.) dispon\u00edvel para baixar em http://www.greenteapress.com/thinkpython2/code . Este livro serve para ajudar voc\u00ea a fazer o que precisa. Em geral, se o livro oferece exemplos de c\u00f3digo, voc\u00ea pode us\u00e1-los nos seus programas e documenta\u00e7\u00e3o. N\u00e3o \u00e9 preciso entrar em contato conosco para pedir permiss\u00e3o, a menos que esteja reproduzindo uma por\u00e7\u00e3o significativa do c\u00f3digo. Por exemplo, escrever um programa que use v\u00e1rios peda\u00e7os de c\u00f3digo deste livro n\u00e3o exige permiss\u00e3o. Vender ou distribuir um CD-ROM de exemplos dos livros da O\u2019Reilly exige permiss\u00e3o. Responder a uma pergunta citando este livro e reproduzindo exemplos de c\u00f3digo n\u00e3o exige permiss\u00e3o. Incorporar uma quantidade significativa de exemplos de c\u00f3digo deste livro na documenta\u00e7\u00e3o do seu produto exige permiss\u00e3o. Agradecemos, mas n\u00e3o exigimos, cr\u00e9dito. O cr\u00e9dito normalmente inclui o t\u00edtulo, o autor, a editora e o ISBN. Por exemplo: \u201c Pense em Python , 2\u00aa edi\u00e7\u00e3o, por Allen B. Downey (O\u2019Reilly). Copyright 2016 Allen Downey, 978-1-4919-3936-9.\u201d Se acreditar que o seu uso dos exemplos de c\u00f3digo n\u00e3o se ajusta \u00e0 permiss\u00e3o dada anteriormente, fique \u00e0 vontade para entrar em contato conosco pelo email permissions@oreilly.com . Como entrar em contato conosco Envie coment\u00e1rios e d\u00favidas sobre este livro \u00e0 editora, escrevendo para: novatec@novatec.com.br . Temos uma p\u00e1gina web para este livro na qual inclu\u00edmos erratas, exemplos e quaisquer outras informa\u00e7\u00f5es adicionais. P\u00e1gina da edi\u00e7\u00e3o em portugu\u00eas http://www.novatec.com.br/catalogo/7522508-pense-em-python P\u00e1gina da edi\u00e7\u00e3o original em ingl\u00eas http://bit.ly/think-python_2E Para obter mais informa\u00e7\u00f5es sobre os livros da Novatec, acesse nosso site em http://www.novatec.com.br . Agradecimentos Muito obrigado a Jeff Elkner, que traduziu meu livro de Java para o Python, o que deu in\u00edcio a este projeto e me apresentou ao que acabou sendo a minha linguagem favorita. Agrade\u00e7o tamb\u00e9m a Chris Meyers, que contribuiu em v\u00e1rias se\u00e7\u00f5es do Pense como um cientista da computa\u00e7\u00e3o . Obrigado \u00e0 Funda\u00e7\u00e3o do Software Livre pelo desenvolvimento da Licen\u00e7a de Documenta\u00e7\u00e3o Livre GNU, que me ajudou a tornar poss\u00edvel a colabora\u00e7\u00e3o com Jeff e Chris, e ao Creative Commons pela licen\u00e7a que estou usando agora. Obrigado aos editores do Lulu, que trabalharam no Pense como um cientista da computa\u00e7\u00e3o . Obrigado aos editores da O\u2019Reilly Media, que trabalharam no Pense em Python . Obrigado a todos os estudantes que trabalharam com vers\u00f5es anteriores deste livro e a todos os contribuidores (listados a seguir) que enviaram corre\u00e7\u00f5es e sugest\u00f5es. Lista de contribuidores Mais de cem leitores perspicazes e atentos enviaram sugest\u00f5es e corre\u00e7\u00f5es nos \u00faltimos anos. Suas contribui\u00e7\u00f5es e entusiasmo por este projeto foram inestim\u00e1veis. Se tiver alguma sugest\u00e3o ou corre\u00e7\u00e3o, por favor, envie um email a feedback@thinkpython.com . Se eu fizer alguma altera\u00e7\u00e3o baseada no seu coment\u00e1rio, acrescentarei seu nome \u00e0 lista de contribuidores (a menos que voc\u00ea pe\u00e7a para eu omitir a informa\u00e7\u00e3o). Se voc\u00ea incluir pelo menos uma parte da frase onde o erro aparece, \u00e9 mais f\u00e1cil para eu procur\u00e1-lo. Tamb\u00e9m pode ser o n\u00famero da p\u00e1gina e se\u00e7\u00e3o, mas a\u00ed \u00e9 um pouquinho mais dif\u00edcil de encontrar o erro a ser corrigido. Obrigado! Lloyd Hugh Allen enviou uma corre\u00e7\u00e3o da Se\u00e7\u00e3o 8.4. Yvon Boulianne enviou a corre\u00e7\u00e3o de um erro sem\u00e2ntico no Cap\u00edtulo 5. Fred Bremmer enviou uma corre\u00e7\u00e3o da Se\u00e7\u00e3o 2.1. Jonah Cohen escreveu os scripts em Perl para converter a fonte de LaTeX deste livro para o belo HTML. Michael Conlon enviou uma corre\u00e7\u00e3o gramatical do Cap\u00edtulo 2 e uma melhoria no estilo do Cap\u00edtulo 1, al\u00e9m de iniciar a discuss\u00e3o sobre os aspectos t\u00e9cnicos de interpretadores. Benoit Girard enviou uma corre\u00e7\u00e3o a um erro humor\u00edstico na Se\u00e7\u00e3o 5.6. Courtney Gleason e Katherine Smith escreveram horsebet.py, que foi usado como um estudo de caso em uma vers\u00e3o anterior do livro. O programa agora pode ser encontrado no site. Lee Harr enviou mais corre\u00e7\u00f5es do que temos espa\u00e7o para relacionar aqui, e na verdade ele deve ser apontado como um dos editores principais do texto. James Kaylin \u00e9 um estudante que usa o texto. Ele enviou v\u00e1rias corre\u00e7\u00f5es. David Kershaw corrigiu a fun\u00e7\u00e3o catTwice defeituosa na Se\u00e7\u00e3o 3.10. Eddie Lam entregou diversas corre\u00e7\u00f5es aos Cap\u00edtulos 1, 2, e 3. Ele tamb\u00e9m corrigiu o Makefile para criar um \u00edndice na primeira vez que rodar e nos ajudou a estabelecer um esquema de versionamento. Man-Yong Lee enviou uma corre\u00e7\u00e3o do c\u00f3digo de exemplo na Se\u00e7\u00e3o 2.4. David Mayo indicou que a palavra \u201cinconscientemente\u201d no Cap\u00edtulo 1 devia ser alterada para \u201csubconscientemente\u201d. Chris McAloon enviou v\u00e1rias corre\u00e7\u00f5es para as Se\u00e7\u00f5es 3.9 e 3.10. Matthew J. Moelter tem contribu\u00eddo j\u00e1 h\u00e1 um bom tempo e entregou diversas corre\u00e7\u00f5es e sugest\u00f5es para o livro. Simon Dicon Montford informou que havia uma defini\u00e7\u00e3o de fun\u00e7\u00e3o ausente e v\u00e1rios erros de ortografia no Cap\u00edtulo 3. Ele tamb\u00e9m encontrou erros na fun\u00e7\u00e3o increment no Cap\u00edtulo 13. John Ouzts corrigiu a defini\u00e7\u00e3o de \u201cvalor de retorno\u201d no Cap\u00edtulo 3. Kevin Parks enviou coment\u00e1rios e sugest\u00f5es valiosos para melhorar a distribui\u00e7\u00e3o do livro. David Pool encontrou um erro de ortografia no gloss\u00e1rio do Cap\u00edtulo 1, e tamb\u00e9m enviou palavras gentis de encorajamento. Michael Schmitt enviou uma corre\u00e7\u00e3o ao cap\u00edtulo sobre arquivos e exce\u00e7\u00f5es. Robin Shaw indicou um erro na Se\u00e7\u00e3o 13.1, onde a fun\u00e7\u00e3o printTime foi usada em um exemplo sem ser definida. Paul Sleigh encontrou um erro no Cap\u00edtulo 7 e um bug no script em Perl de Jonah Cohen, que gera o HTML do LaTeX. Craig T. Snydal est\u00e1 testando o texto em um curso na Drew University. Ele contribuiu com v\u00e1rias sugest\u00f5es valiosas e corre\u00e7\u00f5es. Ian Thomas e seus alunos est\u00e3o usando o texto em um curso de programa\u00e7\u00e3o. Eles s\u00e3o os primeiros a testar os cap\u00edtulos da segunda metade do livro e fizeram muitas corre\u00e7\u00f5es e sugest\u00f5es. Keith Verheyden enviou uma corre\u00e7\u00e3o no Cap\u00edtulo 3. Peter Winstanley nos avisou sobre um erro antigo no latim do Cap\u00edtulo 3. Chris Wrobel fez corre\u00e7\u00f5es ao c\u00f3digo no cap\u00edtulo sobre arquivos E/S e exce\u00e7\u00f5es. Moshe Zadka fez contribui\u00e7\u00f5es inestim\u00e1veis para este projeto. Al\u00e9m de escrever o primeiro rascunho do cap\u00edtulo sobre Dicion\u00e1rios, ele forneceu orienta\u00e7\u00e3o cont\u00ednua nas primeiras etapas do livro. Christoph Zwerschke enviou v\u00e1rias corre\u00e7\u00f5es e sugest\u00f5es pedag\u00f3gicas, e explicou a diferen\u00e7a entre gleich e selbe. James Mayer enviou-nos um monte de erros tipogr\u00e1ficos e ortogr\u00e1ficos, inclusive dois da lista de contribuidores. Hayden McAfee percebeu uma inconsist\u00eancia potencialmente confusa entre dois exemplos. Angel Arnal faz parte de uma equipe internacional de tradutores que trabalhou na vers\u00e3o do texto para o espanhol. Ele tamb\u00e9m encontrou v\u00e1rios erros na vers\u00e3o em ingl\u00eas. Tauhidul Hoque e Lex Berezhny criaram as ilustra\u00e7\u00f5es do Cap\u00edtulo 1 e melhoraram muitas das outras ilustra\u00e7\u00f5es. O Dr. Michele Alzetta pegou um erro no Cap\u00edtulo 8 e enviou alguns coment\u00e1rios pedag\u00f3gicos interessantes e sugest\u00f5es sobre Fibonacci e o jogo do Mico. Andy Mitchell pegou um erro de ortografia no Cap\u00edtulo 1 e um exemplo ruim no Cap\u00edtulo 2. Kalin Harvey sugeriu um esclarecimento no Cap\u00edtulo 7 e achou alguns erros de ortografia. Christopher P. Smith encontrou v\u00e1rios erros de ortografia e ajudou-nos a atualizar o livro para o Python 2.2. David Hutchins encontrou um erro de ortografia no pref\u00e1cio. Gregor Lingl \u00e9 professor de Python em uma escola de Ensino M\u00e9dio em Viena, na \u00c1ustria. Ele est\u00e1 trabalhando em uma tradu\u00e7\u00e3o do livro para o alem\u00e3o e encontrou alguns erros feios no Cap\u00edtulo 5. Julie Peters achou um erro de ortografia no pref\u00e1cio. Florin Oprina enviou uma melhoria para o makeTime, uma corre\u00e7\u00e3o no printTime e um belo erro de ortografia. D. J. Webre sugeriu um esclarecimento no Cap\u00edtulo 3. Ken encontrou um punhado de erros nos Cap\u00edtulos 8, 9 e 11. Ivo Wever achou um erro de ortografia no Cap\u00edtulo 5 e sugeriu um esclarecimento no Cap\u00edtulo 3. Curtis Yanko sugeriu um esclarecimento no Cap\u00edtulo 2. Ben Logan enviou v\u00e1rios erros de ortografia e problemas com a tradu\u00e7\u00e3o do livro para HTML. Jason Armstrong percebeu que faltava uma palavra no Cap\u00edtulo 2. Louis Cordier notou um ponto no Cap\u00edtulo 16 onde o c\u00f3digo n\u00e3o correspondia com o texto. Brian Caim sugeriu v\u00e1rios esclarecimentos nos Cap\u00edtulos 2 e 3. Rob Black entregou um monte de corre\u00e7\u00f5es, inclusive algumas altera\u00e7\u00f5es para Python 2.2. Jean-Philippe Rey, da \u00c9cole Centrale Paris, enviou uma s\u00e9rie de patches, inclusive algumas atualiza\u00e7\u00f5es do Python 2.2 e outras melhorias bem pensadas. Jason Mader, da George Washington University, fez uma s\u00e9rie de sugest\u00f5es e corre\u00e7\u00f5es \u00fateis. Jan Gundtofte-Bruun nos lembrou de que \u201cun erro\u201d \u00e9 um erro. Abel David e Alexis Dinno nos lembraram de que o plural de \u201cmatriz\u201d \u00e9 \u201cmatrizes\u201d, n\u00e3o \u201cmatrixes\u201d. Este erro esteve no livro por anos, mas dois leitores com as mesmas iniciais informaram a respeito dele no mesmo dia. Bizarro. Charles Thayer nos estimulou a sumir com os pontos e v\u00edrgulas que t\u00ednhamos posto no final de algumas instru\u00e7\u00f5es e a otimizar nosso uso de \u201cargumento\u201d e \u201cpar\u00e2metro\u201d. Roger Sperberg indicou uma parte distorcida de l\u00f3gica no Cap\u00edtulo 3. Sam Bull indicou um par\u00e1grafo confuso no Cap\u00edtulo 2. Andrew Cheung indicou duas ocorr\u00eancias de \u201cuso antes da defini\u00e7\u00e3o\u201d. C. Corey Capel notou uma palavra ausente e um erro de ortografia no Cap\u00edtulo 4. Alessandra ajudou a eliminar algumas coisas confusas do Turtle. Wim Champagne encontrou uma confus\u00e3o de palavras em um exemplo de dicion\u00e1rio. Douglas Wright indicou um problema com a divis\u00e3o pelo piso em arc. Jared Spindor encontrou uma confus\u00e3o no fim de uma frase. Lin Peiheng enviou v\u00e1rias sugest\u00f5es muito \u00fateis. Ray Hagtvedt enviou dois erros e um quase erro. Torsten H\u00fcbsch indicou uma inconsist\u00eancia no Swampy. Inga Petuhhov corrigiu um exemplo no Cap\u00edtulo 14. Arne Babenhauserheide enviou v\u00e1rias corre\u00e7\u00f5es \u00fateis. Mark E. Casida \u00e9 \u00e9 bom em encontrar palavras repetidas. Scott Tyler preencheu um que faltava. E em seguida enviou um monte de corre\u00e7\u00f5es. Gordon Shephard enviou v\u00e1rias corre\u00e7\u00f5es, todas em emails separados. Andrew Turner notou um erro no Cap\u00edtulo 8. Adam Hobart corrigiu um problema com a divis\u00e3o pelo piso em arc. Daryl Hammond e Sarah Zimmerman indicaram que eu trouxe o math.pi para a mesa cedo demais. E Zim achou um erro de ortografia. George Sass encontrou um bug em uma se\u00e7\u00e3o de depura\u00e7\u00e3o. Brian Bingham sugeriu o Exerc\u00edcio 11.5. Leah Engelbert-Fenton indicou que usei tuple como um nome de vari\u00e1vel, contrariando meu pr\u00f3prio conselho. E, em seguida, encontrou uma por\u00e7\u00e3o de erros de ortografia e um \u201cuso antes da defini\u00e7\u00e3o\u201d. Joe Funke achou um erro de ortografia. Chao-chao Chen encontrou uma inconsist\u00eancia no exemplo de Fibonacci. Jeff Paine sabe a diferen\u00e7a entre espa\u00e7o e spam. Lubos Pintes enviou um erro de ortografia. Gregg Lind e Abigail Heithoff sugeriram o Exerc\u00edcio 14.3. Max Hailperin entregou uma s\u00e9rie de corre\u00e7\u00f5es e sugest\u00f5es. Max \u00e9 um dos autores das extraordin\u00e1rias Abstra\u00e7\u00f5es Concretas (Tecnologia de curso, 1998), que voc\u00ea pode querer ler quando terminar este livro. Chotipat Pornavalai encontrou um erro em uma mensagem de erro. Stanislaw Antol enviou uma lista com v\u00e1rias sugest\u00f5es \u00fateis. Eric Pashman enviou uma s\u00e9rie de corre\u00e7\u00f5es para os Cap\u00edtulos 4-11. Miguel Azevedo encontrou alguns erros de ortografia. Jianhua Liu enviou uma longa lista de corre\u00e7\u00f5es. Nick King encontrou uma palavra que faltava. Martin Zuther enviou uma longa lista de sugest\u00f5es. Adam Zimmerman encontrou uma inconsist\u00eancia em uma ocorr\u00eancia de \u201cocorr\u00eancia\u201d e v\u00e1rios outros erros. Ratnakar Tiwari sugeriu uma nota de rodap\u00e9 explicando tri\u00e2ngulos degenerados. Anurag Goel sugeriu outra solu\u00e7\u00e3o para is_abecedarian e enviou algumas corre\u00e7\u00f5es adicionais. E ele sabe soletrar Jane Austen. Kelli Kratzer notou um dos erros de ortografia. Mark Griffiths indicou um exemplo confuso no Cap\u00edtulo 3. Roydan Ongie encontrou um erro no meu m\u00e9todo de Newton. Patryk Wolowiec me ajudou com um problema na vers\u00e3o do HTML. Mark Chonofsky me falou de uma nova palavra-chave no Python 3. Russell Coleman ajudou com a minha geometria. Wei Huang notou v\u00e1rios erros tipogr\u00e1ficos. Karen Barber achou o erro de ortografia mais antigo no livro. Nam Nguyen encontrou um erro de ortografia e indicou que usei o Decorator, mas n\u00e3o mencionei o nome. St\u00e9phane Morin enviou v\u00e1rias corre\u00e7\u00f5es e sugest\u00f5es. Paul Stoop corrigiu um erro de ortografia em uses_only. Eric Bronner indicou uma confus\u00e3o na discuss\u00e3o da ordem de opera\u00e7\u00f5es. Alexandros Gezerlis definiu um novo padr\u00e3o para o n\u00famero e a qualidade das sugest\u00f5es que enviou. Estamos profundamente gratos! Gray Thomas sabe diferenciar a direita da esquerda. Giovanni Escobar Sosa enviou uma longa lista de corre\u00e7\u00f5es e sugest\u00f5es. Alix Etienne corrigiu uma das URLs. Kuang He encontrou um erro de ortografia. Daniel Neilson corrigiu um erro sobre a ordem de opera\u00e7\u00f5es. Will McGinnis indicou que polyline foi definida de forma diferente em dois lugares. Swarup Sahoo notou que faltava um ponto e v\u00edrgula. Frank Hecker indicou que um exerc\u00edcio estava mal especificado e encontrou alguns links quebrados. Animesh B me ajudou a esclarecer um exemplo confuso. Martin Caspersen encontrou dois erros de arredondamento. Gregor Ulm enviou v\u00e1rias corre\u00e7\u00f5es e sugest\u00f5es. Dimitrios Tsirigkas sugeriu que eu esclarecesse um exerc\u00edcio. Carlos Tafur enviou uma p\u00e1gina de corre\u00e7\u00f5es e sugest\u00f5es. Martin Nordsletten encontrou um bug na solu\u00e7\u00e3o de um exerc\u00edcio. Lars O.D. Christensen encontrou uma refer\u00eancia quebrada. Vitor Simeone encontrou um erro de ortografia. Sven Hoexter indicou que uma entrada de uma vari\u00e1vel nomeada se sobrep\u00f5e a uma fun\u00e7\u00e3o integrada. Viet Le encontrou um erro de ortografia. Stephen Gregory indicou o problema com cmp no Python 3. Matthew Shultz me avisou sobre um link quebrado. Lokesh Kumar Makani me avisou sobre alguns links quebrados e algumas altera\u00e7\u00f5es em mensagens de erro. Ishwar Bhat corrigiu minha declara\u00e7\u00e3o do \u00faltimo teorema de Fermat. Brian McGhie sugeriu um esclarecimento. Andrea Zanella traduziu o livro para o italiano e enviou uma s\u00e9rie de corre\u00e7\u00f5es ao longo do caminho. Muito, muito obrigado a Melissa Lewis e Luciano Ramalho pelos coment\u00e1rios e sugest\u00f5es excelentes na segunda edi\u00e7\u00e3o. Obrigado a Harry Percival do PythonAnywhere por ajudar as pessoas a come\u00e7ar a usar o Python em um navegador. Xavier Van Aubel fez v\u00e1rias corre\u00e7\u00f5es \u00fateis na segunda edi\u00e7\u00e3o.","title":"Pref\u00e1cio"},{"location":"00-prefacio/#prefacio","text":"","title":"Pref\u00e1cio"},{"location":"00-prefacio/#a-estranha-historia-deste-livro","text":"Em janeiro de 1999 eu me preparava para dar aula a uma turma de programa\u00e7\u00e3o introdut\u00f3ria em Java. J\u00e1 tinha dado esse curso tr\u00eas vezes e estava ficando frustrado. O \u00edndice de aprova\u00e7\u00e3o era muito baixo e mesmo entre os alunos aprovados, o n\u00edvel geral das notas era baixo demais. Um dos problemas que eu via eram os livros. Eram muito grandes, com detalhes desnecess\u00e1rios sobre o Java, e n\u00e3o havia orienta\u00e7\u00e3o de alto n\u00edvel sobre como programar. E todos eles sofriam do efeito al\u00e7ap\u00e3o: no in\u00edcio era f\u00e1cil, os alunos iam aprendendo aos poucos, e l\u00e1 pelo Cap\u00edtulo 5, perdiam o ch\u00e3o. Era muito material novo, muito r\u00e1pido, e eles acabavam engatinhando no resto do semestre. Duas semanas antes do primeiro dia de aula, eu decidi escrever meu pr\u00f3prio livro. Meus objetivos eram: que o livro fosse curto. Era melhor os alunos lerem 10 p\u00e1ginas que n\u00e3o lerem 50. abordar o vocabul\u00e1rio com cuidado. Tentei minimizar o jarg\u00e3o e definir cada termo no momento do primeiro uso. construir o aprendizado passo a passo. Para evitar al\u00e7ap\u00f5es, dividi os t\u00f3picos mais dif\u00edceis e em uma s\u00e9rie de etapas menores. que o conte\u00fado fosse concentrado em programar mesmo, n\u00e3o na linguagem de programa\u00e7\u00e3o. Selecionei um subconjunto m\u00ednimo \u00fatil do Java e omiti o resto. Eu precisava de um t\u00edtulo, ent\u00e3o, por capricho, decidi cham\u00e1-lo de Pense como um cientista da computa\u00e7\u00e3o . A minha primeira vers\u00e3o era apenas um esbo\u00e7o, mas funcionou. Os alunos liam e entendiam o suficiente para podermos usar o tempo de aula para os t\u00f3picos dif\u00edceis, interessantes e (o mais importante) para permitir que os alunos praticassem. Lancei o livro sob uma Licen\u00e7a de Documenta\u00e7\u00e3o Livre GNU, que permite aos usu\u00e1rios copiar, modificar e distribuir o livro. E o que aconteceu em seguida foi legal. Jeff Elkner, um professor de ensino m\u00e9dio na Virg\u00ednia adotou meu livro e o traduziu para Python. Ele me enviou uma c\u00f3pia de sua tradu\u00e7\u00e3o e tive a experi\u00eancia excepcional de aprender Python lendo o meu pr\u00f3prio livro. Com a editora Green Tea, publiquei a primeira vers\u00e3o em Python em 2001. Em 2003 comecei a trabalhar no Olin College e a ensinar Python pela primeira vez na vida. O contraste com o Java era not\u00e1vel. Os estudantes tinham menos dificuldades, aprendiam mais, trabalhavam em projetos mais interessantes e geralmente se divertiam muito mais. Desde ent\u00e3o continuei a desenvolver o livro, corrigindo erros, melhorando alguns exemplos e acrescentando material, especialmente exerc\u00edcios. O resultado est\u00e1 aqui, agora com o t\u00edtulo menos grandioso de Pense em Python . Fiz algumas altera\u00e7\u00f5es: Acrescentei uma se\u00e7\u00e3o sobre depura\u00e7\u00e3o (debugging) no fim de cada cap\u00edtulo. Essas se\u00e7\u00f5es apresentam t\u00e9cnicas gerais para encontrar e evitar bugs (erros de programa\u00e7\u00e3o) e avisos sobre armadilhas do Python. Acrescentei exerc\u00edcios, incluindo testes curtos de compreens\u00e3o e alguns projetos substanciais. A maior parte dos exerc\u00edcios tem um link para a minha solu\u00e7\u00e3o. Acrescentei uma s\u00e9rie de estudos de caso \u2013 exemplos mais longos com exerc\u00edcios, solu\u00e7\u00f5es e discuss\u00f5es. Expandi a discuss\u00e3o sobre planos de desenvolvimento de programas e padr\u00f5es de design b\u00e1sicos. Acrescentei ap\u00eandices sobre depura\u00e7\u00e3o e an\u00e1lise de algoritmos. Esta edi\u00e7\u00e3o de Pense em Python tem as seguintes novidades: O livro e todo o c\u00f3digo de apoio foram atualizados para o Python 3. Acrescentei algumas se\u00e7\u00f5es e mais detalhes sobre a web, para ajudar os principiantes a executar o Python em um navegador, e n\u00e3o ter que lidar com a instala\u00e7\u00e3o do programa at\u00e9 que seja necess\u00e1rio. Para \u201cM\u00f3dulo turtle\u201d troquei meu pr\u00f3prio pacote gr\u00e1fico turtle, chamado Swampy, para um m\u00f3dulo Python mais padronizado, turtle, que \u00e9 mais f\u00e1cil de instalar e mais eficiente. Acrescentei um novo cap\u00edtulo chamado \u201cExtra\u201d , que introduz alguns recursos adicionais do Python, n\u00e3o estritamente necess\u00e1rios, mas \u00e0s vezes pr\u00e1ticos. Espero que goste de trabalhar com este livro, e que ele o ajude a aprender a programar e pensar, pelo menos um pouquinho, como um cientista da computa\u00e7\u00e3o. Allen B. Downey Olin College","title":"A estranha hist\u00f3ria deste livro"},{"location":"00-prefacio/#convencoes-usadas-neste-livro","text":"As seguintes conven\u00e7\u00f5es tipogr\u00e1ficas s\u00e3o usadas neste livro: It\u00e1lico Indica novos termos, URLs, endere\u00e7os de email, nomes de arquivo e extens\u00f5es de arquivo. Negrito Indica termos definidos no gloss\u00e1rio no final de cap\u00edtulo. Monoespa\u00e7ado Usada para c\u00f3digo de programa, bem como dentro de par\u00e1grafos para referir-se a elementos do programa, como nomes de vari\u00e1veis ou de fun\u00e7\u00f5es, bancos de dados, tipos de dados, vari\u00e1veis de ambiente, instru\u00e7\u00f5es e palavras-chave. Monoespa\u00e7ado negrito Exibe comandos ou outros textos que devem ser digitados literalmente pelo usu\u00e1rio. Monoespa\u00e7ado it\u00e1lico Exibe textos que devem ser substitu\u00eddos por valores fornecidos pelos usu\u00e1rios ou por valores determinados pelo contexto.","title":"Conven\u00e7\u00f5es usadas neste livro"},{"location":"00-prefacio/#uso-do-codigo-dos-exemplos-de-acordo-com-a-politica-da-oreilly","text":"H\u00e1 material suplementar (exemplos de c\u00f3digo, exerc\u00edcios etc.) dispon\u00edvel para baixar em http://www.greenteapress.com/thinkpython2/code . Este livro serve para ajudar voc\u00ea a fazer o que precisa. Em geral, se o livro oferece exemplos de c\u00f3digo, voc\u00ea pode us\u00e1-los nos seus programas e documenta\u00e7\u00e3o. N\u00e3o \u00e9 preciso entrar em contato conosco para pedir permiss\u00e3o, a menos que esteja reproduzindo uma por\u00e7\u00e3o significativa do c\u00f3digo. Por exemplo, escrever um programa que use v\u00e1rios peda\u00e7os de c\u00f3digo deste livro n\u00e3o exige permiss\u00e3o. Vender ou distribuir um CD-ROM de exemplos dos livros da O\u2019Reilly exige permiss\u00e3o. Responder a uma pergunta citando este livro e reproduzindo exemplos de c\u00f3digo n\u00e3o exige permiss\u00e3o. Incorporar uma quantidade significativa de exemplos de c\u00f3digo deste livro na documenta\u00e7\u00e3o do seu produto exige permiss\u00e3o. Agradecemos, mas n\u00e3o exigimos, cr\u00e9dito. O cr\u00e9dito normalmente inclui o t\u00edtulo, o autor, a editora e o ISBN. Por exemplo: \u201c Pense em Python , 2\u00aa edi\u00e7\u00e3o, por Allen B. Downey (O\u2019Reilly). Copyright 2016 Allen Downey, 978-1-4919-3936-9.\u201d Se acreditar que o seu uso dos exemplos de c\u00f3digo n\u00e3o se ajusta \u00e0 permiss\u00e3o dada anteriormente, fique \u00e0 vontade para entrar em contato conosco pelo email permissions@oreilly.com .","title":"Uso do c\u00f3digo dos exemplos (de acordo com a pol\u00edtica da O'Reilly)"},{"location":"00-prefacio/#como-entrar-em-contato-conosco","text":"Envie coment\u00e1rios e d\u00favidas sobre este livro \u00e0 editora, escrevendo para: novatec@novatec.com.br . Temos uma p\u00e1gina web para este livro na qual inclu\u00edmos erratas, exemplos e quaisquer outras informa\u00e7\u00f5es adicionais. P\u00e1gina da edi\u00e7\u00e3o em portugu\u00eas http://www.novatec.com.br/catalogo/7522508-pense-em-python P\u00e1gina da edi\u00e7\u00e3o original em ingl\u00eas http://bit.ly/think-python_2E Para obter mais informa\u00e7\u00f5es sobre os livros da Novatec, acesse nosso site em http://www.novatec.com.br .","title":"Como entrar em contato conosco"},{"location":"00-prefacio/#agradecimentos","text":"Muito obrigado a Jeff Elkner, que traduziu meu livro de Java para o Python, o que deu in\u00edcio a este projeto e me apresentou ao que acabou sendo a minha linguagem favorita. Agrade\u00e7o tamb\u00e9m a Chris Meyers, que contribuiu em v\u00e1rias se\u00e7\u00f5es do Pense como um cientista da computa\u00e7\u00e3o . Obrigado \u00e0 Funda\u00e7\u00e3o do Software Livre pelo desenvolvimento da Licen\u00e7a de Documenta\u00e7\u00e3o Livre GNU, que me ajudou a tornar poss\u00edvel a colabora\u00e7\u00e3o com Jeff e Chris, e ao Creative Commons pela licen\u00e7a que estou usando agora. Obrigado aos editores do Lulu, que trabalharam no Pense como um cientista da computa\u00e7\u00e3o . Obrigado aos editores da O\u2019Reilly Media, que trabalharam no Pense em Python . Obrigado a todos os estudantes que trabalharam com vers\u00f5es anteriores deste livro e a todos os contribuidores (listados a seguir) que enviaram corre\u00e7\u00f5es e sugest\u00f5es.","title":"Agradecimentos"},{"location":"00-prefacio/#lista-de-contribuidores","text":"Mais de cem leitores perspicazes e atentos enviaram sugest\u00f5es e corre\u00e7\u00f5es nos \u00faltimos anos. Suas contribui\u00e7\u00f5es e entusiasmo por este projeto foram inestim\u00e1veis. Se tiver alguma sugest\u00e3o ou corre\u00e7\u00e3o, por favor, envie um email a feedback@thinkpython.com . Se eu fizer alguma altera\u00e7\u00e3o baseada no seu coment\u00e1rio, acrescentarei seu nome \u00e0 lista de contribuidores (a menos que voc\u00ea pe\u00e7a para eu omitir a informa\u00e7\u00e3o). Se voc\u00ea incluir pelo menos uma parte da frase onde o erro aparece, \u00e9 mais f\u00e1cil para eu procur\u00e1-lo. Tamb\u00e9m pode ser o n\u00famero da p\u00e1gina e se\u00e7\u00e3o, mas a\u00ed \u00e9 um pouquinho mais dif\u00edcil de encontrar o erro a ser corrigido. Obrigado! Lloyd Hugh Allen enviou uma corre\u00e7\u00e3o da Se\u00e7\u00e3o 8.4. Yvon Boulianne enviou a corre\u00e7\u00e3o de um erro sem\u00e2ntico no Cap\u00edtulo 5. Fred Bremmer enviou uma corre\u00e7\u00e3o da Se\u00e7\u00e3o 2.1. Jonah Cohen escreveu os scripts em Perl para converter a fonte de LaTeX deste livro para o belo HTML. Michael Conlon enviou uma corre\u00e7\u00e3o gramatical do Cap\u00edtulo 2 e uma melhoria no estilo do Cap\u00edtulo 1, al\u00e9m de iniciar a discuss\u00e3o sobre os aspectos t\u00e9cnicos de interpretadores. Benoit Girard enviou uma corre\u00e7\u00e3o a um erro humor\u00edstico na Se\u00e7\u00e3o 5.6. Courtney Gleason e Katherine Smith escreveram horsebet.py, que foi usado como um estudo de caso em uma vers\u00e3o anterior do livro. O programa agora pode ser encontrado no site. Lee Harr enviou mais corre\u00e7\u00f5es do que temos espa\u00e7o para relacionar aqui, e na verdade ele deve ser apontado como um dos editores principais do texto. James Kaylin \u00e9 um estudante que usa o texto. Ele enviou v\u00e1rias corre\u00e7\u00f5es. David Kershaw corrigiu a fun\u00e7\u00e3o catTwice defeituosa na Se\u00e7\u00e3o 3.10. Eddie Lam entregou diversas corre\u00e7\u00f5es aos Cap\u00edtulos 1, 2, e 3. Ele tamb\u00e9m corrigiu o Makefile para criar um \u00edndice na primeira vez que rodar e nos ajudou a estabelecer um esquema de versionamento. Man-Yong Lee enviou uma corre\u00e7\u00e3o do c\u00f3digo de exemplo na Se\u00e7\u00e3o 2.4. David Mayo indicou que a palavra \u201cinconscientemente\u201d no Cap\u00edtulo 1 devia ser alterada para \u201csubconscientemente\u201d. Chris McAloon enviou v\u00e1rias corre\u00e7\u00f5es para as Se\u00e7\u00f5es 3.9 e 3.10. Matthew J. Moelter tem contribu\u00eddo j\u00e1 h\u00e1 um bom tempo e entregou diversas corre\u00e7\u00f5es e sugest\u00f5es para o livro. Simon Dicon Montford informou que havia uma defini\u00e7\u00e3o de fun\u00e7\u00e3o ausente e v\u00e1rios erros de ortografia no Cap\u00edtulo 3. Ele tamb\u00e9m encontrou erros na fun\u00e7\u00e3o increment no Cap\u00edtulo 13. John Ouzts corrigiu a defini\u00e7\u00e3o de \u201cvalor de retorno\u201d no Cap\u00edtulo 3. Kevin Parks enviou coment\u00e1rios e sugest\u00f5es valiosos para melhorar a distribui\u00e7\u00e3o do livro. David Pool encontrou um erro de ortografia no gloss\u00e1rio do Cap\u00edtulo 1, e tamb\u00e9m enviou palavras gentis de encorajamento. Michael Schmitt enviou uma corre\u00e7\u00e3o ao cap\u00edtulo sobre arquivos e exce\u00e7\u00f5es. Robin Shaw indicou um erro na Se\u00e7\u00e3o 13.1, onde a fun\u00e7\u00e3o printTime foi usada em um exemplo sem ser definida. Paul Sleigh encontrou um erro no Cap\u00edtulo 7 e um bug no script em Perl de Jonah Cohen, que gera o HTML do LaTeX. Craig T. Snydal est\u00e1 testando o texto em um curso na Drew University. Ele contribuiu com v\u00e1rias sugest\u00f5es valiosas e corre\u00e7\u00f5es. Ian Thomas e seus alunos est\u00e3o usando o texto em um curso de programa\u00e7\u00e3o. Eles s\u00e3o os primeiros a testar os cap\u00edtulos da segunda metade do livro e fizeram muitas corre\u00e7\u00f5es e sugest\u00f5es. Keith Verheyden enviou uma corre\u00e7\u00e3o no Cap\u00edtulo 3. Peter Winstanley nos avisou sobre um erro antigo no latim do Cap\u00edtulo 3. Chris Wrobel fez corre\u00e7\u00f5es ao c\u00f3digo no cap\u00edtulo sobre arquivos E/S e exce\u00e7\u00f5es. Moshe Zadka fez contribui\u00e7\u00f5es inestim\u00e1veis para este projeto. Al\u00e9m de escrever o primeiro rascunho do cap\u00edtulo sobre Dicion\u00e1rios, ele forneceu orienta\u00e7\u00e3o cont\u00ednua nas primeiras etapas do livro. Christoph Zwerschke enviou v\u00e1rias corre\u00e7\u00f5es e sugest\u00f5es pedag\u00f3gicas, e explicou a diferen\u00e7a entre gleich e selbe. James Mayer enviou-nos um monte de erros tipogr\u00e1ficos e ortogr\u00e1ficos, inclusive dois da lista de contribuidores. Hayden McAfee percebeu uma inconsist\u00eancia potencialmente confusa entre dois exemplos. Angel Arnal faz parte de uma equipe internacional de tradutores que trabalhou na vers\u00e3o do texto para o espanhol. Ele tamb\u00e9m encontrou v\u00e1rios erros na vers\u00e3o em ingl\u00eas. Tauhidul Hoque e Lex Berezhny criaram as ilustra\u00e7\u00f5es do Cap\u00edtulo 1 e melhoraram muitas das outras ilustra\u00e7\u00f5es. O Dr. Michele Alzetta pegou um erro no Cap\u00edtulo 8 e enviou alguns coment\u00e1rios pedag\u00f3gicos interessantes e sugest\u00f5es sobre Fibonacci e o jogo do Mico. Andy Mitchell pegou um erro de ortografia no Cap\u00edtulo 1 e um exemplo ruim no Cap\u00edtulo 2. Kalin Harvey sugeriu um esclarecimento no Cap\u00edtulo 7 e achou alguns erros de ortografia. Christopher P. Smith encontrou v\u00e1rios erros de ortografia e ajudou-nos a atualizar o livro para o Python 2.2. David Hutchins encontrou um erro de ortografia no pref\u00e1cio. Gregor Lingl \u00e9 professor de Python em uma escola de Ensino M\u00e9dio em Viena, na \u00c1ustria. Ele est\u00e1 trabalhando em uma tradu\u00e7\u00e3o do livro para o alem\u00e3o e encontrou alguns erros feios no Cap\u00edtulo 5. Julie Peters achou um erro de ortografia no pref\u00e1cio. Florin Oprina enviou uma melhoria para o makeTime, uma corre\u00e7\u00e3o no printTime e um belo erro de ortografia. D. J. Webre sugeriu um esclarecimento no Cap\u00edtulo 3. Ken encontrou um punhado de erros nos Cap\u00edtulos 8, 9 e 11. Ivo Wever achou um erro de ortografia no Cap\u00edtulo 5 e sugeriu um esclarecimento no Cap\u00edtulo 3. Curtis Yanko sugeriu um esclarecimento no Cap\u00edtulo 2. Ben Logan enviou v\u00e1rios erros de ortografia e problemas com a tradu\u00e7\u00e3o do livro para HTML. Jason Armstrong percebeu que faltava uma palavra no Cap\u00edtulo 2. Louis Cordier notou um ponto no Cap\u00edtulo 16 onde o c\u00f3digo n\u00e3o correspondia com o texto. Brian Caim sugeriu v\u00e1rios esclarecimentos nos Cap\u00edtulos 2 e 3. Rob Black entregou um monte de corre\u00e7\u00f5es, inclusive algumas altera\u00e7\u00f5es para Python 2.2. Jean-Philippe Rey, da \u00c9cole Centrale Paris, enviou uma s\u00e9rie de patches, inclusive algumas atualiza\u00e7\u00f5es do Python 2.2 e outras melhorias bem pensadas. Jason Mader, da George Washington University, fez uma s\u00e9rie de sugest\u00f5es e corre\u00e7\u00f5es \u00fateis. Jan Gundtofte-Bruun nos lembrou de que \u201cun erro\u201d \u00e9 um erro. Abel David e Alexis Dinno nos lembraram de que o plural de \u201cmatriz\u201d \u00e9 \u201cmatrizes\u201d, n\u00e3o \u201cmatrixes\u201d. Este erro esteve no livro por anos, mas dois leitores com as mesmas iniciais informaram a respeito dele no mesmo dia. Bizarro. Charles Thayer nos estimulou a sumir com os pontos e v\u00edrgulas que t\u00ednhamos posto no final de algumas instru\u00e7\u00f5es e a otimizar nosso uso de \u201cargumento\u201d e \u201cpar\u00e2metro\u201d. Roger Sperberg indicou uma parte distorcida de l\u00f3gica no Cap\u00edtulo 3. Sam Bull indicou um par\u00e1grafo confuso no Cap\u00edtulo 2. Andrew Cheung indicou duas ocorr\u00eancias de \u201cuso antes da defini\u00e7\u00e3o\u201d. C. Corey Capel notou uma palavra ausente e um erro de ortografia no Cap\u00edtulo 4. Alessandra ajudou a eliminar algumas coisas confusas do Turtle. Wim Champagne encontrou uma confus\u00e3o de palavras em um exemplo de dicion\u00e1rio. Douglas Wright indicou um problema com a divis\u00e3o pelo piso em arc. Jared Spindor encontrou uma confus\u00e3o no fim de uma frase. Lin Peiheng enviou v\u00e1rias sugest\u00f5es muito \u00fateis. Ray Hagtvedt enviou dois erros e um quase erro. Torsten H\u00fcbsch indicou uma inconsist\u00eancia no Swampy. Inga Petuhhov corrigiu um exemplo no Cap\u00edtulo 14. Arne Babenhauserheide enviou v\u00e1rias corre\u00e7\u00f5es \u00fateis. Mark E. Casida \u00e9 \u00e9 bom em encontrar palavras repetidas. Scott Tyler preencheu um que faltava. E em seguida enviou um monte de corre\u00e7\u00f5es. Gordon Shephard enviou v\u00e1rias corre\u00e7\u00f5es, todas em emails separados. Andrew Turner notou um erro no Cap\u00edtulo 8. Adam Hobart corrigiu um problema com a divis\u00e3o pelo piso em arc. Daryl Hammond e Sarah Zimmerman indicaram que eu trouxe o math.pi para a mesa cedo demais. E Zim achou um erro de ortografia. George Sass encontrou um bug em uma se\u00e7\u00e3o de depura\u00e7\u00e3o. Brian Bingham sugeriu o Exerc\u00edcio 11.5. Leah Engelbert-Fenton indicou que usei tuple como um nome de vari\u00e1vel, contrariando meu pr\u00f3prio conselho. E, em seguida, encontrou uma por\u00e7\u00e3o de erros de ortografia e um \u201cuso antes da defini\u00e7\u00e3o\u201d. Joe Funke achou um erro de ortografia. Chao-chao Chen encontrou uma inconsist\u00eancia no exemplo de Fibonacci. Jeff Paine sabe a diferen\u00e7a entre espa\u00e7o e spam. Lubos Pintes enviou um erro de ortografia. Gregg Lind e Abigail Heithoff sugeriram o Exerc\u00edcio 14.3. Max Hailperin entregou uma s\u00e9rie de corre\u00e7\u00f5es e sugest\u00f5es. Max \u00e9 um dos autores das extraordin\u00e1rias Abstra\u00e7\u00f5es Concretas (Tecnologia de curso, 1998), que voc\u00ea pode querer ler quando terminar este livro. Chotipat Pornavalai encontrou um erro em uma mensagem de erro. Stanislaw Antol enviou uma lista com v\u00e1rias sugest\u00f5es \u00fateis. Eric Pashman enviou uma s\u00e9rie de corre\u00e7\u00f5es para os Cap\u00edtulos 4-11. Miguel Azevedo encontrou alguns erros de ortografia. Jianhua Liu enviou uma longa lista de corre\u00e7\u00f5es. Nick King encontrou uma palavra que faltava. Martin Zuther enviou uma longa lista de sugest\u00f5es. Adam Zimmerman encontrou uma inconsist\u00eancia em uma ocorr\u00eancia de \u201cocorr\u00eancia\u201d e v\u00e1rios outros erros. Ratnakar Tiwari sugeriu uma nota de rodap\u00e9 explicando tri\u00e2ngulos degenerados. Anurag Goel sugeriu outra solu\u00e7\u00e3o para is_abecedarian e enviou algumas corre\u00e7\u00f5es adicionais. E ele sabe soletrar Jane Austen. Kelli Kratzer notou um dos erros de ortografia. Mark Griffiths indicou um exemplo confuso no Cap\u00edtulo 3. Roydan Ongie encontrou um erro no meu m\u00e9todo de Newton. Patryk Wolowiec me ajudou com um problema na vers\u00e3o do HTML. Mark Chonofsky me falou de uma nova palavra-chave no Python 3. Russell Coleman ajudou com a minha geometria. Wei Huang notou v\u00e1rios erros tipogr\u00e1ficos. Karen Barber achou o erro de ortografia mais antigo no livro. Nam Nguyen encontrou um erro de ortografia e indicou que usei o Decorator, mas n\u00e3o mencionei o nome. St\u00e9phane Morin enviou v\u00e1rias corre\u00e7\u00f5es e sugest\u00f5es. Paul Stoop corrigiu um erro de ortografia em uses_only. Eric Bronner indicou uma confus\u00e3o na discuss\u00e3o da ordem de opera\u00e7\u00f5es. Alexandros Gezerlis definiu um novo padr\u00e3o para o n\u00famero e a qualidade das sugest\u00f5es que enviou. Estamos profundamente gratos! Gray Thomas sabe diferenciar a direita da esquerda. Giovanni Escobar Sosa enviou uma longa lista de corre\u00e7\u00f5es e sugest\u00f5es. Alix Etienne corrigiu uma das URLs. Kuang He encontrou um erro de ortografia. Daniel Neilson corrigiu um erro sobre a ordem de opera\u00e7\u00f5es. Will McGinnis indicou que polyline foi definida de forma diferente em dois lugares. Swarup Sahoo notou que faltava um ponto e v\u00edrgula. Frank Hecker indicou que um exerc\u00edcio estava mal especificado e encontrou alguns links quebrados. Animesh B me ajudou a esclarecer um exemplo confuso. Martin Caspersen encontrou dois erros de arredondamento. Gregor Ulm enviou v\u00e1rias corre\u00e7\u00f5es e sugest\u00f5es. Dimitrios Tsirigkas sugeriu que eu esclarecesse um exerc\u00edcio. Carlos Tafur enviou uma p\u00e1gina de corre\u00e7\u00f5es e sugest\u00f5es. Martin Nordsletten encontrou um bug na solu\u00e7\u00e3o de um exerc\u00edcio. Lars O.D. Christensen encontrou uma refer\u00eancia quebrada. Vitor Simeone encontrou um erro de ortografia. Sven Hoexter indicou que uma entrada de uma vari\u00e1vel nomeada se sobrep\u00f5e a uma fun\u00e7\u00e3o integrada. Viet Le encontrou um erro de ortografia. Stephen Gregory indicou o problema com cmp no Python 3. Matthew Shultz me avisou sobre um link quebrado. Lokesh Kumar Makani me avisou sobre alguns links quebrados e algumas altera\u00e7\u00f5es em mensagens de erro. Ishwar Bhat corrigiu minha declara\u00e7\u00e3o do \u00faltimo teorema de Fermat. Brian McGhie sugeriu um esclarecimento. Andrea Zanella traduziu o livro para o italiano e enviou uma s\u00e9rie de corre\u00e7\u00f5es ao longo do caminho. Muito, muito obrigado a Melissa Lewis e Luciano Ramalho pelos coment\u00e1rios e sugest\u00f5es excelentes na segunda edi\u00e7\u00e3o. Obrigado a Harry Percival do PythonAnywhere por ajudar as pessoas a come\u00e7ar a usar o Python em um navegador. Xavier Van Aubel fez v\u00e1rias corre\u00e7\u00f5es \u00fateis na segunda edi\u00e7\u00e3o.","title":"Lista de contribuidores"},{"location":"01-jornada/","text":"Cap\u00edtulo 1: A jornada do programa O objetivo deste livro \u00e9 ensinar a pensar como um cientista da computa\u00e7\u00e3o. Esta forma de pensar combina algumas das melhores caracter\u00edsticas da matem\u00e1tica, da engenharia e das ci\u00eancias naturais. Assim como os matem\u00e1ticos, os cientistas da computa\u00e7\u00e3o usam linguagens formais para denotar ideias (especificamente opera\u00e7\u00f5es de computa\u00e7\u00e3o). Como engenheiros, eles projetam coisas, reunindo componentes em sistemas e avaliando as op\u00e7\u00f5es de melhor retorno entre as alternativas \u00e0 disposi\u00e7\u00e3o. Como cientistas, observam o comportamento de sistemas complexos, formam hip\u00f3teses e testam previs\u00f5es. A habilidade espec\u00edfica mais importante de um cientista da computa\u00e7\u00e3o \u00e9 a resolu\u00e7\u00e3o de problemas . Resolu\u00e7\u00e3o de problemas significa a capacidade de formular problemas, pensar criativamente em solu\u00e7\u00f5es e expressar uma solu\u00e7\u00e3o de forma clara e precisa. Assim, o processo de aprender a programar \u00e9 uma oportunidade excelente para exercitar a habilidade de resolver problemas. \u00c9 por isso que este cap\u00edtulo se chama \u201cA jornada do programa\u201d. Em um n\u00edvel voc\u00ea aprender\u00e1 a programar, uma habilidade \u00fatil por si mesma. Em outro n\u00edvel usar\u00e1 a programa\u00e7\u00e3o como um meio para um fim. Conforme avan\u00e7armos, este fim ficar\u00e1 mais claro. 1.1 - O que \u00e9 um programa? Um programa \u00e9 uma sequ\u00eancia de instru\u00e7\u00f5es que especifica como executar uma opera\u00e7\u00e3o de computa\u00e7\u00e3o. A opera\u00e7\u00e3o de computa\u00e7\u00e3o pode ser algo matem\u00e1tico, como solucionar um sistema de equa\u00e7\u00f5es ou encontrar as ra\u00edzes de um polin\u00f4mio, mas tamb\u00e9m pode ser uma opera\u00e7\u00e3o de computa\u00e7\u00e3o simb\u00f3lica, como a busca e a substitui\u00e7\u00e3o de textos em um documento; ou algo gr\u00e1fico, como o processamento de uma imagem ou a reprodu\u00e7\u00e3o de um v\u00eddeo. Os detalhes parecem diferentes em linguagens diferentes, mas algumas instru\u00e7\u00f5es b\u00e1sicas aparecem em quase todas as linguagens: entrada Receber dados do teclado, de um arquivo, da rede ou de algum outro dispositivo. sa\u00edda Exibir dados na tela, salv\u00e1-los em um arquivo, envi\u00e1-los pela rede etc. matem\u00e1tica Executar opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas como adi\u00e7\u00e3o e multiplica\u00e7\u00e3o. execu\u00e7\u00e3o condicional Verificar a exist\u00eancia de certas condi\u00e7\u00f5es e executar o c\u00f3digo adequado. repeti\u00e7\u00e3o Executar v\u00e1rias vezes alguma a\u00e7\u00e3o, normalmente com algumas varia\u00e7\u00f5es. Acredite ou n\u00e3o, isto \u00e9 basicamente tudo o que \u00e9 preciso saber. Cada programa que voc\u00ea j\u00e1 usou, complicado ou n\u00e3o, \u00e9 composto de instru\u00e7\u00f5es muito parecidas com essas. Podemos ent\u00e3o chegar \u00e0 conclus\u00e3o de que programar \u00e9 o processo de quebrar uma tarefa grande e complexa em subtarefas cada vez menores, at\u00e9 que estas sejam simples o suficiente para serem executadas por uma dessas instru\u00e7\u00f5es b\u00e1sicas. 1.2 - Execu\u00e7\u00e3o do Python Um dos desafios de come\u00e7ar a usar Python \u00e9 ter que instalar no seu computador o pr\u00f3prio programa e outros relacionados. Se tiver familiaridade com o seu sistema operacional, e especialmente se n\u00e3o tiver problemas com a interface de linha de comando, voc\u00ea n\u00e3o ter\u00e1 dificuldade para instalar o Python. Mas para principiantes pode ser trabalhoso aprender sobre administra\u00e7\u00e3o de sistemas e programa\u00e7\u00e3o ao mesmo tempo. Para evitar esse problema, recomendo que comece a executar o Python em um navegador. Depois, quando voc\u00ea j\u00e1 conhecer o Python um pouco mais, darei sugest\u00f5es para instal\u00e1-lo em seu computador. H\u00e1 uma s\u00e9rie de sites que ajudam a usar e executar o Python. Se j\u00e1 tem um favorito, v\u00e1 em frente e use-o. Sen\u00e3o, recomendo o PythonAnywhere. Apresento instru\u00e7\u00f5es detalhadas sobre os primeiros passos no link http://tinyurl.com/thinkpython2e. H\u00e1 duas vers\u00f5es do Python, o Python 2 e o Python 3. Como elas s\u00e3o muito semelhantes, se voc\u00ea aprender uma vers\u00e3o, \u00e9 f\u00e1cil trocar para a outra. Como \u00e9 iniciante, voc\u00ea encontrar\u00e1 poucas diferen\u00e7as. Este livro foi escrito para o Python 3, mas tamb\u00e9m inclu\u00ed algumas notas sobre o Python 2. O interpretador do Python \u00e9 um programa que l\u00ea e executa o c\u00f3digo Python. Dependendo do seu ambiente, \u00e9 poss\u00edvel iniciar o interpretador clicando em um \u00edcone, ou digitando python em uma linha de comando. Quando ele iniciar, voc\u00ea dever\u00e1 ver uma sa\u00edda como esta: Python 3.4.0 (default, Jun 19 2015, 14:20:21) [GCC 4.8.2] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> As tr\u00eas primeiras linhas cont\u00eam informa\u00e7\u00f5es sobre o interpretador e o sistema operacional em que est\u00e1 sendo executado, portanto podem ser diferentes para voc\u00ea. Mas \u00e9 preciso conferir se o n\u00famero da vers\u00e3o, que \u00e9 3.4.0 neste exemplo, come\u00e7a com 3, o que indica que voc\u00ea est\u00e1 executando o Python 3. Se come\u00e7ar com 2, voc\u00ea est\u00e1 executando (adivinhe!) o Python 2. A \u00faltima linha \u00e9 um prompt indicando que o interpretador est\u00e1 pronto para voc\u00ea digitar o c\u00f3digo. Se digitar uma linha de c\u00f3digo e pressionar Enter, o interpretador exibe o resultado: >>> 1 + 1 2 Agora voc\u00ea est\u00e1 pronto para come\u00e7ar. Daqui em diante, vou supor que voc\u00ea sabe como inicializar o interpretador do Python e executar o c\u00f3digo. 1.3 - O primeiro programa Tradicionalmente, o primeiro programa que se escreve em uma nova linguagem chama-se \u201cHello, World!\u201d, porque tudo o que faz \u00e9 exibir as palavras \u201cHello, World!\u201d na tela. No Python, ele se parece com isto: >>> print('Hello, World!') Este \u00e9 um exemplo de uma instru\u00e7\u00e3o print (instru\u00e7\u00e3o de impress\u00e3o), embora na realidade ela n\u00e3o imprima nada em papel. Ela exibe um resultado na tela. Nesse caso, o resultado s\u00e3o as palavras: Hello, World! As aspas apenas marcam o come\u00e7o e o fim do texto a ser exibido; elas n\u00e3o aparecem no resultado. Os par\u00eanteses indicam que o print \u00e9 uma fun\u00e7\u00e3o. Veremos fun\u00e7\u00f5es no Cap\u00edtulo 3. No Python 2, a instru\u00e7\u00e3o print \u00e9 ligeiramente diferente; ela n\u00e3o \u00e9 uma fun\u00e7\u00e3o, portanto n\u00e3o usa par\u00eanteses. >>> print 'Hello, World!' Esta distin\u00e7\u00e3o far\u00e1 mais sentido em breve, mas isso \u00e9 o suficiente para come\u00e7ar. 1.4 - Operadores aritm\u00e9ticos Depois do \u201cHello, World\u201d, o pr\u00f3ximo passo \u00e9 a aritm\u00e9tica. O Python tem operadores, que s\u00e3o s\u00edmbolos especiais representando opera\u00e7\u00f5es de computa\u00e7\u00e3o, como adi\u00e7\u00e3o e multiplica\u00e7\u00e3o. Os operadores +, - e * executam a adi\u00e7\u00e3o, a subtra\u00e7\u00e3o e a multiplica\u00e7\u00e3o, como nos seguintes exemplos: >>> 40 + 2 42 >>> 43 - 1 42 >>> 6 * 7 42 O operador / executa a divis\u00e3o: >>> 84 / 2 42.0 Pode ser que voc\u00ea fique intrigado pelo resultado ser 42.0 em vez de 42. Vou explicar isso na pr\u00f3xima se\u00e7\u00e3o. Finalmente, o operador ** executa a exponencia\u00e7\u00e3o; isto \u00e9, eleva um n\u00famero a uma pot\u00eancia: >>> 6 ** 2 + 6 42 Em algumas outras linguagens, o ^ \u00e9 usado para a exponencia\u00e7\u00e3o, mas no Python \u00e9 um operador bitwise, chamado XOR. Se n\u00e3o tiver familiaridade com operadores bitwise, o resultado o surpreender\u00e1: >>> 6 ^ 2 4 N\u00e3o abordarei operadores bitwise neste livro, mas voc\u00ea pode ler sobre eles em http://wiki.python.org/moin/BitwiseOperators. 1.5 - Valores e tipos Um valor \u00e9 uma das coisas b\u00e1sicas com as quais um programa trabalha, como uma letra ou um n\u00famero. Alguns valores que vimos at\u00e9 agora foram 2, 42.0 e 'Hello, World!'. Esses valores pertencem a tipos diferentes: 2 \u00e9 um n\u00famero inteiro, 42.0 \u00e9 um n\u00famero de ponto flutuante e 'Hello, World!' \u00e9 uma string, assim chamada porque as letras que cont\u00e9m est\u00e3o em uma sequ\u00eancia em cadeia. Se n\u00e3o tiver certeza sobre qual \u00e9 o tipo de certo valor, o interpretador pode dizer isso a voc\u00ea: >>> type(2) <class 'int'> >>> type(42.0) <class 'float'> >>> type('Hello, World!') <class 'str'> Nesses resultados, a palavra \u201cclass\u201d [classe] \u00e9 usada no sentido de categoria; um tipo \u00e9 uma categoria de valores. Como se poderia esperar, n\u00fameros inteiros pertencem ao tipo int, strings pertencem ao tipo str e os n\u00fameros de ponto flutuante pertencem ao tipo float. E valores como '2' e '42.0'? Parecem n\u00fameros, mas est\u00e3o entre aspas como se fossem strings: >>> type('2') <class 'str'> >>> type('42.0') <class 'str'> Ent\u00e3o s\u00e3o strings. Ao digitar um n\u00famero inteiro grande, alguns podem usar a nota\u00e7\u00e3o americana, com v\u00edrgulas entre grupos de d\u00edgitos, como em 1,000,000. Este n\u00e3o \u00e9 um n\u00famero inteiro leg\u00edtimo no Python e resultar\u00e1 em: >>> 1,000,000 (1, 0, 0) O que n\u00e3o \u00e9 de modo algum o que esper\u00e1vamos! O Python interpreta 1,000,000 como uma sequ\u00eancia de n\u00fameros inteiros separados por v\u00edrgulas. Aprenderemos mais sobre este tipo de sequ\u00eancia mais adiante. 1.6 - Linguagens formais e naturais As linguagens naturais s\u00e3o os idiomas que as pessoas falam, como ingl\u00eas, espanhol e franc\u00eas. Elas n\u00e3o foram criadas pelas pessoas (embora as pessoas tentem impor certa ordem a elas); desenvolveram-se naturalmente. As linguagens formais s\u00e3o linguagens criadas pelas pessoas para aplica\u00e7\u00f5es espec\u00edficas. Por exemplo, a nota\u00e7\u00e3o que os matem\u00e1ticos usam \u00e9 uma linguagem formal especialmente boa para denotar rela\u00e7\u00f5es entre n\u00fameros e s\u00edmbolos. Os qu\u00edmicos usam uma linguagem formal para representar a estrutura qu\u00edmica de mol\u00e9culas. E o mais importante: As linguagens de programa\u00e7\u00e3o s\u00e3o idiomas formais criados para expressar opera\u00e7\u00f5es de computa\u00e7\u00e3o. As linguagens formais geralmente t\u00eam regras de sintaxe estritas que governam a estrutura de declara\u00e7\u00f5es. Por exemplo, na matem\u00e1tica a declara\u00e7\u00e3o 3 + 3 = 6 tem uma sintaxe correta, mas n\u00e3o 3 + = 3$6. Na qu\u00edmica, H2O \u00e9 uma f\u00f3rmula sintaticamente correta, mas 2Zz n\u00e3o \u00e9. As regras de sintaxe v\u00eam em duas categorias relativas a s\u00edmbolos e estrutura. Os s\u00edmbolos s\u00e3o os elementos b\u00e1sicos da linguagem, como palavras, n\u00fameros e elementos qu\u00edmicos. Um dos problemas com 3 + = 3$6 \u00e9 que o $ n\u00e3o \u00e9 um s\u00edmbolo leg\u00edtimo na matem\u00e1tica (pelo menos at\u00e9 onde eu sei). De forma similar, 2Zz n\u00e3o \u00e9 leg\u00edtimo porque n\u00e3o h\u00e1 nenhum elemento com a abreviatura Zz. O segundo tipo de regra de sintaxe refere-se ao modo no qual os s\u00edmbolos s\u00e3o combinados. A equa\u00e7\u00e3o 3 + = 3 n\u00e3o \u00e9 leg\u00edtima porque, embora + e = sejam s\u00edmbolos leg\u00edtimos, n\u00e3o se pode ter um na sequ\u00eancia do outro. De forma similar, em uma f\u00f3rmula qu\u00edmica o subscrito vem depois do nome de elemento, n\u00e3o antes. Esta \u00e9 um@ frase bem estruturada em portugu\u00ea$, mas com s*mbolos inv\u00e1lidos. Esta frase todos os s\u00edmbolos v\u00e1lidos tem, mas estrutura v\u00e1lida sem. Ao ler uma frase em portugu\u00eas ou uma declara\u00e7\u00e3o em uma linguagem formal, \u00e9 preciso compreender a estrutura (embora em uma linguagem natural voc\u00ea fa\u00e7a isto de forma subconsciente). Este processo \u00e9 chamado de an\u00e1lise. Embora as linguagens formais e naturais tenham muitas caracter\u00edsticas em comum \u2013 s\u00edmbolos, estrutura e sintaxe \u2013 h\u00e1 algumas diferen\u00e7as: ambiguidade As linguagens naturais s\u00e3o cheias de ambiguidade e as pessoas lidam com isso usando pistas contextuais e outras informa\u00e7\u00f5es. As linguagens formais s\u00e3o criadas para ser quase ou completamente inequ\u00edvocas, ou seja, qualquer afirma\u00e7\u00e3o tem exatamente um significado, independentemente do contexto. redund\u00e2ncia Para compensar a ambiguidade e reduzir equ\u00edvocos, as linguagens naturais usam muita redund\u00e2ncia. Por causa disso, muitas vezes s\u00e3o verborr\u00e1gicas. As linguagens formais s\u00e3o menos redundantes e mais concisas. literalidade As linguagens naturais s\u00e3o cheias de express\u00f5es e met\u00e1foras. Se eu digo \u201cCaiu a ficha\u201d, provavelmente n\u00e3o h\u00e1 ficha nenhuma na hist\u00f3ria, nem nada que tenha ca\u00eddo (esta \u00e9 uma express\u00e3o para dizer que algu\u00e9m entendeu algo depois de certo per\u00edodo de confus\u00e3o). As linguagens formais t\u00eam significados exatamente iguais ao que expressam. Como todos n\u00f3s crescemos falando linguagens naturais, \u00e0s vezes \u00e9 dif\u00edcil se ajustar a linguagens formais. A diferen\u00e7a entre a linguagem natural e a formal \u00e9 semelhante \u00e0 diferen\u00e7a entre poesia e prosa, mas vai al\u00e9m: Poesia As palavras s\u00e3o usadas tanto pelos sons como pelos significados, e o poema inteiro cria um efeito ou resposta emocional. A ambiguidade n\u00e3o \u00e9 apenas comum, mas muitas vezes proposital. Prosa O significado literal das palavras \u00e9 o mais importante e a estrutura contribui para este significado. A prosa \u00e9 mais acess\u00edvel \u00e0 an\u00e1lise que a poesia, mas muitas vezes ainda \u00e9 amb\u00edgua. Programas A significado de um programa de computador \u00e9 inequ\u00edvoco e literal e pode ser entendido inteiramente pela an\u00e1lise dos s\u00edmbolos e da estrutura. As linguagens formais s\u00e3o mais densas que as naturais, ent\u00e3o exigem mais tempo para a leitura. Al\u00e9m disso, a estrutura \u00e9 importante, ent\u00e3o nem sempre \u00e9 melhor ler de cima para baixo e da esquerda para a direita. Em vez disso, aprenda a analisar o programa primeiro, identificando os s\u00edmbolos e interpretando a estrutura. E os detalhes fazem diferen\u00e7a. Pequenos erros em ortografia e pontua\u00e7\u00e3o, que podem n\u00e3o importar tanto nas linguagens naturais, podem fazer uma grande diferen\u00e7a em uma l\u00edngua formal. 1.7 - Depura\u00e7\u00e3o Os programadores erram. Por um capricho do destino, erros de programa\u00e7\u00e3o s\u00e3o chamados de bugs (insetos) e o processo de rastre\u00e1-los chama-se depura\u00e7\u00e3o (debugging). Programar, e especialmente fazer a depura\u00e7\u00e3o, \u00e0s vezes traz emo\u00e7\u00f5es fortes. Se tiver dificuldade com certo bug, voc\u00ea pode ficar zangado, desesperado ou constrangido. H\u00e1 evid\u00eancias de que as pessoas respondem naturalmente a computadores como se fossem pessoas. Quando funcionam bem, pensamos neles como parceiros da equipe, e quando s\u00e3o teimosos ou grosseiros, respondemos a eles do mesmo jeito que fazemos com pessoas grosseiras e teimosas (Reeves e Nass, The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places \u2014 A equa\u00e7\u00e3o da m\u00eddia: como as pessoas tratam os computadores, a televis\u00e3o e as novas m\u00eddias como se fossem pessoas e lugares reais ). Prepare-se para essas rea\u00e7\u00f5es, pois isso pode ajudar a lidar com elas. Uma abordagem \u00e9 pensar no computador como um funcion\u00e1rio com certas vantagens, como velocidade e precis\u00e3o, e certas desvantagens, como a falta de empatia e a incapacidade de compreender um contexto mais amplo. Seu trabalho \u00e9 ser um bom gerente: encontrar formas de aproveitar as vantagens e atenuar as desvantagens. E tamb\u00e9m encontrar formas de usar suas emo\u00e7\u00f5es para lidar com o problema sem deixar suas rea\u00e7\u00f5es interferirem na sua capacidade de trabalho. Aprender a depurar erros pode ser frustrante, mas \u00e9 uma habilidade valiosa, \u00fatil para muitas atividades al\u00e9m da programa\u00e7\u00e3o. No fim de cada cap\u00edtulo h\u00e1 uma se\u00e7\u00e3o como esta, com as minhas sugest\u00f5es para fazer a depura\u00e7\u00e3o. Espero que sejam \u00fateis! 1.8 - Gloss\u00e1rio resolu\u00e7\u00e3o de problemas O processo de formular um problema, encontrar uma solu\u00e7\u00e3o e express\u00e1-la. linguagem de alto n\u00edvel Uma linguagem de programa\u00e7\u00e3o como Python, que foi criada com o intuito de ser f\u00e1cil para os humanos escreverem e lerem. linguagem de baixo n\u00edvel Uma linguagem de programa\u00e7\u00e3o criada para o computador executar com facilidade; tamb\u00e9m chamada de \u201clinguagem de m\u00e1quina\u201d ou \u201clinguagem assembly\u201d. portabilidade A propriedade de um programa de poder ser executado em mais de um tipo de computador. interpretador Um programa que l\u00ea outro programa e o executa. prompt Caracteres expostos pelo interpretador para indicar que est\u00e1 pronto para receber entradas do usu\u00e1rio. programa Conjunto de instru\u00e7\u00f5es que especificam uma opera\u00e7\u00e3o de computa\u00e7\u00e3o. instru\u00e7\u00e3o print Uma instru\u00e7\u00e3o que faz o interpretador do Python exibir um valor na tela. operador Um s\u00edmbolo especial que representa uma opera\u00e7\u00e3o de computa\u00e7\u00e3o simples como adi\u00e7\u00e3o, multiplica\u00e7\u00e3o ou concatena\u00e7\u00e3o de strings. valor Uma das unidades b\u00e1sicas de dados, como um n\u00famero ou string, que um programa manipula. tipo Uma categoria de valores. Os tipos que vimos por enquanto s\u00e3o n\u00fameros inteiros (tipo int), n\u00fameros de ponto flutuante (tipo float) e strings (tipo str). inteiro Um tipo que representa n\u00fameros inteiros. ponto flutuante Um tipo que representa n\u00fameros com partes fracion\u00e1rias. string Um tipo que representa sequ\u00eancias de caracteres. linguagem natural Qualquer linguagem que as pessoas falam e que se desenvolveu naturalmente. linguagem formal Qualquer linguagem que as pessoas criaram com objetivos espec\u00edficos, como representar ideias matem\u00e1ticas ou programas de computador; todas as linguagens de programa\u00e7\u00e3o s\u00e3o linguagens formais. s\u00edmbolo Um dos elementos b\u00e1sicos da estrutura sint\u00e1tica de um programa, an\u00e1logo a uma palavra em linguagem natural. sintaxe As regras que governam a estrutura de um programa. an\u00e1lise Examinar um programa e sua estrutura sint\u00e1tica. bug Um erro em um programa. depura\u00e7\u00e3o O processo de encontrar e corrigir (depurar) bugs. 1.9 - Exerc\u00edcios Exerc\u00edcio 1.1 \u00c9 uma boa ideia ler este livro em frente a um computador para testar os exemplos durante a leitura. Sempre que estiver testando um novo recurso, voc\u00ea deve tentar fazer erros. Por exemplo, no programa \u201cHello, World!\u201d, o que acontece se omitir uma das aspas? E se omitir ambas? E se voc\u00ea soletrar a instru\u00e7\u00e3o print de forma errada? Este tipo de experimento ajuda a lembrar o que foi lido; tamb\u00e9m ajuda quando voc\u00ea estiver programando, porque assim conhecer\u00e1 o significado das mensagens de erro. \u00c9 melhor fazer erros agora e de prop\u00f3sito que depois e acidentalmente. Em uma instru\u00e7\u00e3o print, o que acontece se voc\u00ea omitir um dos par\u00eanteses ou ambos? Se estiver tentando imprimir uma string, o que acontece se omitir uma das aspas ou ambas? Voc\u00ea pode usar um sinal de menos para fazer um n\u00famero negativo como -2. O que acontece se puser um sinal de mais antes de um n\u00famero? E se escrever assim: 2++2? Na nota\u00e7\u00e3o matem\u00e1tica, zeros \u00e0 esquerda s\u00e3o aceit\u00e1veis, como em 02. O que acontece se voc\u00ea tentar usar isso no Python? O que acontece se voc\u00ea tiver dois valores sem nenhum operador entre eles? Exerc\u00edcio 1.2 Inicialize o interpretador do Python e use-o como uma calculadora. Quantos segundos h\u00e1 em 42 minutos e 42 segundos? Quantas milhas h\u00e1 em 10 quil\u00f4metros? Dica: uma milha equivale a 1,61 quil\u00f4metro. Se voc\u00ea correr 10 quil\u00f4metros em 42 minutos e 42 segundos, qual \u00e9 o seu passo m\u00e9dio (tempo por milha em minutos e segundos)? Qual \u00e9 a sua velocidade m\u00e9dia em milhas por hora?","title":"Cap\u00edtulo 1: A jornada do programa"},{"location":"01-jornada/#capitulo-1-a-jornada-do-programa","text":"O objetivo deste livro \u00e9 ensinar a pensar como um cientista da computa\u00e7\u00e3o. Esta forma de pensar combina algumas das melhores caracter\u00edsticas da matem\u00e1tica, da engenharia e das ci\u00eancias naturais. Assim como os matem\u00e1ticos, os cientistas da computa\u00e7\u00e3o usam linguagens formais para denotar ideias (especificamente opera\u00e7\u00f5es de computa\u00e7\u00e3o). Como engenheiros, eles projetam coisas, reunindo componentes em sistemas e avaliando as op\u00e7\u00f5es de melhor retorno entre as alternativas \u00e0 disposi\u00e7\u00e3o. Como cientistas, observam o comportamento de sistemas complexos, formam hip\u00f3teses e testam previs\u00f5es. A habilidade espec\u00edfica mais importante de um cientista da computa\u00e7\u00e3o \u00e9 a resolu\u00e7\u00e3o de problemas . Resolu\u00e7\u00e3o de problemas significa a capacidade de formular problemas, pensar criativamente em solu\u00e7\u00f5es e expressar uma solu\u00e7\u00e3o de forma clara e precisa. Assim, o processo de aprender a programar \u00e9 uma oportunidade excelente para exercitar a habilidade de resolver problemas. \u00c9 por isso que este cap\u00edtulo se chama \u201cA jornada do programa\u201d. Em um n\u00edvel voc\u00ea aprender\u00e1 a programar, uma habilidade \u00fatil por si mesma. Em outro n\u00edvel usar\u00e1 a programa\u00e7\u00e3o como um meio para um fim. Conforme avan\u00e7armos, este fim ficar\u00e1 mais claro.","title":"Cap\u00edtulo 1: A jornada do programa"},{"location":"01-jornada/#11-o-que-e-um-programa","text":"Um programa \u00e9 uma sequ\u00eancia de instru\u00e7\u00f5es que especifica como executar uma opera\u00e7\u00e3o de computa\u00e7\u00e3o. A opera\u00e7\u00e3o de computa\u00e7\u00e3o pode ser algo matem\u00e1tico, como solucionar um sistema de equa\u00e7\u00f5es ou encontrar as ra\u00edzes de um polin\u00f4mio, mas tamb\u00e9m pode ser uma opera\u00e7\u00e3o de computa\u00e7\u00e3o simb\u00f3lica, como a busca e a substitui\u00e7\u00e3o de textos em um documento; ou algo gr\u00e1fico, como o processamento de uma imagem ou a reprodu\u00e7\u00e3o de um v\u00eddeo. Os detalhes parecem diferentes em linguagens diferentes, mas algumas instru\u00e7\u00f5es b\u00e1sicas aparecem em quase todas as linguagens: entrada Receber dados do teclado, de um arquivo, da rede ou de algum outro dispositivo. sa\u00edda Exibir dados na tela, salv\u00e1-los em um arquivo, envi\u00e1-los pela rede etc. matem\u00e1tica Executar opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas como adi\u00e7\u00e3o e multiplica\u00e7\u00e3o. execu\u00e7\u00e3o condicional Verificar a exist\u00eancia de certas condi\u00e7\u00f5es e executar o c\u00f3digo adequado. repeti\u00e7\u00e3o Executar v\u00e1rias vezes alguma a\u00e7\u00e3o, normalmente com algumas varia\u00e7\u00f5es. Acredite ou n\u00e3o, isto \u00e9 basicamente tudo o que \u00e9 preciso saber. Cada programa que voc\u00ea j\u00e1 usou, complicado ou n\u00e3o, \u00e9 composto de instru\u00e7\u00f5es muito parecidas com essas. Podemos ent\u00e3o chegar \u00e0 conclus\u00e3o de que programar \u00e9 o processo de quebrar uma tarefa grande e complexa em subtarefas cada vez menores, at\u00e9 que estas sejam simples o suficiente para serem executadas por uma dessas instru\u00e7\u00f5es b\u00e1sicas.","title":"1.1 - O que \u00e9 um programa?"},{"location":"01-jornada/#12-execucao-do-python","text":"Um dos desafios de come\u00e7ar a usar Python \u00e9 ter que instalar no seu computador o pr\u00f3prio programa e outros relacionados. Se tiver familiaridade com o seu sistema operacional, e especialmente se n\u00e3o tiver problemas com a interface de linha de comando, voc\u00ea n\u00e3o ter\u00e1 dificuldade para instalar o Python. Mas para principiantes pode ser trabalhoso aprender sobre administra\u00e7\u00e3o de sistemas e programa\u00e7\u00e3o ao mesmo tempo. Para evitar esse problema, recomendo que comece a executar o Python em um navegador. Depois, quando voc\u00ea j\u00e1 conhecer o Python um pouco mais, darei sugest\u00f5es para instal\u00e1-lo em seu computador. H\u00e1 uma s\u00e9rie de sites que ajudam a usar e executar o Python. Se j\u00e1 tem um favorito, v\u00e1 em frente e use-o. Sen\u00e3o, recomendo o PythonAnywhere. Apresento instru\u00e7\u00f5es detalhadas sobre os primeiros passos no link http://tinyurl.com/thinkpython2e. H\u00e1 duas vers\u00f5es do Python, o Python 2 e o Python 3. Como elas s\u00e3o muito semelhantes, se voc\u00ea aprender uma vers\u00e3o, \u00e9 f\u00e1cil trocar para a outra. Como \u00e9 iniciante, voc\u00ea encontrar\u00e1 poucas diferen\u00e7as. Este livro foi escrito para o Python 3, mas tamb\u00e9m inclu\u00ed algumas notas sobre o Python 2. O interpretador do Python \u00e9 um programa que l\u00ea e executa o c\u00f3digo Python. Dependendo do seu ambiente, \u00e9 poss\u00edvel iniciar o interpretador clicando em um \u00edcone, ou digitando python em uma linha de comando. Quando ele iniciar, voc\u00ea dever\u00e1 ver uma sa\u00edda como esta: Python 3.4.0 (default, Jun 19 2015, 14:20:21) [GCC 4.8.2] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> As tr\u00eas primeiras linhas cont\u00eam informa\u00e7\u00f5es sobre o interpretador e o sistema operacional em que est\u00e1 sendo executado, portanto podem ser diferentes para voc\u00ea. Mas \u00e9 preciso conferir se o n\u00famero da vers\u00e3o, que \u00e9 3.4.0 neste exemplo, come\u00e7a com 3, o que indica que voc\u00ea est\u00e1 executando o Python 3. Se come\u00e7ar com 2, voc\u00ea est\u00e1 executando (adivinhe!) o Python 2. A \u00faltima linha \u00e9 um prompt indicando que o interpretador est\u00e1 pronto para voc\u00ea digitar o c\u00f3digo. Se digitar uma linha de c\u00f3digo e pressionar Enter, o interpretador exibe o resultado: >>> 1 + 1 2 Agora voc\u00ea est\u00e1 pronto para come\u00e7ar. Daqui em diante, vou supor que voc\u00ea sabe como inicializar o interpretador do Python e executar o c\u00f3digo.","title":"1.2 - Execu\u00e7\u00e3o do Python"},{"location":"01-jornada/#13-o-primeiro-programa","text":"Tradicionalmente, o primeiro programa que se escreve em uma nova linguagem chama-se \u201cHello, World!\u201d, porque tudo o que faz \u00e9 exibir as palavras \u201cHello, World!\u201d na tela. No Python, ele se parece com isto: >>> print('Hello, World!') Este \u00e9 um exemplo de uma instru\u00e7\u00e3o print (instru\u00e7\u00e3o de impress\u00e3o), embora na realidade ela n\u00e3o imprima nada em papel. Ela exibe um resultado na tela. Nesse caso, o resultado s\u00e3o as palavras: Hello, World! As aspas apenas marcam o come\u00e7o e o fim do texto a ser exibido; elas n\u00e3o aparecem no resultado. Os par\u00eanteses indicam que o print \u00e9 uma fun\u00e7\u00e3o. Veremos fun\u00e7\u00f5es no Cap\u00edtulo 3. No Python 2, a instru\u00e7\u00e3o print \u00e9 ligeiramente diferente; ela n\u00e3o \u00e9 uma fun\u00e7\u00e3o, portanto n\u00e3o usa par\u00eanteses. >>> print 'Hello, World!' Esta distin\u00e7\u00e3o far\u00e1 mais sentido em breve, mas isso \u00e9 o suficiente para come\u00e7ar.","title":"1.3 - O primeiro programa"},{"location":"01-jornada/#14-operadores-aritmeticos","text":"Depois do \u201cHello, World\u201d, o pr\u00f3ximo passo \u00e9 a aritm\u00e9tica. O Python tem operadores, que s\u00e3o s\u00edmbolos especiais representando opera\u00e7\u00f5es de computa\u00e7\u00e3o, como adi\u00e7\u00e3o e multiplica\u00e7\u00e3o. Os operadores +, - e * executam a adi\u00e7\u00e3o, a subtra\u00e7\u00e3o e a multiplica\u00e7\u00e3o, como nos seguintes exemplos: >>> 40 + 2 42 >>> 43 - 1 42 >>> 6 * 7 42 O operador / executa a divis\u00e3o: >>> 84 / 2 42.0 Pode ser que voc\u00ea fique intrigado pelo resultado ser 42.0 em vez de 42. Vou explicar isso na pr\u00f3xima se\u00e7\u00e3o. Finalmente, o operador ** executa a exponencia\u00e7\u00e3o; isto \u00e9, eleva um n\u00famero a uma pot\u00eancia: >>> 6 ** 2 + 6 42 Em algumas outras linguagens, o ^ \u00e9 usado para a exponencia\u00e7\u00e3o, mas no Python \u00e9 um operador bitwise, chamado XOR. Se n\u00e3o tiver familiaridade com operadores bitwise, o resultado o surpreender\u00e1: >>> 6 ^ 2 4 N\u00e3o abordarei operadores bitwise neste livro, mas voc\u00ea pode ler sobre eles em http://wiki.python.org/moin/BitwiseOperators.","title":"1.4 - Operadores aritm\u00e9ticos"},{"location":"01-jornada/#15-valores-e-tipos","text":"Um valor \u00e9 uma das coisas b\u00e1sicas com as quais um programa trabalha, como uma letra ou um n\u00famero. Alguns valores que vimos at\u00e9 agora foram 2, 42.0 e 'Hello, World!'. Esses valores pertencem a tipos diferentes: 2 \u00e9 um n\u00famero inteiro, 42.0 \u00e9 um n\u00famero de ponto flutuante e 'Hello, World!' \u00e9 uma string, assim chamada porque as letras que cont\u00e9m est\u00e3o em uma sequ\u00eancia em cadeia. Se n\u00e3o tiver certeza sobre qual \u00e9 o tipo de certo valor, o interpretador pode dizer isso a voc\u00ea: >>> type(2) <class 'int'> >>> type(42.0) <class 'float'> >>> type('Hello, World!') <class 'str'> Nesses resultados, a palavra \u201cclass\u201d [classe] \u00e9 usada no sentido de categoria; um tipo \u00e9 uma categoria de valores. Como se poderia esperar, n\u00fameros inteiros pertencem ao tipo int, strings pertencem ao tipo str e os n\u00fameros de ponto flutuante pertencem ao tipo float. E valores como '2' e '42.0'? Parecem n\u00fameros, mas est\u00e3o entre aspas como se fossem strings: >>> type('2') <class 'str'> >>> type('42.0') <class 'str'> Ent\u00e3o s\u00e3o strings. Ao digitar um n\u00famero inteiro grande, alguns podem usar a nota\u00e7\u00e3o americana, com v\u00edrgulas entre grupos de d\u00edgitos, como em 1,000,000. Este n\u00e3o \u00e9 um n\u00famero inteiro leg\u00edtimo no Python e resultar\u00e1 em: >>> 1,000,000 (1, 0, 0) O que n\u00e3o \u00e9 de modo algum o que esper\u00e1vamos! O Python interpreta 1,000,000 como uma sequ\u00eancia de n\u00fameros inteiros separados por v\u00edrgulas. Aprenderemos mais sobre este tipo de sequ\u00eancia mais adiante.","title":"1.5 - Valores e tipos"},{"location":"01-jornada/#16-linguagens-formais-e-naturais","text":"As linguagens naturais s\u00e3o os idiomas que as pessoas falam, como ingl\u00eas, espanhol e franc\u00eas. Elas n\u00e3o foram criadas pelas pessoas (embora as pessoas tentem impor certa ordem a elas); desenvolveram-se naturalmente. As linguagens formais s\u00e3o linguagens criadas pelas pessoas para aplica\u00e7\u00f5es espec\u00edficas. Por exemplo, a nota\u00e7\u00e3o que os matem\u00e1ticos usam \u00e9 uma linguagem formal especialmente boa para denotar rela\u00e7\u00f5es entre n\u00fameros e s\u00edmbolos. Os qu\u00edmicos usam uma linguagem formal para representar a estrutura qu\u00edmica de mol\u00e9culas. E o mais importante: As linguagens de programa\u00e7\u00e3o s\u00e3o idiomas formais criados para expressar opera\u00e7\u00f5es de computa\u00e7\u00e3o. As linguagens formais geralmente t\u00eam regras de sintaxe estritas que governam a estrutura de declara\u00e7\u00f5es. Por exemplo, na matem\u00e1tica a declara\u00e7\u00e3o 3 + 3 = 6 tem uma sintaxe correta, mas n\u00e3o 3 + = 3$6. Na qu\u00edmica, H2O \u00e9 uma f\u00f3rmula sintaticamente correta, mas 2Zz n\u00e3o \u00e9. As regras de sintaxe v\u00eam em duas categorias relativas a s\u00edmbolos e estrutura. Os s\u00edmbolos s\u00e3o os elementos b\u00e1sicos da linguagem, como palavras, n\u00fameros e elementos qu\u00edmicos. Um dos problemas com 3 + = 3$6 \u00e9 que o $ n\u00e3o \u00e9 um s\u00edmbolo leg\u00edtimo na matem\u00e1tica (pelo menos at\u00e9 onde eu sei). De forma similar, 2Zz n\u00e3o \u00e9 leg\u00edtimo porque n\u00e3o h\u00e1 nenhum elemento com a abreviatura Zz. O segundo tipo de regra de sintaxe refere-se ao modo no qual os s\u00edmbolos s\u00e3o combinados. A equa\u00e7\u00e3o 3 + = 3 n\u00e3o \u00e9 leg\u00edtima porque, embora + e = sejam s\u00edmbolos leg\u00edtimos, n\u00e3o se pode ter um na sequ\u00eancia do outro. De forma similar, em uma f\u00f3rmula qu\u00edmica o subscrito vem depois do nome de elemento, n\u00e3o antes. Esta \u00e9 um@ frase bem estruturada em portugu\u00ea$, mas com s*mbolos inv\u00e1lidos. Esta frase todos os s\u00edmbolos v\u00e1lidos tem, mas estrutura v\u00e1lida sem. Ao ler uma frase em portugu\u00eas ou uma declara\u00e7\u00e3o em uma linguagem formal, \u00e9 preciso compreender a estrutura (embora em uma linguagem natural voc\u00ea fa\u00e7a isto de forma subconsciente). Este processo \u00e9 chamado de an\u00e1lise. Embora as linguagens formais e naturais tenham muitas caracter\u00edsticas em comum \u2013 s\u00edmbolos, estrutura e sintaxe \u2013 h\u00e1 algumas diferen\u00e7as: ambiguidade As linguagens naturais s\u00e3o cheias de ambiguidade e as pessoas lidam com isso usando pistas contextuais e outras informa\u00e7\u00f5es. As linguagens formais s\u00e3o criadas para ser quase ou completamente inequ\u00edvocas, ou seja, qualquer afirma\u00e7\u00e3o tem exatamente um significado, independentemente do contexto. redund\u00e2ncia Para compensar a ambiguidade e reduzir equ\u00edvocos, as linguagens naturais usam muita redund\u00e2ncia. Por causa disso, muitas vezes s\u00e3o verborr\u00e1gicas. As linguagens formais s\u00e3o menos redundantes e mais concisas. literalidade As linguagens naturais s\u00e3o cheias de express\u00f5es e met\u00e1foras. Se eu digo \u201cCaiu a ficha\u201d, provavelmente n\u00e3o h\u00e1 ficha nenhuma na hist\u00f3ria, nem nada que tenha ca\u00eddo (esta \u00e9 uma express\u00e3o para dizer que algu\u00e9m entendeu algo depois de certo per\u00edodo de confus\u00e3o). As linguagens formais t\u00eam significados exatamente iguais ao que expressam. Como todos n\u00f3s crescemos falando linguagens naturais, \u00e0s vezes \u00e9 dif\u00edcil se ajustar a linguagens formais. A diferen\u00e7a entre a linguagem natural e a formal \u00e9 semelhante \u00e0 diferen\u00e7a entre poesia e prosa, mas vai al\u00e9m: Poesia As palavras s\u00e3o usadas tanto pelos sons como pelos significados, e o poema inteiro cria um efeito ou resposta emocional. A ambiguidade n\u00e3o \u00e9 apenas comum, mas muitas vezes proposital. Prosa O significado literal das palavras \u00e9 o mais importante e a estrutura contribui para este significado. A prosa \u00e9 mais acess\u00edvel \u00e0 an\u00e1lise que a poesia, mas muitas vezes ainda \u00e9 amb\u00edgua. Programas A significado de um programa de computador \u00e9 inequ\u00edvoco e literal e pode ser entendido inteiramente pela an\u00e1lise dos s\u00edmbolos e da estrutura. As linguagens formais s\u00e3o mais densas que as naturais, ent\u00e3o exigem mais tempo para a leitura. Al\u00e9m disso, a estrutura \u00e9 importante, ent\u00e3o nem sempre \u00e9 melhor ler de cima para baixo e da esquerda para a direita. Em vez disso, aprenda a analisar o programa primeiro, identificando os s\u00edmbolos e interpretando a estrutura. E os detalhes fazem diferen\u00e7a. Pequenos erros em ortografia e pontua\u00e7\u00e3o, que podem n\u00e3o importar tanto nas linguagens naturais, podem fazer uma grande diferen\u00e7a em uma l\u00edngua formal.","title":"1.6 - Linguagens formais e naturais"},{"location":"01-jornada/#17-depuracao","text":"Os programadores erram. Por um capricho do destino, erros de programa\u00e7\u00e3o s\u00e3o chamados de bugs (insetos) e o processo de rastre\u00e1-los chama-se depura\u00e7\u00e3o (debugging). Programar, e especialmente fazer a depura\u00e7\u00e3o, \u00e0s vezes traz emo\u00e7\u00f5es fortes. Se tiver dificuldade com certo bug, voc\u00ea pode ficar zangado, desesperado ou constrangido. H\u00e1 evid\u00eancias de que as pessoas respondem naturalmente a computadores como se fossem pessoas. Quando funcionam bem, pensamos neles como parceiros da equipe, e quando s\u00e3o teimosos ou grosseiros, respondemos a eles do mesmo jeito que fazemos com pessoas grosseiras e teimosas (Reeves e Nass, The Media Equation: How People Treat Computers, Television, and New Media Like Real People and Places \u2014 A equa\u00e7\u00e3o da m\u00eddia: como as pessoas tratam os computadores, a televis\u00e3o e as novas m\u00eddias como se fossem pessoas e lugares reais ). Prepare-se para essas rea\u00e7\u00f5es, pois isso pode ajudar a lidar com elas. Uma abordagem \u00e9 pensar no computador como um funcion\u00e1rio com certas vantagens, como velocidade e precis\u00e3o, e certas desvantagens, como a falta de empatia e a incapacidade de compreender um contexto mais amplo. Seu trabalho \u00e9 ser um bom gerente: encontrar formas de aproveitar as vantagens e atenuar as desvantagens. E tamb\u00e9m encontrar formas de usar suas emo\u00e7\u00f5es para lidar com o problema sem deixar suas rea\u00e7\u00f5es interferirem na sua capacidade de trabalho. Aprender a depurar erros pode ser frustrante, mas \u00e9 uma habilidade valiosa, \u00fatil para muitas atividades al\u00e9m da programa\u00e7\u00e3o. No fim de cada cap\u00edtulo h\u00e1 uma se\u00e7\u00e3o como esta, com as minhas sugest\u00f5es para fazer a depura\u00e7\u00e3o. Espero que sejam \u00fateis!","title":"1.7 - Depura\u00e7\u00e3o"},{"location":"01-jornada/#18-glossario","text":"resolu\u00e7\u00e3o de problemas O processo de formular um problema, encontrar uma solu\u00e7\u00e3o e express\u00e1-la. linguagem de alto n\u00edvel Uma linguagem de programa\u00e7\u00e3o como Python, que foi criada com o intuito de ser f\u00e1cil para os humanos escreverem e lerem. linguagem de baixo n\u00edvel Uma linguagem de programa\u00e7\u00e3o criada para o computador executar com facilidade; tamb\u00e9m chamada de \u201clinguagem de m\u00e1quina\u201d ou \u201clinguagem assembly\u201d. portabilidade A propriedade de um programa de poder ser executado em mais de um tipo de computador. interpretador Um programa que l\u00ea outro programa e o executa. prompt Caracteres expostos pelo interpretador para indicar que est\u00e1 pronto para receber entradas do usu\u00e1rio. programa Conjunto de instru\u00e7\u00f5es que especificam uma opera\u00e7\u00e3o de computa\u00e7\u00e3o. instru\u00e7\u00e3o print Uma instru\u00e7\u00e3o que faz o interpretador do Python exibir um valor na tela. operador Um s\u00edmbolo especial que representa uma opera\u00e7\u00e3o de computa\u00e7\u00e3o simples como adi\u00e7\u00e3o, multiplica\u00e7\u00e3o ou concatena\u00e7\u00e3o de strings. valor Uma das unidades b\u00e1sicas de dados, como um n\u00famero ou string, que um programa manipula. tipo Uma categoria de valores. Os tipos que vimos por enquanto s\u00e3o n\u00fameros inteiros (tipo int), n\u00fameros de ponto flutuante (tipo float) e strings (tipo str). inteiro Um tipo que representa n\u00fameros inteiros. ponto flutuante Um tipo que representa n\u00fameros com partes fracion\u00e1rias. string Um tipo que representa sequ\u00eancias de caracteres. linguagem natural Qualquer linguagem que as pessoas falam e que se desenvolveu naturalmente. linguagem formal Qualquer linguagem que as pessoas criaram com objetivos espec\u00edficos, como representar ideias matem\u00e1ticas ou programas de computador; todas as linguagens de programa\u00e7\u00e3o s\u00e3o linguagens formais. s\u00edmbolo Um dos elementos b\u00e1sicos da estrutura sint\u00e1tica de um programa, an\u00e1logo a uma palavra em linguagem natural. sintaxe As regras que governam a estrutura de um programa. an\u00e1lise Examinar um programa e sua estrutura sint\u00e1tica. bug Um erro em um programa. depura\u00e7\u00e3o O processo de encontrar e corrigir (depurar) bugs.","title":"1.8 - Gloss\u00e1rio"},{"location":"01-jornada/#19-exercicios","text":"","title":"1.9 - Exerc\u00edcios"},{"location":"01-jornada/#exercicio-11","text":"\u00c9 uma boa ideia ler este livro em frente a um computador para testar os exemplos durante a leitura. Sempre que estiver testando um novo recurso, voc\u00ea deve tentar fazer erros. Por exemplo, no programa \u201cHello, World!\u201d, o que acontece se omitir uma das aspas? E se omitir ambas? E se voc\u00ea soletrar a instru\u00e7\u00e3o print de forma errada? Este tipo de experimento ajuda a lembrar o que foi lido; tamb\u00e9m ajuda quando voc\u00ea estiver programando, porque assim conhecer\u00e1 o significado das mensagens de erro. \u00c9 melhor fazer erros agora e de prop\u00f3sito que depois e acidentalmente. Em uma instru\u00e7\u00e3o print, o que acontece se voc\u00ea omitir um dos par\u00eanteses ou ambos? Se estiver tentando imprimir uma string, o que acontece se omitir uma das aspas ou ambas? Voc\u00ea pode usar um sinal de menos para fazer um n\u00famero negativo como -2. O que acontece se puser um sinal de mais antes de um n\u00famero? E se escrever assim: 2++2? Na nota\u00e7\u00e3o matem\u00e1tica, zeros \u00e0 esquerda s\u00e3o aceit\u00e1veis, como em 02. O que acontece se voc\u00ea tentar usar isso no Python? O que acontece se voc\u00ea tiver dois valores sem nenhum operador entre eles?","title":"Exerc\u00edcio 1.1"},{"location":"01-jornada/#exercicio-12","text":"Inicialize o interpretador do Python e use-o como uma calculadora. Quantos segundos h\u00e1 em 42 minutos e 42 segundos? Quantas milhas h\u00e1 em 10 quil\u00f4metros? Dica: uma milha equivale a 1,61 quil\u00f4metro. Se voc\u00ea correr 10 quil\u00f4metros em 42 minutos e 42 segundos, qual \u00e9 o seu passo m\u00e9dio (tempo por milha em minutos e segundos)? Qual \u00e9 a sua velocidade m\u00e9dia em milhas por hora?","title":"Exerc\u00edcio 1.2"},{"location":"02-vars-expr-instr/","text":"Cap\u00edtulo 2: Vari\u00e1veis, express\u00f5es e instru\u00e7\u00f5es Um dos recursos mais eficientes de uma linguagem de programa\u00e7\u00e3o \u00e9 a capacidade de manipular vari\u00e1veis. Uma vari\u00e1vel \u00e9 um nome que se refere a um valor. 2.1 - Instru\u00e7\u00f5es de atribui\u00e7\u00e3o Uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o cria uma nova vari\u00e1vel e d\u00e1 um valor a ela: >>> message = 'And now for something completely different' >>> n = 17 >>> pi = 3.141592653589793 Esse exemplo faz tr\u00eas atribui\u00e7\u00f5es. A primeira atribui uma string a uma nova vari\u00e1vel chamada message; a segunda d\u00e1 o n\u00famero inteiro 17 a n; a terceira atribui o valor (aproximado) de \u03c0 a pi. Uma forma comum de representar vari\u00e1veis por escrito \u00e9 colocar o nome com uma flecha apontando para o seu valor. Este tipo de n\u00famero \u00e9 chamado de diagrama de estado porque mostra o estado no qual cada uma das vari\u00e1veis est\u00e1 (pense nele como o estado de esp\u00edrito da vari\u00e1vel). A Figura 2.1 mostra o resultado do exemplo anterior. Figura 2.1 \u2013 Diagrama de estado. 2.2 - Nomes de vari\u00e1veis Os programadores geralmente escolhem nomes significativos para as suas vari\u00e1veis \u2013 eles documentam o uso da vari\u00e1vel. Nomes de vari\u00e1veis podem ser t\u00e3o longos quanto voc\u00ea queira. Podem conter tanto letras como n\u00fameros, mas n\u00e3o podem come\u00e7ar com um n\u00famero. \u00c9 legal usar letras mai\u00fasculas, mas a conven\u00e7\u00e3o \u00e9 usar apenas letras min\u00fasculas para nomes de vari\u00e1veis. O caractere de sublinhar (_) pode aparecer em um nome. Muitas vezes \u00e9 usado em nomes com v\u00e1rias palavras, como your_name ou airspeed_of_unladen_swallow. Se voc\u00ea der um nome ilegal a uma vari\u00e1vel, recebe um erro de sintaxe: >>> 76trombones = 'big parade' SyntaxError: invalid syntax >>> more@ = 1000000 SyntaxError: invalid syntax >>> class = 'Advanced Theoretical Zymurgy' SyntaxError: invalid syntax 76trombones \u00e9 ilegal porque come\u00e7a com um n\u00famero. more@ \u00e9 ilegal porque cont\u00e9m um caractere ilegal, o @ . Mas o que h\u00e1 de errado com class ? A quest\u00e3o \u00e9 que class \u00e9 uma das palavras-chave do Python. O interpretador usa palavras-chave para reconhecer a estrutura do programa e elas n\u00e3o podem ser usadas como nomes de vari\u00e1vel. O Python 3 tem estas palavras-chave: and del from None True as elif global nonlocal try assert else if not while break except import or with class False in pass yield continue finally is raise def for lambda return Voc\u00ea n\u00e3o precisa memorizar essa lista. Na maior parte dos ambientes de desenvolvimento, as palavras-chave s\u00e3o exibidas em uma cor diferente; se voc\u00ea tentar usar uma como nome de vari\u00e1vel, vai perceber. 2.3 - Express\u00f5es e instru\u00e7\u00f5es Uma express\u00e3o \u00e9 uma combina\u00e7\u00e3o de valores, vari\u00e1veis e operadores. Um valor por si mesmo \u00e9 considerado uma express\u00e3o, assim como uma vari\u00e1vel, portanto as express\u00f5es seguintes s\u00e3o todas legais: >>> 42 42 >>> n 17 >>> n + 25 42 Quando voc\u00ea digita uma express\u00e3o no prompt, o interpretador a avalia, ou seja, ele encontra o valor da express\u00e3o. Neste exemplo, o n tem o valor 17 e n + 25 tem o valor 42. Uma instru\u00e7\u00e3o \u00e9 uma unidade de c\u00f3digo que tem um efeito, como criar uma vari\u00e1vel ou exibir um valor. >>> n = 17 >>> print(n) A primeira linha \u00e9 uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o que d\u00e1 um valor a n. A segunda linha \u00e9 uma instru\u00e7\u00e3o de exibi\u00e7\u00e3o que exibe o valor de n. Quando voc\u00ea digita uma instru\u00e7\u00e3o, o interpretador a executa, o que significa que ele faz o que a instru\u00e7\u00e3o diz. Em geral, instru\u00e7\u00f5es n\u00e3o t\u00eam valores. 2.4 - Modo script At\u00e9 agora executamos o Python no modo interativo, no qual voc\u00ea interage diretamente com o interpretador. O modo interativo \u00e9 uma boa forma de come\u00e7ar, mas se estiver trabalhando com mais do que algumas linhas do c\u00f3digo, o processo pode ficar desorganizado. A alternativa \u00e9 salvar o c\u00f3digo em um arquivo chamado script e ent\u00e3o executar o interpretador no modo script para execut\u00e1-lo. Por conven\u00e7\u00e3o, os scripts no Python t\u00eam nomes que terminam com .py. Se souber como criar e executar um script no seu computador, voc\u00ea est\u00e1 pronto. Sen\u00e3o, recomendo usar o PythonAnywhere novamente. Inseri instru\u00e7\u00f5es sobre como executar programas no modo script em http://tinyurl.com/thinkpython2e. Como o Python oferece os dois modos, voc\u00ea pode testar peda\u00e7os do c\u00f3digo no modo interativo antes de coloc\u00e1-los em um script. Mas h\u00e1 diferen\u00e7as entre o modo interativo e o modo script que podem confundir as pessoas. Por exemplo, se estiver usando o Python como uma calculadora, voc\u00ea poderia digitar: >>> miles = 26.2 >>> miles * 1.61 42.182 A primeira linha atribui um valor a miles, mas n\u00e3o tem efeito vis\u00edvel. A segunda linha \u00e9 uma express\u00e3o, ent\u00e3o o interpretador a avalia e exibe o resultado. No fim, chega-se ao resultado de que uma maratona tem aproximadamente 42 quil\u00f4metros. Mas se voc\u00ea digitar o mesmo c\u00f3digo em um script e execut\u00e1-lo, n\u00e3o recebe nenhuma sa\u00edda. Uma express\u00e3o, por conta pr\u00f3pria, n\u00e3o tem efeito vis\u00edvel no modo script. O Python, na verdade, avalia a express\u00e3o, mas n\u00e3o exibe o valor a menos que voc\u00ea especifique: miles = 26.2 print(miles * 1.61) Este comportamento pode confundir um pouco no in\u00edcio. Um script normalmente cont\u00e9m uma sequ\u00eancia de instru\u00e7\u00f5es. Se houver mais de uma instru\u00e7\u00e3o, os resultados aparecem um ap\u00f3s o outro, conforme as instru\u00e7\u00f5es sejam executadas. Por exemplo, o script print(1) x = 2 print(x) produz a sa\u00edda 1 2 A instru\u00e7\u00e3o de atribui\u00e7\u00e3o n\u00e3o produz nenhuma sa\u00edda. Para verificar sua compreens\u00e3o, digite as seguintes instru\u00e7\u00f5es no interpretador do Python e veja o que fazem: 5 x = 5 x + 1 Agora ponha as mesmas instru\u00e7\u00f5es em um script e o execute. Qual \u00e9 a sa\u00edda? Altere o script transformando cada express\u00e3o em uma instru\u00e7\u00e3o de exibi\u00e7\u00e3o e ent\u00e3o o execute novamente. 2.5 - Ordem das opera\u00e7\u00f5es Quando uma express\u00e3o cont\u00e9m mais de um operador, a ordem da avalia\u00e7\u00e3o depende da ordem das opera\u00e7\u00f5es. Para operadores matem\u00e1ticos, o Python segue a conven\u00e7\u00e3o matem\u00e1tica. O acr\u00f4nimo PEMDAS pode ser \u00fatil para lembrar das regras: Os Par\u00eanteses t\u00eam a preced\u00eancia mais alta e podem ser usados para for\u00e7ar a avalia\u00e7\u00e3o de uma express\u00e3o na ordem que voc\u00ea quiser. Como as express\u00f5es em par\u00eanteses s\u00e3o avaliadas primeiro, 2 * (3-1) \u00e9 4, e (1+1)**(5-2) \u00e9 8. Tamb\u00e9m \u00e9 poss\u00edvel usar par\u00eanteses para facilitar a leitura de uma express\u00e3o, como no caso de (minute * 100) / 60 , mesmo se o resultado n\u00e3o for alterado. A Exponencia\u00e7\u00e3o tem a pr\u00f3xima preced\u00eancia mais alta, ent\u00e3o 1 + 2**3 \u00e9 9, n\u00e3o 27, e 2 * 3**2 \u00e9 18, n\u00e3o 36. A Multiplica\u00e7\u00e3o e a Divis\u00e3o t\u00eam preced\u00eancia mais alta que a Adi\u00e7\u00e3o e a Subtra\u00e7\u00e3o. Assim, 2 * 3 - 1 \u00e9 5, n\u00e3o 4, e 6 + 4 / 2 \u00e9 8, n\u00e3o 5. Os operadores com a mesma preced\u00eancia s\u00e3o avaliados da esquerda para a direita (exceto na exponencia\u00e7\u00e3o). Assim, na express\u00e3o degrees / 2 * pi , a divis\u00e3o acontece primeiro e o resultado \u00e9 multiplicado por pi . Para dividir por 2\u03c0, voc\u00ea pode usar par\u00eanteses ou escrever degrees / 2 / pi . Eu n\u00e3o fico sempre tentando lembrar da preced\u00eancia de operadores. Se a express\u00e3o n\u00e3o estiver clara \u00e0 primeira vista, uso par\u00eanteses para fazer isso. 2.6 - Opera\u00e7\u00f5es com strings Em geral, n\u00e3o \u00e9 poss\u00edvel executar opera\u00e7\u00f5es matem\u00e1ticas com strings, mesmo se elas parecerem n\u00fameros, ent\u00e3o coisas assim s\u00e3o ilegais: '2'-'1' 'eggs'/'easy' 'third'*'a charm' Mas h\u00e1 duas exce\u00e7\u00f5es, + e * . O operador + executa uma concatena\u00e7\u00e3o de strings, ou seja, une as strings pelas extremidades. Por exemplo: >>> first = 'throat' >>> second = 'warbler' >>> first + second throatwarbler O operador * tamb\u00e9m funciona em strings; ele executa a repeti\u00e7\u00e3o. Por exemplo, 'Spam' * 3 \u00e9 'SpamSpamSpam'. Se um dos valores for uma string, o outro tem de ser um n\u00famero inteiro. Este uso de + e * faz sentido por analogia com a adi\u00e7\u00e3o e a multiplica\u00e7\u00e3o. Tal como 4 * 3 \u00e9 equivalente a 4 + 4 + 4 , esperamos que 'Spam' * 3 seja o mesmo que 'Spam'+'Spam'+'Spam', e assim \u00e9. Por outro lado, h\u00e1 uma diferen\u00e7a significativa entre a concatena\u00e7\u00e3o de strings e a repeti\u00e7\u00e3o em rela\u00e7\u00e3o \u00e0 adi\u00e7\u00e3o e \u00e0 multiplica\u00e7\u00e3o de n\u00fameros inteiros. Voc\u00ea consegue pensar em uma propriedade que a adi\u00e7\u00e3o tem, mas a concatena\u00e7\u00e3o de strings n\u00e3o tem? 2.7 - Coment\u00e1rios Conforme os programas ficam maiores e mais complicados, eles s\u00e3o mais dif\u00edceis de ler. As linguagens formais s\u00e3o densas e muitas vezes \u00e9 dif\u00edcil ver um peda\u00e7o de c\u00f3digo e compreender o que ele faz ou por que faz isso. Por essa raz\u00e3o, \u00e9 uma boa ideia acrescentar notas aos seus programas para explicar em linguagem natural o que o programa est\u00e1 fazendo. Essas notas s\u00e3o chamadas de coment\u00e1rios, e come\u00e7am com o s\u00edmbolo # : # computa a percentagem da hora que passou percentage = (minute * 100) / 60 Nesse caso, o coment\u00e1rio aparece sozinho em uma linha. Voc\u00ea tamb\u00e9m pode p\u00f4r coment\u00e1rios no fim das linhas: percentage = (minute * 100) / 60 # percentagem de uma hora Tudo do # ao fim da linha \u00e9 ignorado \u2013 n\u00e3o tem efeito na execu\u00e7\u00e3o do programa. Os coment\u00e1rios tornam-se mais \u00fateis quando documentam algo no c\u00f3digo que n\u00e3o est\u00e1 \u00f3bvio. Podemos supor que o leitor compreenda o que o c\u00f3digo faz; assim, \u00e9 mais \u00fatil explicar porque faz o que faz. Este coment\u00e1rio \u00e9 redundante em rela\u00e7\u00e3o ao c\u00f3digo, al\u00e9m de in\u00fatil: v = 5 # atribui 5 a v Este coment\u00e1rio cont\u00e9m informa\u00e7\u00f5es \u00fateis que n\u00e3o est\u00e3o no c\u00f3digo: v = 5 # velocidade em metros/segundo. Bons nomes de vari\u00e1veis podem reduzir a necessidade de coment\u00e1rios, mas nomes longos podem tornar express\u00f5es complexas dif\u00edceis de ler, ent\u00e3o \u00e9 preciso analisar o que vale mais a pena. 2.8 - Depura\u00e7\u00e3o H\u00e1 tr\u00eas tipos de erros que podem ocorrer em um programa: erros de sintaxe, erros de tempo de execu\u00e7\u00e3o e erros sem\u00e2nticos. \u00c9 \u00fatil distinguir entre eles para rastre\u00e1-los mais rapidamente. Erro de sintaxe A \u201csintaxe\u201d refere-se \u00e0 estrutura de um programa e suas respectivas regras. Por exemplo, os par\u00eanteses devem vir em pares correspondentes, ent\u00e3o (1 + 2) \u00e9 legal, mas 8) \u00e9 um erro de sintaxe. Se houver um erro de sintaxe em algum lugar no seu programa, o Python exibe uma mensagem de erro e para, e n\u00e3o ser\u00e1 poss\u00edvel executar o programa. Nas primeiras poucas semanas da sua carreira em programa\u00e7\u00e3o, voc\u00ea pode passar muito tempo rastreando erros de sintaxe. Ao adquirir experi\u00eancia, voc\u00ea far\u00e1 menos erros e os encontrar\u00e1 mais r\u00e1pido. Erro de tempo de execu\u00e7\u00e3o O segundo tipo de erro \u00e9 o erro de tempo de execu\u00e7\u00e3o, assim chamado porque o erro n\u00e3o aparece at\u00e9 que o programa seja executado. Esses erros tamb\u00e9m se chamam de exce\u00e7\u00f5es porque normalmente indicam que algo excepcional (e ruim) aconteceu. Os erros de tempo de execu\u00e7\u00e3o s\u00e3o raros nos programas simples que veremos nos primeiros cap\u00edtulos, ent\u00e3o pode demorar um pouco at\u00e9 voc\u00ea encontrar algum. Erro sem\u00e2ntico O terceiro tipo do erro \u00e9 \u201csem\u00e2ntico\u201d, ou seja, relacionado ao significado. Se houver um erro sem\u00e2ntico no seu programa, ele ser\u00e1 executado sem gerar mensagens de erro, mas n\u00e3o vai fazer a coisa certa. Vai fazer algo diferente. Especificamente, vai fazer o que voc\u00ea disser para fazer. Identificar erros sem\u00e2nticos pode ser complicado, porque \u00e9 preciso trabalhar de tr\u00e1s para a frente, vendo a sa\u00edda do programa e tentando compreender o que ele est\u00e1 fazendo. 2.9 - Gloss\u00e1rio vari\u00e1vel Um nome que se refere a um valor. atribui\u00e7\u00e3o Uma instru\u00e7\u00e3o que atribui um valor a uma vari\u00e1vel. diagrama de estado Uma representa\u00e7\u00e3o gr\u00e1fica de um grupo de vari\u00e1veis e os valores a que se referem. palavra-chave Uma palavra reservada, usada para analisar um programa; n\u00e3o \u00e9 poss\u00edvel usar palavras-chave como if, def e while como nomes de vari\u00e1veis. operando Um dos valores que um operador produz. express\u00e3o Uma combina\u00e7\u00e3o de vari\u00e1veis, operadores e valores que representa um resultado \u00fanico. avaliar Simplificar uma express\u00e3o executando as opera\u00e7\u00f5es para produzir um valor \u00fanico. instru\u00e7\u00e3o Uma se\u00e7\u00e3o do c\u00f3digo que representa um comando ou a\u00e7\u00e3o. Por enquanto, as instru\u00e7\u00f5es que vimos s\u00e3o instru\u00e7\u00f5es de atribui\u00e7\u00f5es e de exibi\u00e7\u00e3o. executar Executar uma instru\u00e7\u00e3o para fazer o que ela diz. modo interativo Um modo de usar o interpretador do Python, digitando o c\u00f3digo no prompt. modo script Um modo de usar o interpretador do Python para ler c\u00f3digo em um script e execut\u00e1-lo. script Um programa armazenado em um arquivo. ordem das opera\u00e7\u00f5es As regras que governam a ordem na qual as express\u00f5es que envolvem v\u00e1rios operadores e operandos s\u00e3o avaliadas. concatenar Juntar dois operandos pelas extremidades. coment\u00e1rios Informa\u00e7\u00f5es em um programa destinadas a outros programadores (ou qualquer pessoa que leia o texto fonte) que n\u00e3o t\u00eam efeito sobre a execu\u00e7\u00e3o do programa. erro de sintaxe Um erro em um programa que torna sua an\u00e1lise imposs\u00edvel (e por isso imposs\u00edvel de interpretar). exce\u00e7\u00e3o Um erro que se descobre quando o programa \u00e9 executado. sem\u00e2ntica O significado de um programa. erro sem\u00e2ntico Um erro que faz com que um programa fa\u00e7a algo diferente do que o programador pretendia. 2.10 - Exerc\u00edcios Exerc\u00edcio 2.1 Repetindo o meu conselho do cap\u00edtulo anterior, sempre que voc\u00ea aprender um recurso novo, voc\u00ea deve test\u00e1-lo no modo interativo e fazer erros de prop\u00f3sito para ver o que acontece. Vimos que n = 42 \u00e9 legal. E 42 = n? Ou x = y = 1? Em algumas linguagens, cada instru\u00e7\u00e3o termina em um ponto e v\u00edrgula ;. O que acontece se voc\u00ea puser um ponto e v\u00edrgula no fim de uma instru\u00e7\u00e3o no Python? E se puser um ponto no fim de uma instru\u00e7\u00e3o? Em nota\u00e7\u00e3o matem\u00e1tica \u00e9 poss\u00edvel multiplicar x e y desta forma: xy. O que acontece se voc\u00ea tentar fazer o mesmo no Python? Exerc\u00edcio 2.2 Pratique o uso do interpretador do Python como uma calculadora: O volume de uma esfera com raio r \u00e9 . Qual \u00e9 o volume de uma esfera com raio 5? Suponha que o pre\u00e7o de capa de um livro seja R$ 24,95, mas as livrarias recebem um desconto de 40%. O transporte custa R$ 3,00 para o primeiro exemplar e 75 centavos para cada exemplar adicional. Qual \u00e9 o custo total de atacado para 60 c\u00f3pias? Se eu sair da minha casa \u00e0s 6:52 e correr 1 quil\u00f4metro a um certo passo (8min15s por quil\u00f4metro), ent\u00e3o 3 quil\u00f4metros a um passo mais r\u00e1pido (7min12s por quil\u00f4metro) e 1 quil\u00f4metro no mesmo passo usado em primeiro lugar, que horas chego em casa para o caf\u00e9 da manh\u00e3?","title":"Cap\u00edtulo 2: Vari\u00e1veis, express\u00f5es e instru\u00e7\u00f5es"},{"location":"02-vars-expr-instr/#capitulo-2-variaveis-expressoes-e-instrucoes","text":"Um dos recursos mais eficientes de uma linguagem de programa\u00e7\u00e3o \u00e9 a capacidade de manipular vari\u00e1veis. Uma vari\u00e1vel \u00e9 um nome que se refere a um valor.","title":"Cap\u00edtulo 2: Vari\u00e1veis, express\u00f5es e instru\u00e7\u00f5es"},{"location":"02-vars-expr-instr/#21-instrucoes-de-atribuicao","text":"Uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o cria uma nova vari\u00e1vel e d\u00e1 um valor a ela: >>> message = 'And now for something completely different' >>> n = 17 >>> pi = 3.141592653589793 Esse exemplo faz tr\u00eas atribui\u00e7\u00f5es. A primeira atribui uma string a uma nova vari\u00e1vel chamada message; a segunda d\u00e1 o n\u00famero inteiro 17 a n; a terceira atribui o valor (aproximado) de \u03c0 a pi. Uma forma comum de representar vari\u00e1veis por escrito \u00e9 colocar o nome com uma flecha apontando para o seu valor. Este tipo de n\u00famero \u00e9 chamado de diagrama de estado porque mostra o estado no qual cada uma das vari\u00e1veis est\u00e1 (pense nele como o estado de esp\u00edrito da vari\u00e1vel). A Figura 2.1 mostra o resultado do exemplo anterior. Figura 2.1 \u2013 Diagrama de estado.","title":"2.1 - Instru\u00e7\u00f5es de atribui\u00e7\u00e3o"},{"location":"02-vars-expr-instr/#22-nomes-de-variaveis","text":"Os programadores geralmente escolhem nomes significativos para as suas vari\u00e1veis \u2013 eles documentam o uso da vari\u00e1vel. Nomes de vari\u00e1veis podem ser t\u00e3o longos quanto voc\u00ea queira. Podem conter tanto letras como n\u00fameros, mas n\u00e3o podem come\u00e7ar com um n\u00famero. \u00c9 legal usar letras mai\u00fasculas, mas a conven\u00e7\u00e3o \u00e9 usar apenas letras min\u00fasculas para nomes de vari\u00e1veis. O caractere de sublinhar (_) pode aparecer em um nome. Muitas vezes \u00e9 usado em nomes com v\u00e1rias palavras, como your_name ou airspeed_of_unladen_swallow. Se voc\u00ea der um nome ilegal a uma vari\u00e1vel, recebe um erro de sintaxe: >>> 76trombones = 'big parade' SyntaxError: invalid syntax >>> more@ = 1000000 SyntaxError: invalid syntax >>> class = 'Advanced Theoretical Zymurgy' SyntaxError: invalid syntax 76trombones \u00e9 ilegal porque come\u00e7a com um n\u00famero. more@ \u00e9 ilegal porque cont\u00e9m um caractere ilegal, o @ . Mas o que h\u00e1 de errado com class ? A quest\u00e3o \u00e9 que class \u00e9 uma das palavras-chave do Python. O interpretador usa palavras-chave para reconhecer a estrutura do programa e elas n\u00e3o podem ser usadas como nomes de vari\u00e1vel. O Python 3 tem estas palavras-chave: and del from None True as elif global nonlocal try assert else if not while break except import or with class False in pass yield continue finally is raise def for lambda return Voc\u00ea n\u00e3o precisa memorizar essa lista. Na maior parte dos ambientes de desenvolvimento, as palavras-chave s\u00e3o exibidas em uma cor diferente; se voc\u00ea tentar usar uma como nome de vari\u00e1vel, vai perceber.","title":"2.2 - Nomes de vari\u00e1veis"},{"location":"02-vars-expr-instr/#23-expressoes-e-instrucoes","text":"Uma express\u00e3o \u00e9 uma combina\u00e7\u00e3o de valores, vari\u00e1veis e operadores. Um valor por si mesmo \u00e9 considerado uma express\u00e3o, assim como uma vari\u00e1vel, portanto as express\u00f5es seguintes s\u00e3o todas legais: >>> 42 42 >>> n 17 >>> n + 25 42 Quando voc\u00ea digita uma express\u00e3o no prompt, o interpretador a avalia, ou seja, ele encontra o valor da express\u00e3o. Neste exemplo, o n tem o valor 17 e n + 25 tem o valor 42. Uma instru\u00e7\u00e3o \u00e9 uma unidade de c\u00f3digo que tem um efeito, como criar uma vari\u00e1vel ou exibir um valor. >>> n = 17 >>> print(n) A primeira linha \u00e9 uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o que d\u00e1 um valor a n. A segunda linha \u00e9 uma instru\u00e7\u00e3o de exibi\u00e7\u00e3o que exibe o valor de n. Quando voc\u00ea digita uma instru\u00e7\u00e3o, o interpretador a executa, o que significa que ele faz o que a instru\u00e7\u00e3o diz. Em geral, instru\u00e7\u00f5es n\u00e3o t\u00eam valores.","title":"2.3 - Express\u00f5es e instru\u00e7\u00f5es"},{"location":"02-vars-expr-instr/#24-modo-script","text":"At\u00e9 agora executamos o Python no modo interativo, no qual voc\u00ea interage diretamente com o interpretador. O modo interativo \u00e9 uma boa forma de come\u00e7ar, mas se estiver trabalhando com mais do que algumas linhas do c\u00f3digo, o processo pode ficar desorganizado. A alternativa \u00e9 salvar o c\u00f3digo em um arquivo chamado script e ent\u00e3o executar o interpretador no modo script para execut\u00e1-lo. Por conven\u00e7\u00e3o, os scripts no Python t\u00eam nomes que terminam com .py. Se souber como criar e executar um script no seu computador, voc\u00ea est\u00e1 pronto. Sen\u00e3o, recomendo usar o PythonAnywhere novamente. Inseri instru\u00e7\u00f5es sobre como executar programas no modo script em http://tinyurl.com/thinkpython2e. Como o Python oferece os dois modos, voc\u00ea pode testar peda\u00e7os do c\u00f3digo no modo interativo antes de coloc\u00e1-los em um script. Mas h\u00e1 diferen\u00e7as entre o modo interativo e o modo script que podem confundir as pessoas. Por exemplo, se estiver usando o Python como uma calculadora, voc\u00ea poderia digitar: >>> miles = 26.2 >>> miles * 1.61 42.182 A primeira linha atribui um valor a miles, mas n\u00e3o tem efeito vis\u00edvel. A segunda linha \u00e9 uma express\u00e3o, ent\u00e3o o interpretador a avalia e exibe o resultado. No fim, chega-se ao resultado de que uma maratona tem aproximadamente 42 quil\u00f4metros. Mas se voc\u00ea digitar o mesmo c\u00f3digo em um script e execut\u00e1-lo, n\u00e3o recebe nenhuma sa\u00edda. Uma express\u00e3o, por conta pr\u00f3pria, n\u00e3o tem efeito vis\u00edvel no modo script. O Python, na verdade, avalia a express\u00e3o, mas n\u00e3o exibe o valor a menos que voc\u00ea especifique: miles = 26.2 print(miles * 1.61) Este comportamento pode confundir um pouco no in\u00edcio. Um script normalmente cont\u00e9m uma sequ\u00eancia de instru\u00e7\u00f5es. Se houver mais de uma instru\u00e7\u00e3o, os resultados aparecem um ap\u00f3s o outro, conforme as instru\u00e7\u00f5es sejam executadas. Por exemplo, o script print(1) x = 2 print(x) produz a sa\u00edda 1 2 A instru\u00e7\u00e3o de atribui\u00e7\u00e3o n\u00e3o produz nenhuma sa\u00edda. Para verificar sua compreens\u00e3o, digite as seguintes instru\u00e7\u00f5es no interpretador do Python e veja o que fazem: 5 x = 5 x + 1 Agora ponha as mesmas instru\u00e7\u00f5es em um script e o execute. Qual \u00e9 a sa\u00edda? Altere o script transformando cada express\u00e3o em uma instru\u00e7\u00e3o de exibi\u00e7\u00e3o e ent\u00e3o o execute novamente.","title":"2.4 - Modo script"},{"location":"02-vars-expr-instr/#25-ordem-das-operacoes","text":"Quando uma express\u00e3o cont\u00e9m mais de um operador, a ordem da avalia\u00e7\u00e3o depende da ordem das opera\u00e7\u00f5es. Para operadores matem\u00e1ticos, o Python segue a conven\u00e7\u00e3o matem\u00e1tica. O acr\u00f4nimo PEMDAS pode ser \u00fatil para lembrar das regras: Os Par\u00eanteses t\u00eam a preced\u00eancia mais alta e podem ser usados para for\u00e7ar a avalia\u00e7\u00e3o de uma express\u00e3o na ordem que voc\u00ea quiser. Como as express\u00f5es em par\u00eanteses s\u00e3o avaliadas primeiro, 2 * (3-1) \u00e9 4, e (1+1)**(5-2) \u00e9 8. Tamb\u00e9m \u00e9 poss\u00edvel usar par\u00eanteses para facilitar a leitura de uma express\u00e3o, como no caso de (minute * 100) / 60 , mesmo se o resultado n\u00e3o for alterado. A Exponencia\u00e7\u00e3o tem a pr\u00f3xima preced\u00eancia mais alta, ent\u00e3o 1 + 2**3 \u00e9 9, n\u00e3o 27, e 2 * 3**2 \u00e9 18, n\u00e3o 36. A Multiplica\u00e7\u00e3o e a Divis\u00e3o t\u00eam preced\u00eancia mais alta que a Adi\u00e7\u00e3o e a Subtra\u00e7\u00e3o. Assim, 2 * 3 - 1 \u00e9 5, n\u00e3o 4, e 6 + 4 / 2 \u00e9 8, n\u00e3o 5. Os operadores com a mesma preced\u00eancia s\u00e3o avaliados da esquerda para a direita (exceto na exponencia\u00e7\u00e3o). Assim, na express\u00e3o degrees / 2 * pi , a divis\u00e3o acontece primeiro e o resultado \u00e9 multiplicado por pi . Para dividir por 2\u03c0, voc\u00ea pode usar par\u00eanteses ou escrever degrees / 2 / pi . Eu n\u00e3o fico sempre tentando lembrar da preced\u00eancia de operadores. Se a express\u00e3o n\u00e3o estiver clara \u00e0 primeira vista, uso par\u00eanteses para fazer isso.","title":"2.5 - Ordem das opera\u00e7\u00f5es"},{"location":"02-vars-expr-instr/#26-operacoes-com-strings","text":"Em geral, n\u00e3o \u00e9 poss\u00edvel executar opera\u00e7\u00f5es matem\u00e1ticas com strings, mesmo se elas parecerem n\u00fameros, ent\u00e3o coisas assim s\u00e3o ilegais: '2'-'1' 'eggs'/'easy' 'third'*'a charm' Mas h\u00e1 duas exce\u00e7\u00f5es, + e * . O operador + executa uma concatena\u00e7\u00e3o de strings, ou seja, une as strings pelas extremidades. Por exemplo: >>> first = 'throat' >>> second = 'warbler' >>> first + second throatwarbler O operador * tamb\u00e9m funciona em strings; ele executa a repeti\u00e7\u00e3o. Por exemplo, 'Spam' * 3 \u00e9 'SpamSpamSpam'. Se um dos valores for uma string, o outro tem de ser um n\u00famero inteiro. Este uso de + e * faz sentido por analogia com a adi\u00e7\u00e3o e a multiplica\u00e7\u00e3o. Tal como 4 * 3 \u00e9 equivalente a 4 + 4 + 4 , esperamos que 'Spam' * 3 seja o mesmo que 'Spam'+'Spam'+'Spam', e assim \u00e9. Por outro lado, h\u00e1 uma diferen\u00e7a significativa entre a concatena\u00e7\u00e3o de strings e a repeti\u00e7\u00e3o em rela\u00e7\u00e3o \u00e0 adi\u00e7\u00e3o e \u00e0 multiplica\u00e7\u00e3o de n\u00fameros inteiros. Voc\u00ea consegue pensar em uma propriedade que a adi\u00e7\u00e3o tem, mas a concatena\u00e7\u00e3o de strings n\u00e3o tem?","title":"2.6 - Opera\u00e7\u00f5es com strings"},{"location":"02-vars-expr-instr/#27-comentarios","text":"Conforme os programas ficam maiores e mais complicados, eles s\u00e3o mais dif\u00edceis de ler. As linguagens formais s\u00e3o densas e muitas vezes \u00e9 dif\u00edcil ver um peda\u00e7o de c\u00f3digo e compreender o que ele faz ou por que faz isso. Por essa raz\u00e3o, \u00e9 uma boa ideia acrescentar notas aos seus programas para explicar em linguagem natural o que o programa est\u00e1 fazendo. Essas notas s\u00e3o chamadas de coment\u00e1rios, e come\u00e7am com o s\u00edmbolo # : # computa a percentagem da hora que passou percentage = (minute * 100) / 60 Nesse caso, o coment\u00e1rio aparece sozinho em uma linha. Voc\u00ea tamb\u00e9m pode p\u00f4r coment\u00e1rios no fim das linhas: percentage = (minute * 100) / 60 # percentagem de uma hora Tudo do # ao fim da linha \u00e9 ignorado \u2013 n\u00e3o tem efeito na execu\u00e7\u00e3o do programa. Os coment\u00e1rios tornam-se mais \u00fateis quando documentam algo no c\u00f3digo que n\u00e3o est\u00e1 \u00f3bvio. Podemos supor que o leitor compreenda o que o c\u00f3digo faz; assim, \u00e9 mais \u00fatil explicar porque faz o que faz. Este coment\u00e1rio \u00e9 redundante em rela\u00e7\u00e3o ao c\u00f3digo, al\u00e9m de in\u00fatil: v = 5 # atribui 5 a v Este coment\u00e1rio cont\u00e9m informa\u00e7\u00f5es \u00fateis que n\u00e3o est\u00e3o no c\u00f3digo: v = 5 # velocidade em metros/segundo. Bons nomes de vari\u00e1veis podem reduzir a necessidade de coment\u00e1rios, mas nomes longos podem tornar express\u00f5es complexas dif\u00edceis de ler, ent\u00e3o \u00e9 preciso analisar o que vale mais a pena.","title":"2.7 - Coment\u00e1rios"},{"location":"02-vars-expr-instr/#28-depuracao","text":"H\u00e1 tr\u00eas tipos de erros que podem ocorrer em um programa: erros de sintaxe, erros de tempo de execu\u00e7\u00e3o e erros sem\u00e2nticos. \u00c9 \u00fatil distinguir entre eles para rastre\u00e1-los mais rapidamente. Erro de sintaxe A \u201csintaxe\u201d refere-se \u00e0 estrutura de um programa e suas respectivas regras. Por exemplo, os par\u00eanteses devem vir em pares correspondentes, ent\u00e3o (1 + 2) \u00e9 legal, mas 8) \u00e9 um erro de sintaxe. Se houver um erro de sintaxe em algum lugar no seu programa, o Python exibe uma mensagem de erro e para, e n\u00e3o ser\u00e1 poss\u00edvel executar o programa. Nas primeiras poucas semanas da sua carreira em programa\u00e7\u00e3o, voc\u00ea pode passar muito tempo rastreando erros de sintaxe. Ao adquirir experi\u00eancia, voc\u00ea far\u00e1 menos erros e os encontrar\u00e1 mais r\u00e1pido. Erro de tempo de execu\u00e7\u00e3o O segundo tipo de erro \u00e9 o erro de tempo de execu\u00e7\u00e3o, assim chamado porque o erro n\u00e3o aparece at\u00e9 que o programa seja executado. Esses erros tamb\u00e9m se chamam de exce\u00e7\u00f5es porque normalmente indicam que algo excepcional (e ruim) aconteceu. Os erros de tempo de execu\u00e7\u00e3o s\u00e3o raros nos programas simples que veremos nos primeiros cap\u00edtulos, ent\u00e3o pode demorar um pouco at\u00e9 voc\u00ea encontrar algum. Erro sem\u00e2ntico O terceiro tipo do erro \u00e9 \u201csem\u00e2ntico\u201d, ou seja, relacionado ao significado. Se houver um erro sem\u00e2ntico no seu programa, ele ser\u00e1 executado sem gerar mensagens de erro, mas n\u00e3o vai fazer a coisa certa. Vai fazer algo diferente. Especificamente, vai fazer o que voc\u00ea disser para fazer. Identificar erros sem\u00e2nticos pode ser complicado, porque \u00e9 preciso trabalhar de tr\u00e1s para a frente, vendo a sa\u00edda do programa e tentando compreender o que ele est\u00e1 fazendo.","title":"2.8 - Depura\u00e7\u00e3o"},{"location":"02-vars-expr-instr/#29-glossario","text":"vari\u00e1vel Um nome que se refere a um valor. atribui\u00e7\u00e3o Uma instru\u00e7\u00e3o que atribui um valor a uma vari\u00e1vel. diagrama de estado Uma representa\u00e7\u00e3o gr\u00e1fica de um grupo de vari\u00e1veis e os valores a que se referem. palavra-chave Uma palavra reservada, usada para analisar um programa; n\u00e3o \u00e9 poss\u00edvel usar palavras-chave como if, def e while como nomes de vari\u00e1veis. operando Um dos valores que um operador produz. express\u00e3o Uma combina\u00e7\u00e3o de vari\u00e1veis, operadores e valores que representa um resultado \u00fanico. avaliar Simplificar uma express\u00e3o executando as opera\u00e7\u00f5es para produzir um valor \u00fanico. instru\u00e7\u00e3o Uma se\u00e7\u00e3o do c\u00f3digo que representa um comando ou a\u00e7\u00e3o. Por enquanto, as instru\u00e7\u00f5es que vimos s\u00e3o instru\u00e7\u00f5es de atribui\u00e7\u00f5es e de exibi\u00e7\u00e3o. executar Executar uma instru\u00e7\u00e3o para fazer o que ela diz. modo interativo Um modo de usar o interpretador do Python, digitando o c\u00f3digo no prompt. modo script Um modo de usar o interpretador do Python para ler c\u00f3digo em um script e execut\u00e1-lo. script Um programa armazenado em um arquivo. ordem das opera\u00e7\u00f5es As regras que governam a ordem na qual as express\u00f5es que envolvem v\u00e1rios operadores e operandos s\u00e3o avaliadas. concatenar Juntar dois operandos pelas extremidades. coment\u00e1rios Informa\u00e7\u00f5es em um programa destinadas a outros programadores (ou qualquer pessoa que leia o texto fonte) que n\u00e3o t\u00eam efeito sobre a execu\u00e7\u00e3o do programa. erro de sintaxe Um erro em um programa que torna sua an\u00e1lise imposs\u00edvel (e por isso imposs\u00edvel de interpretar). exce\u00e7\u00e3o Um erro que se descobre quando o programa \u00e9 executado. sem\u00e2ntica O significado de um programa. erro sem\u00e2ntico Um erro que faz com que um programa fa\u00e7a algo diferente do que o programador pretendia.","title":"2.9 - Gloss\u00e1rio"},{"location":"02-vars-expr-instr/#210-exercicios","text":"","title":"2.10 - Exerc\u00edcios"},{"location":"02-vars-expr-instr/#exercicio-21","text":"Repetindo o meu conselho do cap\u00edtulo anterior, sempre que voc\u00ea aprender um recurso novo, voc\u00ea deve test\u00e1-lo no modo interativo e fazer erros de prop\u00f3sito para ver o que acontece. Vimos que n = 42 \u00e9 legal. E 42 = n? Ou x = y = 1? Em algumas linguagens, cada instru\u00e7\u00e3o termina em um ponto e v\u00edrgula ;. O que acontece se voc\u00ea puser um ponto e v\u00edrgula no fim de uma instru\u00e7\u00e3o no Python? E se puser um ponto no fim de uma instru\u00e7\u00e3o? Em nota\u00e7\u00e3o matem\u00e1tica \u00e9 poss\u00edvel multiplicar x e y desta forma: xy. O que acontece se voc\u00ea tentar fazer o mesmo no Python?","title":"Exerc\u00edcio 2.1"},{"location":"02-vars-expr-instr/#exercicio-22","text":"Pratique o uso do interpretador do Python como uma calculadora: O volume de uma esfera com raio r \u00e9 . Qual \u00e9 o volume de uma esfera com raio 5? Suponha que o pre\u00e7o de capa de um livro seja R$ 24,95, mas as livrarias recebem um desconto de 40%. O transporte custa R$ 3,00 para o primeiro exemplar e 75 centavos para cada exemplar adicional. Qual \u00e9 o custo total de atacado para 60 c\u00f3pias? Se eu sair da minha casa \u00e0s 6:52 e correr 1 quil\u00f4metro a um certo passo (8min15s por quil\u00f4metro), ent\u00e3o 3 quil\u00f4metros a um passo mais r\u00e1pido (7min12s por quil\u00f4metro) e 1 quil\u00f4metro no mesmo passo usado em primeiro lugar, que horas chego em casa para o caf\u00e9 da manh\u00e3?","title":"Exerc\u00edcio 2.2"},{"location":"03-funcoes/","text":"Cap\u00edtulo 3: Fun\u00e7\u00f5es No contexto da programa\u00e7\u00e3o, uma fun\u00e7\u00e3o \u00e9 uma sequ\u00eancia nomeada de instru\u00e7\u00f5es que executa uma opera\u00e7\u00e3o de computa\u00e7\u00e3o. Ao definir uma fun\u00e7\u00e3o, voc\u00ea especifica o nome e a sequ\u00eancia de instru\u00e7\u00f5es. Depois, pode \u201cchamar\u201d a fun\u00e7\u00e3o pelo nome. 3.1 - Chamada de fun\u00e7\u00e3o J\u00e1 vimos um exemplo de chamada de fun\u00e7\u00e3o: >>> type(42) <class 'int'> O nome da fun\u00e7\u00e3o \u00e9 type. A express\u00e3o entre par\u00eanteses \u00e9 chamada de argumento da fun\u00e7\u00e3o. Para esta fun\u00e7\u00e3o, o resultado \u00e9 o tipo do argumento. \u00c9 comum dizer que uma fun\u00e7\u00e3o \u201crecebe\u201d um argumento e \u201cretorna\u201d um resultado. O resultado tamb\u00e9m \u00e9 chamado de valor de retorno. O Python oferece fun\u00e7\u00f5es que convertem valores de um tipo em outro. A fun\u00e7\u00e3o int recebe qualquer valor e o converte em um n\u00famero inteiro, se for poss\u00edvel, ou declara que h\u00e1 um erro: >>> int('32') 32 >>> int('Hello') ValueError: invalid literal for int(): Hello int pode converter valores de ponto flutuante em n\u00fameros inteiros, mas n\u00e3o faz arredondamentos; ela apenas corta a parte da fra\u00e7\u00e3o: >>> int(3.99999) 3 >>> int(-2.3) -2 float converte n\u00fameros inteiros e strings em n\u00fameros de ponto flutuante: >>> float(32) 32.0 >>> float('3.14159') 3.14159 Finalmente, str converte o argumento em uma string: >>> str(32) '32' >>> str(3.14159) '3.14159' 3.2 - Fun\u00e7\u00f5es matem\u00e1ticas O Python tem um m\u00f3dulo matem\u00e1tico que oferece a maioria das fun\u00e7\u00f5es matem\u00e1ticas comuns. Um m\u00f3dulo \u00e9 um arquivo que cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es relacionadas. Antes que possamos usar as fun\u00e7\u00f5es em um m\u00f3dulo, precisamos import\u00e1-lo com uma instru\u00e7\u00e3o de importa\u00e7\u00e3o: >>> import math Esta instru\u00e7\u00e3o cria um objeto de m\u00f3dulo chamado math (matem\u00e1tica). Ao se exibir o objeto de m\u00f3dulo, s\u00e3o apresentadas informa\u00e7\u00f5es sobre ele: >>> math <module 'math' (built-in)> O objeto de m\u00f3dulo cont\u00e9m as fun\u00e7\u00f5es e vari\u00e1veis definidas no m\u00f3dulo. Para acessar uma das fun\u00e7\u00f5es, \u00e9 preciso especificar o nome do m\u00f3dulo e o nome da fun\u00e7\u00e3o, separados por um ponto. Este formato \u00e9 chamado de nota\u00e7\u00e3o de ponto. >>> ratio = signal_power / noise_power >>> decibels = 10 * math.log10(ratio) >>> radians = 0.7 >>> height = math.sin(radians) O primeiro exemplo usa math.log10 para calcular a propor\u00e7\u00e3o de sinal e de ru\u00eddo em decib\u00e9is (assumindo que signal_power e noise_power tenham sido definidos). O m\u00f3dulo matem\u00e1tico tamb\u00e9m oferece a fun\u00e7\u00e3o log, que calcula logaritmos de base e. O segundo exemplo encontra o seno de radians. O nome da vari\u00e1vel indica que sin e outras fun\u00e7\u00f5es trigonom\u00e9tricas (cos, tan etc.) recebem argumentos em radianos. Para converter graus em radianos, divida por 180 e multiplique por \u03c0: >>> degrees = 45 >>> radians = degrees / 180.0 * math.pi >>> math.sin(radians) 0.707106781187 A express\u00e3o math.pi recebe a vari\u00e1vel pi do m\u00f3dulo matem\u00e1tico. Seu valor \u00e9 uma aproxima\u00e7\u00e3o de ponto flutuante de \u03c0, com precis\u00e3o aproximada de 15 d\u00edgitos. Se souber trigonometria, voc\u00ea pode verificar o resultado anterior comparando-o com a raiz quadrada de 2 dividida por 2: >>> math.sqrt(2) / 2.0 0.707106781187 3.3 - Composi\u00e7\u00e3o Por enquanto, falamos sobre os elementos de um programa \u2013 vari\u00e1veis, express\u00f5es e instru\u00e7\u00f5es \u2013 de forma isolada, mas n\u00e3o sobre como combin\u00e1-los. Uma das caracter\u00edsticas mais \u00fateis das linguagens de programa\u00e7\u00e3o \u00e9 a sua capacidade de usar pequenos blocos de montar para compor programas. Por exemplo, o argumento de uma fun\u00e7\u00e3o pode ser qualquer tipo de express\u00e3o, inclusive operadores aritm\u00e9ticos: x = math.sin(degrees / 360.0 * 2 * math.pi) E at\u00e9 chamadas de fun\u00e7\u00e3o: x = math.exp(math.log(x+1)) \u00c9 poss\u00edvel colocar um valor, uma express\u00e3o arbitr\u00e1ria, em quase qualquer lugar. Com uma exce\u00e7\u00e3o: o lado esquerdo de uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o tem que ser um nome de vari\u00e1vel. Qualquer outra express\u00e3o no lado esquerdo \u00e9 um erro de sintaxe (veremos exce\u00e7\u00f5es a esta regra depois). >>> minutes = hours * 60 # correto >>> hours * 60 = minutes # errado! SyntaxError: can't assign to operator 3.4 - Como acrescentar novas fun\u00e7\u00f5es Por enquanto, s\u00f3 usamos fun\u00e7\u00f5es que v\u00eam com o Python, mas tamb\u00e9m \u00e9 poss\u00edvel acrescentar novas fun\u00e7\u00f5es. Uma defini\u00e7\u00e3o de fun\u00e7\u00e3o especifica o nome de uma nova fun\u00e7\u00e3o e a sequ\u00eancia de instru\u00e7\u00f5es que s\u00e3o executadas quando a fun\u00e7\u00e3o \u00e9 chamada. Aqui est\u00e1 um exemplo: def print_lyrics(): print(\"I'm a lumberjack, and I'm okay.\") print(\"I sleep all night and I work all day.\") def \u00e9 uma palavra-chave que indica uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. O nome da fun\u00e7\u00e3o \u00e9 print_lyrics . As regras para nomes de fun\u00e7\u00e3o s\u00e3o as mesmas que as das vari\u00e1veis: letras, n\u00fameros e sublinhado s\u00e3o legais, mas o primeiro caractere n\u00e3o pode ser um n\u00famero. N\u00e3o podemos usar uma palavra-chave como nome de uma fun\u00e7\u00e3o e devemos evitar ter uma vari\u00e1vel e uma fun\u00e7\u00e3o com o mesmo nome. Os par\u00eanteses vazios depois do nome indicam que esta fun\u00e7\u00e3o n\u00e3o usa argumentos. A primeira linha da defini\u00e7\u00e3o de fun\u00e7\u00e3o chama-se cabe\u00e7alho; o resto \u00e9 chamado de corpo. O cabe\u00e7alho precisa terminar em dois pontos e o corpo precisa ser endentado. Por conven\u00e7\u00e3o, a endenta\u00e7\u00e3o sempre \u00e9 de quatro espa\u00e7os. O corpo pode conter qualquer n\u00famero de instru\u00e7\u00f5es. As strings nas instru\u00e7\u00f5es de exibi\u00e7\u00e3o s\u00e3o limitadas por aspas duplas. As aspas simples e as aspas duplas fazem a mesma coisa; a maior parte das pessoas usa aspas simples apenas nos casos em que aspas simples (que tamb\u00e9m s\u00e3o ap\u00f3strofes) aparecem na string. Todas as aspas (simples e duplas) devem ser \u201caspas retas\u201d, normalmente encontradas ao lado do Enter no teclado. \u201cAspas curvas\u201d, como as desta ora\u00e7\u00e3o, n\u00e3o s\u00e3o legais no Python. Se digitar uma defini\u00e7\u00e3o de fun\u00e7\u00e3o no modo interativo, o interpretador exibe pontos (...) para mostrar que a defini\u00e7\u00e3o n\u00e3o est\u00e1 completa: >>> def print_lyrics(): ... print(\"I'm a lumberjack, and I'm okay.\") ... print(\"I sleep all night and I work all day.\") ... Para terminar a fun\u00e7\u00e3o, \u00e9 preciso inserir uma linha vazia. A defini\u00e7\u00e3o de uma fun\u00e7\u00e3o cria um objeto de fun\u00e7\u00e3o, que tem o tipo function: >>> print(print_lyrics) <function print_lyrics at 0xb7e99e9c> >>> type(print_lyrics) <class 'function'> A sintaxe para chamar a nova fun\u00e7\u00e3o \u00e9 a mesma que a das fun\u00e7\u00f5es integradas: >>> print_lyrics() I'm a lumberjack, and I'm okay. I sleep all night and I work all day. Uma vez que a fun\u00e7\u00e3o tenha sido definida, \u00e9 poss\u00edvel us\u00e1-la dentro de outra fun\u00e7\u00e3o. Por exemplo, para repetir o refr\u00e3o anterior, podemos escrever uma fun\u00e7\u00e3o chamada repeat_lyrics : def repeat_lyrics(): print_lyrics() print_lyrics() E da\u00ed chamar repeat_lyrics : >>> repeat_lyrics() I'm a lumberjack, and I'm okay. I sleep all night and I work all day. I'm a lumberjack, and I'm okay. I sleep all night and I work all day. Mas a can\u00e7\u00e3o n\u00e3o \u00e9 bem assim. 3.5 - Uso e defini\u00e7\u00f5es Juntando fragmentos de c\u00f3digo da se\u00e7\u00e3o anterior, o programa inteiro fica assim: def print_lyrics(): print(\"I'm a lumberjack, and I'm okay.\") print(\"I sleep all night and I work all day.\") def repeat_lyrics(): print_lyrics() print_lyrics() repeat_lyrics() Este programa cont\u00e9m duas defini\u00e7\u00f5es de fun\u00e7\u00e3o: print_lyrics e repeat_lyrics . As defini\u00e7\u00f5es de fun\u00e7\u00e3o s\u00e3o executadas como outras instru\u00e7\u00f5es, mas o efeito \u00e9 criar objetos de fun\u00e7\u00e3o. As instru\u00e7\u00f5es dentro da fun\u00e7\u00e3o n\u00e3o s\u00e3o executadas at\u00e9 que a fun\u00e7\u00e3o seja chamada, e a defini\u00e7\u00e3o de fun\u00e7\u00e3o n\u00e3o gera nenhuma sa\u00edda. Como poder\u00edamos esperar, \u00e9 preciso criar uma fun\u00e7\u00e3o antes de execut\u00e1-la. Em outras palavras, a defini\u00e7\u00e3o de fun\u00e7\u00e3o tem que ser executada antes que a fun\u00e7\u00e3o seja chamada. Como exerc\u00edcio, mova a \u00faltima linha deste programa para o topo, para que a chamada de fun\u00e7\u00e3o apare\u00e7a antes das defini\u00e7\u00f5es. Execute o programa e veja qual \u00e9 a mensagem de erro que aparece. Agora mova a chamada de fun\u00e7\u00e3o de volta para baixo e mova a defini\u00e7\u00e3o de print_lyrics para depois da defini\u00e7\u00e3o de repeat_lyrics . O que acontece quando este programa \u00e9 executado? 3.6 - Fluxo de execu\u00e7\u00e3o Para garantir que uma fun\u00e7\u00e3o seja definida antes do seu primeiro uso, \u00e9 preciso saber a ordem na qual as instru\u00e7\u00f5es ser\u00e3o executadas. Isso \u00e9 chamado de fluxo de execu\u00e7\u00e3o. A execu\u00e7\u00e3o sempre come\u00e7a na primeira instru\u00e7\u00e3o do programa. As instru\u00e7\u00f5es s\u00e3o executadas uma ap\u00f3s a outra, de cima para baixo. As defini\u00e7\u00f5es de fun\u00e7\u00e3o n\u00e3o alteram o fluxo da execu\u00e7\u00e3o do programa, mas lembre-se de que as instru\u00e7\u00f5es dentro da fun\u00e7\u00e3o n\u00e3o s\u00e3o executadas at\u00e9 a fun\u00e7\u00e3o ser chamada. Uma chamada de fun\u00e7\u00e3o \u00e9 como um desvio no fluxo de execu\u00e7\u00e3o. Em vez de ir \u00e0 pr\u00f3xima instru\u00e7\u00e3o, o fluxo salta para o corpo da fun\u00e7\u00e3o, executa as instru\u00e7\u00f5es l\u00e1, e ent\u00e3o volta para continuar de onde parou. Parece bastante simples, at\u00e9 voc\u00ea lembrar que uma fun\u00e7\u00e3o pode chamar outra. Enquanto estiver no meio de uma fun\u00e7\u00e3o, o programa pode ter que executar as instru\u00e7\u00f5es em outra fun\u00e7\u00e3o. Ent\u00e3o, enquanto estiver executando a nova fun\u00e7\u00e3o, o programa pode ter que executar mais uma fun\u00e7\u00e3o! Felizmente, o Python \u00e9 bom em n\u00e3o perder o fio da meada, ent\u00e3o cada vez que uma fun\u00e7\u00e3o \u00e9 conclu\u00edda, o programa continua de onde parou na fun\u00e7\u00e3o que o chamou. Quando chega no fim do programa, ele \u00e9 encerrado. Resumindo, nem sempre se deve ler um programa de cima para baixo. \u00c0s vezes faz mais sentido seguir o fluxo de execu\u00e7\u00e3o. 3.7 - Par\u00e2metros e argumentos Algumas fun\u00e7\u00f5es que vimos exigem argumentos. Por exemplo, ao chamar math.sin, voc\u00ea usa um n\u00famero como argumento. Algumas fun\u00e7\u00f5es exigem mais de um argumento: o math.pow exige dois, a base e o expoente. Dentro da fun\u00e7\u00e3o, os argumentos s\u00e3o atribu\u00eddos a vari\u00e1veis chamadas par\u00e2metros. Aqui est\u00e1 a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que precisa de um argumento: def print_twice(bruce): print(bruce) print(bruce) Esta fun\u00e7\u00e3o atribui o argumento a um par\u00e2metro chamado bruce. Quando a fun\u00e7\u00e3o \u00e9 chamada, ela exibe o valor do par\u00e2metro (seja qual for) duas vezes. Esta fun\u00e7\u00e3o funciona com qualquer valor que possa ser exibido: >>> print_twice('Spam') Spam Spam >>> print_twice(42) 42 42 >>> print_twice(math.pi) 3.14159265359 3.14159265359 As mesmas regras de composi\u00e7\u00e3o usadas para fun\u00e7\u00f5es integradas tamb\u00e9m s\u00e3o aplicadas a fun\u00e7\u00f5es definidas pelos programadores, ent\u00e3o podemos usar qualquer tipo de express\u00e3o como argumento para print_twice : >>> print_twice('Spam '*4) Spam Spam Spam Spam Spam Spam Spam Spam >>> print_twice(math.cos(math.pi)) -1.0 -1.0 O argumento \u00e9 avaliado antes de a fun\u00e7\u00e3o ser chamada. Ent\u00e3o, nos exemplos, as express\u00f5es 'Spam * 4 e math.cos(math.pi) s\u00f3 s\u00e3o avaliadas uma vez. Voc\u00ea tamb\u00e9m pode usar uma vari\u00e1vel como argumento: >>> michael = 'Eric, the half a bee.' >>> print_twice(michael) Eric, the half a bee. Eric, the half a bee. O nome da vari\u00e1vel que passamos como argumento (michael) n\u00e3o tem nada a ver com o nome do par\u00e2metro (bruce). N\u00e3o importa que o valor tenha sido chamado de volta (em quem chama); aqui em print_twice , chamamos todo mundo de bruce. 3.8 - As vari\u00e1veis e os par\u00e2metros s\u00e3o locais Quando voc\u00ea cria uma vari\u00e1vel dentro de uma fun\u00e7\u00e3o, ela \u00e9 local, ou seja, ela s\u00f3 existe dentro da fun\u00e7\u00e3o. Por exemplo: def cat_twice(part1, part2): cat = part1 + part2 print_twice(cat) Esta fun\u00e7\u00e3o recebe dois argumentos, concatena-os e exibe o resultado duas vezes. Aqui est\u00e1 um exemplo que a usa: >>> line1 = 'Bing tiddle ' >>> line2 = 'tiddle bang.' >>> cat_twice(line1, line2) Bing tiddle tiddle bang. Bing tiddle tiddle bang. Quando cat_twice \u00e9 encerrada, a vari\u00e1vel cat \u00e9 destru\u00edda. Se tentarmos exibi-la, recebemos uma exce\u00e7\u00e3o: >>> print(cat) NameError: name 'cat' is not defined Os par\u00e2metros tamb\u00e9m s\u00e3o locais. Por exemplo, al\u00e9m de print_twice, n\u00e3o existe o bruce. 3.9 - Diagrama da pilha Para monitorar quais vari\u00e1veis podem ser usadas e onde, \u00e9 uma boa ideia desenhar um diagrama da pilha. Assim como diagramas de estado, os diagramas da pilha mostram o valor de cada vari\u00e1vel, mas tamb\u00e9m mostram a fun\u00e7\u00e3o \u00e0 qual cada vari\u00e1vel pertence. Cada fun\u00e7\u00e3o \u00e9 representada por um frame (quadro). Um frame \u00e9 uma caixa com o nome de uma fun\u00e7\u00e3o junto a ele e os par\u00e2metros e as vari\u00e1veis da fun\u00e7\u00e3o dentro dele. O diagrama da pilha para o exemplo anterior \u00e9 exibido na Figura 3.1. Figura 3.1 \u2013 Diagrama da pilha. Os frames s\u00e3o organizados em uma pilha que indica qual fun\u00e7\u00e3o que foi chamada por outra, e assim por diante. Neste exemplo, print_twice foi chamada por cat_twice e cat_twice foi chamada por __main__ , que \u00e9 um nome especial para o frame na posi\u00e7\u00e3o mais proeminente. Quando voc\u00ea cria uma vari\u00e1vel fora de qualquer fun\u00e7\u00e3o, ela pertence a __main__ . Cada par\u00e2metro refere-se ao mesmo valor como seu argumento correspondente. Desta forma, part1 tem o mesmo valor que line1, part2 tem o mesmo valor que line2 e bruce tem o mesmo valor que cat. Se ocorrer um erro durante uma chamada de fun\u00e7\u00e3o, o Python exibe o nome da fun\u00e7\u00e3o, o nome da fun\u00e7\u00e3o que a chamou e o nome da fun\u00e7\u00e3o que chamou esta fun\u00e7\u00e3o por sua vez, voltando at\u00e9 __main__ . Por exemplo, se voc\u00ea tentar acessar cat de dentro de print_twice , receber\u00e1 uma mensagem de NameError : Traceback (innermost last): File \"test.py\", line 13, in __main__ cat_twice(line1, line2) File \"test.py\", line 5, in cat_twice print_twice(cat) File \"test.py\", line 9, in print_twice print(cat) NameError: name 'cat' is not defined Esta lista de fun\u00e7\u00f5es \u00e9 chamada de traceback. Ela mostra o arquivo do programa em que o erro ocorreu e em que linha, e quais fun\u00e7\u00f5es estavam sendo executadas no momento. Ele tamb\u00e9m mostra a linha de c\u00f3digo que causou o erro. A ordem das fun\u00e7\u00f5es no traceback \u00e9 a mesma que a ordem dos frames no diagrama da pilha. A fun\u00e7\u00e3o que est\u00e1 sendo executada no momento est\u00e1 no final. 3.10 - Fun\u00e7\u00f5es com resultado e fun\u00e7\u00f5es nulas Algumas fun\u00e7\u00f5es que usamos, como as fun\u00e7\u00f5es matem\u00e1ticas, devolvem resultados; por falta de um nome melhor, vou cham\u00e1-las de fun\u00e7\u00f5es com resultados. Outras fun\u00e7\u00f5es, como print_twice, executam uma a\u00e7\u00e3o, mas n\u00e3o devolvem um valor. Elas s\u00e3o chamadas de fun\u00e7\u00f5es nulas. Quando voc\u00ea chama uma fun\u00e7\u00e3o com resultado, quase sempre quer fazer algo com o resultado; por exemplo, voc\u00ea pode atribui-lo a uma vari\u00e1vel ou us\u00e1-la como parte de uma express\u00e3o: x = math.cos(radians) golden = (math.sqrt(5) + 1) / 2 Quando voc\u00ea chama uma fun\u00e7\u00e3o no modo interativo, o Python exibe o resultado: >>> math.sqrt(5) 2.2360679774997898 Mas em um script, se voc\u00ea chamar uma fun\u00e7\u00e3o com resultado e mais nada, o valor de retorno \u00e9 perdido para sempre! math.sqrt(5) Este script calcula a raiz quadrada de 5, mas como n\u00e3o armazena ou exibe o resultado, n\u00e3o \u00e9 muito \u00fatil. As fun\u00e7\u00f5es nulas podem exibir algo na tela ou ter algum outro efeito, mas n\u00e3o t\u00eam um valor de retorno. Se voc\u00ea atribuir o resultado a uma vari\u00e1vel, recebe um valor especial chamado None: >>> result = print_twice('Bing') Bing Bing >>> print(result) None O valor None n\u00e3o \u00e9 o mesmo que a string 'None' . \u00c9 um valor especial que tem seu pr\u00f3prio tipo: >>> print(type(None)) <class 'NoneType'> As fun\u00e7\u00f5es que apresentamos por enquanto s\u00e3o todas nulas. Vamos apresentar fun\u00e7\u00f5es com resultado mais adiante. 3.11 - Por que fun\u00e7\u00f5es? Caso o objetivo de dividir um programa em fun\u00e7\u00f5es n\u00e3o esteja claro, saiba que na verdade h\u00e1 v\u00e1rias raz\u00f5es: Criar uma nova fun\u00e7\u00e3o d\u00e1 a oportunidade de nomear um grupo de instru\u00e7\u00f5es, o que deixa o seu programa mais f\u00e1cil de ler e de depurar. As fun\u00e7\u00f5es podem tornar um programa menor, eliminando o c\u00f3digo repetitivo. Depois, se fizer alguma altera\u00e7\u00e3o, basta faz\u00ea-la em um lugar s\u00f3. Dividir um programa longo em fun\u00e7\u00f5es permite depurar as partes uma de cada vez e ent\u00e3o reuni-las em um conjunto funcional. As fun\u00e7\u00f5es bem projetadas muitas vezes s\u00e3o \u00fateis para muitos programas. Uma vez que escreva e depure uma, voc\u00ea pode reutiliz\u00e1-la. 3.12 - Depura\u00e7\u00e3o Uma das habilidades mais importantes que voc\u00ea vai aprender \u00e9 a depura\u00e7\u00e3o. Embora possa ser frustrante, a depura\u00e7\u00e3o \u00e9 uma das partes mais intelectualmente ricas, desafiadoras e interessantes da programa\u00e7\u00e3o. De certa forma, depurar \u00e9 similar ao trabalho de um detetive. Voc\u00ea tem pistas e precisa inferir os processos e eventos que levaram aos resultados exibidos. A depura\u00e7\u00e3o tamb\u00e9m \u00e9 como ci\u00eancia experimental. Uma vez que voc\u00ea tenha uma ideia sobre o que est\u00e1 errado, basta alterar o programa e tentar novamente. Se a sua hip\u00f3tese estava correta, voc\u00ea pode prever o resultado da altera\u00e7\u00e3o e chegar um passo mais perto de um programa funcional. Se a sua hip\u00f3tese estava errada, \u00e9 preciso criar outra. Como dizia Sherlock Holmes, \u201cQuando se elimina o imposs\u00edvel, o que sobra, por mais incr\u00edvel que pare\u00e7a, s\u00f3 pode ser a verdade.\u201d (A. Conan Doyle, O signo dos quatro). Para algumas pessoas, programar e depurar s\u00e3o a mesma coisa. Isto \u00e9, a programa\u00e7\u00e3o \u00e9 o processo de depurar gradualmente um programa at\u00e9 que ele fa\u00e7a o que o programador quer. A ideia \u00e9 que voc\u00ea comece com um programa funcional e fa\u00e7a pequenas altera\u00e7\u00f5es, depurando-as no decorrer do trabalho. Por exemplo, o Linux \u00e9 um sistema operacional que cont\u00e9m milh\u00f5es de linhas de c\u00f3digo, mas come\u00e7ou como um programa simples que Linus Torvalds usava para explorar o chip Intel 80386. Segundo Larry Greenfield, \u201cUm dos primeiros projetos de Linus foi um programa que alternaria entre a exibi\u00e7\u00e3o de AAAA e BBBB. Mais tarde isso se desenvolveu at\u00e9 virar o Linux.\u201d (Guia do usu\u00e1rio de Linux vers\u00e3o beta 1). 3.13 - Gloss\u00e1rio fun\u00e7\u00e3o Uma sequ\u00eancia nomeada de declara\u00e7\u00f5es que executa alguma opera\u00e7\u00e3o \u00fatil. As fun\u00e7\u00f5es podem receber argumentos ou n\u00e3o e podem ou n\u00e3o produzir algum resultado. defini\u00e7\u00e3o de fun\u00e7\u00e3o Uma instru\u00e7\u00e3o que cria uma fun\u00e7\u00e3o nova, especificando seu nome, par\u00e2metros e as instru\u00e7\u00f5es que cont\u00e9m. objeto da fun\u00e7\u00e3o Um valor \u00e9 criado por uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. O nome da fun\u00e7\u00e3o \u00e9 uma vari\u00e1vel que se refere a um objeto de fun\u00e7\u00e3o. cabe\u00e7alho A primeira linha de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. corpo A sequ\u00eancia de instru\u00e7\u00f5es dentro de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. par\u00e2metro Um nome usado dentro de uma fun\u00e7\u00e3o para se referir ao valor passado como argumento. chamada de fun\u00e7\u00e3o Uma instru\u00e7\u00e3o que executa uma fun\u00e7\u00e3o. \u00c9 composta pelo nome da fun\u00e7\u00e3o seguido de uma lista de argumentos entre par\u00eanteses. argumento Um valor apresentado a uma fun\u00e7\u00e3o quando a fun\u00e7\u00e3o \u00e9 chamada. Este valor \u00e9 atribu\u00eddo ao par\u00e2metro correspondente na fun\u00e7\u00e3o. vari\u00e1vel local Uma vari\u00e1vel definida dentro de uma fun\u00e7\u00e3o. Uma vari\u00e1vel local s\u00f3 pode ser usada dentro da sua fun\u00e7\u00e3o. valor de retorno O resultado de uma fun\u00e7\u00e3o. Se uma chamada de fun\u00e7\u00e3o for usada como uma express\u00e3o, o valor de retorno \u00e9 o valor da express\u00e3o. fun\u00e7\u00e3o com resultado Uma fun\u00e7\u00e3o que devolve um valor. fun\u00e7\u00e3o nula Uma fun\u00e7\u00e3o que sempre devolve None. None Um valor especial apresentado por fun\u00e7\u00f5es nulas. m\u00f3dulo Um arquivo que cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es relacionadas e outras defini\u00e7\u00f5es. instru\u00e7\u00e3o de importa\u00e7\u00e3o Uma instru\u00e7\u00e3o que l\u00ea um arquivo de m\u00f3dulo e cria um objeto de m\u00f3dulo. objeto de m\u00f3dulo Um valor criado por uma instru\u00e7\u00e3o import que oferece acesso aos valores definidos em um m\u00f3dulo. nota\u00e7\u00e3o de ponto A sintaxe para chamar uma fun\u00e7\u00e3o em outro m\u00f3dulo especificando o nome do m\u00f3dulo seguido de um ponto e o nome da fun\u00e7\u00e3o. composi\u00e7\u00e3o O uso de uma express\u00e3o como parte de uma express\u00e3o maior ou de uma instru\u00e7\u00e3o como parte de uma instru\u00e7\u00e3o maior. fluxo de execu\u00e7\u00e3o A ordem na qual as instru\u00e7\u00f5es s\u00e3o executadas. diagrama da pilha Representa\u00e7\u00e3o gr\u00e1fica de uma pilha de fun\u00e7\u00f5es, suas vari\u00e1veis e os valores a que se referem. frame Uma caixa em um diagrama da pilha que representa uma chamada de fun\u00e7\u00e3o. Cont\u00e9m as vari\u00e1veis locais e os par\u00e2metros da fun\u00e7\u00e3o. traceback Lista das fun\u00e7\u00f5es que est\u00e3o sendo executadas, exibidas quando ocorre uma exce\u00e7\u00e3o. 3.14 - Exerc\u00edcios Exerc\u00edcio 3.1 Escreva uma fun\u00e7\u00e3o chamada right_justify, que receba uma string chamada s como par\u00e2metro e exiba a string com espa\u00e7os suficientes \u00e0 frente para que a \u00faltima letra da string esteja na coluna 70 da tela: >>> right_justify('monty') monty Dica: Use concatena\u00e7\u00e3o de strings e repeti\u00e7\u00e3o. Al\u00e9m disso, o Python oferece uma fun\u00e7\u00e3o integrada chamada len, que apresenta o comprimento de uma string, ent\u00e3o o valor de len('monty') \u00e9 5. Exerc\u00edcio 3.2 Um objeto de fun\u00e7\u00e3o \u00e9 um valor que pode ser atribu\u00eddo a uma vari\u00e1vel ou passado como argumento. Por exemplo, do_twice \u00e9 uma fun\u00e7\u00e3o que toma um objeto de fun\u00e7\u00e3o como argumento e o chama duas vezes: def do_twice(f): f() f() Aqui est\u00e1 um exemplo que usa do_twice para chamar uma fun\u00e7\u00e3o chamada print_spam duas vezes: def print_spam(): print('spam') do_twice(print_spam) Digite este exemplo em um script e teste-o. Altere do_twice para que receba dois argumentos, um objeto de fun\u00e7\u00e3o e um valor, e chame a fun\u00e7\u00e3o duas vezes, passando o valor como um argumento. Copie a defini\u00e7\u00e3o de print_twice que aparece anteriormente neste cap\u00edtulo no seu script. Use a vers\u00e3o alterada de do_twice para chamar print_twice duas vezes, passando 'spam' como um argumento. Defina uma fun\u00e7\u00e3o nova chamada do_four que receba um objeto de fun\u00e7\u00e3o e um valor e chame a fun\u00e7\u00e3o quatro vezes, passando o valor como um par\u00e2metro. Deve haver s\u00f3 duas afirma\u00e7\u00f5es no corpo desta fun\u00e7\u00e3o, n\u00e3o quatro. Solu\u00e7\u00e3o: http://thinkpython2.com/code/do_four.py. Exerc\u00edcio 3.3 Nota: Este exerc\u00edcio deve ser feito usando-se apenas as instru\u00e7\u00f5es e os outros recursos que aprendemos at\u00e9 agora. Escreva uma fun\u00e7\u00e3o que desenhe uma grade como a seguinte: + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + Dica: para exibir mais de um valor em uma linha, podemos usar uma sequ\u00eancia de valores separados por v\u00edrgula: python print('+', '-') Por padr\u00e3o, print avan\u00e7a para a linha seguinte, mas podemos ignorar esse comportamento e inserir um espa\u00e7o no fim, desta forma: python print('+', end=' ') print('-') A sa\u00edda dessas instru\u00e7\u00f5es \u00e9 + - . Uma instru\u00e7\u00e3o print sem argumento termina a linha atual e vai para a pr\u00f3xima linha. Escreva uma fun\u00e7\u00e3o que desenhe uma grade semelhante com quatro linhas e quatro colunas. Solu\u00e7\u00e3o: http://thinkpython2.com/code/grid.py. Cr\u00e9dito: Este exerc\u00edcio \u00e9 baseado em outro apresentado por Oualline, em Practical C Programming, Third Edition, O\u2019Reilly Media, 1997.","title":"Cap\u00edtulo 3: Fun\u00e7\u00f5es"},{"location":"03-funcoes/#capitulo-3-funcoes","text":"No contexto da programa\u00e7\u00e3o, uma fun\u00e7\u00e3o \u00e9 uma sequ\u00eancia nomeada de instru\u00e7\u00f5es que executa uma opera\u00e7\u00e3o de computa\u00e7\u00e3o. Ao definir uma fun\u00e7\u00e3o, voc\u00ea especifica o nome e a sequ\u00eancia de instru\u00e7\u00f5es. Depois, pode \u201cchamar\u201d a fun\u00e7\u00e3o pelo nome.","title":"Cap\u00edtulo 3: Fun\u00e7\u00f5es"},{"location":"03-funcoes/#31-chamada-de-funcao","text":"J\u00e1 vimos um exemplo de chamada de fun\u00e7\u00e3o: >>> type(42) <class 'int'> O nome da fun\u00e7\u00e3o \u00e9 type. A express\u00e3o entre par\u00eanteses \u00e9 chamada de argumento da fun\u00e7\u00e3o. Para esta fun\u00e7\u00e3o, o resultado \u00e9 o tipo do argumento. \u00c9 comum dizer que uma fun\u00e7\u00e3o \u201crecebe\u201d um argumento e \u201cretorna\u201d um resultado. O resultado tamb\u00e9m \u00e9 chamado de valor de retorno. O Python oferece fun\u00e7\u00f5es que convertem valores de um tipo em outro. A fun\u00e7\u00e3o int recebe qualquer valor e o converte em um n\u00famero inteiro, se for poss\u00edvel, ou declara que h\u00e1 um erro: >>> int('32') 32 >>> int('Hello') ValueError: invalid literal for int(): Hello int pode converter valores de ponto flutuante em n\u00fameros inteiros, mas n\u00e3o faz arredondamentos; ela apenas corta a parte da fra\u00e7\u00e3o: >>> int(3.99999) 3 >>> int(-2.3) -2 float converte n\u00fameros inteiros e strings em n\u00fameros de ponto flutuante: >>> float(32) 32.0 >>> float('3.14159') 3.14159 Finalmente, str converte o argumento em uma string: >>> str(32) '32' >>> str(3.14159) '3.14159'","title":"3.1 - Chamada de fun\u00e7\u00e3o"},{"location":"03-funcoes/#32-funcoes-matematicas","text":"O Python tem um m\u00f3dulo matem\u00e1tico que oferece a maioria das fun\u00e7\u00f5es matem\u00e1ticas comuns. Um m\u00f3dulo \u00e9 um arquivo que cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es relacionadas. Antes que possamos usar as fun\u00e7\u00f5es em um m\u00f3dulo, precisamos import\u00e1-lo com uma instru\u00e7\u00e3o de importa\u00e7\u00e3o: >>> import math Esta instru\u00e7\u00e3o cria um objeto de m\u00f3dulo chamado math (matem\u00e1tica). Ao se exibir o objeto de m\u00f3dulo, s\u00e3o apresentadas informa\u00e7\u00f5es sobre ele: >>> math <module 'math' (built-in)> O objeto de m\u00f3dulo cont\u00e9m as fun\u00e7\u00f5es e vari\u00e1veis definidas no m\u00f3dulo. Para acessar uma das fun\u00e7\u00f5es, \u00e9 preciso especificar o nome do m\u00f3dulo e o nome da fun\u00e7\u00e3o, separados por um ponto. Este formato \u00e9 chamado de nota\u00e7\u00e3o de ponto. >>> ratio = signal_power / noise_power >>> decibels = 10 * math.log10(ratio) >>> radians = 0.7 >>> height = math.sin(radians) O primeiro exemplo usa math.log10 para calcular a propor\u00e7\u00e3o de sinal e de ru\u00eddo em decib\u00e9is (assumindo que signal_power e noise_power tenham sido definidos). O m\u00f3dulo matem\u00e1tico tamb\u00e9m oferece a fun\u00e7\u00e3o log, que calcula logaritmos de base e. O segundo exemplo encontra o seno de radians. O nome da vari\u00e1vel indica que sin e outras fun\u00e7\u00f5es trigonom\u00e9tricas (cos, tan etc.) recebem argumentos em radianos. Para converter graus em radianos, divida por 180 e multiplique por \u03c0: >>> degrees = 45 >>> radians = degrees / 180.0 * math.pi >>> math.sin(radians) 0.707106781187 A express\u00e3o math.pi recebe a vari\u00e1vel pi do m\u00f3dulo matem\u00e1tico. Seu valor \u00e9 uma aproxima\u00e7\u00e3o de ponto flutuante de \u03c0, com precis\u00e3o aproximada de 15 d\u00edgitos. Se souber trigonometria, voc\u00ea pode verificar o resultado anterior comparando-o com a raiz quadrada de 2 dividida por 2: >>> math.sqrt(2) / 2.0 0.707106781187","title":"3.2 - Fun\u00e7\u00f5es matem\u00e1ticas"},{"location":"03-funcoes/#33-composicao","text":"Por enquanto, falamos sobre os elementos de um programa \u2013 vari\u00e1veis, express\u00f5es e instru\u00e7\u00f5es \u2013 de forma isolada, mas n\u00e3o sobre como combin\u00e1-los. Uma das caracter\u00edsticas mais \u00fateis das linguagens de programa\u00e7\u00e3o \u00e9 a sua capacidade de usar pequenos blocos de montar para compor programas. Por exemplo, o argumento de uma fun\u00e7\u00e3o pode ser qualquer tipo de express\u00e3o, inclusive operadores aritm\u00e9ticos: x = math.sin(degrees / 360.0 * 2 * math.pi) E at\u00e9 chamadas de fun\u00e7\u00e3o: x = math.exp(math.log(x+1)) \u00c9 poss\u00edvel colocar um valor, uma express\u00e3o arbitr\u00e1ria, em quase qualquer lugar. Com uma exce\u00e7\u00e3o: o lado esquerdo de uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o tem que ser um nome de vari\u00e1vel. Qualquer outra express\u00e3o no lado esquerdo \u00e9 um erro de sintaxe (veremos exce\u00e7\u00f5es a esta regra depois). >>> minutes = hours * 60 # correto >>> hours * 60 = minutes # errado! SyntaxError: can't assign to operator","title":"3.3 - Composi\u00e7\u00e3o"},{"location":"03-funcoes/#34-como-acrescentar-novas-funcoes","text":"Por enquanto, s\u00f3 usamos fun\u00e7\u00f5es que v\u00eam com o Python, mas tamb\u00e9m \u00e9 poss\u00edvel acrescentar novas fun\u00e7\u00f5es. Uma defini\u00e7\u00e3o de fun\u00e7\u00e3o especifica o nome de uma nova fun\u00e7\u00e3o e a sequ\u00eancia de instru\u00e7\u00f5es que s\u00e3o executadas quando a fun\u00e7\u00e3o \u00e9 chamada. Aqui est\u00e1 um exemplo: def print_lyrics(): print(\"I'm a lumberjack, and I'm okay.\") print(\"I sleep all night and I work all day.\") def \u00e9 uma palavra-chave que indica uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. O nome da fun\u00e7\u00e3o \u00e9 print_lyrics . As regras para nomes de fun\u00e7\u00e3o s\u00e3o as mesmas que as das vari\u00e1veis: letras, n\u00fameros e sublinhado s\u00e3o legais, mas o primeiro caractere n\u00e3o pode ser um n\u00famero. N\u00e3o podemos usar uma palavra-chave como nome de uma fun\u00e7\u00e3o e devemos evitar ter uma vari\u00e1vel e uma fun\u00e7\u00e3o com o mesmo nome. Os par\u00eanteses vazios depois do nome indicam que esta fun\u00e7\u00e3o n\u00e3o usa argumentos. A primeira linha da defini\u00e7\u00e3o de fun\u00e7\u00e3o chama-se cabe\u00e7alho; o resto \u00e9 chamado de corpo. O cabe\u00e7alho precisa terminar em dois pontos e o corpo precisa ser endentado. Por conven\u00e7\u00e3o, a endenta\u00e7\u00e3o sempre \u00e9 de quatro espa\u00e7os. O corpo pode conter qualquer n\u00famero de instru\u00e7\u00f5es. As strings nas instru\u00e7\u00f5es de exibi\u00e7\u00e3o s\u00e3o limitadas por aspas duplas. As aspas simples e as aspas duplas fazem a mesma coisa; a maior parte das pessoas usa aspas simples apenas nos casos em que aspas simples (que tamb\u00e9m s\u00e3o ap\u00f3strofes) aparecem na string. Todas as aspas (simples e duplas) devem ser \u201caspas retas\u201d, normalmente encontradas ao lado do Enter no teclado. \u201cAspas curvas\u201d, como as desta ora\u00e7\u00e3o, n\u00e3o s\u00e3o legais no Python. Se digitar uma defini\u00e7\u00e3o de fun\u00e7\u00e3o no modo interativo, o interpretador exibe pontos (...) para mostrar que a defini\u00e7\u00e3o n\u00e3o est\u00e1 completa: >>> def print_lyrics(): ... print(\"I'm a lumberjack, and I'm okay.\") ... print(\"I sleep all night and I work all day.\") ... Para terminar a fun\u00e7\u00e3o, \u00e9 preciso inserir uma linha vazia. A defini\u00e7\u00e3o de uma fun\u00e7\u00e3o cria um objeto de fun\u00e7\u00e3o, que tem o tipo function: >>> print(print_lyrics) <function print_lyrics at 0xb7e99e9c> >>> type(print_lyrics) <class 'function'> A sintaxe para chamar a nova fun\u00e7\u00e3o \u00e9 a mesma que a das fun\u00e7\u00f5es integradas: >>> print_lyrics() I'm a lumberjack, and I'm okay. I sleep all night and I work all day. Uma vez que a fun\u00e7\u00e3o tenha sido definida, \u00e9 poss\u00edvel us\u00e1-la dentro de outra fun\u00e7\u00e3o. Por exemplo, para repetir o refr\u00e3o anterior, podemos escrever uma fun\u00e7\u00e3o chamada repeat_lyrics : def repeat_lyrics(): print_lyrics() print_lyrics() E da\u00ed chamar repeat_lyrics : >>> repeat_lyrics() I'm a lumberjack, and I'm okay. I sleep all night and I work all day. I'm a lumberjack, and I'm okay. I sleep all night and I work all day. Mas a can\u00e7\u00e3o n\u00e3o \u00e9 bem assim.","title":"3.4 - Como acrescentar novas fun\u00e7\u00f5es"},{"location":"03-funcoes/#35-uso-e-definicoes","text":"Juntando fragmentos de c\u00f3digo da se\u00e7\u00e3o anterior, o programa inteiro fica assim: def print_lyrics(): print(\"I'm a lumberjack, and I'm okay.\") print(\"I sleep all night and I work all day.\") def repeat_lyrics(): print_lyrics() print_lyrics() repeat_lyrics() Este programa cont\u00e9m duas defini\u00e7\u00f5es de fun\u00e7\u00e3o: print_lyrics e repeat_lyrics . As defini\u00e7\u00f5es de fun\u00e7\u00e3o s\u00e3o executadas como outras instru\u00e7\u00f5es, mas o efeito \u00e9 criar objetos de fun\u00e7\u00e3o. As instru\u00e7\u00f5es dentro da fun\u00e7\u00e3o n\u00e3o s\u00e3o executadas at\u00e9 que a fun\u00e7\u00e3o seja chamada, e a defini\u00e7\u00e3o de fun\u00e7\u00e3o n\u00e3o gera nenhuma sa\u00edda. Como poder\u00edamos esperar, \u00e9 preciso criar uma fun\u00e7\u00e3o antes de execut\u00e1-la. Em outras palavras, a defini\u00e7\u00e3o de fun\u00e7\u00e3o tem que ser executada antes que a fun\u00e7\u00e3o seja chamada. Como exerc\u00edcio, mova a \u00faltima linha deste programa para o topo, para que a chamada de fun\u00e7\u00e3o apare\u00e7a antes das defini\u00e7\u00f5es. Execute o programa e veja qual \u00e9 a mensagem de erro que aparece. Agora mova a chamada de fun\u00e7\u00e3o de volta para baixo e mova a defini\u00e7\u00e3o de print_lyrics para depois da defini\u00e7\u00e3o de repeat_lyrics . O que acontece quando este programa \u00e9 executado?","title":"3.5 - Uso e defini\u00e7\u00f5es"},{"location":"03-funcoes/#36-fluxo-de-execucao","text":"Para garantir que uma fun\u00e7\u00e3o seja definida antes do seu primeiro uso, \u00e9 preciso saber a ordem na qual as instru\u00e7\u00f5es ser\u00e3o executadas. Isso \u00e9 chamado de fluxo de execu\u00e7\u00e3o. A execu\u00e7\u00e3o sempre come\u00e7a na primeira instru\u00e7\u00e3o do programa. As instru\u00e7\u00f5es s\u00e3o executadas uma ap\u00f3s a outra, de cima para baixo. As defini\u00e7\u00f5es de fun\u00e7\u00e3o n\u00e3o alteram o fluxo da execu\u00e7\u00e3o do programa, mas lembre-se de que as instru\u00e7\u00f5es dentro da fun\u00e7\u00e3o n\u00e3o s\u00e3o executadas at\u00e9 a fun\u00e7\u00e3o ser chamada. Uma chamada de fun\u00e7\u00e3o \u00e9 como um desvio no fluxo de execu\u00e7\u00e3o. Em vez de ir \u00e0 pr\u00f3xima instru\u00e7\u00e3o, o fluxo salta para o corpo da fun\u00e7\u00e3o, executa as instru\u00e7\u00f5es l\u00e1, e ent\u00e3o volta para continuar de onde parou. Parece bastante simples, at\u00e9 voc\u00ea lembrar que uma fun\u00e7\u00e3o pode chamar outra. Enquanto estiver no meio de uma fun\u00e7\u00e3o, o programa pode ter que executar as instru\u00e7\u00f5es em outra fun\u00e7\u00e3o. Ent\u00e3o, enquanto estiver executando a nova fun\u00e7\u00e3o, o programa pode ter que executar mais uma fun\u00e7\u00e3o! Felizmente, o Python \u00e9 bom em n\u00e3o perder o fio da meada, ent\u00e3o cada vez que uma fun\u00e7\u00e3o \u00e9 conclu\u00edda, o programa continua de onde parou na fun\u00e7\u00e3o que o chamou. Quando chega no fim do programa, ele \u00e9 encerrado. Resumindo, nem sempre se deve ler um programa de cima para baixo. \u00c0s vezes faz mais sentido seguir o fluxo de execu\u00e7\u00e3o.","title":"3.6 - Fluxo de execu\u00e7\u00e3o"},{"location":"03-funcoes/#37-parametros-e-argumentos","text":"Algumas fun\u00e7\u00f5es que vimos exigem argumentos. Por exemplo, ao chamar math.sin, voc\u00ea usa um n\u00famero como argumento. Algumas fun\u00e7\u00f5es exigem mais de um argumento: o math.pow exige dois, a base e o expoente. Dentro da fun\u00e7\u00e3o, os argumentos s\u00e3o atribu\u00eddos a vari\u00e1veis chamadas par\u00e2metros. Aqui est\u00e1 a defini\u00e7\u00e3o de uma fun\u00e7\u00e3o que precisa de um argumento: def print_twice(bruce): print(bruce) print(bruce) Esta fun\u00e7\u00e3o atribui o argumento a um par\u00e2metro chamado bruce. Quando a fun\u00e7\u00e3o \u00e9 chamada, ela exibe o valor do par\u00e2metro (seja qual for) duas vezes. Esta fun\u00e7\u00e3o funciona com qualquer valor que possa ser exibido: >>> print_twice('Spam') Spam Spam >>> print_twice(42) 42 42 >>> print_twice(math.pi) 3.14159265359 3.14159265359 As mesmas regras de composi\u00e7\u00e3o usadas para fun\u00e7\u00f5es integradas tamb\u00e9m s\u00e3o aplicadas a fun\u00e7\u00f5es definidas pelos programadores, ent\u00e3o podemos usar qualquer tipo de express\u00e3o como argumento para print_twice : >>> print_twice('Spam '*4) Spam Spam Spam Spam Spam Spam Spam Spam >>> print_twice(math.cos(math.pi)) -1.0 -1.0 O argumento \u00e9 avaliado antes de a fun\u00e7\u00e3o ser chamada. Ent\u00e3o, nos exemplos, as express\u00f5es 'Spam * 4 e math.cos(math.pi) s\u00f3 s\u00e3o avaliadas uma vez. Voc\u00ea tamb\u00e9m pode usar uma vari\u00e1vel como argumento: >>> michael = 'Eric, the half a bee.' >>> print_twice(michael) Eric, the half a bee. Eric, the half a bee. O nome da vari\u00e1vel que passamos como argumento (michael) n\u00e3o tem nada a ver com o nome do par\u00e2metro (bruce). N\u00e3o importa que o valor tenha sido chamado de volta (em quem chama); aqui em print_twice , chamamos todo mundo de bruce.","title":"3.7 - Par\u00e2metros e argumentos"},{"location":"03-funcoes/#38-as-variaveis-e-os-parametros-sao-locais","text":"Quando voc\u00ea cria uma vari\u00e1vel dentro de uma fun\u00e7\u00e3o, ela \u00e9 local, ou seja, ela s\u00f3 existe dentro da fun\u00e7\u00e3o. Por exemplo: def cat_twice(part1, part2): cat = part1 + part2 print_twice(cat) Esta fun\u00e7\u00e3o recebe dois argumentos, concatena-os e exibe o resultado duas vezes. Aqui est\u00e1 um exemplo que a usa: >>> line1 = 'Bing tiddle ' >>> line2 = 'tiddle bang.' >>> cat_twice(line1, line2) Bing tiddle tiddle bang. Bing tiddle tiddle bang. Quando cat_twice \u00e9 encerrada, a vari\u00e1vel cat \u00e9 destru\u00edda. Se tentarmos exibi-la, recebemos uma exce\u00e7\u00e3o: >>> print(cat) NameError: name 'cat' is not defined Os par\u00e2metros tamb\u00e9m s\u00e3o locais. Por exemplo, al\u00e9m de print_twice, n\u00e3o existe o bruce.","title":"3.8 - As vari\u00e1veis e os par\u00e2metros s\u00e3o locais"},{"location":"03-funcoes/#39-diagrama-da-pilha","text":"Para monitorar quais vari\u00e1veis podem ser usadas e onde, \u00e9 uma boa ideia desenhar um diagrama da pilha. Assim como diagramas de estado, os diagramas da pilha mostram o valor de cada vari\u00e1vel, mas tamb\u00e9m mostram a fun\u00e7\u00e3o \u00e0 qual cada vari\u00e1vel pertence. Cada fun\u00e7\u00e3o \u00e9 representada por um frame (quadro). Um frame \u00e9 uma caixa com o nome de uma fun\u00e7\u00e3o junto a ele e os par\u00e2metros e as vari\u00e1veis da fun\u00e7\u00e3o dentro dele. O diagrama da pilha para o exemplo anterior \u00e9 exibido na Figura 3.1. Figura 3.1 \u2013 Diagrama da pilha. Os frames s\u00e3o organizados em uma pilha que indica qual fun\u00e7\u00e3o que foi chamada por outra, e assim por diante. Neste exemplo, print_twice foi chamada por cat_twice e cat_twice foi chamada por __main__ , que \u00e9 um nome especial para o frame na posi\u00e7\u00e3o mais proeminente. Quando voc\u00ea cria uma vari\u00e1vel fora de qualquer fun\u00e7\u00e3o, ela pertence a __main__ . Cada par\u00e2metro refere-se ao mesmo valor como seu argumento correspondente. Desta forma, part1 tem o mesmo valor que line1, part2 tem o mesmo valor que line2 e bruce tem o mesmo valor que cat. Se ocorrer um erro durante uma chamada de fun\u00e7\u00e3o, o Python exibe o nome da fun\u00e7\u00e3o, o nome da fun\u00e7\u00e3o que a chamou e o nome da fun\u00e7\u00e3o que chamou esta fun\u00e7\u00e3o por sua vez, voltando at\u00e9 __main__ . Por exemplo, se voc\u00ea tentar acessar cat de dentro de print_twice , receber\u00e1 uma mensagem de NameError : Traceback (innermost last): File \"test.py\", line 13, in __main__ cat_twice(line1, line2) File \"test.py\", line 5, in cat_twice print_twice(cat) File \"test.py\", line 9, in print_twice print(cat) NameError: name 'cat' is not defined Esta lista de fun\u00e7\u00f5es \u00e9 chamada de traceback. Ela mostra o arquivo do programa em que o erro ocorreu e em que linha, e quais fun\u00e7\u00f5es estavam sendo executadas no momento. Ele tamb\u00e9m mostra a linha de c\u00f3digo que causou o erro. A ordem das fun\u00e7\u00f5es no traceback \u00e9 a mesma que a ordem dos frames no diagrama da pilha. A fun\u00e7\u00e3o que est\u00e1 sendo executada no momento est\u00e1 no final.","title":"3.9 - Diagrama da pilha"},{"location":"03-funcoes/#310-funcoes-com-resultado-e-funcoes-nulas","text":"Algumas fun\u00e7\u00f5es que usamos, como as fun\u00e7\u00f5es matem\u00e1ticas, devolvem resultados; por falta de um nome melhor, vou cham\u00e1-las de fun\u00e7\u00f5es com resultados. Outras fun\u00e7\u00f5es, como print_twice, executam uma a\u00e7\u00e3o, mas n\u00e3o devolvem um valor. Elas s\u00e3o chamadas de fun\u00e7\u00f5es nulas. Quando voc\u00ea chama uma fun\u00e7\u00e3o com resultado, quase sempre quer fazer algo com o resultado; por exemplo, voc\u00ea pode atribui-lo a uma vari\u00e1vel ou us\u00e1-la como parte de uma express\u00e3o: x = math.cos(radians) golden = (math.sqrt(5) + 1) / 2 Quando voc\u00ea chama uma fun\u00e7\u00e3o no modo interativo, o Python exibe o resultado: >>> math.sqrt(5) 2.2360679774997898 Mas em um script, se voc\u00ea chamar uma fun\u00e7\u00e3o com resultado e mais nada, o valor de retorno \u00e9 perdido para sempre! math.sqrt(5) Este script calcula a raiz quadrada de 5, mas como n\u00e3o armazena ou exibe o resultado, n\u00e3o \u00e9 muito \u00fatil. As fun\u00e7\u00f5es nulas podem exibir algo na tela ou ter algum outro efeito, mas n\u00e3o t\u00eam um valor de retorno. Se voc\u00ea atribuir o resultado a uma vari\u00e1vel, recebe um valor especial chamado None: >>> result = print_twice('Bing') Bing Bing >>> print(result) None O valor None n\u00e3o \u00e9 o mesmo que a string 'None' . \u00c9 um valor especial que tem seu pr\u00f3prio tipo: >>> print(type(None)) <class 'NoneType'> As fun\u00e7\u00f5es que apresentamos por enquanto s\u00e3o todas nulas. Vamos apresentar fun\u00e7\u00f5es com resultado mais adiante.","title":"3.10 - Fun\u00e7\u00f5es com resultado e fun\u00e7\u00f5es nulas"},{"location":"03-funcoes/#311-por-que-funcoes","text":"Caso o objetivo de dividir um programa em fun\u00e7\u00f5es n\u00e3o esteja claro, saiba que na verdade h\u00e1 v\u00e1rias raz\u00f5es: Criar uma nova fun\u00e7\u00e3o d\u00e1 a oportunidade de nomear um grupo de instru\u00e7\u00f5es, o que deixa o seu programa mais f\u00e1cil de ler e de depurar. As fun\u00e7\u00f5es podem tornar um programa menor, eliminando o c\u00f3digo repetitivo. Depois, se fizer alguma altera\u00e7\u00e3o, basta faz\u00ea-la em um lugar s\u00f3. Dividir um programa longo em fun\u00e7\u00f5es permite depurar as partes uma de cada vez e ent\u00e3o reuni-las em um conjunto funcional. As fun\u00e7\u00f5es bem projetadas muitas vezes s\u00e3o \u00fateis para muitos programas. Uma vez que escreva e depure uma, voc\u00ea pode reutiliz\u00e1-la.","title":"3.11 - Por que fun\u00e7\u00f5es?"},{"location":"03-funcoes/#312-depuracao","text":"Uma das habilidades mais importantes que voc\u00ea vai aprender \u00e9 a depura\u00e7\u00e3o. Embora possa ser frustrante, a depura\u00e7\u00e3o \u00e9 uma das partes mais intelectualmente ricas, desafiadoras e interessantes da programa\u00e7\u00e3o. De certa forma, depurar \u00e9 similar ao trabalho de um detetive. Voc\u00ea tem pistas e precisa inferir os processos e eventos que levaram aos resultados exibidos. A depura\u00e7\u00e3o tamb\u00e9m \u00e9 como ci\u00eancia experimental. Uma vez que voc\u00ea tenha uma ideia sobre o que est\u00e1 errado, basta alterar o programa e tentar novamente. Se a sua hip\u00f3tese estava correta, voc\u00ea pode prever o resultado da altera\u00e7\u00e3o e chegar um passo mais perto de um programa funcional. Se a sua hip\u00f3tese estava errada, \u00e9 preciso criar outra. Como dizia Sherlock Holmes, \u201cQuando se elimina o imposs\u00edvel, o que sobra, por mais incr\u00edvel que pare\u00e7a, s\u00f3 pode ser a verdade.\u201d (A. Conan Doyle, O signo dos quatro). Para algumas pessoas, programar e depurar s\u00e3o a mesma coisa. Isto \u00e9, a programa\u00e7\u00e3o \u00e9 o processo de depurar gradualmente um programa at\u00e9 que ele fa\u00e7a o que o programador quer. A ideia \u00e9 que voc\u00ea comece com um programa funcional e fa\u00e7a pequenas altera\u00e7\u00f5es, depurando-as no decorrer do trabalho. Por exemplo, o Linux \u00e9 um sistema operacional que cont\u00e9m milh\u00f5es de linhas de c\u00f3digo, mas come\u00e7ou como um programa simples que Linus Torvalds usava para explorar o chip Intel 80386. Segundo Larry Greenfield, \u201cUm dos primeiros projetos de Linus foi um programa que alternaria entre a exibi\u00e7\u00e3o de AAAA e BBBB. Mais tarde isso se desenvolveu at\u00e9 virar o Linux.\u201d (Guia do usu\u00e1rio de Linux vers\u00e3o beta 1).","title":"3.12 - Depura\u00e7\u00e3o"},{"location":"03-funcoes/#313-glossario","text":"fun\u00e7\u00e3o Uma sequ\u00eancia nomeada de declara\u00e7\u00f5es que executa alguma opera\u00e7\u00e3o \u00fatil. As fun\u00e7\u00f5es podem receber argumentos ou n\u00e3o e podem ou n\u00e3o produzir algum resultado. defini\u00e7\u00e3o de fun\u00e7\u00e3o Uma instru\u00e7\u00e3o que cria uma fun\u00e7\u00e3o nova, especificando seu nome, par\u00e2metros e as instru\u00e7\u00f5es que cont\u00e9m. objeto da fun\u00e7\u00e3o Um valor \u00e9 criado por uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. O nome da fun\u00e7\u00e3o \u00e9 uma vari\u00e1vel que se refere a um objeto de fun\u00e7\u00e3o. cabe\u00e7alho A primeira linha de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. corpo A sequ\u00eancia de instru\u00e7\u00f5es dentro de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. par\u00e2metro Um nome usado dentro de uma fun\u00e7\u00e3o para se referir ao valor passado como argumento. chamada de fun\u00e7\u00e3o Uma instru\u00e7\u00e3o que executa uma fun\u00e7\u00e3o. \u00c9 composta pelo nome da fun\u00e7\u00e3o seguido de uma lista de argumentos entre par\u00eanteses. argumento Um valor apresentado a uma fun\u00e7\u00e3o quando a fun\u00e7\u00e3o \u00e9 chamada. Este valor \u00e9 atribu\u00eddo ao par\u00e2metro correspondente na fun\u00e7\u00e3o. vari\u00e1vel local Uma vari\u00e1vel definida dentro de uma fun\u00e7\u00e3o. Uma vari\u00e1vel local s\u00f3 pode ser usada dentro da sua fun\u00e7\u00e3o. valor de retorno O resultado de uma fun\u00e7\u00e3o. Se uma chamada de fun\u00e7\u00e3o for usada como uma express\u00e3o, o valor de retorno \u00e9 o valor da express\u00e3o. fun\u00e7\u00e3o com resultado Uma fun\u00e7\u00e3o que devolve um valor. fun\u00e7\u00e3o nula Uma fun\u00e7\u00e3o que sempre devolve None. None Um valor especial apresentado por fun\u00e7\u00f5es nulas. m\u00f3dulo Um arquivo que cont\u00e9m uma cole\u00e7\u00e3o de fun\u00e7\u00f5es relacionadas e outras defini\u00e7\u00f5es. instru\u00e7\u00e3o de importa\u00e7\u00e3o Uma instru\u00e7\u00e3o que l\u00ea um arquivo de m\u00f3dulo e cria um objeto de m\u00f3dulo. objeto de m\u00f3dulo Um valor criado por uma instru\u00e7\u00e3o import que oferece acesso aos valores definidos em um m\u00f3dulo. nota\u00e7\u00e3o de ponto A sintaxe para chamar uma fun\u00e7\u00e3o em outro m\u00f3dulo especificando o nome do m\u00f3dulo seguido de um ponto e o nome da fun\u00e7\u00e3o. composi\u00e7\u00e3o O uso de uma express\u00e3o como parte de uma express\u00e3o maior ou de uma instru\u00e7\u00e3o como parte de uma instru\u00e7\u00e3o maior. fluxo de execu\u00e7\u00e3o A ordem na qual as instru\u00e7\u00f5es s\u00e3o executadas. diagrama da pilha Representa\u00e7\u00e3o gr\u00e1fica de uma pilha de fun\u00e7\u00f5es, suas vari\u00e1veis e os valores a que se referem. frame Uma caixa em um diagrama da pilha que representa uma chamada de fun\u00e7\u00e3o. Cont\u00e9m as vari\u00e1veis locais e os par\u00e2metros da fun\u00e7\u00e3o. traceback Lista das fun\u00e7\u00f5es que est\u00e3o sendo executadas, exibidas quando ocorre uma exce\u00e7\u00e3o.","title":"3.13 - Gloss\u00e1rio"},{"location":"03-funcoes/#314-exercicios","text":"","title":"3.14 - Exerc\u00edcios"},{"location":"03-funcoes/#exercicio-31","text":"Escreva uma fun\u00e7\u00e3o chamada right_justify, que receba uma string chamada s como par\u00e2metro e exiba a string com espa\u00e7os suficientes \u00e0 frente para que a \u00faltima letra da string esteja na coluna 70 da tela: >>> right_justify('monty') monty Dica: Use concatena\u00e7\u00e3o de strings e repeti\u00e7\u00e3o. Al\u00e9m disso, o Python oferece uma fun\u00e7\u00e3o integrada chamada len, que apresenta o comprimento de uma string, ent\u00e3o o valor de len('monty') \u00e9 5.","title":"Exerc\u00edcio 3.1"},{"location":"03-funcoes/#exercicio-32","text":"Um objeto de fun\u00e7\u00e3o \u00e9 um valor que pode ser atribu\u00eddo a uma vari\u00e1vel ou passado como argumento. Por exemplo, do_twice \u00e9 uma fun\u00e7\u00e3o que toma um objeto de fun\u00e7\u00e3o como argumento e o chama duas vezes: def do_twice(f): f() f() Aqui est\u00e1 um exemplo que usa do_twice para chamar uma fun\u00e7\u00e3o chamada print_spam duas vezes: def print_spam(): print('spam') do_twice(print_spam) Digite este exemplo em um script e teste-o. Altere do_twice para que receba dois argumentos, um objeto de fun\u00e7\u00e3o e um valor, e chame a fun\u00e7\u00e3o duas vezes, passando o valor como um argumento. Copie a defini\u00e7\u00e3o de print_twice que aparece anteriormente neste cap\u00edtulo no seu script. Use a vers\u00e3o alterada de do_twice para chamar print_twice duas vezes, passando 'spam' como um argumento. Defina uma fun\u00e7\u00e3o nova chamada do_four que receba um objeto de fun\u00e7\u00e3o e um valor e chame a fun\u00e7\u00e3o quatro vezes, passando o valor como um par\u00e2metro. Deve haver s\u00f3 duas afirma\u00e7\u00f5es no corpo desta fun\u00e7\u00e3o, n\u00e3o quatro. Solu\u00e7\u00e3o: http://thinkpython2.com/code/do_four.py.","title":"Exerc\u00edcio 3.2"},{"location":"03-funcoes/#exercicio-33","text":"Nota: Este exerc\u00edcio deve ser feito usando-se apenas as instru\u00e7\u00f5es e os outros recursos que aprendemos at\u00e9 agora. Escreva uma fun\u00e7\u00e3o que desenhe uma grade como a seguinte: + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + Dica: para exibir mais de um valor em uma linha, podemos usar uma sequ\u00eancia de valores separados por v\u00edrgula: python print('+', '-') Por padr\u00e3o, print avan\u00e7a para a linha seguinte, mas podemos ignorar esse comportamento e inserir um espa\u00e7o no fim, desta forma: python print('+', end=' ') print('-') A sa\u00edda dessas instru\u00e7\u00f5es \u00e9 + - . Uma instru\u00e7\u00e3o print sem argumento termina a linha atual e vai para a pr\u00f3xima linha. Escreva uma fun\u00e7\u00e3o que desenhe uma grade semelhante com quatro linhas e quatro colunas. Solu\u00e7\u00e3o: http://thinkpython2.com/code/grid.py. Cr\u00e9dito: Este exerc\u00edcio \u00e9 baseado em outro apresentado por Oualline, em Practical C Programming, Third Edition, O\u2019Reilly Media, 1997.","title":"Exerc\u00edcio 3.3"},{"location":"04-caso-interface/","text":"Cap\u00edtulo 4: Estudo de caso: projeto de interface Este cap\u00edtulo apresenta um estudo de caso que demonstra o processo de cria\u00e7\u00e3o de fun\u00e7\u00f5es que operam simultaneamente. Ele apresenta o m\u00f3dulo turtle, que permite criar imagens usando [ turtle graphics ][1]. O m\u00f3dulo turtle \u00e9 inclu\u00eddo na maior parte das instala\u00e7\u00f5es do Python, mas se estiver executando a linguagem com o PythonAnywhere voc\u00ea n\u00e3o poder\u00e1 executar os exemplos do turtle (pelo menos n\u00e3o era poss\u00edvel quando escrevi este livro). Se j\u00e1 tiver instalado o Python no seu computador, voc\u00ea poder\u00e1 executar os exemplos. Caso n\u00e3o, agora \u00e9 uma boa hora para instalar. Publiquei instru\u00e7\u00f5es no site http://tinyurl.com/thinkpython2e. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/polygon.py. 4.1 - M\u00f3dulo turtle Para conferir se voc\u00ea tem o m\u00f3dulo turtle, abra o interpretador do Python e digite: >>> import turtle >>> bob = turtle.Turtle() Ao executar este c\u00f3digo o programa deve abrir uma nova janela com uma pequena flecha que representa o turtle. Feche a janela. Crie um arquivo chamado mypolygon.py e digite o seguinte c\u00f3digo: import turtle bob = turtle.Turtle() print(bob) turtle.mainloop() O m\u00f3dulo turtle (com t min\u00fasculo) apresenta uma fun\u00e7\u00e3o chamada Turtle (com T mai\u00fasculo), que cria um objeto Turtle, ao qual atribu\u00edmos uma vari\u00e1vel chamada bob. Exibir bob faz algo assim: <turtle.Turtle object at 0xb7bfbf4c> Isto significa que bob se refere a um objeto com o tipo Turtle definido no m\u00f3dulo turtle. mainloop diz que a janela deve esperar que o usu\u00e1rio fa\u00e7a algo, embora neste caso n\u00e3o haja muito a fazer, exceto fechar a janela. Uma vez que tenha criado o Turtle, voc\u00ea pode chamar um m\u00e9todo para mov\u00ea-lo pela janela. M\u00e9todo \u00e9 semelhante a uma fun\u00e7\u00e3o, mas usa uma sintaxe ligeiramente diferente. Por exemplo, para mover o turtle para a frente: bob.fd(100) O m\u00e9todo fd \u00e9 associado com o objeto turtle, que denominamos bob. Chamar de um m\u00e9todo \u00e9 como fazer um pedido: voc\u00ea est\u00e1 pedindo que bob avance. O argumento de fd \u00e9 uma dist\u00e2ncia em p\u00edxeis, ent\u00e3o o tamanho real depende da sua tela. Outros m\u00e9todos que voc\u00ea pode chamar em um Turtle s\u00e3o bk para mover-se para tr\u00e1s, lt para virar \u00e0 esquerda e rt para virar \u00e0 direita. O argumento para lt e rt \u00e9 um \u00e2ngulo em graus. Al\u00e9m disso, cada Turtle segura uma caneta, que est\u00e1 abaixada ou levantada; se a caneta estiver abaixada, o Turtle deixa um rastro quando se move. Os m\u00e9todos pu e pd representam \u201ccaneta para cima\u201d e \u201ccaneta para baixo\u201d. Para desenhar um \u00e2ngulo reto, acrescente estas linhas ao programa (depois de criar bob e antes de chamar o mainloop): bob.fd(100) bob.lt(90) bob.fd(100) Ao executar este programa, voc\u00ea deveria ver bob mover-se para o leste e depois para o norte, deixando dois segmentos de reta para tr\u00e1s. Agora altere o programa para desenhar um quadrado. S\u00f3 siga adiante neste cap\u00edtulo se ele funcionar adequadamente! 4.2 - Repeti\u00e7\u00e3o simples Provavelmente voc\u00ea escreveu algo assim: bob.fd(100) bob.lt(90) bob.fd(100) bob.lt(90) bob.fd(100) bob.lt(90) bob.fd(100) Podemos fazer a mesma coisa de forma mais concisa com uma instru\u00e7\u00e3o for. Acrescente este exemplo a mypolygon.py e execute-o novamente: for i in range(4): print('Hello!') Voc\u00ea deve ver algo assim: Hello! Hello! Hello! Hello! Este \u00e9 o uso mais simples da instru\u00e7\u00e3o for; depois veremos mais sobre isso. Mas isso deve ser o suficiente para que voc\u00ea possa reescrever o seu programa de desenhar quadrados. N\u00e3o continue a leitura at\u00e9 que d\u00ea certo. Aqui est\u00e1 uma instru\u00e7\u00e3o for que desenha um quadrado: for i in range(4): bob.fd(100) bob.lt(90) A sintaxe de uma instru\u00e7\u00e3o for \u00e9 semelhante \u00e0 defini\u00e7\u00e3o de uma fun\u00e7\u00e3o. Tem um cabe\u00e7alho que termina em dois pontos e um corpo endentado. O corpo pode conter qualquer n\u00famero de instru\u00e7\u00f5es. Uma instru\u00e7\u00e3o for tamb\u00e9m \u00e9 chamada de loop porque o fluxo da execu\u00e7\u00e3o passa pelo corpo e depois volta ao topo. Neste caso, ele passa pelo corpo quatro vezes. Esta vers\u00e3o, na verdade, \u00e9 um pouco diferente do c\u00f3digo anterior que desenha quadrados porque faz outra volta depois de desenhar o \u00faltimo lado do quadrado. A volta extra leva mais tempo, mas simplifica o c\u00f3digo se fizermos a mesma coisa a cada vez pelo loop. Esta vers\u00e3o tamb\u00e9m tem o efeito de trazer o turtle de volta \u00e0 posi\u00e7\u00e3o inicial, de frente para a mesma dire\u00e7\u00e3o em que estava. 4.3 - Exerc\u00edcios A seguir, uma s\u00e9rie de exerc\u00edcios usando TurtleWorld. Eles servem para divertir, mas tamb\u00e9m t\u00eam outro objetivo. Enquanto trabalha neles, pense que objetivo pode ser. As se\u00e7\u00f5es seguintes t\u00eam as solu\u00e7\u00f5es para os exerc\u00edcios, mas n\u00e3o olhe at\u00e9 que tenha terminado (ou, pelo menos, tentado). Escreva uma fun\u00e7\u00e3o chamada square que receba um par\u00e2metro chamado t, que \u00e9 um turtle. Ela deve usar o turtle para desenhar um quadrado. Escreva uma chamada de fun\u00e7\u00e3o que passe bob como um argumento para o square e ent\u00e3o execute o programa novamente. Acrescente outro par\u00e2metro, chamado length, ao square. Altere o corpo para que o comprimento dos lados seja length e ent\u00e3o altere a chamada da fun\u00e7\u00e3o para fornecer um segundo argumento. Execute o programa novamente. Teste o seu programa com uma variedade de valores para length. Fa\u00e7a uma c\u00f3pia do square e mude o nome para polygon. Acrescente outro par\u00e2metro chamado n e altere o corpo para que desenhe um pol\u00edgono regular de n lados. Dica: os \u00e2ngulos exteriores de um pol\u00edgono regular de n lados s\u00e3o 360/n graus. Escreva uma fun\u00e7\u00e3o chamada circle que use o turtle, t e um raio r como par\u00e2metros e desenhe um c\u00edrculo aproximado ao chamar polygon com um comprimento e n\u00famero de lados adequados. Teste a sua fun\u00e7\u00e3o com uma s\u00e9rie de valores de r. Dica: descubra a circunfer\u00eancia do c\u00edrculo e certifique-se de que length * n = circumference. Fa\u00e7a uma vers\u00e3o mais geral do circle chamada arc, que receba um par\u00e2metro adicional de angle, para determinar qual fra\u00e7\u00e3o do c\u00edrculo deve ser desenhada. angle est\u00e1 em unidades de graus, ent\u00e3o quando angle=360, o arc deve desenhar um c\u00edrculo completo. 4.4 - Encapsulamento O primeiro exerc\u00edcio pede que voc\u00ea ponha seu c\u00f3digo para desenhar quadrados em uma defini\u00e7\u00e3o de fun\u00e7\u00e3o e ent\u00e3o chame a fun\u00e7\u00e3o, passando o turtle como par\u00e2metro. Aqui est\u00e1 uma solu\u00e7\u00e3o: def square(t): for i in range(4): t.fd(100) t.lt(90) square(bob) As instru\u00e7\u00f5es mais internas, fd e lt, s\u00e3o endentadas duas vezes para mostrar que est\u00e3o dentro do loop for, que est\u00e1 dentro da defini\u00e7\u00e3o da fun\u00e7\u00e3o. A linha seguinte, square(bob), est\u00e1 alinhada \u00e0 margem esquerda, o que indica tanto o fim do loop for como da defini\u00e7\u00e3o de fun\u00e7\u00e3o. Dentro da fun\u00e7\u00e3o, o t indica o mesmo turtle bob, ent\u00e3o t.lt (90) tem o mesmo efeito que bob.lt (90). Neste caso, por que n\u00e3o chamar o par\u00e2metro bob? A ideia \u00e9 que t pode ser qualquer turtle, n\u00e3o apenas bob, ent\u00e3o voc\u00ea pode criar um segundo turtle e pass\u00e1-lo como argumento ao square: alice = turtle.Turtle() square(alice) Incluir uma parte do c\u00f3digo em uma fun\u00e7\u00e3o chama-se encapsulamento. Um dos benef\u00edcios do encapsulamento \u00e9 que ele atribui um nome ao c\u00f3digo, o que serve como uma esp\u00e9cie de documenta\u00e7\u00e3o. Outra vantagem \u00e9 que se voc\u00ea reutilizar o c\u00f3digo, \u00e9 mais conciso chamar uma fun\u00e7\u00e3o duas vezes que copiar e colar o corpo! 4.5 - Generaliza\u00e7\u00e3o O pr\u00f3ximo passo \u00e9 acrescentar um par\u00e2metro length ao square. Aqui est\u00e1 uma solu\u00e7\u00e3o: def square(t, length): for i in range(4): t.fd(length) t.lt(90) square(bob, 100) Acrescentar um par\u00e2metro a uma fun\u00e7\u00e3o chama-se generaliza\u00e7\u00e3o porque ele torna a fun\u00e7\u00e3o mais geral: na vers\u00e3o anterior, o quadrado \u00e9 sempre do mesmo tamanho; nesta vers\u00e3o, pode ser de qualquer tamanho. O pr\u00f3ximo passo tamb\u00e9m \u00e9 uma generaliza\u00e7\u00e3o. Em vez de desenhar quadrados, polygon desenha pol\u00edgonos regulares com qualquer n\u00famero de lados. Aqui est\u00e1 uma solu\u00e7\u00e3o: def polygon(t, n, length): angle = 360 / n for i in range(n): t.fd(length) t.lt(angle) polygon(bob, 7, 70) Este exemplo desenha um pol\u00edgono de 7 lados, cada um de comprimento 70. Se estiver usando Python 2, o valor do angle poderia estar errado por causa da divis\u00e3o de n\u00famero inteiro. Uma solu\u00e7\u00e3o simples \u00e9 calcular angle = 360.0 / n. Como o numerador \u00e9 um n\u00famero de ponto flutuante, o resultado \u00e9 em ponto flutuante. Quando uma fun\u00e7\u00e3o tem v\u00e1rios argumentos num\u00e9ricos, \u00e9 f\u00e1cil esquecer o que eles s\u00e3o ou a ordem na qual eles devem estar. Neste caso, muitas vezes \u00e9 uma boa ideia incluir os nomes dos par\u00e2metros na lista de argumentos: polygon (bob, n=7, length=70) Esses s\u00e3o os argumentos de palavra-chave porque incluem os nomes dos par\u00e2metros como \u201cpalavras-chave\u201d (para n\u00e3o confundir com palavras-chave do Python, tais como while e def). Esta sintaxe torna o programa mais leg\u00edvel. Tamb\u00e9m \u00e9 uma lembran\u00e7a sobre como os argumentos e os par\u00e2metros funcionam: quando voc\u00ea chama uma fun\u00e7\u00e3o, os argumentos s\u00e3o atribu\u00eddos aos par\u00e2metros. 4.6 - Projeto da interface O pr\u00f3ximo passo \u00e9 escrever circle, que recebe um raio r, como par\u00e2metro. Aqui est\u00e1 uma solu\u00e7\u00e3o simples que usa o polygon para desenhar um pol\u00edgono de 50 lados: import math def circle(t, r): circumference = 2 * math.pi * r n = 50 length = circumference / n polygon(t, n, length) A primeira linha calcula a circunfer\u00eancia de um c\u00edrculo com o raio r usando a f\u00f3rmula 2\u03c0r. J\u00e1 que usamos math.pi, temos que importar math. Por conven\u00e7\u00e3o, instru\u00e7\u00f5es import normalmente ficam no in\u00edcio do script. n \u00e9 o n\u00famero de segmentos de reta na nossa aproxima\u00e7\u00e3o de um c\u00edrculo, ent\u00e3o length \u00e9 o comprimento de cada segmento. Assim, polygon desenha um pol\u00edgono 50 lados que se aproxima de um c\u00edrculo com o raio r. Uma limita\u00e7\u00e3o desta solu\u00e7\u00e3o \u00e9 que n \u00e9 uma constante. Para c\u00edrculos muito grandes, os segmentos de reta s\u00e3o longos demais, e para c\u00edrculos pequenos, perdemos tempo desenhando segmentos muito pequenos. Uma solu\u00e7\u00e3o seria generalizar a fun\u00e7\u00e3o tomando n como par\u00e2metro. Isso daria ao usu\u00e1rio (seja quem for que chame circle) mais controle, mas a interface seria menos limpa. A interface de uma fun\u00e7\u00e3o \u00e9 um resumo de como ela \u00e9 usada: Quais s\u00e3o os par\u00e2metros? O que a fun\u00e7\u00e3o faz? E qual \u00e9 o valor de retorno? Uma interface \u00e9 \u201climpa\u201d se permitir \u00e0 pessoa que a chama fazer o que quiser sem ter que lidar com detalhes desnecess\u00e1rios. Neste exemplo, r pertence \u00e0 interface porque especifica o c\u00edrculo a ser desenhado. n \u00e9 menos adequado porque pertence aos detalhes de como o c\u00edrculo deve ser apresentado. Em vez de poluir a interface, \u00e9 melhor escolher um valor adequado para n, dependendo da circumference: def circle(t, r): circumference = 2 * math.pi * r n = int(circumference / 3) + 1 length = circumference / n polygon(t, n, length) Neste ponto, o n\u00famero de segmentos \u00e9 um n\u00famero inteiro pr\u00f3ximo a circumference/3, ent\u00e3o o comprimento de cada segmento \u00e9 aproximadamente 3, pequeno o suficiente para que os c\u00edrculos fiquem bons, mas grandes o suficiente para serem eficientes e aceit\u00e1veis para c\u00edrculos de qualquer tamanho. 4.7 - Refatora\u00e7\u00e3o Quando escrevi circle, pude reutilizar polygon porque um pol\u00edgono de muitos lados \u00e9 uma boa aproxima\u00e7\u00e3o de um c\u00edrculo. Mas o arc n\u00e3o \u00e9 t\u00e3o cooperativo; n\u00e3o podemos usar polygon ou circle para desenhar um arco. Uma alternativa \u00e9 come\u00e7ar com uma c\u00f3pia de polygon e transform\u00e1-la em arc. O resultado poderia ser algo assim: def arc(t, r, angle): arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n for i in range(n): t.fd(step_length) t.lt(step_angle) A segunda metade desta fun\u00e7\u00e3o parece com a do polygon, mas n\u00e3o \u00e9 poss\u00edvel reutilizar o polygon sem mudar a interface. Poder\u00edamos generalizar polygon para receber um \u00e2ngulo como um terceiro argumento, mas ent\u00e3o polygon n\u00e3o seria mais um nome adequado! Em vez disso, vamos chamar a fun\u00e7\u00e3o mais geral de polyline: def polyline(t, n, length, angle): for i in range(n): t.fd(length) t.lt(angle) Agora podemos reescrever polygon e arc para usar polyline: def polygon(t, n, length): angle = 360.0 / n polyline(t, n, length, angle) def arc(t, r, angle): arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = float(angle) / n polyline(t, n, step_length, step_angle) Finalmente, podemos reescrever circle para usar arc: def circle(t, r): arc(t, r, 360) Este processo \u2013 recompor um programa para melhorar interfaces e facilitar a reutiliza\u00e7\u00e3o do c\u00f3digo \u2013 \u00e9 chamado de refatora\u00e7\u00e3o. Neste caso, notamos que houve c\u00f3digo semelhante em arc e polygon, ent\u00e3o n\u00f3s o \u201cfatoramos\u201d no polyline. Se tiv\u00e9ssemos planejado, poder\u00edamos ter escrito polyline primeiro e evitado a refatora\u00e7\u00e3o, mas muitas vezes n\u00e3o sabemos o suficiente j\u00e1 no in\u00edcio de um projeto para projetar todas as interfaces. Quando come\u00e7armos a escrever c\u00f3digo, entenderemos melhor o problema. \u00c0s vezes, a refatora\u00e7\u00e3o \u00e9 um sinal de que aprendemos algo. 4.8 - Um plano de desenvolvimento Um plano de desenvolvimento \u00e9 um processo para escrever programas. O processo que usamos neste estudo de caso \u00e9 \u201cencapsulamento e generaliza\u00e7\u00e3o\u201d. Os passos deste processo s\u00e3o: Comece escrevendo um pequeno programa sem defini\u00e7\u00f5es de fun\u00e7\u00e3o. Uma vez que o programa esteja funcionando, identifique uma parte coerente dele, encapsule essa parte em uma fun\u00e7\u00e3o e d\u00ea um nome a ela. Generalize a fun\u00e7\u00e3o acrescentando os par\u00e2metros adequados. Repita os passos 1-3 at\u00e9 que tenha um conjunto de fun\u00e7\u00f5es operantes. Copie e cole o c\u00f3digo operante para evitar a redigita\u00e7\u00e3o (e redepura\u00e7\u00e3o). Procure oportunidades de melhorar o programa pela refatora\u00e7\u00e3o. Por exemplo, se voc\u00ea tem um c\u00f3digo semelhante em v\u00e1rios lugares, pode ser uma boa ideia fator\u00e1-lo em uma fun\u00e7\u00e3o geral adequada. Este processo tem algumas desvantagens \u2013 veremos alternativas mais tarde \u2013 mas pode ser \u00fatil se voc\u00ea n\u00e3o souber de antem\u00e3o como dividir o programa em fun\u00e7\u00f5es. Esta abordagem permite criar o projeto no decorrer do trabalho. 4.9 - docstring Uma docstring \u00e9 uma string no in\u00edcio de uma fun\u00e7\u00e3o que explica a interface (\u201cdoc\u201d \u00e9 uma abrevia\u00e7\u00e3o para \u201cdocumenta\u00e7\u00e3o\u201d). Aqui est\u00e1 um exemplo: def polyline(t, n, length, angle): \"\"\"Desenha n segmentos de reta com o comprimento dado e \u00e2ngulo (em graus) entre eles. t \u00e9 um turtle. \"\"\" for i in range(n): t.fd(length) t.lt(angle) Por conven\u00e7\u00e3o, todas as docstrings t\u00eam aspas triplas, tamb\u00e9m conhecidas como strings multilinha porque as aspas triplas permitem que a string se estenda por mais de uma linha. \u00c9 conciso, mas cont\u00e9m a informa\u00e7\u00e3o essencial que algu\u00e9m precisaria para usar esta fun\u00e7\u00e3o. Explica sucintamente o que a fun\u00e7\u00e3o faz (sem entrar nos detalhes de como o faz). Explica que efeito cada par\u00e2metro tem sobre o comportamento da fun\u00e7\u00e3o e o tipo que cada par\u00e2metro deve ser (se n\u00e3o for \u00f3bvio). Escrever este tipo de documenta\u00e7\u00e3o \u00e9 uma parte importante do projeto da interface. Uma interface bem projetada deve ser simples de explicar; se n\u00e3o for assim, talvez a interface possa ser melhorada. 4.10 - Depura\u00e7\u00e3o Uma interface \u00e9 como um contrato entre uma fun\u00e7\u00e3o e quem a chama. Quem chama concorda em fornecer certos par\u00e2metros e a fun\u00e7\u00e3o concorda em fazer certa a\u00e7\u00e3o. Por exemplo, polyline precisa de quatro argumentos: t tem que ser um Turtle; n tem que ser um n\u00famero inteiro; length deve ser um n\u00famero positivo; e o angle tem que ser um n\u00famero, que se espera estar em graus. Essas exig\u00eancias s\u00e3o chamadas de precondi\u00e7\u00f5es porque se sup\u00f5e que sejam verdade antes que a fun\u00e7\u00e3o seja executada. De forma inversa, as condi\u00e7\u00f5es no fim da fun\u00e7\u00e3o s\u00e3o p\u00f3s-condi\u00e7\u00f5es. As p\u00f3s-condi\u00e7\u00f5es incluem o efeito desejado da fun\u00e7\u00e3o (como o desenho de segmentos de reta) e qualquer efeito colateral (como mover o Turtle ou fazer outras mudan\u00e7as). Precondi\u00e7\u00f5es s\u00e3o responsabilidade de quem chama. Se quem chama violar uma precondi\u00e7\u00e3o (adequadamente documentada!) e a fun\u00e7\u00e3o n\u00e3o funcionar corretamente, o problema est\u00e1 nesta pessoa, n\u00e3o na fun\u00e7\u00e3o. Se as precondi\u00e7\u00f5es forem satisfeitas e as p\u00f3s-condi\u00e7\u00f5es n\u00e3o forem, o problema est\u00e1 na fun\u00e7\u00e3o. Se as suas precondi\u00e7\u00f5es e p\u00f3s-condi\u00e7\u00f5es forem claras, elas podem ajudar na depura\u00e7\u00e3o. 4.11 - Gloss\u00e1rio m\u00e9todo Uma fun\u00e7\u00e3o associada a um objeto e chamada usando a nota\u00e7\u00e3o de ponto. loop Parte de um programa que pode ser executada repetidamente. encapsulamento O processo de transformar uma sequ\u00eancia de instru\u00e7\u00f5es em uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. generaliza\u00e7\u00e3o O processo de substituir algo desnecessariamente espec\u00edfico (como um n\u00famero) por algo adequadamente geral (como uma vari\u00e1vel ou par\u00e2metro). argumento de palavra-chave Um argumento que inclui o nome do par\u00e2metro como uma \u201cpalavra-chave\u201d. interface Uma descri\u00e7\u00e3o de como usar uma fun\u00e7\u00e3o, incluindo o nome e as descri\u00e7\u00f5es dos argumentos e do valor de retorno. refatora\u00e7\u00e3o O processo de alterar um programa funcional para melhorar a interface de fun\u00e7\u00f5es e outras qualidades do c\u00f3digo. plano de desenvolvimento Um processo de escrever programas. docstring Uma string que aparece no in\u00edcio de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o para documentar a interface da fun\u00e7\u00e3o. precondi\u00e7\u00e3o Uma exig\u00eancia que deve ser satisfeita por quem chama a fun\u00e7\u00e3o, antes de execut\u00e1-la. p\u00f3s-condi\u00e7\u00e3o Uma exig\u00eancia que deve ser satisfeita pela fun\u00e7\u00e3o antes que ela seja encerrada. 4.12 - Exerc\u00edcios Exerc\u00edcio 4.1 Baixe o c\u00f3digo deste cap\u00edtulo no site http://thinkpython2.com/code/polygon.py. Desenhe um diagrama da pilha que mostre o estado do programa enquanto executa circle (bob, radius). Voc\u00ea pode fazer a aritm\u00e9tica \u00e0 m\u00e3o ou acrescentar instru\u00e7\u00f5es print ao c\u00f3digo. A vers\u00e3o de arc na se\u00e7\u00e3o 4.7 - Refatora\u00e7\u00e3o n\u00e3o \u00e9 muito precisa porque a aproxima\u00e7\u00e3o linear do c\u00edrculo est\u00e1 sempre do lado de fora do c\u00edrculo verdadeiro. Consequentemente, o Turtle acaba ficando alguns p\u00edxeis de dist\u00e2ncia do destino correto. Minha solu\u00e7\u00e3o mostra um modo de reduzir o efeito deste erro. Leia o c\u00f3digo e veja se faz sentido para voc\u00ea. Se desenhar um diagrama, poder\u00e1 ver como funciona. Exerc\u00edcio 4.2 Escreva um conjunto de fun\u00e7\u00f5es adequadamente geral que possa desenhar flores como as da Figura 4.1. Figura 4.1 \u2013 Flores de tartaruga. Solu\u00e7\u00e3o: http://thinkpython2.com/code/flower.py, tamb\u00e9m exige http://thinkpython2.com/code/polygon.py. Exerc\u00edcio 4.3 Escreva um conjunto de fun\u00e7\u00f5es adequadamente geral que possa desenhar formas como as da Figura 4.2. Figura 4.2 \u2013 Tortas de tartaruga. Solu\u00e7\u00e3o: http://thinkpython2.com/code/pie.py. Exerc\u00edcio 4.4 As letras do alfabeto podem ser constru\u00eddas a partir de um n\u00famero moderado de elementos b\u00e1sicos, como linhas verticais e horizontais e algumas curvas. Crie um alfabeto que possa ser desenhado com um n\u00famero m\u00ednimo de elementos b\u00e1sicos e ent\u00e3o escreva fun\u00e7\u00f5es que desenhem as letras. Voc\u00ea deve escrever uma fun\u00e7\u00e3o para cada letra, com os nomes draw_a, draw_b etc., e colocar suas fun\u00e7\u00f5es em um arquivo chamado letters.py. Voc\u00ea pode baixar uma \u201cm\u00e1quina de escrever de turtle\u201d no site http://thinkpython2.com/code/typewriter.py para ajudar a testar o seu c\u00f3digo. Voc\u00ea pode ver uma solu\u00e7\u00e3o no site http://thinkpython2.com/code/letters.py; ela tamb\u00e9m exige http://thinkpython2.com/code/polygon.py. Exerc\u00edcio 4.5 Leia sobre espirais em https://pt.wikipedia.org/wiki/Espiral; ent\u00e3o escreva um programa que desenhe uma espiral de Arquimedes (ou um dos outros tipos). [1] turtle graphics ou gr\u00e1ficos de tartaruga \u00e9 o sistema de desenho popularizado pela linguagem Logo, onde os comandos movimentam um cursor triangular pela tela, conhecido como turtle ou tartaruga. A tartaruga deixa um rastro \u00e0 medida que \u00e9 movimentada, e \u00e9 com esses rastros que se forma um desenho. Diferente dos sistemas usuais de desenho em computa\u00e7\u00e3o gr\u00e1fica, o sistema turtle graphics n\u00e3o exige o uso de coordenadas cartesianas.","title":"Cap\u00edtulo 4: Estudo de caso: projeto de interface"},{"location":"04-caso-interface/#capitulo-4-estudo-de-caso-projeto-de-interface","text":"Este cap\u00edtulo apresenta um estudo de caso que demonstra o processo de cria\u00e7\u00e3o de fun\u00e7\u00f5es que operam simultaneamente. Ele apresenta o m\u00f3dulo turtle, que permite criar imagens usando [ turtle graphics ][1]. O m\u00f3dulo turtle \u00e9 inclu\u00eddo na maior parte das instala\u00e7\u00f5es do Python, mas se estiver executando a linguagem com o PythonAnywhere voc\u00ea n\u00e3o poder\u00e1 executar os exemplos do turtle (pelo menos n\u00e3o era poss\u00edvel quando escrevi este livro). Se j\u00e1 tiver instalado o Python no seu computador, voc\u00ea poder\u00e1 executar os exemplos. Caso n\u00e3o, agora \u00e9 uma boa hora para instalar. Publiquei instru\u00e7\u00f5es no site http://tinyurl.com/thinkpython2e. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/polygon.py.","title":"Cap\u00edtulo 4: Estudo de caso: projeto de interface"},{"location":"04-caso-interface/#41-modulo-turtle","text":"Para conferir se voc\u00ea tem o m\u00f3dulo turtle, abra o interpretador do Python e digite: >>> import turtle >>> bob = turtle.Turtle() Ao executar este c\u00f3digo o programa deve abrir uma nova janela com uma pequena flecha que representa o turtle. Feche a janela. Crie um arquivo chamado mypolygon.py e digite o seguinte c\u00f3digo: import turtle bob = turtle.Turtle() print(bob) turtle.mainloop() O m\u00f3dulo turtle (com t min\u00fasculo) apresenta uma fun\u00e7\u00e3o chamada Turtle (com T mai\u00fasculo), que cria um objeto Turtle, ao qual atribu\u00edmos uma vari\u00e1vel chamada bob. Exibir bob faz algo assim: <turtle.Turtle object at 0xb7bfbf4c> Isto significa que bob se refere a um objeto com o tipo Turtle definido no m\u00f3dulo turtle. mainloop diz que a janela deve esperar que o usu\u00e1rio fa\u00e7a algo, embora neste caso n\u00e3o haja muito a fazer, exceto fechar a janela. Uma vez que tenha criado o Turtle, voc\u00ea pode chamar um m\u00e9todo para mov\u00ea-lo pela janela. M\u00e9todo \u00e9 semelhante a uma fun\u00e7\u00e3o, mas usa uma sintaxe ligeiramente diferente. Por exemplo, para mover o turtle para a frente: bob.fd(100) O m\u00e9todo fd \u00e9 associado com o objeto turtle, que denominamos bob. Chamar de um m\u00e9todo \u00e9 como fazer um pedido: voc\u00ea est\u00e1 pedindo que bob avance. O argumento de fd \u00e9 uma dist\u00e2ncia em p\u00edxeis, ent\u00e3o o tamanho real depende da sua tela. Outros m\u00e9todos que voc\u00ea pode chamar em um Turtle s\u00e3o bk para mover-se para tr\u00e1s, lt para virar \u00e0 esquerda e rt para virar \u00e0 direita. O argumento para lt e rt \u00e9 um \u00e2ngulo em graus. Al\u00e9m disso, cada Turtle segura uma caneta, que est\u00e1 abaixada ou levantada; se a caneta estiver abaixada, o Turtle deixa um rastro quando se move. Os m\u00e9todos pu e pd representam \u201ccaneta para cima\u201d e \u201ccaneta para baixo\u201d. Para desenhar um \u00e2ngulo reto, acrescente estas linhas ao programa (depois de criar bob e antes de chamar o mainloop): bob.fd(100) bob.lt(90) bob.fd(100) Ao executar este programa, voc\u00ea deveria ver bob mover-se para o leste e depois para o norte, deixando dois segmentos de reta para tr\u00e1s. Agora altere o programa para desenhar um quadrado. S\u00f3 siga adiante neste cap\u00edtulo se ele funcionar adequadamente!","title":"4.1 - M\u00f3dulo turtle"},{"location":"04-caso-interface/#42-repeticao-simples","text":"Provavelmente voc\u00ea escreveu algo assim: bob.fd(100) bob.lt(90) bob.fd(100) bob.lt(90) bob.fd(100) bob.lt(90) bob.fd(100) Podemos fazer a mesma coisa de forma mais concisa com uma instru\u00e7\u00e3o for. Acrescente este exemplo a mypolygon.py e execute-o novamente: for i in range(4): print('Hello!') Voc\u00ea deve ver algo assim: Hello! Hello! Hello! Hello! Este \u00e9 o uso mais simples da instru\u00e7\u00e3o for; depois veremos mais sobre isso. Mas isso deve ser o suficiente para que voc\u00ea possa reescrever o seu programa de desenhar quadrados. N\u00e3o continue a leitura at\u00e9 que d\u00ea certo. Aqui est\u00e1 uma instru\u00e7\u00e3o for que desenha um quadrado: for i in range(4): bob.fd(100) bob.lt(90) A sintaxe de uma instru\u00e7\u00e3o for \u00e9 semelhante \u00e0 defini\u00e7\u00e3o de uma fun\u00e7\u00e3o. Tem um cabe\u00e7alho que termina em dois pontos e um corpo endentado. O corpo pode conter qualquer n\u00famero de instru\u00e7\u00f5es. Uma instru\u00e7\u00e3o for tamb\u00e9m \u00e9 chamada de loop porque o fluxo da execu\u00e7\u00e3o passa pelo corpo e depois volta ao topo. Neste caso, ele passa pelo corpo quatro vezes. Esta vers\u00e3o, na verdade, \u00e9 um pouco diferente do c\u00f3digo anterior que desenha quadrados porque faz outra volta depois de desenhar o \u00faltimo lado do quadrado. A volta extra leva mais tempo, mas simplifica o c\u00f3digo se fizermos a mesma coisa a cada vez pelo loop. Esta vers\u00e3o tamb\u00e9m tem o efeito de trazer o turtle de volta \u00e0 posi\u00e7\u00e3o inicial, de frente para a mesma dire\u00e7\u00e3o em que estava.","title":"4.2 - Repeti\u00e7\u00e3o simples"},{"location":"04-caso-interface/#43-exercicios","text":"A seguir, uma s\u00e9rie de exerc\u00edcios usando TurtleWorld. Eles servem para divertir, mas tamb\u00e9m t\u00eam outro objetivo. Enquanto trabalha neles, pense que objetivo pode ser. As se\u00e7\u00f5es seguintes t\u00eam as solu\u00e7\u00f5es para os exerc\u00edcios, mas n\u00e3o olhe at\u00e9 que tenha terminado (ou, pelo menos, tentado). Escreva uma fun\u00e7\u00e3o chamada square que receba um par\u00e2metro chamado t, que \u00e9 um turtle. Ela deve usar o turtle para desenhar um quadrado. Escreva uma chamada de fun\u00e7\u00e3o que passe bob como um argumento para o square e ent\u00e3o execute o programa novamente. Acrescente outro par\u00e2metro, chamado length, ao square. Altere o corpo para que o comprimento dos lados seja length e ent\u00e3o altere a chamada da fun\u00e7\u00e3o para fornecer um segundo argumento. Execute o programa novamente. Teste o seu programa com uma variedade de valores para length. Fa\u00e7a uma c\u00f3pia do square e mude o nome para polygon. Acrescente outro par\u00e2metro chamado n e altere o corpo para que desenhe um pol\u00edgono regular de n lados. Dica: os \u00e2ngulos exteriores de um pol\u00edgono regular de n lados s\u00e3o 360/n graus. Escreva uma fun\u00e7\u00e3o chamada circle que use o turtle, t e um raio r como par\u00e2metros e desenhe um c\u00edrculo aproximado ao chamar polygon com um comprimento e n\u00famero de lados adequados. Teste a sua fun\u00e7\u00e3o com uma s\u00e9rie de valores de r. Dica: descubra a circunfer\u00eancia do c\u00edrculo e certifique-se de que length * n = circumference. Fa\u00e7a uma vers\u00e3o mais geral do circle chamada arc, que receba um par\u00e2metro adicional de angle, para determinar qual fra\u00e7\u00e3o do c\u00edrculo deve ser desenhada. angle est\u00e1 em unidades de graus, ent\u00e3o quando angle=360, o arc deve desenhar um c\u00edrculo completo.","title":"4.3 - Exerc\u00edcios"},{"location":"04-caso-interface/#44-encapsulamento","text":"O primeiro exerc\u00edcio pede que voc\u00ea ponha seu c\u00f3digo para desenhar quadrados em uma defini\u00e7\u00e3o de fun\u00e7\u00e3o e ent\u00e3o chame a fun\u00e7\u00e3o, passando o turtle como par\u00e2metro. Aqui est\u00e1 uma solu\u00e7\u00e3o: def square(t): for i in range(4): t.fd(100) t.lt(90) square(bob) As instru\u00e7\u00f5es mais internas, fd e lt, s\u00e3o endentadas duas vezes para mostrar que est\u00e3o dentro do loop for, que est\u00e1 dentro da defini\u00e7\u00e3o da fun\u00e7\u00e3o. A linha seguinte, square(bob), est\u00e1 alinhada \u00e0 margem esquerda, o que indica tanto o fim do loop for como da defini\u00e7\u00e3o de fun\u00e7\u00e3o. Dentro da fun\u00e7\u00e3o, o t indica o mesmo turtle bob, ent\u00e3o t.lt (90) tem o mesmo efeito que bob.lt (90). Neste caso, por que n\u00e3o chamar o par\u00e2metro bob? A ideia \u00e9 que t pode ser qualquer turtle, n\u00e3o apenas bob, ent\u00e3o voc\u00ea pode criar um segundo turtle e pass\u00e1-lo como argumento ao square: alice = turtle.Turtle() square(alice) Incluir uma parte do c\u00f3digo em uma fun\u00e7\u00e3o chama-se encapsulamento. Um dos benef\u00edcios do encapsulamento \u00e9 que ele atribui um nome ao c\u00f3digo, o que serve como uma esp\u00e9cie de documenta\u00e7\u00e3o. Outra vantagem \u00e9 que se voc\u00ea reutilizar o c\u00f3digo, \u00e9 mais conciso chamar uma fun\u00e7\u00e3o duas vezes que copiar e colar o corpo!","title":"4.4 - Encapsulamento"},{"location":"04-caso-interface/#45-generalizacao","text":"O pr\u00f3ximo passo \u00e9 acrescentar um par\u00e2metro length ao square. Aqui est\u00e1 uma solu\u00e7\u00e3o: def square(t, length): for i in range(4): t.fd(length) t.lt(90) square(bob, 100) Acrescentar um par\u00e2metro a uma fun\u00e7\u00e3o chama-se generaliza\u00e7\u00e3o porque ele torna a fun\u00e7\u00e3o mais geral: na vers\u00e3o anterior, o quadrado \u00e9 sempre do mesmo tamanho; nesta vers\u00e3o, pode ser de qualquer tamanho. O pr\u00f3ximo passo tamb\u00e9m \u00e9 uma generaliza\u00e7\u00e3o. Em vez de desenhar quadrados, polygon desenha pol\u00edgonos regulares com qualquer n\u00famero de lados. Aqui est\u00e1 uma solu\u00e7\u00e3o: def polygon(t, n, length): angle = 360 / n for i in range(n): t.fd(length) t.lt(angle) polygon(bob, 7, 70) Este exemplo desenha um pol\u00edgono de 7 lados, cada um de comprimento 70. Se estiver usando Python 2, o valor do angle poderia estar errado por causa da divis\u00e3o de n\u00famero inteiro. Uma solu\u00e7\u00e3o simples \u00e9 calcular angle = 360.0 / n. Como o numerador \u00e9 um n\u00famero de ponto flutuante, o resultado \u00e9 em ponto flutuante. Quando uma fun\u00e7\u00e3o tem v\u00e1rios argumentos num\u00e9ricos, \u00e9 f\u00e1cil esquecer o que eles s\u00e3o ou a ordem na qual eles devem estar. Neste caso, muitas vezes \u00e9 uma boa ideia incluir os nomes dos par\u00e2metros na lista de argumentos: polygon (bob, n=7, length=70) Esses s\u00e3o os argumentos de palavra-chave porque incluem os nomes dos par\u00e2metros como \u201cpalavras-chave\u201d (para n\u00e3o confundir com palavras-chave do Python, tais como while e def). Esta sintaxe torna o programa mais leg\u00edvel. Tamb\u00e9m \u00e9 uma lembran\u00e7a sobre como os argumentos e os par\u00e2metros funcionam: quando voc\u00ea chama uma fun\u00e7\u00e3o, os argumentos s\u00e3o atribu\u00eddos aos par\u00e2metros.","title":"4.5 - Generaliza\u00e7\u00e3o"},{"location":"04-caso-interface/#46-projeto-da-interface","text":"O pr\u00f3ximo passo \u00e9 escrever circle, que recebe um raio r, como par\u00e2metro. Aqui est\u00e1 uma solu\u00e7\u00e3o simples que usa o polygon para desenhar um pol\u00edgono de 50 lados: import math def circle(t, r): circumference = 2 * math.pi * r n = 50 length = circumference / n polygon(t, n, length) A primeira linha calcula a circunfer\u00eancia de um c\u00edrculo com o raio r usando a f\u00f3rmula 2\u03c0r. J\u00e1 que usamos math.pi, temos que importar math. Por conven\u00e7\u00e3o, instru\u00e7\u00f5es import normalmente ficam no in\u00edcio do script. n \u00e9 o n\u00famero de segmentos de reta na nossa aproxima\u00e7\u00e3o de um c\u00edrculo, ent\u00e3o length \u00e9 o comprimento de cada segmento. Assim, polygon desenha um pol\u00edgono 50 lados que se aproxima de um c\u00edrculo com o raio r. Uma limita\u00e7\u00e3o desta solu\u00e7\u00e3o \u00e9 que n \u00e9 uma constante. Para c\u00edrculos muito grandes, os segmentos de reta s\u00e3o longos demais, e para c\u00edrculos pequenos, perdemos tempo desenhando segmentos muito pequenos. Uma solu\u00e7\u00e3o seria generalizar a fun\u00e7\u00e3o tomando n como par\u00e2metro. Isso daria ao usu\u00e1rio (seja quem for que chame circle) mais controle, mas a interface seria menos limpa. A interface de uma fun\u00e7\u00e3o \u00e9 um resumo de como ela \u00e9 usada: Quais s\u00e3o os par\u00e2metros? O que a fun\u00e7\u00e3o faz? E qual \u00e9 o valor de retorno? Uma interface \u00e9 \u201climpa\u201d se permitir \u00e0 pessoa que a chama fazer o que quiser sem ter que lidar com detalhes desnecess\u00e1rios. Neste exemplo, r pertence \u00e0 interface porque especifica o c\u00edrculo a ser desenhado. n \u00e9 menos adequado porque pertence aos detalhes de como o c\u00edrculo deve ser apresentado. Em vez de poluir a interface, \u00e9 melhor escolher um valor adequado para n, dependendo da circumference: def circle(t, r): circumference = 2 * math.pi * r n = int(circumference / 3) + 1 length = circumference / n polygon(t, n, length) Neste ponto, o n\u00famero de segmentos \u00e9 um n\u00famero inteiro pr\u00f3ximo a circumference/3, ent\u00e3o o comprimento de cada segmento \u00e9 aproximadamente 3, pequeno o suficiente para que os c\u00edrculos fiquem bons, mas grandes o suficiente para serem eficientes e aceit\u00e1veis para c\u00edrculos de qualquer tamanho.","title":"4.6 - Projeto da interface"},{"location":"04-caso-interface/#47-refatoracao","text":"Quando escrevi circle, pude reutilizar polygon porque um pol\u00edgono de muitos lados \u00e9 uma boa aproxima\u00e7\u00e3o de um c\u00edrculo. Mas o arc n\u00e3o \u00e9 t\u00e3o cooperativo; n\u00e3o podemos usar polygon ou circle para desenhar um arco. Uma alternativa \u00e9 come\u00e7ar com uma c\u00f3pia de polygon e transform\u00e1-la em arc. O resultado poderia ser algo assim: def arc(t, r, angle): arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = angle / n for i in range(n): t.fd(step_length) t.lt(step_angle) A segunda metade desta fun\u00e7\u00e3o parece com a do polygon, mas n\u00e3o \u00e9 poss\u00edvel reutilizar o polygon sem mudar a interface. Poder\u00edamos generalizar polygon para receber um \u00e2ngulo como um terceiro argumento, mas ent\u00e3o polygon n\u00e3o seria mais um nome adequado! Em vez disso, vamos chamar a fun\u00e7\u00e3o mais geral de polyline: def polyline(t, n, length, angle): for i in range(n): t.fd(length) t.lt(angle) Agora podemos reescrever polygon e arc para usar polyline: def polygon(t, n, length): angle = 360.0 / n polyline(t, n, length, angle) def arc(t, r, angle): arc_length = 2 * math.pi * r * angle / 360 n = int(arc_length / 3) + 1 step_length = arc_length / n step_angle = float(angle) / n polyline(t, n, step_length, step_angle) Finalmente, podemos reescrever circle para usar arc: def circle(t, r): arc(t, r, 360) Este processo \u2013 recompor um programa para melhorar interfaces e facilitar a reutiliza\u00e7\u00e3o do c\u00f3digo \u2013 \u00e9 chamado de refatora\u00e7\u00e3o. Neste caso, notamos que houve c\u00f3digo semelhante em arc e polygon, ent\u00e3o n\u00f3s o \u201cfatoramos\u201d no polyline. Se tiv\u00e9ssemos planejado, poder\u00edamos ter escrito polyline primeiro e evitado a refatora\u00e7\u00e3o, mas muitas vezes n\u00e3o sabemos o suficiente j\u00e1 no in\u00edcio de um projeto para projetar todas as interfaces. Quando come\u00e7armos a escrever c\u00f3digo, entenderemos melhor o problema. \u00c0s vezes, a refatora\u00e7\u00e3o \u00e9 um sinal de que aprendemos algo.","title":"4.7 - Refatora\u00e7\u00e3o"},{"location":"04-caso-interface/#48-um-plano-de-desenvolvimento","text":"Um plano de desenvolvimento \u00e9 um processo para escrever programas. O processo que usamos neste estudo de caso \u00e9 \u201cencapsulamento e generaliza\u00e7\u00e3o\u201d. Os passos deste processo s\u00e3o: Comece escrevendo um pequeno programa sem defini\u00e7\u00f5es de fun\u00e7\u00e3o. Uma vez que o programa esteja funcionando, identifique uma parte coerente dele, encapsule essa parte em uma fun\u00e7\u00e3o e d\u00ea um nome a ela. Generalize a fun\u00e7\u00e3o acrescentando os par\u00e2metros adequados. Repita os passos 1-3 at\u00e9 que tenha um conjunto de fun\u00e7\u00f5es operantes. Copie e cole o c\u00f3digo operante para evitar a redigita\u00e7\u00e3o (e redepura\u00e7\u00e3o). Procure oportunidades de melhorar o programa pela refatora\u00e7\u00e3o. Por exemplo, se voc\u00ea tem um c\u00f3digo semelhante em v\u00e1rios lugares, pode ser uma boa ideia fator\u00e1-lo em uma fun\u00e7\u00e3o geral adequada. Este processo tem algumas desvantagens \u2013 veremos alternativas mais tarde \u2013 mas pode ser \u00fatil se voc\u00ea n\u00e3o souber de antem\u00e3o como dividir o programa em fun\u00e7\u00f5es. Esta abordagem permite criar o projeto no decorrer do trabalho.","title":"4.8 - Um plano de desenvolvimento"},{"location":"04-caso-interface/#49-docstring","text":"Uma docstring \u00e9 uma string no in\u00edcio de uma fun\u00e7\u00e3o que explica a interface (\u201cdoc\u201d \u00e9 uma abrevia\u00e7\u00e3o para \u201cdocumenta\u00e7\u00e3o\u201d). Aqui est\u00e1 um exemplo: def polyline(t, n, length, angle): \"\"\"Desenha n segmentos de reta com o comprimento dado e \u00e2ngulo (em graus) entre eles. t \u00e9 um turtle. \"\"\" for i in range(n): t.fd(length) t.lt(angle) Por conven\u00e7\u00e3o, todas as docstrings t\u00eam aspas triplas, tamb\u00e9m conhecidas como strings multilinha porque as aspas triplas permitem que a string se estenda por mais de uma linha. \u00c9 conciso, mas cont\u00e9m a informa\u00e7\u00e3o essencial que algu\u00e9m precisaria para usar esta fun\u00e7\u00e3o. Explica sucintamente o que a fun\u00e7\u00e3o faz (sem entrar nos detalhes de como o faz). Explica que efeito cada par\u00e2metro tem sobre o comportamento da fun\u00e7\u00e3o e o tipo que cada par\u00e2metro deve ser (se n\u00e3o for \u00f3bvio). Escrever este tipo de documenta\u00e7\u00e3o \u00e9 uma parte importante do projeto da interface. Uma interface bem projetada deve ser simples de explicar; se n\u00e3o for assim, talvez a interface possa ser melhorada.","title":"4.9 - docstring"},{"location":"04-caso-interface/#410-depuracao","text":"Uma interface \u00e9 como um contrato entre uma fun\u00e7\u00e3o e quem a chama. Quem chama concorda em fornecer certos par\u00e2metros e a fun\u00e7\u00e3o concorda em fazer certa a\u00e7\u00e3o. Por exemplo, polyline precisa de quatro argumentos: t tem que ser um Turtle; n tem que ser um n\u00famero inteiro; length deve ser um n\u00famero positivo; e o angle tem que ser um n\u00famero, que se espera estar em graus. Essas exig\u00eancias s\u00e3o chamadas de precondi\u00e7\u00f5es porque se sup\u00f5e que sejam verdade antes que a fun\u00e7\u00e3o seja executada. De forma inversa, as condi\u00e7\u00f5es no fim da fun\u00e7\u00e3o s\u00e3o p\u00f3s-condi\u00e7\u00f5es. As p\u00f3s-condi\u00e7\u00f5es incluem o efeito desejado da fun\u00e7\u00e3o (como o desenho de segmentos de reta) e qualquer efeito colateral (como mover o Turtle ou fazer outras mudan\u00e7as). Precondi\u00e7\u00f5es s\u00e3o responsabilidade de quem chama. Se quem chama violar uma precondi\u00e7\u00e3o (adequadamente documentada!) e a fun\u00e7\u00e3o n\u00e3o funcionar corretamente, o problema est\u00e1 nesta pessoa, n\u00e3o na fun\u00e7\u00e3o. Se as precondi\u00e7\u00f5es forem satisfeitas e as p\u00f3s-condi\u00e7\u00f5es n\u00e3o forem, o problema est\u00e1 na fun\u00e7\u00e3o. Se as suas precondi\u00e7\u00f5es e p\u00f3s-condi\u00e7\u00f5es forem claras, elas podem ajudar na depura\u00e7\u00e3o.","title":"4.10 - Depura\u00e7\u00e3o"},{"location":"04-caso-interface/#411-glossario","text":"m\u00e9todo Uma fun\u00e7\u00e3o associada a um objeto e chamada usando a nota\u00e7\u00e3o de ponto. loop Parte de um programa que pode ser executada repetidamente. encapsulamento O processo de transformar uma sequ\u00eancia de instru\u00e7\u00f5es em uma defini\u00e7\u00e3o de fun\u00e7\u00e3o. generaliza\u00e7\u00e3o O processo de substituir algo desnecessariamente espec\u00edfico (como um n\u00famero) por algo adequadamente geral (como uma vari\u00e1vel ou par\u00e2metro). argumento de palavra-chave Um argumento que inclui o nome do par\u00e2metro como uma \u201cpalavra-chave\u201d. interface Uma descri\u00e7\u00e3o de como usar uma fun\u00e7\u00e3o, incluindo o nome e as descri\u00e7\u00f5es dos argumentos e do valor de retorno. refatora\u00e7\u00e3o O processo de alterar um programa funcional para melhorar a interface de fun\u00e7\u00f5es e outras qualidades do c\u00f3digo. plano de desenvolvimento Um processo de escrever programas. docstring Uma string que aparece no in\u00edcio de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o para documentar a interface da fun\u00e7\u00e3o. precondi\u00e7\u00e3o Uma exig\u00eancia que deve ser satisfeita por quem chama a fun\u00e7\u00e3o, antes de execut\u00e1-la. p\u00f3s-condi\u00e7\u00e3o Uma exig\u00eancia que deve ser satisfeita pela fun\u00e7\u00e3o antes que ela seja encerrada.","title":"4.11 - Gloss\u00e1rio"},{"location":"04-caso-interface/#412-exercicios","text":"","title":"4.12 - Exerc\u00edcios"},{"location":"04-caso-interface/#exercicio-41","text":"Baixe o c\u00f3digo deste cap\u00edtulo no site http://thinkpython2.com/code/polygon.py. Desenhe um diagrama da pilha que mostre o estado do programa enquanto executa circle (bob, radius). Voc\u00ea pode fazer a aritm\u00e9tica \u00e0 m\u00e3o ou acrescentar instru\u00e7\u00f5es print ao c\u00f3digo. A vers\u00e3o de arc na se\u00e7\u00e3o 4.7 - Refatora\u00e7\u00e3o n\u00e3o \u00e9 muito precisa porque a aproxima\u00e7\u00e3o linear do c\u00edrculo est\u00e1 sempre do lado de fora do c\u00edrculo verdadeiro. Consequentemente, o Turtle acaba ficando alguns p\u00edxeis de dist\u00e2ncia do destino correto. Minha solu\u00e7\u00e3o mostra um modo de reduzir o efeito deste erro. Leia o c\u00f3digo e veja se faz sentido para voc\u00ea. Se desenhar um diagrama, poder\u00e1 ver como funciona.","title":"Exerc\u00edcio 4.1"},{"location":"04-caso-interface/#exercicio-42","text":"Escreva um conjunto de fun\u00e7\u00f5es adequadamente geral que possa desenhar flores como as da Figura 4.1. Figura 4.1 \u2013 Flores de tartaruga. Solu\u00e7\u00e3o: http://thinkpython2.com/code/flower.py, tamb\u00e9m exige http://thinkpython2.com/code/polygon.py.","title":"Exerc\u00edcio 4.2"},{"location":"04-caso-interface/#exercicio-43","text":"Escreva um conjunto de fun\u00e7\u00f5es adequadamente geral que possa desenhar formas como as da Figura 4.2. Figura 4.2 \u2013 Tortas de tartaruga. Solu\u00e7\u00e3o: http://thinkpython2.com/code/pie.py.","title":"Exerc\u00edcio 4.3"},{"location":"04-caso-interface/#exercicio-44","text":"As letras do alfabeto podem ser constru\u00eddas a partir de um n\u00famero moderado de elementos b\u00e1sicos, como linhas verticais e horizontais e algumas curvas. Crie um alfabeto que possa ser desenhado com um n\u00famero m\u00ednimo de elementos b\u00e1sicos e ent\u00e3o escreva fun\u00e7\u00f5es que desenhem as letras. Voc\u00ea deve escrever uma fun\u00e7\u00e3o para cada letra, com os nomes draw_a, draw_b etc., e colocar suas fun\u00e7\u00f5es em um arquivo chamado letters.py. Voc\u00ea pode baixar uma \u201cm\u00e1quina de escrever de turtle\u201d no site http://thinkpython2.com/code/typewriter.py para ajudar a testar o seu c\u00f3digo. Voc\u00ea pode ver uma solu\u00e7\u00e3o no site http://thinkpython2.com/code/letters.py; ela tamb\u00e9m exige http://thinkpython2.com/code/polygon.py.","title":"Exerc\u00edcio 4.4"},{"location":"04-caso-interface/#exercicio-45","text":"Leia sobre espirais em https://pt.wikipedia.org/wiki/Espiral; ent\u00e3o escreva um programa que desenhe uma espiral de Arquimedes (ou um dos outros tipos). [1] turtle graphics ou gr\u00e1ficos de tartaruga \u00e9 o sistema de desenho popularizado pela linguagem Logo, onde os comandos movimentam um cursor triangular pela tela, conhecido como turtle ou tartaruga. A tartaruga deixa um rastro \u00e0 medida que \u00e9 movimentada, e \u00e9 com esses rastros que se forma um desenho. Diferente dos sistemas usuais de desenho em computa\u00e7\u00e3o gr\u00e1fica, o sistema turtle graphics n\u00e3o exige o uso de coordenadas cartesianas.","title":"Exerc\u00edcio 4.5"},{"location":"05-cond-recur/","text":"Cap\u00edtulo 5: Condicionais e recursividade O t\u00f3pico principal deste cap\u00edtulo \u00e9 a instru\u00e7\u00e3o if, que executa c\u00f3digos diferentes dependendo do estado do programa. Mas primeiro quero apresentar dois novos operadores: divis\u00e3o pelo piso e m\u00f3dulo. 5.1 - Divis\u00e3o pelo piso e m\u00f3dulo O operador de divis\u00e3o pelo piso, //, divide dois n\u00fameros e arredonda o resultado para um n\u00famero inteiro para baixo. Por exemplo, suponha que o tempo de execu\u00e7\u00e3o de um filme seja de 105 minutos. Voc\u00ea pode querer saber a quanto isso corresponde em horas. A divis\u00e3o convencional devolve um n\u00famero de ponto flutuante: >>> minutes = 105 >>> minutes / 60 1.75 Mas n\u00e3o \u00e9 comum escrever horas com pontos decimais. A divis\u00e3o pelo piso devolve o n\u00famero inteiro de horas, ignorando a parte fracion\u00e1ria: >>> minutes = 105 >>> hours = minutes // 60 >>> hours 1 Para obter o resto, voc\u00ea pode subtrair uma hora em minutos: >>> remainder = minutes - hours * 60 >>> remainder 45 Uma alternativa \u00e9 usar o operador m\u00f3dulo, %, que divide dois n\u00fameros e devolve o resto: >>> remainder = minutes % 60 >>> remainder 45 O operador m\u00f3dulo \u00e9 mais \u00fatil do que parece. Por exemplo, \u00e9 poss\u00edvel verificar se um n\u00famero \u00e9 divis\u00edvel por outro \u2013 se x % y for zero, ent\u00e3o x \u00e9 divis\u00edvel por y. Al\u00e9m disso, voc\u00ea pode extrair o d\u00edgito ou d\u00edgitos mais \u00e0 direita de um n\u00famero. Por exemplo, x % 10 produz o d\u00edgito mais \u00e0 direita de x (na base 10). Da mesma forma x % 100 produz os dois \u00faltimos d\u00edgitos. Se estiver usando o Python 2, a divis\u00e3o funciona de forma diferente. O operador de divis\u00e3o, /, executa a divis\u00e3o pelo piso se ambos os operandos forem n\u00fameros inteiros e faz a divis\u00e3o de ponto flutuante se pelo menos um dos operandos for do tipo float. 5.2 - Express\u00f5es booleanas Uma express\u00e3o booleana \u00e9 uma express\u00e3o que pode ser verdadeira ou falsa. Os exemplos seguintes usam o operador ==, que compara dois operandos e produz True se forem iguais e False se n\u00e3o forem: >>> 5 == 5 True >>> 5 == 6 False True e False s\u00e3o valores especiais que pertencem ao tipo bool; n\u00e3o s\u00e3o strings: >>> type(True) <class 'bool'> >>> type(False) <class 'bool'> O operador == \u00e9 um dos operadores relacionais; os outros s\u00e3o: x != y # x n\u00e3o \u00e9 igual a y x > y # x \u00e9 maior que y x < y # x \u00e9 menor que y x >= y # x \u00e9 maior ou igual a y x <= y # x \u00e9 menor ou igual a y Embora essas opera\u00e7\u00f5es provavelmente sejam familiares para voc\u00ea, os s\u00edmbolos do Python s\u00e3o diferentes dos s\u00edmbolos matem\u00e1ticos. Um erro comum \u00e9 usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = \u00e9 um operador de atribui\u00e7\u00e3o e == \u00e9 um operador relacional. N\u00e3o existe =< ou =>. 5.3 - Operadores l\u00f3gicos H\u00e1 tr\u00eas operadores l\u00f3gicos: and, or e not. A sem\u00e2ntica (significado) destes operadores \u00e9 semelhante ao seu significado em ingl\u00eas. Por exemplo, x> 0 and x <10 s\u00f3 \u00e9 verdade se x for maior que 0 e menor que 10. n%2 == 0 or n%3 == 0 \u00e9 verdadeiro se uma ou as duas condi\u00e7\u00e3o(\u00f5es) for(em) verdadeira(s), isto \u00e9, se o n\u00famero for divis\u00edvel por 2 ou 3. Finalmente, o operador not nega uma express\u00e3o booleana, ent\u00e3o not (x > y) \u00e9 verdade se x > y for falso, isto \u00e9, se x for menor que ou igual a y. Falando estritamente, os operandos dos operadores l\u00f3gicos devem ser express\u00f5es booleanas, mas o Python n\u00e3o \u00e9 muito estrito. Qualquer n\u00famero que n\u00e3o seja zero \u00e9 interpretado como True: >>> 42 and True True Esta flexibilidade tem sua utilidade, mas h\u00e1 algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evit\u00e1-la (a menos que saiba o que est\u00e1 fazendo). 5.4 - Execu\u00e7\u00e3o condicional Para escrever programas \u00fateis, quase sempre precisamos da capacidade de verificar condi\u00e7\u00f5es e mudar o comportamento do programa de acordo com elas. Instru\u00e7\u00f5es condicionais nos d\u00e3o esta capacidade. A forma mais simples \u00e9 a instru\u00e7\u00e3o if: if x > 0: print('x is positive') A express\u00e3o booleana depois do if \u00e9 chamada de condi\u00e7\u00e3o. Se for verdadeira, a instru\u00e7\u00e3o endentada \u00e9 executada. Se n\u00e3o, nada acontece. Instru\u00e7\u00f5es if t\u00eam a mesma estrutura que defini\u00e7\u00f5es de fun\u00e7\u00e3o: um cabe\u00e7alho seguido de um corpo endentado. Instru\u00e7\u00f5es como essa s\u00e3o chamadas de instru\u00e7\u00f5es compostas. N\u00e3o h\u00e1 limite para o n\u00famero de instru\u00e7\u00f5es que podem aparecer no corpo, mas deve haver pelo menos uma. Ocasionalmente, \u00e9 \u00fatil ter um corpo sem instru\u00e7\u00f5es (normalmente como um espa\u00e7o reservado para c\u00f3digo que ainda n\u00e3o foi escrito). Neste caso, voc\u00ea pode usar a instru\u00e7\u00e3o pass, que n\u00e3o faz nada. if x < 0: pass # A FAZER: lidar com valores negativos! 5.5 - Execu\u00e7\u00e3o alternativa Uma segunda forma da instru\u00e7\u00e3o if \u00e9 a \u201cexecu\u00e7\u00e3o alternativa\u201d, na qual h\u00e1 duas possibilidades e a condi\u00e7\u00e3o determina qual ser\u00e1 executada. A sintaxe pode ser algo assim: if x % 2 == 0: print('x is even') else: print('x is odd') Se o resto quando x for dividido por 2 for 0, ent\u00e3o sabemos que x \u00e9 par e o programa exibe uma mensagem adequada. Se a condi\u00e7\u00e3o for falsa, o segundo conjunto de instru\u00e7\u00f5es \u00e9 executado. Como a condi\u00e7\u00e3o deve ser verdadeira ou falsa, exatamente uma das alternativas ser\u00e1 executada. As alternativas s\u00e3o chamadas de ramos (branches), porque s\u00e3o ramos no fluxo da execu\u00e7\u00e3o. 5.6 - Condicionais encadeadas \u00c0s vezes, h\u00e1 mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma opera\u00e7\u00e3o de computa\u00e7\u00e3o \u00e9 uma condicional encadeada: if x < y: print('x is less than y') elif x > y: print('x is greater than y') else: print('x and y are equal') elif \u00e9 uma abreviatura de \u201celse if\u201d. Novamente, exatamente um ramo ser\u00e1 executado. N\u00e3o h\u00e1 nenhum limite para o n\u00famero de instru\u00e7\u00f5es elif. Se houver uma cl\u00e1usula else, ela deve estar no fim, mas n\u00e3o \u00e9 preciso haver uma. if choice == 'a': draw_a() elif choice == 'b': draw_b() elif choice == 'c': draw_c() Cada condi\u00e7\u00e3o \u00e9 verificada em ordem. Se a primeira for falsa, a pr\u00f3xima \u00e9 verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente \u00e9 executado e a instru\u00e7\u00e3o \u00e9 encerrada. Mesmo se mais de uma condi\u00e7\u00e3o for verdade, s\u00f3 o primeiro ramo verdadeiro \u00e9 executado. 5.7 - Condicionais aninhadas Uma condicional tamb\u00e9m pode ser aninhada dentro de outra. Poder\u00edamos ter escrito o exemplo na se\u00e7\u00e3o anterior desta forma: if x == y: print('x and y are equal') else: if x < y: print('x is less than y') else: print('x is greater than y') A condicional exterior cont\u00e9m dois ramos. O primeiro ramo cont\u00e9m uma instru\u00e7\u00e3o simples. O segundo ramo cont\u00e9m outra instru\u00e7\u00e3o if, que tem outros dois ramos pr\u00f3prios. Esses dois ramos s\u00e3o instru\u00e7\u00f5es simples, embora pudessem ser instru\u00e7\u00f5es condicionais tamb\u00e9m. Embora a endenta\u00e7\u00e3o das instru\u00e7\u00f5es evidencie a estrutura das condicionais, condicionais aninhadas s\u00e3o dif\u00edceis de ler rapidamente. \u00c9 uma boa ideia evit\u00e1-las quando for poss\u00edvel. Operadores l\u00f3gicos muitas vezes oferecem uma forma de simplificar instru\u00e7\u00f5es condicionais aninhadas. Por exemplo, podemos reescrever o seguinte c\u00f3digo usando uma \u00fanica condicional: if 0 < x: if x < 10: print('x is a positive single-digit number.') A instru\u00e7\u00e3o print s\u00f3 \u00e9 executada se a colocarmos depois de ambas as condicionais, ent\u00e3o podemos obter o mesmo efeito com o operador and: if 0 < x and x < 10: print('x is a positive single-digit number.') Para este tipo de condi\u00e7\u00e3o, o Python oferece uma op\u00e7\u00e3o mais concisa: if 0 < x < 10: print('x is a positive single-digit number.') 5.8 - Recursividade \u00c9 legal para uma fun\u00e7\u00e3o chamar outra; tamb\u00e9m \u00e9 legal para uma fun\u00e7\u00e3o chamar a si pr\u00f3pria. Pode n\u00e3o ser \u00f3bvio porque isso \u00e9 uma coisa boa, mas na verdade \u00e9 uma das coisas mais m\u00e1gicas que um programa pode fazer. Por exemplo, veja a seguinte fun\u00e7\u00e3o: def countdown(n): if n <= 0: print('Blastoff!') else: print(n) countdown(n-1) Se n for 0 ou negativo, a palavra \u201cBlastoff!\u201d \u00e9 exibida, sen\u00e3o a sa\u00edda \u00e9 n e ent\u00e3o a fun\u00e7\u00e3o countdown \u00e9 chamada \u2013 por si mesma \u2013 passando n-1 como argumento. O que acontece se chamarmos esta fun\u00e7\u00e3o assim? >>> countdown(3) A execu\u00e7\u00e3o de countdown inicia com n=3 e como n \u00e9 maior que 0, ela produz o valor 3 e ent\u00e3o chama a si mesma... A execu\u00e7\u00e3o de countdown inicia com n=2 e como n \u00e9 maior que 0, ela produz o valor 2 e ent\u00e3o chama a si mesma... A execu\u00e7\u00e3o de countdown inicia com n=1 e como n \u00e9 maior que 0, ela produz o valor 1 e ent\u00e3o chama a si mesma... A execu\u00e7\u00e3o de countdown inicia com n=0 e como n n\u00e3o \u00e9 maior que 0, ela produz a palavra \u201cBlastoff!\u201d e ent\u00e3o retorna. O countdown que recebeu n=1 retorna. O countdown que recebeu n=2 retorna. O countdown que recebeu n=3 retorna. E ent\u00e3o voc\u00ea est\u00e1 de volta ao __main__ . Ent\u00e3o a sa\u00edda completa ser\u00e1 assim: 3 2 1 Blastoff! Uma fun\u00e7\u00e3o que chama a si mesma \u00e9 dita recursiva; o processo para execut\u00e1-la \u00e9 a recursividade. Como em outro exemplo, podemos escrever uma fun\u00e7\u00e3o que exiba uma string n vezes: def print_n(s, n): if n <= 0: return print(s) print_n(s, n-1) Se n <= 0 a instru\u00e7\u00e3o return causa a sa\u00edda da fun\u00e7\u00e3o. O fluxo de execu\u00e7\u00e3o volta imediatamente a quem fez a chamada, e as linhas restantes da fun\u00e7\u00e3o n\u00e3o s\u00e3o executadas. O resto da fun\u00e7\u00e3o \u00e9 similar \u00e0 countdown: ela mostra s e ent\u00e3o chama a si mesma para mostrar s mais n-1 vezes. Ent\u00e3o o n\u00famero de linhas da sa\u00edda \u00e9 1 + (n - 1), at\u00e9 chegar a n. Para exemplos simples como esse, provavelmente \u00e9 mais f\u00e1cil usar um loop for. Mais adiante veremos exemplos que s\u00e3o dif\u00edceis de escrever com um loop for e f\u00e1ceis de escrever com recursividade, ent\u00e3o \u00e9 bom come\u00e7ar cedo. 5.9 - Diagramas da pilha para fun\u00e7\u00f5es recursivas Em \u201cDiagrama da pilha\u201d, na p\u00e1gina 55, usamos um diagrama da pilha para representar o estado de um programa durante uma chamada de fun\u00e7\u00e3o. O mesmo tipo de diagrama pode ajudar a interpretar uma fun\u00e7\u00e3o recursiva. Cada vez que uma fun\u00e7\u00e3o \u00e9 chamada, o Python cria um frame para conter as vari\u00e1veis locais e par\u00e2metros da fun\u00e7\u00e3o. Para uma fun\u00e7\u00e3o recursiva, pode haver mais de um frame na pilha ao mesmo tempo. A Figura 5.1 mostra um diagrama da pilha para countdown chamado com n = 3. Figura 5.1 \u2013 Diagrama da pilha. Como de h\u00e1bito, o topo da pilha \u00e9 o frame de __main__ . Est\u00e1 vazio porque n\u00e3o criamos nenhuma vari\u00e1vel em __main__ nem passamos argumentos a ela. Os quatro frames do countdown t\u00eam valores diferentes para o par\u00e2metro n . O fundo da pilha, onde n = 0 , \u00e9 chamado caso-base. Ele n\u00e3o faz uma chamada recursiva, ent\u00e3o n\u00e3o h\u00e1 mais frames. Como exerc\u00edcio, desenhe um diagrama da pilha para print_n chamado com s = 'Hello' e n = 2 . Ent\u00e3o escreva uma fun\u00e7\u00e3o chamada do_n que tome um objeto de fun\u00e7\u00e3o e um n\u00famero n como argumentos e que chame a respectiva fun\u00e7\u00e3o n vezes. 5.10 - Recursividade infinita Se a recursividade nunca atingir um caso-base, continua fazendo chamadas recursivas para sempre, e o programa nunca termina. Isso \u00e9 conhecido como recursividade infinita e geralmente n\u00e3o \u00e9 uma boa ideia. Aqui est\u00e1 um programa m\u00ednimo com recursividade infinita: def recurse(): recurse() Na maior parte dos ambientes de programa\u00e7\u00e3o, um programa com recursividade infinita n\u00e3o \u00e9 realmente executado para sempre. O Python exibe uma mensagem de erro quando a profundidade m\u00e1xima de recursividade \u00e9 atingida: File \"<stdin>\", line 2, in recurse File \"<stdin>\", line 2, in recurse File \"<stdin>\", line 2, in recurse . . . File \"<stdin>\", line 2, in recurse RuntimeError: Maximum recursion depth exceeded Este traceback \u00e9 um pouco maior que o que vimos no cap\u00edtulo anterior. Quando o erro ocorre, h\u00e1 mil frames de recurse na pilha! Se voc\u00ea escrever em recursividade infinita por engano, confira se a sua fun\u00e7\u00e3o tem um caso-base que n\u00e3o faz uma chamada recursiva. E se houver um caso-base, verifique se voc\u00ea vai mesmo atingi-lo. 5.11 - Entrada de teclado Os programas que escrevemos at\u00e9 agora n\u00e3o aceitam entradas do usu\u00e1rio. Eles sempre fazem a mesma coisa cada vez. O Python fornece uma fun\u00e7\u00e3o integrada chamada input que interrompe o programa e espera que o usu\u00e1rio digite algo. Quando o usu\u00e1rio pressionar Return ou Enter, o programa volta a ser executado e input retorna o que o usu\u00e1rio digitou como uma string. No Python 2, a mesma fun\u00e7\u00e3o \u00e9 chamada raw_input . >>> text = input() What are you waiting for? >>> text What are you waiting for? Antes de receber entradas do usu\u00e1rio, \u00e9 uma boa ideia exibir um prompt dizendo ao usu\u00e1rio o que ele deve digitar. input pode ter um prompt como argumento: >>> name = input('What...is your name?\\\\n') What...is your name? Arthur, King of the Britons! >>> name Arthur, King of the Britons! A sequ\u00eancia \\n no final do prompt representa um newline, que \u00e9 um caractere especial de quebra de linha. \u00c9 por isso que a entrada do usu\u00e1rio aparece abaixo do prompt. Se esperar que o usu\u00e1rio digite um n\u00famero inteiro, voc\u00ea pode tentar converter o valor de retorno para int: >>> prompt = 'What...is the airspeed velocity of an unladen swallow?\\\\n' >>> speed = input(prompt) What...is the airspeed velocity of an unladen swallow? 42 >>> int(speed) 42 Mas se o usu\u00e1rio digitar algo al\u00e9m de uma s\u00e9rie de d\u00edgitos, voc\u00ea recebe um erro: >>> speed = input(prompt) What...is the airspeed velocity of an unladen swallow? What do you mean, an African or a European swallow? >>> int(speed) ValueError: invalid literal for int() with base 10 Veremos como tratar este tipo de erro mais adiante. 5.12 - Depura\u00e7\u00e3o Quando um erro de sintaxe ou de tempo de execu\u00e7\u00e3o ocorre, a mensagem de erro cont\u00e9m muita informa\u00e7\u00e3o, \u00e0s vezes, at\u00e9 demais. As partes mais \u00fateis s\u00e3o normalmente: que tipo de erro foi; onde ocorreu. Erros de sintaxe s\u00e3o normalmente f\u00e1ceis de encontrar, mas h\u00e1 algumas pegadinhas. Erros de whitespace podem ser complicados porque os espa\u00e7os e tabula\u00e7\u00f5es s\u00e3o invis\u00edveis e estamos acostumados a ignor\u00e1-los. >>> x = 5 >>> y = 6 File \"<stdin>\", line 1 y = 6 ^ IndentationError: unexpected indent Neste exemplo, o problema \u00e9 que a segunda linha est\u00e1 endentada por um espa\u00e7o. Mas a mensagem de erro aponta para y, o que pode ser capcioso. Em geral, mensagens de erro indicam onde o problema foi descoberto, mas o erro real pode estar em outra parte do c\u00f3digo, \u00e0s vezes, em uma linha anterior. O mesmo acontece com erros em tempo de execu\u00e7\u00e3o. Suponha que voc\u00ea esteja tentando calcular a propor\u00e7\u00e3o de sinal a ru\u00eddo em decib\u00e9is. A f\u00f3rmula \u00e9 SNRdb = 10 log10 (Psignal/Pnoise). No Python, voc\u00ea poderia escrever algo assim: import math signal_power = 9 noise_power = 10 ratio = signal_power // noise_power decibels = 10 * math.log10(ratio) print(decibels) Ao executar este programa, voc\u00ea recebe uma exce\u00e7\u00e3o: Traceback (most recent call last): File \"snr.py\", line 5, in ? decibels = 10 * math.log10(ratio) ValueError: math domain error A mensagem de erro indica a linha 5, mas n\u00e3o h\u00e1 nada de errado com esta linha. Uma op\u00e7\u00e3o para encontrar o verdadeiro erro \u00e9 exibir o valor de ratio, que acaba sendo 0. O problema est\u00e1 na linha 4, que usa a divis\u00e3o pelo piso em vez da divis\u00e3o de ponto flutuante. \u00c9 preciso ler as mensagens de erro com aten\u00e7\u00e3o, mas n\u00e3o assumir que tudo que dizem esteja correto. 5.13 - Gloss\u00e1rio divis\u00e3o pelo piso Um operador, denotado por //, que divide dois n\u00fameros e arredonda o resultado para baixo (em dire\u00e7\u00e3o ao zero), a um n\u00famero inteiro. operador m\u00f3dulo Um operador, denotado com um sinal de percentagem (%), que funciona com n\u00fameros inteiros e devolve o resto quando um n\u00famero \u00e9 dividido por outro. express\u00e3o booleana Uma express\u00e3o cujo valor \u00e9 True (verdadeiro) ou False (falso). operador relacional Um destes operadores, que compara seus operandos: `==`, `!=`, `>`, ` < `, `>=` e ` < =`. operador l\u00f3gico Um destes operadores, que combina express\u00f5es booleanas: and (e), or (ou) e not (n\u00e3o). instru\u00e7\u00e3o condicional Uma instru\u00e7\u00e3o que controla o fluxo de execu\u00e7\u00e3o, dependendo de alguma condi\u00e7\u00e3o. condi\u00e7\u00e3o A express\u00e3o booleana em uma instru\u00e7\u00e3o condicional que determina qual ramo deve ser executado. instru\u00e7\u00e3o composta Uma instru\u00e7\u00e3o composta de um cabe\u00e7alho e um corpo. O cabe\u00e7alho termina em dois pontos (:). O corpo \u00e9 endentado em rela\u00e7\u00e3o ao cabe\u00e7alho. ramo Uma das sequ\u00eancias alternativas de instru\u00e7\u00f5es em uma instru\u00e7\u00e3o condicional. condicional encadeada Uma instru\u00e7\u00e3o condicional com uma s\u00e9rie de ramos alternativos. condicional aninhada Uma instru\u00e7\u00e3o condicional que aparece em um dos ramos de outra instru\u00e7\u00e3o condicional. instru\u00e7\u00e3o de retorno Uma instru\u00e7\u00e3o que faz uma fun\u00e7\u00e3o terminar imediatamente e voltar a quem a chamou. recursividade O processo de chamar a fun\u00e7\u00e3o que est\u00e1 sendo executada no momento. caso-base Um ramo condicional em uma fun\u00e7\u00e3o recursiva que n\u00e3o faz uma chamada recursiva. recursividade infinita Recursividade que n\u00e3o tem um caso-base, ou nunca o atinge. A recursividade infinita eventualmente causa um erro em tempo de execu\u00e7\u00e3o. 5.14 - Exerc\u00edcios Exerc\u00edcio 5.1 O m\u00f3dulo time fornece uma fun\u00e7\u00e3o, tamb\u00e9m chamada time, que devolve a Hora M\u00e9dia de Greenwich na \u201c\u00e9poca\u201d, que \u00e9 um momento arbitr\u00e1rio usado como ponto de refer\u00eancia. Em sistemas UNIX, a \u00e9poca \u00e9 primeiro de janeiro de 1970. >>> import time >>> time.time() 1437746094.5735958 Escreva um script que leia a hora atual e a converta em um tempo em horas, minutos e segundos, mais o n\u00famero de dias desde a \u00e9poca. Exerc\u00edcio 5.2 O \u00faltimo teorema de Fermat diz que n\u00e3o existem n\u00fameros inteiros a, b e c tais que a**n + b**n == c**n para quaisquer valores de n maiores que 2. Escreva uma fun\u00e7\u00e3o chamada check_fermat que receba quatro par\u00e2metros \u2013 a, b, c e n \u2013 e verifique se o teorema de Fermat se mant\u00e9m. Se n for maior que 2 e a**n + b**n == c**n o programa deve imprimir, \u201cHoly smokes, Fermat was wrong!\u201d Sen\u00e3o o programa deve exibir \u201cNo, that doesn\u2019t work.\u201d Escreva uma fun\u00e7\u00e3o que pe\u00e7a ao usu\u00e1rio para digitar valores para a, b, c e n, os converta em n\u00fameros inteiros e use check_fermat para verificar se violam o teorema de Fermat. Exerc\u00edcio 5.3 Se voc\u00ea tiver tr\u00eas gravetos, pode ser que consiga arranj\u00e1-los em um tri\u00e2ngulo ou n\u00e3o. Por exemplo, se um dos gravetos tiver 12 polegadas de comprimento e outros dois tiverem uma polegada de comprimento, n\u00e3o ser\u00e1 poss\u00edvel fazer com que os gravetos curtos se encontrem no meio. H\u00e1 um teste simples para ver se \u00e9 poss\u00edvel formar um tri\u00e2ngulo para quaisquer tr\u00eas comprimentos: Se algum dos tr\u00eas comprimentos for maior que a soma dos outros dois, ent\u00e3o voc\u00ea n\u00e3o pode formar um tri\u00e2ngulo. Sen\u00e3o, voc\u00ea pode. (Se a soma de dois comprimentos igualar o terceiro, eles formam um tri\u00e2ngulo chamado \u201cdegenerado\u201d.) Escreva uma fun\u00e7\u00e3o chamada is_triangle que receba tr\u00eas n\u00fameros inteiros como argumentos, e que imprima \u201cYes\u201d ou \u201cNo\u201d, dependendo da possibilidade de formar ou n\u00e3o um tri\u00e2ngulo de gravetos com os comprimentos dados. Escreva uma fun\u00e7\u00e3o que pe\u00e7a ao usu\u00e1rio para digitar tr\u00eas comprimentos de gravetos, os converta em n\u00fameros inteiros e use is_triangle para verificar se os gravetos com os comprimentos dados podem formar um tri\u00e2ngulo. Exerc\u00edcio 5.4 Qual \u00e9 a sa\u00edda do seguinte programa? Desenhe um diagrama da pilha que mostre o estado do programa quando exibir o resultado. def recurse(n, s): if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, 0) O que aconteceria se voc\u00ea chamasse esta fun\u00e7\u00e3o desta forma: recurse(-1, 0)? Escreva uma docstring que explique tudo o que algu\u00e9m precisaria saber para usar esta fun\u00e7\u00e3o (e mais nada). Os seguintes exerc\u00edcios usam o m\u00f3dulo turtle, descrito no Cap\u00edtulo 4: Exerc\u00edcio 5.5 Leia a pr\u00f3xima fun\u00e7\u00e3o e veja se consegue compreender o que ela faz (veja os exemplos no Cap\u00edtulo 4). Ent\u00e3o execute-a e veja se acertou. def draw(t, length, n): if n == 0: return angle = 50 t.fd(length * n) t.lt(angle) draw(t, length, n-1) t.rt(2 * angle) draw(t, length, n-1) t.lt(angle) t.bk(length * n) Exerc\u00edcio 5.6 Figura 5.2 \u2013 Uma curva de Koch. A curva de Koch \u00e9 um fractal que parece com o da Figura 5.2. Para desenhar uma curva de Koch com o comprimento x, tudo o que voc\u00ea tem que fazer \u00e9: Desenhe uma curva de Koch com o comprimento x/3. Vire 60 graus \u00e0 esquerda. Desenhe uma curva de Koch com o comprimento x/3. Vire 120 graus \u00e0 direita. Desenhe uma curva de Koch com o comprimento x/3. Vire 60 graus \u00e0 esquerda. Desenhe uma curva de Koch com o comprimento x/3. A exce\u00e7\u00e3o \u00e9 se x for menor que 3: neste caso, voc\u00ea pode desenhar apenas uma linha reta com o comprimento x. Escreva uma fun\u00e7\u00e3o chamada koch que receba um turtle e um comprimento como par\u00e2metros, e use o turtle para desenhar uma curva de Koch com o comprimento dado. Escreva uma fun\u00e7\u00e3o chamada snowflake que desenhe tr\u00eas curvas de Koch para fazer o tra\u00e7ado de um floco de neve. Solu\u00e7\u00e3o: http://thinkpython2.com/code/koch.py. A curva de Koch pode ser generalizada de v\u00e1rios modos. Veja exemplos em http://en.wikipedia.org/wiki/Koch_snowflake e implemente o seu favorito.","title":"Cap\u00edtulo 5: Condicionais e recursividade"},{"location":"05-cond-recur/#capitulo-5-condicionais-e-recursividade","text":"O t\u00f3pico principal deste cap\u00edtulo \u00e9 a instru\u00e7\u00e3o if, que executa c\u00f3digos diferentes dependendo do estado do programa. Mas primeiro quero apresentar dois novos operadores: divis\u00e3o pelo piso e m\u00f3dulo.","title":"Cap\u00edtulo 5: Condicionais e recursividade"},{"location":"05-cond-recur/#51-divisao-pelo-piso-e-modulo","text":"O operador de divis\u00e3o pelo piso, //, divide dois n\u00fameros e arredonda o resultado para um n\u00famero inteiro para baixo. Por exemplo, suponha que o tempo de execu\u00e7\u00e3o de um filme seja de 105 minutos. Voc\u00ea pode querer saber a quanto isso corresponde em horas. A divis\u00e3o convencional devolve um n\u00famero de ponto flutuante: >>> minutes = 105 >>> minutes / 60 1.75 Mas n\u00e3o \u00e9 comum escrever horas com pontos decimais. A divis\u00e3o pelo piso devolve o n\u00famero inteiro de horas, ignorando a parte fracion\u00e1ria: >>> minutes = 105 >>> hours = minutes // 60 >>> hours 1 Para obter o resto, voc\u00ea pode subtrair uma hora em minutos: >>> remainder = minutes - hours * 60 >>> remainder 45 Uma alternativa \u00e9 usar o operador m\u00f3dulo, %, que divide dois n\u00fameros e devolve o resto: >>> remainder = minutes % 60 >>> remainder 45 O operador m\u00f3dulo \u00e9 mais \u00fatil do que parece. Por exemplo, \u00e9 poss\u00edvel verificar se um n\u00famero \u00e9 divis\u00edvel por outro \u2013 se x % y for zero, ent\u00e3o x \u00e9 divis\u00edvel por y. Al\u00e9m disso, voc\u00ea pode extrair o d\u00edgito ou d\u00edgitos mais \u00e0 direita de um n\u00famero. Por exemplo, x % 10 produz o d\u00edgito mais \u00e0 direita de x (na base 10). Da mesma forma x % 100 produz os dois \u00faltimos d\u00edgitos. Se estiver usando o Python 2, a divis\u00e3o funciona de forma diferente. O operador de divis\u00e3o, /, executa a divis\u00e3o pelo piso se ambos os operandos forem n\u00fameros inteiros e faz a divis\u00e3o de ponto flutuante se pelo menos um dos operandos for do tipo float.","title":"5.1 - Divis\u00e3o pelo piso e m\u00f3dulo"},{"location":"05-cond-recur/#52-expressoes-booleanas","text":"Uma express\u00e3o booleana \u00e9 uma express\u00e3o que pode ser verdadeira ou falsa. Os exemplos seguintes usam o operador ==, que compara dois operandos e produz True se forem iguais e False se n\u00e3o forem: >>> 5 == 5 True >>> 5 == 6 False True e False s\u00e3o valores especiais que pertencem ao tipo bool; n\u00e3o s\u00e3o strings: >>> type(True) <class 'bool'> >>> type(False) <class 'bool'> O operador == \u00e9 um dos operadores relacionais; os outros s\u00e3o: x != y # x n\u00e3o \u00e9 igual a y x > y # x \u00e9 maior que y x < y # x \u00e9 menor que y x >= y # x \u00e9 maior ou igual a y x <= y # x \u00e9 menor ou igual a y Embora essas opera\u00e7\u00f5es provavelmente sejam familiares para voc\u00ea, os s\u00edmbolos do Python s\u00e3o diferentes dos s\u00edmbolos matem\u00e1ticos. Um erro comum \u00e9 usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = \u00e9 um operador de atribui\u00e7\u00e3o e == \u00e9 um operador relacional. N\u00e3o existe =< ou =>.","title":"5.2 - Express\u00f5es booleanas"},{"location":"05-cond-recur/#53-operadores-logicos","text":"H\u00e1 tr\u00eas operadores l\u00f3gicos: and, or e not. A sem\u00e2ntica (significado) destes operadores \u00e9 semelhante ao seu significado em ingl\u00eas. Por exemplo, x> 0 and x <10 s\u00f3 \u00e9 verdade se x for maior que 0 e menor que 10. n%2 == 0 or n%3 == 0 \u00e9 verdadeiro se uma ou as duas condi\u00e7\u00e3o(\u00f5es) for(em) verdadeira(s), isto \u00e9, se o n\u00famero for divis\u00edvel por 2 ou 3. Finalmente, o operador not nega uma express\u00e3o booleana, ent\u00e3o not (x > y) \u00e9 verdade se x > y for falso, isto \u00e9, se x for menor que ou igual a y. Falando estritamente, os operandos dos operadores l\u00f3gicos devem ser express\u00f5es booleanas, mas o Python n\u00e3o \u00e9 muito estrito. Qualquer n\u00famero que n\u00e3o seja zero \u00e9 interpretado como True: >>> 42 and True True Esta flexibilidade tem sua utilidade, mas h\u00e1 algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evit\u00e1-la (a menos que saiba o que est\u00e1 fazendo).","title":"5.3 - Operadores l\u00f3gicos"},{"location":"05-cond-recur/#54-execucao-condicional","text":"Para escrever programas \u00fateis, quase sempre precisamos da capacidade de verificar condi\u00e7\u00f5es e mudar o comportamento do programa de acordo com elas. Instru\u00e7\u00f5es condicionais nos d\u00e3o esta capacidade. A forma mais simples \u00e9 a instru\u00e7\u00e3o if: if x > 0: print('x is positive') A express\u00e3o booleana depois do if \u00e9 chamada de condi\u00e7\u00e3o. Se for verdadeira, a instru\u00e7\u00e3o endentada \u00e9 executada. Se n\u00e3o, nada acontece. Instru\u00e7\u00f5es if t\u00eam a mesma estrutura que defini\u00e7\u00f5es de fun\u00e7\u00e3o: um cabe\u00e7alho seguido de um corpo endentado. Instru\u00e7\u00f5es como essa s\u00e3o chamadas de instru\u00e7\u00f5es compostas. N\u00e3o h\u00e1 limite para o n\u00famero de instru\u00e7\u00f5es que podem aparecer no corpo, mas deve haver pelo menos uma. Ocasionalmente, \u00e9 \u00fatil ter um corpo sem instru\u00e7\u00f5es (normalmente como um espa\u00e7o reservado para c\u00f3digo que ainda n\u00e3o foi escrito). Neste caso, voc\u00ea pode usar a instru\u00e7\u00e3o pass, que n\u00e3o faz nada. if x < 0: pass # A FAZER: lidar com valores negativos!","title":"5.4 - Execu\u00e7\u00e3o condicional"},{"location":"05-cond-recur/#55-execucao-alternativa","text":"Uma segunda forma da instru\u00e7\u00e3o if \u00e9 a \u201cexecu\u00e7\u00e3o alternativa\u201d, na qual h\u00e1 duas possibilidades e a condi\u00e7\u00e3o determina qual ser\u00e1 executada. A sintaxe pode ser algo assim: if x % 2 == 0: print('x is even') else: print('x is odd') Se o resto quando x for dividido por 2 for 0, ent\u00e3o sabemos que x \u00e9 par e o programa exibe uma mensagem adequada. Se a condi\u00e7\u00e3o for falsa, o segundo conjunto de instru\u00e7\u00f5es \u00e9 executado. Como a condi\u00e7\u00e3o deve ser verdadeira ou falsa, exatamente uma das alternativas ser\u00e1 executada. As alternativas s\u00e3o chamadas de ramos (branches), porque s\u00e3o ramos no fluxo da execu\u00e7\u00e3o.","title":"5.5 - Execu\u00e7\u00e3o alternativa"},{"location":"05-cond-recur/#56-condicionais-encadeadas","text":"\u00c0s vezes, h\u00e1 mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma opera\u00e7\u00e3o de computa\u00e7\u00e3o \u00e9 uma condicional encadeada: if x < y: print('x is less than y') elif x > y: print('x is greater than y') else: print('x and y are equal') elif \u00e9 uma abreviatura de \u201celse if\u201d. Novamente, exatamente um ramo ser\u00e1 executado. N\u00e3o h\u00e1 nenhum limite para o n\u00famero de instru\u00e7\u00f5es elif. Se houver uma cl\u00e1usula else, ela deve estar no fim, mas n\u00e3o \u00e9 preciso haver uma. if choice == 'a': draw_a() elif choice == 'b': draw_b() elif choice == 'c': draw_c() Cada condi\u00e7\u00e3o \u00e9 verificada em ordem. Se a primeira for falsa, a pr\u00f3xima \u00e9 verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente \u00e9 executado e a instru\u00e7\u00e3o \u00e9 encerrada. Mesmo se mais de uma condi\u00e7\u00e3o for verdade, s\u00f3 o primeiro ramo verdadeiro \u00e9 executado.","title":"5.6 - Condicionais encadeadas"},{"location":"05-cond-recur/#57-condicionais-aninhadas","text":"Uma condicional tamb\u00e9m pode ser aninhada dentro de outra. Poder\u00edamos ter escrito o exemplo na se\u00e7\u00e3o anterior desta forma: if x == y: print('x and y are equal') else: if x < y: print('x is less than y') else: print('x is greater than y') A condicional exterior cont\u00e9m dois ramos. O primeiro ramo cont\u00e9m uma instru\u00e7\u00e3o simples. O segundo ramo cont\u00e9m outra instru\u00e7\u00e3o if, que tem outros dois ramos pr\u00f3prios. Esses dois ramos s\u00e3o instru\u00e7\u00f5es simples, embora pudessem ser instru\u00e7\u00f5es condicionais tamb\u00e9m. Embora a endenta\u00e7\u00e3o das instru\u00e7\u00f5es evidencie a estrutura das condicionais, condicionais aninhadas s\u00e3o dif\u00edceis de ler rapidamente. \u00c9 uma boa ideia evit\u00e1-las quando for poss\u00edvel. Operadores l\u00f3gicos muitas vezes oferecem uma forma de simplificar instru\u00e7\u00f5es condicionais aninhadas. Por exemplo, podemos reescrever o seguinte c\u00f3digo usando uma \u00fanica condicional: if 0 < x: if x < 10: print('x is a positive single-digit number.') A instru\u00e7\u00e3o print s\u00f3 \u00e9 executada se a colocarmos depois de ambas as condicionais, ent\u00e3o podemos obter o mesmo efeito com o operador and: if 0 < x and x < 10: print('x is a positive single-digit number.') Para este tipo de condi\u00e7\u00e3o, o Python oferece uma op\u00e7\u00e3o mais concisa: if 0 < x < 10: print('x is a positive single-digit number.')","title":"5.7 - Condicionais aninhadas"},{"location":"05-cond-recur/#58-recursividade","text":"\u00c9 legal para uma fun\u00e7\u00e3o chamar outra; tamb\u00e9m \u00e9 legal para uma fun\u00e7\u00e3o chamar a si pr\u00f3pria. Pode n\u00e3o ser \u00f3bvio porque isso \u00e9 uma coisa boa, mas na verdade \u00e9 uma das coisas mais m\u00e1gicas que um programa pode fazer. Por exemplo, veja a seguinte fun\u00e7\u00e3o: def countdown(n): if n <= 0: print('Blastoff!') else: print(n) countdown(n-1) Se n for 0 ou negativo, a palavra \u201cBlastoff!\u201d \u00e9 exibida, sen\u00e3o a sa\u00edda \u00e9 n e ent\u00e3o a fun\u00e7\u00e3o countdown \u00e9 chamada \u2013 por si mesma \u2013 passando n-1 como argumento. O que acontece se chamarmos esta fun\u00e7\u00e3o assim? >>> countdown(3) A execu\u00e7\u00e3o de countdown inicia com n=3 e como n \u00e9 maior que 0, ela produz o valor 3 e ent\u00e3o chama a si mesma... A execu\u00e7\u00e3o de countdown inicia com n=2 e como n \u00e9 maior que 0, ela produz o valor 2 e ent\u00e3o chama a si mesma... A execu\u00e7\u00e3o de countdown inicia com n=1 e como n \u00e9 maior que 0, ela produz o valor 1 e ent\u00e3o chama a si mesma... A execu\u00e7\u00e3o de countdown inicia com n=0 e como n n\u00e3o \u00e9 maior que 0, ela produz a palavra \u201cBlastoff!\u201d e ent\u00e3o retorna. O countdown que recebeu n=1 retorna. O countdown que recebeu n=2 retorna. O countdown que recebeu n=3 retorna. E ent\u00e3o voc\u00ea est\u00e1 de volta ao __main__ . Ent\u00e3o a sa\u00edda completa ser\u00e1 assim: 3 2 1 Blastoff! Uma fun\u00e7\u00e3o que chama a si mesma \u00e9 dita recursiva; o processo para execut\u00e1-la \u00e9 a recursividade. Como em outro exemplo, podemos escrever uma fun\u00e7\u00e3o que exiba uma string n vezes: def print_n(s, n): if n <= 0: return print(s) print_n(s, n-1) Se n <= 0 a instru\u00e7\u00e3o return causa a sa\u00edda da fun\u00e7\u00e3o. O fluxo de execu\u00e7\u00e3o volta imediatamente a quem fez a chamada, e as linhas restantes da fun\u00e7\u00e3o n\u00e3o s\u00e3o executadas. O resto da fun\u00e7\u00e3o \u00e9 similar \u00e0 countdown: ela mostra s e ent\u00e3o chama a si mesma para mostrar s mais n-1 vezes. Ent\u00e3o o n\u00famero de linhas da sa\u00edda \u00e9 1 + (n - 1), at\u00e9 chegar a n. Para exemplos simples como esse, provavelmente \u00e9 mais f\u00e1cil usar um loop for. Mais adiante veremos exemplos que s\u00e3o dif\u00edceis de escrever com um loop for e f\u00e1ceis de escrever com recursividade, ent\u00e3o \u00e9 bom come\u00e7ar cedo.","title":"5.8 - Recursividade"},{"location":"05-cond-recur/#59-diagramas-da-pilha-para-funcoes-recursivas","text":"Em \u201cDiagrama da pilha\u201d, na p\u00e1gina 55, usamos um diagrama da pilha para representar o estado de um programa durante uma chamada de fun\u00e7\u00e3o. O mesmo tipo de diagrama pode ajudar a interpretar uma fun\u00e7\u00e3o recursiva. Cada vez que uma fun\u00e7\u00e3o \u00e9 chamada, o Python cria um frame para conter as vari\u00e1veis locais e par\u00e2metros da fun\u00e7\u00e3o. Para uma fun\u00e7\u00e3o recursiva, pode haver mais de um frame na pilha ao mesmo tempo. A Figura 5.1 mostra um diagrama da pilha para countdown chamado com n = 3. Figura 5.1 \u2013 Diagrama da pilha. Como de h\u00e1bito, o topo da pilha \u00e9 o frame de __main__ . Est\u00e1 vazio porque n\u00e3o criamos nenhuma vari\u00e1vel em __main__ nem passamos argumentos a ela. Os quatro frames do countdown t\u00eam valores diferentes para o par\u00e2metro n . O fundo da pilha, onde n = 0 , \u00e9 chamado caso-base. Ele n\u00e3o faz uma chamada recursiva, ent\u00e3o n\u00e3o h\u00e1 mais frames. Como exerc\u00edcio, desenhe um diagrama da pilha para print_n chamado com s = 'Hello' e n = 2 . Ent\u00e3o escreva uma fun\u00e7\u00e3o chamada do_n que tome um objeto de fun\u00e7\u00e3o e um n\u00famero n como argumentos e que chame a respectiva fun\u00e7\u00e3o n vezes.","title":"5.9 - Diagramas da pilha para fun\u00e7\u00f5es recursivas"},{"location":"05-cond-recur/#510-recursividade-infinita","text":"Se a recursividade nunca atingir um caso-base, continua fazendo chamadas recursivas para sempre, e o programa nunca termina. Isso \u00e9 conhecido como recursividade infinita e geralmente n\u00e3o \u00e9 uma boa ideia. Aqui est\u00e1 um programa m\u00ednimo com recursividade infinita: def recurse(): recurse() Na maior parte dos ambientes de programa\u00e7\u00e3o, um programa com recursividade infinita n\u00e3o \u00e9 realmente executado para sempre. O Python exibe uma mensagem de erro quando a profundidade m\u00e1xima de recursividade \u00e9 atingida: File \"<stdin>\", line 2, in recurse File \"<stdin>\", line 2, in recurse File \"<stdin>\", line 2, in recurse . . . File \"<stdin>\", line 2, in recurse RuntimeError: Maximum recursion depth exceeded Este traceback \u00e9 um pouco maior que o que vimos no cap\u00edtulo anterior. Quando o erro ocorre, h\u00e1 mil frames de recurse na pilha! Se voc\u00ea escrever em recursividade infinita por engano, confira se a sua fun\u00e7\u00e3o tem um caso-base que n\u00e3o faz uma chamada recursiva. E se houver um caso-base, verifique se voc\u00ea vai mesmo atingi-lo.","title":"5.10 - Recursividade infinita"},{"location":"05-cond-recur/#511-entrada-de-teclado","text":"Os programas que escrevemos at\u00e9 agora n\u00e3o aceitam entradas do usu\u00e1rio. Eles sempre fazem a mesma coisa cada vez. O Python fornece uma fun\u00e7\u00e3o integrada chamada input que interrompe o programa e espera que o usu\u00e1rio digite algo. Quando o usu\u00e1rio pressionar Return ou Enter, o programa volta a ser executado e input retorna o que o usu\u00e1rio digitou como uma string. No Python 2, a mesma fun\u00e7\u00e3o \u00e9 chamada raw_input . >>> text = input() What are you waiting for? >>> text What are you waiting for? Antes de receber entradas do usu\u00e1rio, \u00e9 uma boa ideia exibir um prompt dizendo ao usu\u00e1rio o que ele deve digitar. input pode ter um prompt como argumento: >>> name = input('What...is your name?\\\\n') What...is your name? Arthur, King of the Britons! >>> name Arthur, King of the Britons! A sequ\u00eancia \\n no final do prompt representa um newline, que \u00e9 um caractere especial de quebra de linha. \u00c9 por isso que a entrada do usu\u00e1rio aparece abaixo do prompt. Se esperar que o usu\u00e1rio digite um n\u00famero inteiro, voc\u00ea pode tentar converter o valor de retorno para int: >>> prompt = 'What...is the airspeed velocity of an unladen swallow?\\\\n' >>> speed = input(prompt) What...is the airspeed velocity of an unladen swallow? 42 >>> int(speed) 42 Mas se o usu\u00e1rio digitar algo al\u00e9m de uma s\u00e9rie de d\u00edgitos, voc\u00ea recebe um erro: >>> speed = input(prompt) What...is the airspeed velocity of an unladen swallow? What do you mean, an African or a European swallow? >>> int(speed) ValueError: invalid literal for int() with base 10 Veremos como tratar este tipo de erro mais adiante.","title":"5.11 - Entrada de teclado"},{"location":"05-cond-recur/#512-depuracao","text":"Quando um erro de sintaxe ou de tempo de execu\u00e7\u00e3o ocorre, a mensagem de erro cont\u00e9m muita informa\u00e7\u00e3o, \u00e0s vezes, at\u00e9 demais. As partes mais \u00fateis s\u00e3o normalmente: que tipo de erro foi; onde ocorreu. Erros de sintaxe s\u00e3o normalmente f\u00e1ceis de encontrar, mas h\u00e1 algumas pegadinhas. Erros de whitespace podem ser complicados porque os espa\u00e7os e tabula\u00e7\u00f5es s\u00e3o invis\u00edveis e estamos acostumados a ignor\u00e1-los. >>> x = 5 >>> y = 6 File \"<stdin>\", line 1 y = 6 ^ IndentationError: unexpected indent Neste exemplo, o problema \u00e9 que a segunda linha est\u00e1 endentada por um espa\u00e7o. Mas a mensagem de erro aponta para y, o que pode ser capcioso. Em geral, mensagens de erro indicam onde o problema foi descoberto, mas o erro real pode estar em outra parte do c\u00f3digo, \u00e0s vezes, em uma linha anterior. O mesmo acontece com erros em tempo de execu\u00e7\u00e3o. Suponha que voc\u00ea esteja tentando calcular a propor\u00e7\u00e3o de sinal a ru\u00eddo em decib\u00e9is. A f\u00f3rmula \u00e9 SNRdb = 10 log10 (Psignal/Pnoise). No Python, voc\u00ea poderia escrever algo assim: import math signal_power = 9 noise_power = 10 ratio = signal_power // noise_power decibels = 10 * math.log10(ratio) print(decibels) Ao executar este programa, voc\u00ea recebe uma exce\u00e7\u00e3o: Traceback (most recent call last): File \"snr.py\", line 5, in ? decibels = 10 * math.log10(ratio) ValueError: math domain error A mensagem de erro indica a linha 5, mas n\u00e3o h\u00e1 nada de errado com esta linha. Uma op\u00e7\u00e3o para encontrar o verdadeiro erro \u00e9 exibir o valor de ratio, que acaba sendo 0. O problema est\u00e1 na linha 4, que usa a divis\u00e3o pelo piso em vez da divis\u00e3o de ponto flutuante. \u00c9 preciso ler as mensagens de erro com aten\u00e7\u00e3o, mas n\u00e3o assumir que tudo que dizem esteja correto.","title":"5.12 - Depura\u00e7\u00e3o"},{"location":"05-cond-recur/#513-glossario","text":"divis\u00e3o pelo piso Um operador, denotado por //, que divide dois n\u00fameros e arredonda o resultado para baixo (em dire\u00e7\u00e3o ao zero), a um n\u00famero inteiro. operador m\u00f3dulo Um operador, denotado com um sinal de percentagem (%), que funciona com n\u00fameros inteiros e devolve o resto quando um n\u00famero \u00e9 dividido por outro. express\u00e3o booleana Uma express\u00e3o cujo valor \u00e9 True (verdadeiro) ou False (falso). operador relacional Um destes operadores, que compara seus operandos: `==`, `!=`, `>`, ` < `, `>=` e ` < =`. operador l\u00f3gico Um destes operadores, que combina express\u00f5es booleanas: and (e), or (ou) e not (n\u00e3o). instru\u00e7\u00e3o condicional Uma instru\u00e7\u00e3o que controla o fluxo de execu\u00e7\u00e3o, dependendo de alguma condi\u00e7\u00e3o. condi\u00e7\u00e3o A express\u00e3o booleana em uma instru\u00e7\u00e3o condicional que determina qual ramo deve ser executado. instru\u00e7\u00e3o composta Uma instru\u00e7\u00e3o composta de um cabe\u00e7alho e um corpo. O cabe\u00e7alho termina em dois pontos (:). O corpo \u00e9 endentado em rela\u00e7\u00e3o ao cabe\u00e7alho. ramo Uma das sequ\u00eancias alternativas de instru\u00e7\u00f5es em uma instru\u00e7\u00e3o condicional. condicional encadeada Uma instru\u00e7\u00e3o condicional com uma s\u00e9rie de ramos alternativos. condicional aninhada Uma instru\u00e7\u00e3o condicional que aparece em um dos ramos de outra instru\u00e7\u00e3o condicional. instru\u00e7\u00e3o de retorno Uma instru\u00e7\u00e3o que faz uma fun\u00e7\u00e3o terminar imediatamente e voltar a quem a chamou. recursividade O processo de chamar a fun\u00e7\u00e3o que est\u00e1 sendo executada no momento. caso-base Um ramo condicional em uma fun\u00e7\u00e3o recursiva que n\u00e3o faz uma chamada recursiva. recursividade infinita Recursividade que n\u00e3o tem um caso-base, ou nunca o atinge. A recursividade infinita eventualmente causa um erro em tempo de execu\u00e7\u00e3o.","title":"5.13 - Gloss\u00e1rio"},{"location":"05-cond-recur/#514-exercicios","text":"","title":"5.14 - Exerc\u00edcios"},{"location":"05-cond-recur/#exercicio-51","text":"O m\u00f3dulo time fornece uma fun\u00e7\u00e3o, tamb\u00e9m chamada time, que devolve a Hora M\u00e9dia de Greenwich na \u201c\u00e9poca\u201d, que \u00e9 um momento arbitr\u00e1rio usado como ponto de refer\u00eancia. Em sistemas UNIX, a \u00e9poca \u00e9 primeiro de janeiro de 1970. >>> import time >>> time.time() 1437746094.5735958 Escreva um script que leia a hora atual e a converta em um tempo em horas, minutos e segundos, mais o n\u00famero de dias desde a \u00e9poca.","title":"Exerc\u00edcio 5.1"},{"location":"05-cond-recur/#exercicio-52","text":"O \u00faltimo teorema de Fermat diz que n\u00e3o existem n\u00fameros inteiros a, b e c tais que a**n + b**n == c**n para quaisquer valores de n maiores que 2. Escreva uma fun\u00e7\u00e3o chamada check_fermat que receba quatro par\u00e2metros \u2013 a, b, c e n \u2013 e verifique se o teorema de Fermat se mant\u00e9m. Se n for maior que 2 e a**n + b**n == c**n o programa deve imprimir, \u201cHoly smokes, Fermat was wrong!\u201d Sen\u00e3o o programa deve exibir \u201cNo, that doesn\u2019t work.\u201d Escreva uma fun\u00e7\u00e3o que pe\u00e7a ao usu\u00e1rio para digitar valores para a, b, c e n, os converta em n\u00fameros inteiros e use check_fermat para verificar se violam o teorema de Fermat.","title":"Exerc\u00edcio 5.2"},{"location":"05-cond-recur/#exercicio-53","text":"Se voc\u00ea tiver tr\u00eas gravetos, pode ser que consiga arranj\u00e1-los em um tri\u00e2ngulo ou n\u00e3o. Por exemplo, se um dos gravetos tiver 12 polegadas de comprimento e outros dois tiverem uma polegada de comprimento, n\u00e3o ser\u00e1 poss\u00edvel fazer com que os gravetos curtos se encontrem no meio. H\u00e1 um teste simples para ver se \u00e9 poss\u00edvel formar um tri\u00e2ngulo para quaisquer tr\u00eas comprimentos: Se algum dos tr\u00eas comprimentos for maior que a soma dos outros dois, ent\u00e3o voc\u00ea n\u00e3o pode formar um tri\u00e2ngulo. Sen\u00e3o, voc\u00ea pode. (Se a soma de dois comprimentos igualar o terceiro, eles formam um tri\u00e2ngulo chamado \u201cdegenerado\u201d.) Escreva uma fun\u00e7\u00e3o chamada is_triangle que receba tr\u00eas n\u00fameros inteiros como argumentos, e que imprima \u201cYes\u201d ou \u201cNo\u201d, dependendo da possibilidade de formar ou n\u00e3o um tri\u00e2ngulo de gravetos com os comprimentos dados. Escreva uma fun\u00e7\u00e3o que pe\u00e7a ao usu\u00e1rio para digitar tr\u00eas comprimentos de gravetos, os converta em n\u00fameros inteiros e use is_triangle para verificar se os gravetos com os comprimentos dados podem formar um tri\u00e2ngulo.","title":"Exerc\u00edcio 5.3"},{"location":"05-cond-recur/#exercicio-54","text":"Qual \u00e9 a sa\u00edda do seguinte programa? Desenhe um diagrama da pilha que mostre o estado do programa quando exibir o resultado. def recurse(n, s): if n == 0: print(s) else: recurse(n-1, n+s) recurse(3, 0) O que aconteceria se voc\u00ea chamasse esta fun\u00e7\u00e3o desta forma: recurse(-1, 0)? Escreva uma docstring que explique tudo o que algu\u00e9m precisaria saber para usar esta fun\u00e7\u00e3o (e mais nada). Os seguintes exerc\u00edcios usam o m\u00f3dulo turtle, descrito no Cap\u00edtulo 4:","title":"Exerc\u00edcio 5.4"},{"location":"05-cond-recur/#exercicio-55","text":"Leia a pr\u00f3xima fun\u00e7\u00e3o e veja se consegue compreender o que ela faz (veja os exemplos no Cap\u00edtulo 4). Ent\u00e3o execute-a e veja se acertou. def draw(t, length, n): if n == 0: return angle = 50 t.fd(length * n) t.lt(angle) draw(t, length, n-1) t.rt(2 * angle) draw(t, length, n-1) t.lt(angle) t.bk(length * n)","title":"Exerc\u00edcio 5.5"},{"location":"05-cond-recur/#exercicio-56","text":"Figura 5.2 \u2013 Uma curva de Koch. A curva de Koch \u00e9 um fractal que parece com o da Figura 5.2. Para desenhar uma curva de Koch com o comprimento x, tudo o que voc\u00ea tem que fazer \u00e9: Desenhe uma curva de Koch com o comprimento x/3. Vire 60 graus \u00e0 esquerda. Desenhe uma curva de Koch com o comprimento x/3. Vire 120 graus \u00e0 direita. Desenhe uma curva de Koch com o comprimento x/3. Vire 60 graus \u00e0 esquerda. Desenhe uma curva de Koch com o comprimento x/3. A exce\u00e7\u00e3o \u00e9 se x for menor que 3: neste caso, voc\u00ea pode desenhar apenas uma linha reta com o comprimento x. Escreva uma fun\u00e7\u00e3o chamada koch que receba um turtle e um comprimento como par\u00e2metros, e use o turtle para desenhar uma curva de Koch com o comprimento dado. Escreva uma fun\u00e7\u00e3o chamada snowflake que desenhe tr\u00eas curvas de Koch para fazer o tra\u00e7ado de um floco de neve. Solu\u00e7\u00e3o: http://thinkpython2.com/code/koch.py. A curva de Koch pode ser generalizada de v\u00e1rios modos. Veja exemplos em http://en.wikipedia.org/wiki/Koch_snowflake e implemente o seu favorito.","title":"Exerc\u00edcio 5.6"},{"location":"06-funcoes-result/","text":"Cap\u00edtulo 6: Fun\u00e7\u00f5es com resultado Muitas das fun\u00e7\u00f5es do Python que usamos, como as matem\u00e1ticas, produzem valores de retorno. Mas as fun\u00e7\u00f5es que escrevemos at\u00e9 agora s\u00e3o todas nulas: t\u00eam um efeito, como exibir um valor ou mover uma tartaruga, mas n\u00e3o t\u00eam um valor de retorno. Neste cap\u00edtulo voc\u00ea aprender\u00e1 a escrever fun\u00e7\u00f5es com resultados. 6.1 - Valores de retorno A chamada de fun\u00e7\u00e3o gera um valor de retorno, que normalmente atribu\u00edmos a uma vari\u00e1vel ou usamos como parte de uma express\u00e3o. e = math.exp(1.0) height = radius * math.sin(radians) As fun\u00e7\u00f5es que descrevemos, por enquanto, s\u00e3o todas nulas. Resumindo, elas n\u00e3o t\u00eam valores de retorno; mais precisamente, o seu valor de retorno \u00e9 None. Neste cap\u00edtulo veremos (finalmente) como escrever fun\u00e7\u00f5es com resultados. O primeiro exemplo \u00e9 area, que devolve a \u00e1rea de um c\u00edrculo com o raio dado: def area(radius): a = math.pi * radius**2 return a J\u00e1 vimos a instru\u00e7\u00e3o return, mas em uma fun\u00e7\u00e3o com resultado ela inclui uma express\u00e3o. Esta instru\u00e7\u00e3o significa: \u201cVolte imediatamente desta fun\u00e7\u00e3o e use a seguinte express\u00e3o como valor de retorno\u201d. A express\u00e3o pode ser arbitrariamente complicada, ent\u00e3o poder\u00edamos ter escrito esta fun\u00e7\u00e3o de forma mais concisa: def area(radius): return math.pi * radius**2 Por outro lado, vari\u00e1veis tempor\u00e1rias como a, tornam a depura\u00e7\u00e3o mais f\u00e1cil. \u00c0s vezes, \u00e9 \u00fatil ter v\u00e1rias instru\u00e7\u00f5es de retorno, uma em cada ramo de uma condicional: def absolute_value(x): if x < 0: return -x else: return x Como essas instru\u00e7\u00f5es return est\u00e3o em uma condicional alternativa, apenas uma \u00e9 executada. Logo que uma instru\u00e7\u00e3o de retorno seja executada, a fun\u00e7\u00e3o termina sem executar nenhuma instru\u00e7\u00e3o subsequente. Qualquer c\u00f3digo que apare\u00e7a depois de uma instru\u00e7\u00e3o return, ou em qualquer outro lugar que o fluxo da execu\u00e7\u00e3o n\u00e3o atinja, \u00e9 chamado de c\u00f3digo morto. Em uma fun\u00e7\u00e3o com resultado, \u00e9 uma boa ideia garantir que cada caminho poss\u00edvel pelo programa atinja uma instru\u00e7\u00e3o return. Por exemplo: def absolute_value(x): if x < 0: return -x if x > 0: return x Essa fun\u00e7\u00e3o \u00e9 incorreta porque se x for 0, nenhuma condi\u00e7\u00e3o \u00e9 verdade, e a fun\u00e7\u00e3o termina sem chegar a uma instru\u00e7\u00e3o return. Se o fluxo de execu\u00e7\u00e3o chegar ao fim de uma fun\u00e7\u00e3o, o valor de retorno \u00e9 None, que n\u00e3o \u00e9 o valor absoluto de 0: >>> absolute_value(0) None A prop\u00f3sito, o Python oferece uma fun\u00e7\u00e3o integrada chamada abs, que calcula valores absolutos. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o compare que receba dois valores, x e y, e retorne 1 se x > y, 0 se x == y e -1 se x < y. 6.2 - Desenvolvimento incremental Conforme voc\u00ea escrever fun\u00e7\u00f5es maiores, pode ser que passe mais tempo as depurando. Para lidar com programas cada vez mais complexos, voc\u00ea pode querer tentar usar um processo chamado de desenvolvimento incremental. A meta do desenvolvimento incremental \u00e9 evitar longas sess\u00f5es de depura\u00e7\u00e3o, acrescentando e testando pequenas partes do c\u00f3digo de cada vez. Como um exemplo, vamos supor que voc\u00ea queira encontrar a dist\u00e2ncia entre dois pontos dados pelas coordenadas (x1, y1) e(x2, y2). Pelo teorema de Pit\u00e1goras, a dist\u00e2ncia \u00e9: O primeiro passo \u00e9 pensar como uma fun\u00e7\u00e3o distance deveria ser no Python. Em outras palavras, quais s\u00e3o as entradas (par\u00e2metros) e qual \u00e9 a sa\u00edda (valor de retorno)? Nesse caso, as entradas s\u00e3o dois pontos que voc\u00ea pode representar usando quatro n\u00fameros. O valor de retorno \u00e9 a dist\u00e2ncia representada por um valor de ponto flutuante. Imediatamente, \u00e9 poss\u00edvel escrever um rascunho da fun\u00e7\u00e3o: def distance(x1, y1, x2, y2): return 0.0 Claro que esta vers\u00e3o n\u00e3o calcula dist\u00e2ncias; sempre retorna zero. Mas est\u00e1 sintaticamente correta, e pode ser executada, o que significa que voc\u00ea pode test\u00e1-la antes de torn\u00e1-la mais complicada. Para testar a nova fun\u00e7\u00e3o, chame-a com argumentos de amostra: >>> distance(1, 2, 4, 6) 0.0 Escolhi esses valores para que a dist\u00e2ncia horizontal seja 3 e a dist\u00e2ncia vertical, 4; assim, o resultado final \u00e9 5, a hipotenusa de um tri\u00e2ngulo 3-4-5. Ao testar uma fun\u00e7\u00e3o, \u00e9 \u00fatil saber a resposta certa. Neste ponto confirmamos que a fun\u00e7\u00e3o est\u00e1 sintaticamente correta, e podemos come\u00e7ar a acrescentar c\u00f3digo ao corpo. Um pr\u00f3ximo passo razo\u00e1vel \u00e9 encontrar as diferen\u00e7as x2 \u2212 x1 e y2 \u2212 y1. A pr\u00f3xima vers\u00e3o guarda esses valores em vari\u00e1veis tempor\u00e1rias e os exibe: def distance(x1, y1, x2, y2): dx = x2 - x1 dy = y2 - y1 print('dx is', dx) print('dy is', dy) return 0.0 Se a fun\u00e7\u00e3o estiver funcionando, deve exibir dx is 3 e dy is 4. Nesse caso sabemos que a fun\u00e7\u00e3o est\u00e1 recebendo os argumentos corretos e executando o primeiro c\u00e1lculo acertadamente. Se n\u00e3o, h\u00e1 poucas linhas para verificar. Depois calculamos a soma dos quadrados de dx e dy: def distance(x1, y1, x2, y2): dx = x2 - x1 dy = y2 - y1 dsquared = dx**2 + dy**2 print('dsquared is: ', dsquared) return 0.0 Nesta etapa voc\u00ea executaria o programa mais uma vez e verificaria a sa\u00edda (que deve ser 25). Finalmente, pode usar math.sqrt para calcular e devolver o resultado: def distance(x1, y1, x2, y2): dx = x2 - x1 dy = y2 - y1 dsquared = dx**2 + dy**2 result = math.sqrt(dsquared) return result Se funcionar corretamente, pronto. Sen\u00e3o, uma ideia \u00e9 exibir o valor result antes da instru\u00e7\u00e3o de retorno. A vers\u00e3o final da fun\u00e7\u00e3o n\u00e3o exibe nada ao ser executada; apenas retorna um valor. As instru\u00e7\u00f5es print que escrevemos s\u00e3o \u00fateis para depura\u00e7\u00e3o, mas assim que conferir se a fun\u00e7\u00e3o est\u00e1 funcionando voc\u00ea deve retir\u00e1-las. C\u00f3digos desse tipo s\u00e3o chamados de scaffolding (andaime) porque s\u00e3o \u00fateis para construir o programa, mas n\u00e3o s\u00e3o parte do produto final. Ao come\u00e7ar, voc\u00ea deveria acrescentar apenas uma linha ou duas de c\u00f3digo de cada vez. Conforme adquira mais experi\u00eancia, poder\u00e1 escrever e depurar parcelas maiores. De qualquer forma, o desenvolvimento incremental pode economizar muito tempo de depura\u00e7\u00e3o. Os principais aspectos do processo s\u00e3o: Comece com um programa que funcione e fa\u00e7a pequenas altera\u00e7\u00f5es incrementais. Se houver um erro em qualquer ponto, ser\u00e1 bem mais f\u00e1cil encontr\u00e1-lo. Use vari\u00e1veis para guardar valores intermedi\u00e1rios, assim poder\u00e1 exibi-los e verific\u00e1-los. Uma vez que o programa esteja funcionando, voc\u00ea pode querer remover uma parte do scaffolding ou consolidar v\u00e1rias instru\u00e7\u00f5es em express\u00f5es compostas, mas apenas se isso n\u00e3o tornar o programa dif\u00edcil de ler. Como exerc\u00edcio, use o desenvolvimento incremental para escrever uma fun\u00e7\u00e3o chamada hypotenuse, que devolva o comprimento da hipotenusa de um tri\u00e2ngulo ret\u00e2ngulo dados os comprimentos dos outros dois lados como argumentos. Registre cada etapa do processo de desenvolvimento no decorrer do processo. 6.3 - Composi\u00e7\u00e3o Como voc\u00ea j\u00e1 deveria esperar a essa altura, \u00e9 poss\u00edvel chamar uma fun\u00e7\u00e3o de dentro de outra. Como exemplo, escreveremos uma fun\u00e7\u00e3o que recebe dois pontos, o centro do c\u00edrculo e um ponto no per\u00edmetro, para calcular a \u00e1rea do c\u00edrculo. Suponha que o ponto do centro seja guardado nas vari\u00e1veis xc e yc e o ponto de per\u00edmetro est\u00e1 em xp e yp. O primeiro passo deve ser encontrar o raio do c\u00edrculo, que \u00e9 a dist\u00e2ncia entre os dois pontos. Acabamos de escrever uma fun\u00e7\u00e3o, distance, que faz isto: radius = distance(xc, yc, xp, yp) O pr\u00f3ximo passo deve ser encontrar a \u00e1rea de um c\u00edrculo com aquele raio; acabamos de escrever isso tamb\u00e9m: result = area(radius) Encapsulando esses passos em uma fun\u00e7\u00e3o, temos: def circle_area(xc, yc, xp, yp): radius = distance(xc, yc, xp, yp) result = area(radius) return result As vari\u00e1veis tempor\u00e1rias radius e result s\u00e3o \u00fateis para desenvolvimento e depura\u00e7\u00e3o, e uma vez que o programa esteja funcionando podemos torn\u00e1-lo mais conciso compondo chamadas de fun\u00e7\u00e3o: def circle_area(xc, yc, xp, yp): return area(distance(xc, yc, xp, yp)) 6.4 - Fun\u00e7\u00f5es booleanas As fun\u00e7\u00f5es podem retornar booleans, o que pode ser conveniente para esconder testes complicados dentro de fun\u00e7\u00f5es. Por exemplo: def is_divisible(x, y): if x % y == 0: return True else: return False \u00c9 comum dar nomes de fun\u00e7\u00f5es booleanas que pare\u00e7am perguntas de sim ou n\u00e3o; is_divisible retorna True ou False para indicar se x \u00e9 divis\u00edvel por y. Aqui est\u00e1 um exemplo: >>> is_divisible(6, 4) False >>> is_divisible(6, 3) True O resultado do operador == \u00e9 um booleano, ent\u00e3o podemos escrever a fun\u00e7\u00e3o de forma mais concisa, retornando-o diretamente: def is_divisible(x, y): return x % y == 0 As fun\u00e7\u00f5es booleanas muitas vezes s\u00e3o usadas em instru\u00e7\u00f5es condicionais: if is_divisible(x, y): print('x is divisible by y') Pode ser tentador escrever algo assim: if is_divisible(x, y) == True: print('x is divisible by y') Mas a compara\u00e7\u00e3o extra \u00e9 desnecess\u00e1ria. Como um exerc\u00edcio, escreva uma fun\u00e7\u00e3o is_between(x, y, z) que retorne True, se x \u2264 y \u2264 z, ou False, se n\u00e3o for o caso. 6.5 - Mais recursividade Cobrimos apenas um pequeno subconjunto do Python, mas talvez seja bom voc\u00ea saber que este subconjunto \u00e9 uma linguagem de programa\u00e7\u00e3o completa, ou seja, qualquer coisa que possa ser calculada pode ser expressa nesta linguagem. Qualquer programa que j\u00e1 foi escrito pode ser reescrito apenas com os recursos da linguagem que voc\u00ea aprendeu at\u00e9 agora (na verdade, seria preciso alguns comandos para dispositivos de controle como mouse, discos etc., mas isso \u00e9 tudo). Comprovar esta declara\u00e7\u00e3o \u00e9 um exerc\u00edcio nada trivial realizado pela primeira vez por Alan Turing, um dos primeiros cientistas da computa\u00e7\u00e3o (alguns diriam que ele foi matem\u00e1tico, mas muitos dos primeiros cientistas da computa\u00e7\u00e3o come\u00e7aram como matem\u00e1ticos). Assim, \u00e9 conhecida como a Tese de Turing. Para uma exposi\u00e7\u00e3o mais completa (e exata) da Tese de Turing, recomendo o livro de Michael Sipser, Introduction to the Theory of Computation (Introdu\u00e7\u00e3o \u00e0 teoria da computa\u00e7\u00e3o, Course Technology, 2012). Para dar uma ideia do que podemos fazer com as ferramentas que aprendeu at\u00e9 agora, avaliaremos algumas fun\u00e7\u00f5es matem\u00e1ticas definidas recursivamente. Uma defini\u00e7\u00e3o recursiva \u00e9 semelhante a uma defini\u00e7\u00e3o circular, no sentido de que a defini\u00e7\u00e3o cont\u00e9m uma refer\u00eancia \u00e0 coisa que \u00e9 definida. Uma defini\u00e7\u00e3o realmente circular n\u00e3o \u00e9 muito \u00fatil: vorpal Adjetivo usado para descrever algo que \u00e9 vorpal. Ver uma defini\u00e7\u00e3o assim no dicion\u00e1rio pode ser irritante. Por outro lado, se procurar a defini\u00e7\u00e3o da fun\u00e7\u00e3o de fatorial, denotada pelo s\u00edmbolo !, voc\u00ea pode encontrar algo assim: 0! = 1 n! = n\u00b7(n \u2212 1)! Esta defini\u00e7\u00e3o diz que o fatorial de 0 \u00e9 1, e o fatorial de qualquer outro valor, n, \u00e9 n multiplicado pelo fatorial de n-1. Ent\u00e3o 3! \u00e9 3 vezes 2!, que \u00e9 2 vezes 1!, que \u00e9 1 vez 0!. Juntando tudo, 3! \u00e9 igual a 3 vezes 2 vezes 1 vezes 1, que \u00e9 6. Se puder escrever uma defini\u00e7\u00e3o recursiva de algo, voc\u00ea poder\u00e1 escrever um programa em Python que a avalie. O primeiro passo deve ser decidir quais par\u00e2metros ela deve ter. Neste caso, deve estar claro que factorial recebe um n\u00famero inteiro: def factorial(n): Se o argumento for 0, tudo que temos de fazer \u00e9 retornar 1: def factorial(n): if n == 0: return 1 Sen\u00e3o, e a\u00ed \u00e9 que fica interessante, temos que fazer uma chamada recursiva para encontrar o fatorial de n-1 e ent\u00e3o multiplic\u00e1-lo por n: def factorial(n): if n == 0: return 1 else: recurse = factorial(n-1) result = n * recurse return result O fluxo de execu\u00e7\u00e3o deste programa \u00e9 semelhante ao fluxo de countdown em \u201cRecursividade\u201d, na p\u00e1gina 81. Se chamarmos factorial com o valor 3: Como 3 n\u00e3o \u00e9 0, tomamos o segundo ramo e calculamos o fatorial de n-1... Como 2 n\u00e3o \u00e9 0, tomamos o segundo ramo e calculamos o fatorial de n-1... Como 1 n\u00e3o \u00e9 0, tomamos o segundo ramo e calculamos o fatorial de n-1... Como 0 \u00e9 igual a 0, tomamos o primeiro ramo e devolvemos 1 sem fazer mais chamadas recursivas. O valor de retorno, 1, \u00e9 multiplicado por n, que \u00e9 1, e o resultado \u00e9 devolvido. O valor de retorno, 1, \u00e9 multiplicado por n, que \u00e9 2, e o resultado \u00e9 devolvido. O valor devolvido (2) \u00e9 multiplicado por n, que \u00e9 3, e o resultado, 6, torna-se o valor devolvido pela chamada de fun\u00e7\u00e3o que come\u00e7ou o processo inteiro. A Figura 6.1 mostra como \u00e9 o diagrama da pilha para esta sequ\u00eancia de chamadas de fun\u00e7\u00e3o. Figura 6.1 \u2013 Diagrama da pilha para factorial. Os valores devolvidos s\u00e3o mostrados ao serem passados de volta at\u00e9 o alto da pilha. Em cada frame, o valor devolvido \u00e9 o valor de result , que \u00e9 o produto de n e recurse . No \u00faltimo frame, as vari\u00e1veis locais recurse e result n\u00e3o existem, porque o ramo que os cria n\u00e3o \u00e9 executado. 6.6 - Salto de f\u00e9 Seguir o fluxo da execu\u00e7\u00e3o \u00e9 uma forma de ler programas, mas poder\u00e1 ser trabalhoso demais. Uma alternativa \u00e9 o que chamo de \u201csalto de f\u00e9\u201d (leap of faith). Ao chegar a uma chamada de fun\u00e7\u00e3o, em vez de seguir o fluxo de execu\u00e7\u00e3o suponha que a fun\u00e7\u00e3o esteja funcionando corretamente e que est\u00e1 retornando o resultado certo. Na verdade, voc\u00ea j\u00e1 est\u00e1 praticando este salto de f\u00e9 quando usa fun\u00e7\u00f5es integradas. Quando chama math.cos ou math.exp, voc\u00ea n\u00e3o examina o corpo dessas fun\u00e7\u00f5es. Apenas sup\u00f5e que funcionem porque as pessoas que as escreveram eram bons programadores. O mesmo acontece ao chamar uma das suas pr\u00f3prias fun\u00e7\u00f5es. Por exemplo, em \u201cFun\u00e7\u00f5es booleanas\u201d, na p\u00e1gina 97, escrevemos uma fun\u00e7\u00e3o chamada is_divisible que determina se um n\u00famero \u00e9 divis\u00edvel por outro. Uma vez que estejamos convencidos de que esta fun\u00e7\u00e3o est\u00e1 correta \u2013 examinando o c\u00f3digo e testando \u2013 podemos usar a fun\u00e7\u00e3o sem ver o corpo novamente. O mesmo \u00e9 verdade para programas recursivos. Quando chega \u00e0 chamada recursiva, em vez de seguir o fluxo de execu\u00e7\u00e3o, voc\u00ea deveria supor que a chamada recursiva funcione (devolva o resultado correto) e ent\u00e3o perguntar-se: \u201cSupondo que eu possa encontrar o fatorial de n-1, posso calcular o fatorial de n?\u201d. \u00c9 claro que pode, multiplicando por n. Naturalmente, \u00e9 um pouco estranho supor que a fun\u00e7\u00e3o funcione corretamente quando ainda n\u00e3o terminou de escrev\u00ea-la, mas \u00e9 por isso que se chama um salto de f\u00e9! 6.7 - Mais um exemplo Depois do factorial, o exemplo mais comum de uma fun\u00e7\u00e3o matem\u00e1tica definida recursivamente \u00e9 fibonacci, que tem a seguinte defini\u00e7\u00e3o (ver http://en.wikipedia.org/wiki/Fibonacci_number): fibonacci(0) = 0 fibonacci(1) = 1 fibonacci(n) = fibonacci(n \u2212 1) + fibonacci(n \u2212 2) Traduzida para Python, ela fica assim: def fibonacci (n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) Se tentar seguir o fluxo de execu\u00e7\u00e3o aqui, at\u00e9 para valores razoavelmente pequenos de n, sua cabe\u00e7a explode. Por\u00e9m, seguindo o salto de f\u00e9, supondo que as duas chamadas recursivas funcionem corretamente, ent\u00e3o \u00e9 claro que vai receber o resultado correto adicionando-as juntas. 6.8 - Verifica\u00e7\u00e3o de tipos O que acontece se chamarmos factorial e usarmos 1.5 como argumento? >>> factorial(1.5) RuntimeError: Maximum recursion depth exceeded Parece uma recursividade infinita. No entanto, por que isso acontece? A fun\u00e7\u00e3o tem um caso-base \u2013 quando n == 0. Mas se n n\u00e3o \u00e9 um n\u00famero inteiro, podemos perder o caso-base e recorrer para sempre. Na primeira chamada recursiva, o valor de n \u00e9 0.5. No seguinte, \u00e9 -0.5. Da\u00ed, torna-se menor (mais negativo), mas nunca ser\u00e1 0. Temos duas escolhas. Podemos tentar generalizar a fun\u00e7\u00e3o factorial para trabalhar com n\u00fameros de ponto flutuante, ou podemos fazer factorial controlar o tipo de argumento que recebe. A primeira op\u00e7\u00e3o chama-se fun\u00e7\u00e3o gamma e est\u00e1 um pouco al\u00e9m do alcance deste livro. Ent\u00e3o usaremos a segunda op\u00e7\u00e3o. Podemos usar a fun\u00e7\u00e3o integrada isinstance para verificar o tipo de argumento. E vamos aproveitar para verificar tamb\u00e9m se o argumento \u00e9 positivo: def factorial (n): if not isinstance(n, int): print('Factorial is only defined for integers.') return None elif n < 0: print('Factorial is not defined for negative integers.') return None elif n == 0: return 1 else: return n * factorial(n-1) O primeiro caso-base lida com n\u00fameros n\u00e3o inteiros; o segundo, com n\u00fameros inteiros negativos. Em ambos os casos o programa exibe uma mensagem de erro e retorna None para indicar que algo deu errado: >>> factorial('fred') Factorial is only defined for integers. None >>> factorial(-2) Factorial is not defined for negative integers. None Se passarmos por ambas as verifica\u00e7\u00f5es, sabemos que n \u00e9 positivo ou zero, ent\u00e3o podemos comprovar que a recursividade termina. Esse programa demonstra um padr\u00e3o \u00e0s vezes chamado de guardi\u00e3o. As duas primeiras condicionais atuam como guardi\u00e3s, protegendo o c\u00f3digo que segue de valores que poderiam causar um erro. As guardi\u00e3s permitem comprovar a corre\u00e7\u00e3o do c\u00f3digo. Na \u201cBusca reversa\u201d, na p\u00e1gina 165, veremos uma alternativa mais flex\u00edvel para a exibi\u00e7\u00e3o de uma mensagem de erro: o levantamento de exce\u00e7\u00f5es. 6.9 - Depura\u00e7\u00e3o Quebrar um grande programa em fun\u00e7\u00f5es menores cria controles naturais da depura\u00e7\u00e3o. Se uma fun\u00e7\u00e3o n\u00e3o estiver funcionando, h\u00e1 tr\u00eas possibilidades a considerar: H\u00e1 algo errado com os argumentos que a fun\u00e7\u00e3o est\u00e1 recebendo; uma precondi\u00e7\u00e3o est\u00e1 sendo violada. H\u00e1 algo errado com a fun\u00e7\u00e3o; uma p\u00f3s-condi\u00e7\u00e3o foi violada. H\u00e1 algo errado com o valor de retorno ou a forma na qual est\u00e1 sendo usado. Para excluir a primeira possibilidade, voc\u00ea pode acrescentar uma instru\u00e7\u00e3o print no in\u00edcio da fun\u00e7\u00e3o e exibir os valores dos par\u00e2metros (e talvez os seus tipos). Ou escrever c\u00f3digo que verifique as precondi\u00e7\u00f5es explicitamente. Se os par\u00e2metros parecerem bons, acrescente uma instru\u00e7\u00e3o print antes de cada instru\u00e7\u00e3o return e exiba o valor de retorno. Se poss\u00edvel, verifique o resultado \u00e0 m\u00e3o. Uma possibilidade \u00e9 chamar a fun\u00e7\u00e3o com valores facilitem a verifica\u00e7\u00e3o do resultado (como no \u201cDesenvolvimento incremental\u201d, da p\u00e1gina 94). Se a fun\u00e7\u00e3o parecer funcionar, veja a chamada da fun\u00e7\u00e3o para ter certeza de que o valor de retorno est\u00e1 sendo usado corretamente (ou se est\u00e1 sendo usado mesmo!). Acrescentar instru\u00e7\u00f5es de exibi\u00e7\u00e3o no come\u00e7o e no fim de uma fun\u00e7\u00e3o pode ajudar a tornar o fluxo de execu\u00e7\u00e3o mais vis\u00edvel. Por exemplo, aqui est\u00e1 uma vers\u00e3o de factorial com instru\u00e7\u00f5es de exibi\u00e7\u00e3o: def factorial(n): space = ' ' * (4 * n) print(space, 'factorial', n) if n == 0: print(space, 'returning 1') return 1 else: recurse = factorial(n-1) result = n * recurse print(space, 'returning', result) return result space \u00e9 uma string de caracteres especiais que controla a endenta\u00e7\u00e3o da sa\u00edda. Aqui est\u00e1 o resultado de factorial(4): factorial 4 factorial 3 factorial 2 factorial 1 factorial 0 returning 1 returning 1 returning 2 returning 6 returning 24 Se o fluxo de execu\u00e7\u00e3o parecer confuso a voc\u00ea, este tipo de sa\u00edda pode ser \u00fatil. Leva um tempo para desenvolver um scaffolding eficaz, mas um pouco dele pode economizar muita depura\u00e7\u00e3o. 6.10 - Gloss\u00e1rio vari\u00e1vel tempor\u00e1ria Uma vari\u00e1vel usada para guardar um valor intermedi\u00e1rio em um c\u00e1lculo complexo. c\u00f3digo morto A parte de um programa que nunca pode ser executada, muitas vezes porque aparece depois de uma instru\u00e7\u00e3o return. desenvolvimento incremental Um plano de desenvolvimento de programa para evitar a depura\u00e7\u00e3o, que acrescenta e testa poucas linhas de c\u00f3digo de cada vez. scaffolding (andaime) O c\u00f3digo que se usa durante o desenvolvimento de programa, mas que n\u00e3o faz parte da vers\u00e3o final. guardi\u00e3o Um padr\u00e3o de programa\u00e7\u00e3o que usa uma instru\u00e7\u00e3o condicional para verificar e lidar com circunst\u00e2ncias que possam causar erros. 6.11 - Exerc\u00edcios Exerc\u00edcio 6.1 Desenhe um diagrama da pilha do seguinte programa. O que o programa exibe? def b(z): prod = a(z, z) print(z, prod) return prod def a(x, y): x = x + 1 return x * y def c(x, y, z): total = x + y + z square = b(total)**2 return square x = 1 y = x + 1 print(c(x, y+3, x+y)) Exerc\u00edcio 6.2 A fun\u00e7\u00e3o de Ackermann, A(m, n), \u00e9 definida assim: Veja http://en.wikipedia.org/wiki/Ackermann_function. Escreva uma fun\u00e7\u00e3o denominada ack que avalie a fun\u00e7\u00e3o de Ackermann. Use a sua fun\u00e7\u00e3o para avaliar ack(3, 4) , cujo resultado deve ser 125. O que acontece para valores maiores de m e n? Solu\u00e7\u00e3o: http://thinkpython2.com/code/ackermann.py. Exerc\u00edcio 6.3 Um pal\u00edndromo \u00e9 uma palavra que se soletra da mesma forma nos dois sentidos, como \u201cosso\u201d e \u201creviver\u201d. Recursivamente, uma palavra \u00e9 um pal\u00edndromo se a primeira e \u00faltima letras forem iguais e o meio for um pal\u00edndromo. As fun\u00e7\u00f5es seguintes recebem uma string como argumento e retornam as letras iniciais, finais e do meio das palavras: def first(word): return word[0] def last(word): return word[-1] def middle(word): return word[1:-1] Veremos como funcionam no Cap\u00edtulo 8. Digite essas fun\u00e7\u00f5es em um arquivo chamado palindrome.py e teste-as. O que acontece se chamar middle com uma string de duas letras? Uma letra? E se a string estiver vazia, escrita com '' e n\u00e3o contiver nenhuma letra? Escreva uma fun\u00e7\u00e3o chamada is_palindrome que receba uma string como argumento e retorne True se for um pal\u00edndromo e False se n\u00e3o for. Lembre-se de que voc\u00ea pode usar a fun\u00e7\u00e3o integrada len para verificar o comprimento de uma string. Solu\u00e7\u00e3o: http://thinkpython2.com/code/palindrome_soln.py. Exerc\u00edcio 6.4 Um n\u00famero a \u00e9 uma pot\u00eancia de b se for divis\u00edvel por b e a/b for uma pot\u00eancia de b. Escreva uma fun\u00e7\u00e3o chamada is_power que receba os par\u00e2metros a e b e retorne True se a for uma pot\u00eancia de b. Dica: pense no caso-base. Exerc\u00edcio 6.5 O maior divisor comum (MDC, ou GCD em ingl\u00eas) de a e b \u00e9 o maior n\u00famero que divide ambos sem sobrar resto. Um modo de encontrar o MDC de dois n\u00fameros \u00e9 observar qual \u00e9 o resto r quando a \u00e9 dividido por b, verificando que gcd(a, b) = gcd(b, r). Como caso-base, podemos usar gcd(a, 0) = a. Escreva uma fun\u00e7\u00e3o chamada gcd que receba os par\u00e2metros a e b e devolva o maior divisor comum. Cr\u00e9dito: Este exerc\u00edcio \u00e9 baseado em um exemplo do livro de Abelson e Sussman, Structure and Interpretation of Computer Programs (Estrutura e interpreta\u00e7\u00e3o de programas de computador, MIT Press, 1996).","title":"Cap\u00edtulo 6: Fun\u00e7\u00f5es com resultado"},{"location":"06-funcoes-result/#capitulo-6-funcoes-com-resultado","text":"Muitas das fun\u00e7\u00f5es do Python que usamos, como as matem\u00e1ticas, produzem valores de retorno. Mas as fun\u00e7\u00f5es que escrevemos at\u00e9 agora s\u00e3o todas nulas: t\u00eam um efeito, como exibir um valor ou mover uma tartaruga, mas n\u00e3o t\u00eam um valor de retorno. Neste cap\u00edtulo voc\u00ea aprender\u00e1 a escrever fun\u00e7\u00f5es com resultados.","title":"Cap\u00edtulo 6: Fun\u00e7\u00f5es com resultado"},{"location":"06-funcoes-result/#61-valores-de-retorno","text":"A chamada de fun\u00e7\u00e3o gera um valor de retorno, que normalmente atribu\u00edmos a uma vari\u00e1vel ou usamos como parte de uma express\u00e3o. e = math.exp(1.0) height = radius * math.sin(radians) As fun\u00e7\u00f5es que descrevemos, por enquanto, s\u00e3o todas nulas. Resumindo, elas n\u00e3o t\u00eam valores de retorno; mais precisamente, o seu valor de retorno \u00e9 None. Neste cap\u00edtulo veremos (finalmente) como escrever fun\u00e7\u00f5es com resultados. O primeiro exemplo \u00e9 area, que devolve a \u00e1rea de um c\u00edrculo com o raio dado: def area(radius): a = math.pi * radius**2 return a J\u00e1 vimos a instru\u00e7\u00e3o return, mas em uma fun\u00e7\u00e3o com resultado ela inclui uma express\u00e3o. Esta instru\u00e7\u00e3o significa: \u201cVolte imediatamente desta fun\u00e7\u00e3o e use a seguinte express\u00e3o como valor de retorno\u201d. A express\u00e3o pode ser arbitrariamente complicada, ent\u00e3o poder\u00edamos ter escrito esta fun\u00e7\u00e3o de forma mais concisa: def area(radius): return math.pi * radius**2 Por outro lado, vari\u00e1veis tempor\u00e1rias como a, tornam a depura\u00e7\u00e3o mais f\u00e1cil. \u00c0s vezes, \u00e9 \u00fatil ter v\u00e1rias instru\u00e7\u00f5es de retorno, uma em cada ramo de uma condicional: def absolute_value(x): if x < 0: return -x else: return x Como essas instru\u00e7\u00f5es return est\u00e3o em uma condicional alternativa, apenas uma \u00e9 executada. Logo que uma instru\u00e7\u00e3o de retorno seja executada, a fun\u00e7\u00e3o termina sem executar nenhuma instru\u00e7\u00e3o subsequente. Qualquer c\u00f3digo que apare\u00e7a depois de uma instru\u00e7\u00e3o return, ou em qualquer outro lugar que o fluxo da execu\u00e7\u00e3o n\u00e3o atinja, \u00e9 chamado de c\u00f3digo morto. Em uma fun\u00e7\u00e3o com resultado, \u00e9 uma boa ideia garantir que cada caminho poss\u00edvel pelo programa atinja uma instru\u00e7\u00e3o return. Por exemplo: def absolute_value(x): if x < 0: return -x if x > 0: return x Essa fun\u00e7\u00e3o \u00e9 incorreta porque se x for 0, nenhuma condi\u00e7\u00e3o \u00e9 verdade, e a fun\u00e7\u00e3o termina sem chegar a uma instru\u00e7\u00e3o return. Se o fluxo de execu\u00e7\u00e3o chegar ao fim de uma fun\u00e7\u00e3o, o valor de retorno \u00e9 None, que n\u00e3o \u00e9 o valor absoluto de 0: >>> absolute_value(0) None A prop\u00f3sito, o Python oferece uma fun\u00e7\u00e3o integrada chamada abs, que calcula valores absolutos. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o compare que receba dois valores, x e y, e retorne 1 se x > y, 0 se x == y e -1 se x < y.","title":"6.1 - Valores de retorno"},{"location":"06-funcoes-result/#62-desenvolvimento-incremental","text":"Conforme voc\u00ea escrever fun\u00e7\u00f5es maiores, pode ser que passe mais tempo as depurando. Para lidar com programas cada vez mais complexos, voc\u00ea pode querer tentar usar um processo chamado de desenvolvimento incremental. A meta do desenvolvimento incremental \u00e9 evitar longas sess\u00f5es de depura\u00e7\u00e3o, acrescentando e testando pequenas partes do c\u00f3digo de cada vez. Como um exemplo, vamos supor que voc\u00ea queira encontrar a dist\u00e2ncia entre dois pontos dados pelas coordenadas (x1, y1) e(x2, y2). Pelo teorema de Pit\u00e1goras, a dist\u00e2ncia \u00e9: O primeiro passo \u00e9 pensar como uma fun\u00e7\u00e3o distance deveria ser no Python. Em outras palavras, quais s\u00e3o as entradas (par\u00e2metros) e qual \u00e9 a sa\u00edda (valor de retorno)? Nesse caso, as entradas s\u00e3o dois pontos que voc\u00ea pode representar usando quatro n\u00fameros. O valor de retorno \u00e9 a dist\u00e2ncia representada por um valor de ponto flutuante. Imediatamente, \u00e9 poss\u00edvel escrever um rascunho da fun\u00e7\u00e3o: def distance(x1, y1, x2, y2): return 0.0 Claro que esta vers\u00e3o n\u00e3o calcula dist\u00e2ncias; sempre retorna zero. Mas est\u00e1 sintaticamente correta, e pode ser executada, o que significa que voc\u00ea pode test\u00e1-la antes de torn\u00e1-la mais complicada. Para testar a nova fun\u00e7\u00e3o, chame-a com argumentos de amostra: >>> distance(1, 2, 4, 6) 0.0 Escolhi esses valores para que a dist\u00e2ncia horizontal seja 3 e a dist\u00e2ncia vertical, 4; assim, o resultado final \u00e9 5, a hipotenusa de um tri\u00e2ngulo 3-4-5. Ao testar uma fun\u00e7\u00e3o, \u00e9 \u00fatil saber a resposta certa. Neste ponto confirmamos que a fun\u00e7\u00e3o est\u00e1 sintaticamente correta, e podemos come\u00e7ar a acrescentar c\u00f3digo ao corpo. Um pr\u00f3ximo passo razo\u00e1vel \u00e9 encontrar as diferen\u00e7as x2 \u2212 x1 e y2 \u2212 y1. A pr\u00f3xima vers\u00e3o guarda esses valores em vari\u00e1veis tempor\u00e1rias e os exibe: def distance(x1, y1, x2, y2): dx = x2 - x1 dy = y2 - y1 print('dx is', dx) print('dy is', dy) return 0.0 Se a fun\u00e7\u00e3o estiver funcionando, deve exibir dx is 3 e dy is 4. Nesse caso sabemos que a fun\u00e7\u00e3o est\u00e1 recebendo os argumentos corretos e executando o primeiro c\u00e1lculo acertadamente. Se n\u00e3o, h\u00e1 poucas linhas para verificar. Depois calculamos a soma dos quadrados de dx e dy: def distance(x1, y1, x2, y2): dx = x2 - x1 dy = y2 - y1 dsquared = dx**2 + dy**2 print('dsquared is: ', dsquared) return 0.0 Nesta etapa voc\u00ea executaria o programa mais uma vez e verificaria a sa\u00edda (que deve ser 25). Finalmente, pode usar math.sqrt para calcular e devolver o resultado: def distance(x1, y1, x2, y2): dx = x2 - x1 dy = y2 - y1 dsquared = dx**2 + dy**2 result = math.sqrt(dsquared) return result Se funcionar corretamente, pronto. Sen\u00e3o, uma ideia \u00e9 exibir o valor result antes da instru\u00e7\u00e3o de retorno. A vers\u00e3o final da fun\u00e7\u00e3o n\u00e3o exibe nada ao ser executada; apenas retorna um valor. As instru\u00e7\u00f5es print que escrevemos s\u00e3o \u00fateis para depura\u00e7\u00e3o, mas assim que conferir se a fun\u00e7\u00e3o est\u00e1 funcionando voc\u00ea deve retir\u00e1-las. C\u00f3digos desse tipo s\u00e3o chamados de scaffolding (andaime) porque s\u00e3o \u00fateis para construir o programa, mas n\u00e3o s\u00e3o parte do produto final. Ao come\u00e7ar, voc\u00ea deveria acrescentar apenas uma linha ou duas de c\u00f3digo de cada vez. Conforme adquira mais experi\u00eancia, poder\u00e1 escrever e depurar parcelas maiores. De qualquer forma, o desenvolvimento incremental pode economizar muito tempo de depura\u00e7\u00e3o. Os principais aspectos do processo s\u00e3o: Comece com um programa que funcione e fa\u00e7a pequenas altera\u00e7\u00f5es incrementais. Se houver um erro em qualquer ponto, ser\u00e1 bem mais f\u00e1cil encontr\u00e1-lo. Use vari\u00e1veis para guardar valores intermedi\u00e1rios, assim poder\u00e1 exibi-los e verific\u00e1-los. Uma vez que o programa esteja funcionando, voc\u00ea pode querer remover uma parte do scaffolding ou consolidar v\u00e1rias instru\u00e7\u00f5es em express\u00f5es compostas, mas apenas se isso n\u00e3o tornar o programa dif\u00edcil de ler. Como exerc\u00edcio, use o desenvolvimento incremental para escrever uma fun\u00e7\u00e3o chamada hypotenuse, que devolva o comprimento da hipotenusa de um tri\u00e2ngulo ret\u00e2ngulo dados os comprimentos dos outros dois lados como argumentos. Registre cada etapa do processo de desenvolvimento no decorrer do processo.","title":"6.2 - Desenvolvimento incremental"},{"location":"06-funcoes-result/#63-composicao","text":"Como voc\u00ea j\u00e1 deveria esperar a essa altura, \u00e9 poss\u00edvel chamar uma fun\u00e7\u00e3o de dentro de outra. Como exemplo, escreveremos uma fun\u00e7\u00e3o que recebe dois pontos, o centro do c\u00edrculo e um ponto no per\u00edmetro, para calcular a \u00e1rea do c\u00edrculo. Suponha que o ponto do centro seja guardado nas vari\u00e1veis xc e yc e o ponto de per\u00edmetro est\u00e1 em xp e yp. O primeiro passo deve ser encontrar o raio do c\u00edrculo, que \u00e9 a dist\u00e2ncia entre os dois pontos. Acabamos de escrever uma fun\u00e7\u00e3o, distance, que faz isto: radius = distance(xc, yc, xp, yp) O pr\u00f3ximo passo deve ser encontrar a \u00e1rea de um c\u00edrculo com aquele raio; acabamos de escrever isso tamb\u00e9m: result = area(radius) Encapsulando esses passos em uma fun\u00e7\u00e3o, temos: def circle_area(xc, yc, xp, yp): radius = distance(xc, yc, xp, yp) result = area(radius) return result As vari\u00e1veis tempor\u00e1rias radius e result s\u00e3o \u00fateis para desenvolvimento e depura\u00e7\u00e3o, e uma vez que o programa esteja funcionando podemos torn\u00e1-lo mais conciso compondo chamadas de fun\u00e7\u00e3o: def circle_area(xc, yc, xp, yp): return area(distance(xc, yc, xp, yp))","title":"6.3 - Composi\u00e7\u00e3o"},{"location":"06-funcoes-result/#64-funcoes-booleanas","text":"As fun\u00e7\u00f5es podem retornar booleans, o que pode ser conveniente para esconder testes complicados dentro de fun\u00e7\u00f5es. Por exemplo: def is_divisible(x, y): if x % y == 0: return True else: return False \u00c9 comum dar nomes de fun\u00e7\u00f5es booleanas que pare\u00e7am perguntas de sim ou n\u00e3o; is_divisible retorna True ou False para indicar se x \u00e9 divis\u00edvel por y. Aqui est\u00e1 um exemplo: >>> is_divisible(6, 4) False >>> is_divisible(6, 3) True O resultado do operador == \u00e9 um booleano, ent\u00e3o podemos escrever a fun\u00e7\u00e3o de forma mais concisa, retornando-o diretamente: def is_divisible(x, y): return x % y == 0 As fun\u00e7\u00f5es booleanas muitas vezes s\u00e3o usadas em instru\u00e7\u00f5es condicionais: if is_divisible(x, y): print('x is divisible by y') Pode ser tentador escrever algo assim: if is_divisible(x, y) == True: print('x is divisible by y') Mas a compara\u00e7\u00e3o extra \u00e9 desnecess\u00e1ria. Como um exerc\u00edcio, escreva uma fun\u00e7\u00e3o is_between(x, y, z) que retorne True, se x \u2264 y \u2264 z, ou False, se n\u00e3o for o caso.","title":"6.4 - Fun\u00e7\u00f5es booleanas"},{"location":"06-funcoes-result/#65-mais-recursividade","text":"Cobrimos apenas um pequeno subconjunto do Python, mas talvez seja bom voc\u00ea saber que este subconjunto \u00e9 uma linguagem de programa\u00e7\u00e3o completa, ou seja, qualquer coisa que possa ser calculada pode ser expressa nesta linguagem. Qualquer programa que j\u00e1 foi escrito pode ser reescrito apenas com os recursos da linguagem que voc\u00ea aprendeu at\u00e9 agora (na verdade, seria preciso alguns comandos para dispositivos de controle como mouse, discos etc., mas isso \u00e9 tudo). Comprovar esta declara\u00e7\u00e3o \u00e9 um exerc\u00edcio nada trivial realizado pela primeira vez por Alan Turing, um dos primeiros cientistas da computa\u00e7\u00e3o (alguns diriam que ele foi matem\u00e1tico, mas muitos dos primeiros cientistas da computa\u00e7\u00e3o come\u00e7aram como matem\u00e1ticos). Assim, \u00e9 conhecida como a Tese de Turing. Para uma exposi\u00e7\u00e3o mais completa (e exata) da Tese de Turing, recomendo o livro de Michael Sipser, Introduction to the Theory of Computation (Introdu\u00e7\u00e3o \u00e0 teoria da computa\u00e7\u00e3o, Course Technology, 2012). Para dar uma ideia do que podemos fazer com as ferramentas que aprendeu at\u00e9 agora, avaliaremos algumas fun\u00e7\u00f5es matem\u00e1ticas definidas recursivamente. Uma defini\u00e7\u00e3o recursiva \u00e9 semelhante a uma defini\u00e7\u00e3o circular, no sentido de que a defini\u00e7\u00e3o cont\u00e9m uma refer\u00eancia \u00e0 coisa que \u00e9 definida. Uma defini\u00e7\u00e3o realmente circular n\u00e3o \u00e9 muito \u00fatil: vorpal Adjetivo usado para descrever algo que \u00e9 vorpal. Ver uma defini\u00e7\u00e3o assim no dicion\u00e1rio pode ser irritante. Por outro lado, se procurar a defini\u00e7\u00e3o da fun\u00e7\u00e3o de fatorial, denotada pelo s\u00edmbolo !, voc\u00ea pode encontrar algo assim: 0! = 1 n! = n\u00b7(n \u2212 1)! Esta defini\u00e7\u00e3o diz que o fatorial de 0 \u00e9 1, e o fatorial de qualquer outro valor, n, \u00e9 n multiplicado pelo fatorial de n-1. Ent\u00e3o 3! \u00e9 3 vezes 2!, que \u00e9 2 vezes 1!, que \u00e9 1 vez 0!. Juntando tudo, 3! \u00e9 igual a 3 vezes 2 vezes 1 vezes 1, que \u00e9 6. Se puder escrever uma defini\u00e7\u00e3o recursiva de algo, voc\u00ea poder\u00e1 escrever um programa em Python que a avalie. O primeiro passo deve ser decidir quais par\u00e2metros ela deve ter. Neste caso, deve estar claro que factorial recebe um n\u00famero inteiro: def factorial(n): Se o argumento for 0, tudo que temos de fazer \u00e9 retornar 1: def factorial(n): if n == 0: return 1 Sen\u00e3o, e a\u00ed \u00e9 que fica interessante, temos que fazer uma chamada recursiva para encontrar o fatorial de n-1 e ent\u00e3o multiplic\u00e1-lo por n: def factorial(n): if n == 0: return 1 else: recurse = factorial(n-1) result = n * recurse return result O fluxo de execu\u00e7\u00e3o deste programa \u00e9 semelhante ao fluxo de countdown em \u201cRecursividade\u201d, na p\u00e1gina 81. Se chamarmos factorial com o valor 3: Como 3 n\u00e3o \u00e9 0, tomamos o segundo ramo e calculamos o fatorial de n-1... Como 2 n\u00e3o \u00e9 0, tomamos o segundo ramo e calculamos o fatorial de n-1... Como 1 n\u00e3o \u00e9 0, tomamos o segundo ramo e calculamos o fatorial de n-1... Como 0 \u00e9 igual a 0, tomamos o primeiro ramo e devolvemos 1 sem fazer mais chamadas recursivas. O valor de retorno, 1, \u00e9 multiplicado por n, que \u00e9 1, e o resultado \u00e9 devolvido. O valor de retorno, 1, \u00e9 multiplicado por n, que \u00e9 2, e o resultado \u00e9 devolvido. O valor devolvido (2) \u00e9 multiplicado por n, que \u00e9 3, e o resultado, 6, torna-se o valor devolvido pela chamada de fun\u00e7\u00e3o que come\u00e7ou o processo inteiro. A Figura 6.1 mostra como \u00e9 o diagrama da pilha para esta sequ\u00eancia de chamadas de fun\u00e7\u00e3o. Figura 6.1 \u2013 Diagrama da pilha para factorial. Os valores devolvidos s\u00e3o mostrados ao serem passados de volta at\u00e9 o alto da pilha. Em cada frame, o valor devolvido \u00e9 o valor de result , que \u00e9 o produto de n e recurse . No \u00faltimo frame, as vari\u00e1veis locais recurse e result n\u00e3o existem, porque o ramo que os cria n\u00e3o \u00e9 executado.","title":"6.5 - Mais recursividade"},{"location":"06-funcoes-result/#66-salto-de-fe","text":"Seguir o fluxo da execu\u00e7\u00e3o \u00e9 uma forma de ler programas, mas poder\u00e1 ser trabalhoso demais. Uma alternativa \u00e9 o que chamo de \u201csalto de f\u00e9\u201d (leap of faith). Ao chegar a uma chamada de fun\u00e7\u00e3o, em vez de seguir o fluxo de execu\u00e7\u00e3o suponha que a fun\u00e7\u00e3o esteja funcionando corretamente e que est\u00e1 retornando o resultado certo. Na verdade, voc\u00ea j\u00e1 est\u00e1 praticando este salto de f\u00e9 quando usa fun\u00e7\u00f5es integradas. Quando chama math.cos ou math.exp, voc\u00ea n\u00e3o examina o corpo dessas fun\u00e7\u00f5es. Apenas sup\u00f5e que funcionem porque as pessoas que as escreveram eram bons programadores. O mesmo acontece ao chamar uma das suas pr\u00f3prias fun\u00e7\u00f5es. Por exemplo, em \u201cFun\u00e7\u00f5es booleanas\u201d, na p\u00e1gina 97, escrevemos uma fun\u00e7\u00e3o chamada is_divisible que determina se um n\u00famero \u00e9 divis\u00edvel por outro. Uma vez que estejamos convencidos de que esta fun\u00e7\u00e3o est\u00e1 correta \u2013 examinando o c\u00f3digo e testando \u2013 podemos usar a fun\u00e7\u00e3o sem ver o corpo novamente. O mesmo \u00e9 verdade para programas recursivos. Quando chega \u00e0 chamada recursiva, em vez de seguir o fluxo de execu\u00e7\u00e3o, voc\u00ea deveria supor que a chamada recursiva funcione (devolva o resultado correto) e ent\u00e3o perguntar-se: \u201cSupondo que eu possa encontrar o fatorial de n-1, posso calcular o fatorial de n?\u201d. \u00c9 claro que pode, multiplicando por n. Naturalmente, \u00e9 um pouco estranho supor que a fun\u00e7\u00e3o funcione corretamente quando ainda n\u00e3o terminou de escrev\u00ea-la, mas \u00e9 por isso que se chama um salto de f\u00e9!","title":"6.6 - Salto de f\u00e9"},{"location":"06-funcoes-result/#67-mais-um-exemplo","text":"Depois do factorial, o exemplo mais comum de uma fun\u00e7\u00e3o matem\u00e1tica definida recursivamente \u00e9 fibonacci, que tem a seguinte defini\u00e7\u00e3o (ver http://en.wikipedia.org/wiki/Fibonacci_number): fibonacci(0) = 0 fibonacci(1) = 1 fibonacci(n) = fibonacci(n \u2212 1) + fibonacci(n \u2212 2) Traduzida para Python, ela fica assim: def fibonacci (n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) Se tentar seguir o fluxo de execu\u00e7\u00e3o aqui, at\u00e9 para valores razoavelmente pequenos de n, sua cabe\u00e7a explode. Por\u00e9m, seguindo o salto de f\u00e9, supondo que as duas chamadas recursivas funcionem corretamente, ent\u00e3o \u00e9 claro que vai receber o resultado correto adicionando-as juntas.","title":"6.7 - Mais um exemplo"},{"location":"06-funcoes-result/#68-verificacao-de-tipos","text":"O que acontece se chamarmos factorial e usarmos 1.5 como argumento? >>> factorial(1.5) RuntimeError: Maximum recursion depth exceeded Parece uma recursividade infinita. No entanto, por que isso acontece? A fun\u00e7\u00e3o tem um caso-base \u2013 quando n == 0. Mas se n n\u00e3o \u00e9 um n\u00famero inteiro, podemos perder o caso-base e recorrer para sempre. Na primeira chamada recursiva, o valor de n \u00e9 0.5. No seguinte, \u00e9 -0.5. Da\u00ed, torna-se menor (mais negativo), mas nunca ser\u00e1 0. Temos duas escolhas. Podemos tentar generalizar a fun\u00e7\u00e3o factorial para trabalhar com n\u00fameros de ponto flutuante, ou podemos fazer factorial controlar o tipo de argumento que recebe. A primeira op\u00e7\u00e3o chama-se fun\u00e7\u00e3o gamma e est\u00e1 um pouco al\u00e9m do alcance deste livro. Ent\u00e3o usaremos a segunda op\u00e7\u00e3o. Podemos usar a fun\u00e7\u00e3o integrada isinstance para verificar o tipo de argumento. E vamos aproveitar para verificar tamb\u00e9m se o argumento \u00e9 positivo: def factorial (n): if not isinstance(n, int): print('Factorial is only defined for integers.') return None elif n < 0: print('Factorial is not defined for negative integers.') return None elif n == 0: return 1 else: return n * factorial(n-1) O primeiro caso-base lida com n\u00fameros n\u00e3o inteiros; o segundo, com n\u00fameros inteiros negativos. Em ambos os casos o programa exibe uma mensagem de erro e retorna None para indicar que algo deu errado: >>> factorial('fred') Factorial is only defined for integers. None >>> factorial(-2) Factorial is not defined for negative integers. None Se passarmos por ambas as verifica\u00e7\u00f5es, sabemos que n \u00e9 positivo ou zero, ent\u00e3o podemos comprovar que a recursividade termina. Esse programa demonstra um padr\u00e3o \u00e0s vezes chamado de guardi\u00e3o. As duas primeiras condicionais atuam como guardi\u00e3s, protegendo o c\u00f3digo que segue de valores que poderiam causar um erro. As guardi\u00e3s permitem comprovar a corre\u00e7\u00e3o do c\u00f3digo. Na \u201cBusca reversa\u201d, na p\u00e1gina 165, veremos uma alternativa mais flex\u00edvel para a exibi\u00e7\u00e3o de uma mensagem de erro: o levantamento de exce\u00e7\u00f5es.","title":"6.8 - Verifica\u00e7\u00e3o de tipos"},{"location":"06-funcoes-result/#69-depuracao","text":"Quebrar um grande programa em fun\u00e7\u00f5es menores cria controles naturais da depura\u00e7\u00e3o. Se uma fun\u00e7\u00e3o n\u00e3o estiver funcionando, h\u00e1 tr\u00eas possibilidades a considerar: H\u00e1 algo errado com os argumentos que a fun\u00e7\u00e3o est\u00e1 recebendo; uma precondi\u00e7\u00e3o est\u00e1 sendo violada. H\u00e1 algo errado com a fun\u00e7\u00e3o; uma p\u00f3s-condi\u00e7\u00e3o foi violada. H\u00e1 algo errado com o valor de retorno ou a forma na qual est\u00e1 sendo usado. Para excluir a primeira possibilidade, voc\u00ea pode acrescentar uma instru\u00e7\u00e3o print no in\u00edcio da fun\u00e7\u00e3o e exibir os valores dos par\u00e2metros (e talvez os seus tipos). Ou escrever c\u00f3digo que verifique as precondi\u00e7\u00f5es explicitamente. Se os par\u00e2metros parecerem bons, acrescente uma instru\u00e7\u00e3o print antes de cada instru\u00e7\u00e3o return e exiba o valor de retorno. Se poss\u00edvel, verifique o resultado \u00e0 m\u00e3o. Uma possibilidade \u00e9 chamar a fun\u00e7\u00e3o com valores facilitem a verifica\u00e7\u00e3o do resultado (como no \u201cDesenvolvimento incremental\u201d, da p\u00e1gina 94). Se a fun\u00e7\u00e3o parecer funcionar, veja a chamada da fun\u00e7\u00e3o para ter certeza de que o valor de retorno est\u00e1 sendo usado corretamente (ou se est\u00e1 sendo usado mesmo!). Acrescentar instru\u00e7\u00f5es de exibi\u00e7\u00e3o no come\u00e7o e no fim de uma fun\u00e7\u00e3o pode ajudar a tornar o fluxo de execu\u00e7\u00e3o mais vis\u00edvel. Por exemplo, aqui est\u00e1 uma vers\u00e3o de factorial com instru\u00e7\u00f5es de exibi\u00e7\u00e3o: def factorial(n): space = ' ' * (4 * n) print(space, 'factorial', n) if n == 0: print(space, 'returning 1') return 1 else: recurse = factorial(n-1) result = n * recurse print(space, 'returning', result) return result space \u00e9 uma string de caracteres especiais que controla a endenta\u00e7\u00e3o da sa\u00edda. Aqui est\u00e1 o resultado de factorial(4): factorial 4 factorial 3 factorial 2 factorial 1 factorial 0 returning 1 returning 1 returning 2 returning 6 returning 24 Se o fluxo de execu\u00e7\u00e3o parecer confuso a voc\u00ea, este tipo de sa\u00edda pode ser \u00fatil. Leva um tempo para desenvolver um scaffolding eficaz, mas um pouco dele pode economizar muita depura\u00e7\u00e3o.","title":"6.9 - Depura\u00e7\u00e3o"},{"location":"06-funcoes-result/#610-glossario","text":"vari\u00e1vel tempor\u00e1ria Uma vari\u00e1vel usada para guardar um valor intermedi\u00e1rio em um c\u00e1lculo complexo. c\u00f3digo morto A parte de um programa que nunca pode ser executada, muitas vezes porque aparece depois de uma instru\u00e7\u00e3o return. desenvolvimento incremental Um plano de desenvolvimento de programa para evitar a depura\u00e7\u00e3o, que acrescenta e testa poucas linhas de c\u00f3digo de cada vez. scaffolding (andaime) O c\u00f3digo que se usa durante o desenvolvimento de programa, mas que n\u00e3o faz parte da vers\u00e3o final. guardi\u00e3o Um padr\u00e3o de programa\u00e7\u00e3o que usa uma instru\u00e7\u00e3o condicional para verificar e lidar com circunst\u00e2ncias que possam causar erros.","title":"6.10 - Gloss\u00e1rio"},{"location":"06-funcoes-result/#611-exercicios","text":"","title":"6.11 - Exerc\u00edcios"},{"location":"06-funcoes-result/#exercicio-61","text":"Desenhe um diagrama da pilha do seguinte programa. O que o programa exibe? def b(z): prod = a(z, z) print(z, prod) return prod def a(x, y): x = x + 1 return x * y def c(x, y, z): total = x + y + z square = b(total)**2 return square x = 1 y = x + 1 print(c(x, y+3, x+y))","title":"Exerc\u00edcio 6.1"},{"location":"06-funcoes-result/#exercicio-62","text":"A fun\u00e7\u00e3o de Ackermann, A(m, n), \u00e9 definida assim: Veja http://en.wikipedia.org/wiki/Ackermann_function. Escreva uma fun\u00e7\u00e3o denominada ack que avalie a fun\u00e7\u00e3o de Ackermann. Use a sua fun\u00e7\u00e3o para avaliar ack(3, 4) , cujo resultado deve ser 125. O que acontece para valores maiores de m e n? Solu\u00e7\u00e3o: http://thinkpython2.com/code/ackermann.py.","title":"Exerc\u00edcio 6.2"},{"location":"06-funcoes-result/#exercicio-63","text":"Um pal\u00edndromo \u00e9 uma palavra que se soletra da mesma forma nos dois sentidos, como \u201cosso\u201d e \u201creviver\u201d. Recursivamente, uma palavra \u00e9 um pal\u00edndromo se a primeira e \u00faltima letras forem iguais e o meio for um pal\u00edndromo. As fun\u00e7\u00f5es seguintes recebem uma string como argumento e retornam as letras iniciais, finais e do meio das palavras: def first(word): return word[0] def last(word): return word[-1] def middle(word): return word[1:-1] Veremos como funcionam no Cap\u00edtulo 8. Digite essas fun\u00e7\u00f5es em um arquivo chamado palindrome.py e teste-as. O que acontece se chamar middle com uma string de duas letras? Uma letra? E se a string estiver vazia, escrita com '' e n\u00e3o contiver nenhuma letra? Escreva uma fun\u00e7\u00e3o chamada is_palindrome que receba uma string como argumento e retorne True se for um pal\u00edndromo e False se n\u00e3o for. Lembre-se de que voc\u00ea pode usar a fun\u00e7\u00e3o integrada len para verificar o comprimento de uma string. Solu\u00e7\u00e3o: http://thinkpython2.com/code/palindrome_soln.py.","title":"Exerc\u00edcio 6.3"},{"location":"06-funcoes-result/#exercicio-64","text":"Um n\u00famero a \u00e9 uma pot\u00eancia de b se for divis\u00edvel por b e a/b for uma pot\u00eancia de b. Escreva uma fun\u00e7\u00e3o chamada is_power que receba os par\u00e2metros a e b e retorne True se a for uma pot\u00eancia de b. Dica: pense no caso-base.","title":"Exerc\u00edcio 6.4"},{"location":"06-funcoes-result/#exercicio-65","text":"O maior divisor comum (MDC, ou GCD em ingl\u00eas) de a e b \u00e9 o maior n\u00famero que divide ambos sem sobrar resto. Um modo de encontrar o MDC de dois n\u00fameros \u00e9 observar qual \u00e9 o resto r quando a \u00e9 dividido por b, verificando que gcd(a, b) = gcd(b, r). Como caso-base, podemos usar gcd(a, 0) = a. Escreva uma fun\u00e7\u00e3o chamada gcd que receba os par\u00e2metros a e b e devolva o maior divisor comum. Cr\u00e9dito: Este exerc\u00edcio \u00e9 baseado em um exemplo do livro de Abelson e Sussman, Structure and Interpretation of Computer Programs (Estrutura e interpreta\u00e7\u00e3o de programas de computador, MIT Press, 1996).","title":"Exerc\u00edcio 6.5"},{"location":"07-iteracao/","text":"Cap\u00edtulo 7: Itera\u00e7\u00e3o Este cap\u00edtulo \u00e9 sobre a itera\u00e7\u00e3o, a capacidade de executar um bloco de instru\u00e7\u00f5es repetidamente. Vimos um tipo de itera\u00e7\u00e3o, usando a recursividade, em \u201cRecursividade\u201d, na p\u00e1gina 81. Vimos outro tipo, usando um loop for, em \u201cRepeti\u00e7\u00e3o simples\u201d, na p\u00e1gina 65. Neste cap\u00edtulo veremos ainda outro tipo, usando a instru\u00e7\u00e3o while. Por\u00e9m, primeiro quero falar um pouco mais sobre a atribui\u00e7\u00e3o de vari\u00e1veis. 7.1 - Reatribui\u00e7\u00e3o Pode ser que voc\u00ea j\u00e1 tenha descoberto que \u00e9 permitido fazer mais de uma atribui\u00e7\u00e3o para a mesma vari\u00e1vel. Uma nova atribui\u00e7\u00e3o faz uma vari\u00e1vel existente referir-se a um novo valor (e deixar de referir-se ao valor anterior). >>> x = 5 >>> x 5 >>> x = 7 >>> x 7 A primeira vez que exibimos x, seu valor \u00e9 5; na segunda vez, seu valor \u00e9 7. A Figura 7.1 mostra que a reatribui\u00e7\u00e3o parece um diagrama de estado. Neste ponto quero tratar de uma fonte comum de confus\u00e3o. Como o Python usa o sinal de igual (=) para atribui\u00e7\u00e3o, \u00e9 tentador interpretar uma afirma\u00e7\u00e3o como a = b como uma proposi\u00e7\u00e3o matem\u00e1tica de igualdade; isto \u00e9, a declara\u00e7\u00e3o de que a e b s\u00e3o iguais. Mas esta \u00e9 uma interpreta\u00e7\u00e3o equivocada. Em primeiro lugar, a igualdade \u00e9 uma rela\u00e7\u00e3o sim\u00e9trica e a atribui\u00e7\u00e3o n\u00e3o \u00e9. Por exemplo, na matem\u00e1tica, se a=7 ent\u00e3o 7=a. Mas no Python, a instru\u00e7\u00e3o a = 7 \u00e9 legal e 7 = a n\u00e3o \u00e9. Al\u00e9m disso, na matem\u00e1tica, uma proposi\u00e7\u00e3o de igualdade \u00e9 verdadeira ou falsa para sempre. Se a=b agora, ent\u00e3o a sempre ser\u00e1 igual a b. No Python, uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o pode tornar duas vari\u00e1veis iguais, mas elas n\u00e3o precisam se manter assim: >>> a = 5 >>> b = a # a e b agora s\u00e3o iguais >>> a = 3 # a e b n\u00e3o s\u00e3o mais iguais >>> b 5 A terceira linha modifica o valor de a, mas n\u00e3o muda o valor de b, ent\u00e3o elas j\u00e1 n\u00e3o s\u00e3o iguais. A reatribui\u00e7\u00e3o de vari\u00e1veis muitas vezes \u00e9 \u00fatil, mas voc\u00ea deve us\u00e1-la com prud\u00eancia. Se os valores das vari\u00e1veis mudarem frequentemente, isso pode dificultar a leitura e depura\u00e7\u00e3o do c\u00f3digo. Figura 7.1 \u2013 Diagrama de estado. Figura 7.1 \u2013 Diagrama de estado da vari\u00e1vel x. 7.2 - Atualiza\u00e7\u00e3o de vari\u00e1veis Um tipo comum de reatribui\u00e7\u00e3o \u00e9 uma atualiza\u00e7\u00e3o, onde o novo valor da vari\u00e1vel depende do velho. >>> x = x + 1 Isso significa \u201cpegue o valor atual de x, acrescente um, e ent\u00e3o atualize x para o novo valor\u201d. Se voc\u00ea tentar atualizar uma vari\u00e1vel que n\u00e3o existe, recebe um erro porque o Python avalia o lado direito antes de atribuir um valor a x: >>> x = x + 1 NameError: name 'x' is not defined Antes de poder atualizar uma vari\u00e1vel \u00e9 preciso inicializ\u00e1-la, normalmente com uma atribui\u00e7\u00e3o simples: >>> x = 0 >>> x = x + 1 Atualizar uma vari\u00e1vel acrescentando 1 chama-se incremento; subtrair 1 chama-se decremento. 7.3 - Instru\u00e7\u00e3o while Os computadores muitas vezes s\u00e3o usados para automatizar tarefas repetitivas. A repeti\u00e7\u00e3o de tarefas id\u00eanticas ou semelhantes sem fazer erros \u00e9 algo que os computadores fazem bem e as pessoas n\u00e3o. Em um programa de computador, a repeti\u00e7\u00e3o tamb\u00e9m \u00e9 chamada de itera\u00e7\u00e3o. J\u00e1 vimos duas fun\u00e7\u00f5es, countdown e print_n , que se repetem usando recursividade. Como a itera\u00e7\u00e3o \u00e9 bem comum, o Python fornece recursos de linguagem para facilit\u00e1-la. Um deles \u00e9 a instru\u00e7\u00e3o for que vimos em \u201cRepeti\u00e7\u00e3o simples\u201d, na p\u00e1gina 65. Voltaremos a isso mais adiante. Outra \u00e9 a instru\u00e7\u00e3o while . Aqui est\u00e1 uma vers\u00e3o de countdown que usa a instru\u00e7\u00e3o while : def countdown(n): while n > 0: print(n) n = n - 1 print('Blastoff!') Voc\u00ea at\u00e9 pode ler a instru\u00e7\u00e3o while como se fosse uma tradu\u00e7\u00e3o do ingl\u00eas. Significa \u201cEnquanto n for maior que 0, mostre o valor de n e ent\u00e3o decremente n . Quando chegar a 0, mostre a palavra Blastoff!\u201d Mais formalmente, aqui est\u00e1 o fluxo de execu\u00e7\u00e3o para uma instru\u00e7\u00e3o while: Determine se a condi\u00e7\u00e3o \u00e9 verdadeira ou falsa. Se for falsa, saia da instru\u00e7\u00e3o while e continue a execu\u00e7\u00e3o da pr\u00f3xima instru\u00e7\u00e3o. Se a condi\u00e7\u00e3o for verdadeira, execute o corpo e ent\u00e3o volte ao passo 1. Este tipo de fluxo chama-se loop (la\u00e7o), porque o terceiro passo faz um loop de volta ao topo. O corpo do loop deve mudar o valor de uma ou mais vari\u00e1veis para que, a certa altura, a condi\u00e7\u00e3o fique falsa e o loop termine. Sen\u00e3o o loop vai se repetir para sempre, o que \u00e9 chamado de loop infinito. Uma fonte infind\u00e1vel de divertimento para cientistas da computa\u00e7\u00e3o \u00e9 a observa\u00e7\u00e3o das instru\u00e7\u00f5es no xampu, \u201cFa\u00e7a espuma, enx\u00e1gue, repita\u201d, que s\u00e3o parte de um loop infinito. No caso de countdown, podemos provar que o loop termina: se n for zero ou negativo, o loop nunca \u00e9 executado. Sen\u00e3o, n fica cada vez menor ao passar pelo loop, at\u00e9 eventualmente chegar a 0. Para alguns outros loops, n\u00e3o \u00e9 t\u00e3o f\u00e1cil perceber isso. Por exemplo: def sequence(n): while n != 1: print(n) if n % 2 == 0: # n \u00e9 par n = n / 2 else: # n \u00e9 \u00edmpar n = n * 3 + 1 A condi\u00e7\u00e3o deste loop \u00e9 n != 1 , ent\u00e3o o loop continuar\u00e1 at\u00e9 que n seja 1, o que torna a condi\u00e7\u00e3o falsa. Cada vez que passa pelo loop, o programa produz o valor de n e ent\u00e3o verifica se \u00e9 par ou \u00edmpar. Se for par, n \u00e9 dividido por 2. Se for \u00edmpar, o valor de n \u00e9 substitu\u00eddo por n * 3 + 1 . Por exemplo, se o argumento passado a sequence for 3, os valores resultantes de n s\u00e3o 3, 10, 5, 16, 8, 4, 2, 1. Como n \u00e0s vezes aumenta e \u00e0s vezes diminui, n\u00e3o h\u00e1 nenhuma prova \u00f3bvia de que n chegar\u00e1 eventualmente a 1, ou que o programa terminar\u00e1. Para alguns valores de n , podemos provar o t\u00e9rmino. Por exemplo, se o valor inicial for uma pot\u00eancia de dois, n ser\u00e1 par cada vez que passar pelo loop at\u00e9 que chegue a 1. O exemplo anterior termina com uma sequ\u00eancia assim, que inicia com 16. A quest\u00e3o dif\u00edcil \u00e9 se podemos provar que este programa termina para todos os valores positivos de n . Por enquanto, ningu\u00e9m foi capaz de comprovar ou refutar isso! (Veja http://en.wikipedia.org/wiki/Collatz_conjecture.) Como um exerc\u00edcio, reescreva a fun\u00e7\u00e3o print_n de \u201cRecursividade\u201d, na p\u00e1gina 81, usando a itera\u00e7\u00e3o em vez da recursividade. 7.4 - break \u00c0s vezes voc\u00ea n\u00e3o sabe que est\u00e1 na hora de terminar um loop at\u00e9 que j\u00e1 esteja na metade do corpo. Neste caso pode usar a instru\u00e7\u00e3o break para sair do loop. Por exemplo, suponha que voc\u00ea quer receber uma entrada do usu\u00e1rio at\u00e9 que este digite done. Voc\u00ea pode escrever: while True: line = input('> ') if line == 'done': break print(line) print('Done!') A condi\u00e7\u00e3o do loop \u00e9 True, que sempre \u00e9 verdade, ent\u00e3o o loop roda at\u00e9 que chegue \u00e0 instru\u00e7\u00e3o de interrup\u00e7\u00e3o. Cada vez que passa pelo loop, o programa apresenta ao usu\u00e1rio um colchete angular. Se o usu\u00e1rio digitar done, a instru\u00e7\u00e3o break sai do loop. Sen\u00e3o, o programa ecoa o que quer que o usu\u00e1rio digite e volta ao topo do loop. Aqui est\u00e1 uma amostra de execu\u00e7\u00e3o: > not done not done > done Done! Esta forma de escrever loops while \u00e9 comum porque podemos verificar a condi\u00e7\u00e3o em qualquer lugar do loop (n\u00e3o somente no topo) e podemos exprimir a condi\u00e7\u00e3o de parada afirmativamente (\u201cpare quando isto acontecer\u201d) em vez de negativamente (\u201ccontinue a seguir at\u00e9 que isto aconte\u00e7a\u201d). 7.5 - Ra\u00edzes quadradas Loops muitas vezes s\u00e3o usados em programas que calculam resultados num\u00e9ricos, come\u00e7ando com uma resposta aproximada e melhorando-a iterativamente. Por exemplo, uma forma de calcular ra\u00edzes quadradas \u00e9 o m\u00e9todo de Newton. Suponha que voc\u00ea queira saber a raiz quadrada de a. Se come\u00e7ar com quase qualquer estimativa, x, \u00e9 poss\u00edvel calcular uma estimativa melhor com a seguinte f\u00f3rmula: Por exemplo, se a for 4 e x for 3: >>> a = 4 >>> x = 3 >>> y = (x + a/x) / 2 >>> y 2.16666666667 O resultado \u00e9 mais pr\u00f3ximo \u00e0 resposta correta ( = 2). Se repetirmos o processo com a nova estimativa, chegamos ainda mais perto: >>> x = y >>> y = (x + a/x) / 2 >>> y 2.00641025641 Depois de algumas atualiza\u00e7\u00f5es, a estimativa \u00e9 quase exata: >>> x = y >>> y = (x + a/x) / 2 >>> y 2.00001024003 >>> x = y >>> y = (x + a/x) / 2 >>> y 2.00000000003 Em geral, n\u00e3o sabemos com anteced\u00eancia quantos passos s\u00e3o necess\u00e1rios para chegar \u00e0 resposta correta, mas sabemos quando chegamos l\u00e1 porque a estimativa para de mudar: >>> x = y >>> y = (x + a/x) / 2 >>> y 2.0 >>> x = y >>> y = (x + a/x) / 2 >>> y 2.0 Quando y == x, podemos parar. Aqui est\u00e1 um loop que come\u00e7a com uma estimativa inicial, x, e a melhora at\u00e9 que deixe de mudar: while True: print(x) y = (x + a/x) / 2 if y == x: break x = y Para a maior parte de valores de a funciona bem, mas pode ser perigoso testar a igualdade de um float. Os valores de ponto flutuante s\u00e3o aproximadamente corretos: a maioria dos n\u00fameros racionais, como 1/3, e n\u00fameros irracionais, como , n\u00e3o podem ser representados exatamente com um float. Em vez de verificar se x e y s\u00e3o exatamente iguais, \u00e9 mais seguro usar a fun\u00e7\u00e3o integrada abs para calcular o valor absoluto ou magnitude da diferen\u00e7a entre eles: if abs(y-x) < epsilon: break Onde epsilon tem um valor como 0.0000001, que determina a proximidade desejada entre x e y . 7.6 - Algoritmos O m\u00e9todo de Newton \u00e9 um exemplo de um algoritmo: um processo mec\u00e2nico para resolver uma categoria de problemas (neste caso, calcular ra\u00edzes quadradas). Para entender o que \u00e9 um algoritmo, pode ser \u00fatil come\u00e7ar com algo que n\u00e3o \u00e9 um algoritmo. Quando aprendeu a multiplicar n\u00fameros de um d\u00edgito, voc\u00ea provavelmente memorizou a tabuada. Ou seja, voc\u00ea memorizou 100 solu\u00e7\u00f5es espec\u00edficas. Este tipo de conhecimento n\u00e3o \u00e9 algor\u00edtmico. No entanto, se voc\u00ea foi \u201cpregui\u00e7oso\u201d, poderia ter aprendido alguns truques. Por exemplo, para encontrar o produto de n e 9, pode escrever n-1 como o primeiro d\u00edgito e 10-n como o segundo d\u00edgito. Este truque \u00e9 uma solu\u00e7\u00e3o geral para multiplicar qualquer n\u00famero de d\u00edgito \u00fanico por 9. Isto \u00e9 um algoritmo! De forma semelhante, as t\u00e9cnicas que aprendeu, como o transporte na adi\u00e7\u00e3o, o empr\u00e9stimo na subtra\u00e7\u00e3o e a divis\u00e3o longa s\u00e3o todos algoritmos. Uma das caracter\u00edsticas de algoritmos \u00e9 que eles n\u00e3o exigem intelig\u00eancia para serem executados. S\u00e3o processos mec\u00e2nicos, nos quais cada passo segue a partir do \u00faltimo, de acordo com um conjunto de regras simples. A execu\u00e7\u00e3o de algoritmos \u00e9 ma\u00e7ante, mas projet\u00e1-los \u00e9 interessante, intelectualmente desafiador e uma parte central da Ci\u00eancia da Computa\u00e7\u00e3o. Algumas coisas que as pessoas fazem naturalmente, sem dificuldade ou pensamento consciente, s\u00e3o as mais dif\u00edceis para exprimir algoritmicamente. A compreens\u00e3o de linguagem natural \u00e9 um bom exemplo. Todos n\u00f3s o fazemos, mas por enquanto ningu\u00e9m foi capaz de explicar como o fazemos, pelo menos n\u00e3o na forma de um algoritmo. 7.7 - Depura\u00e7\u00e3o Ao come\u00e7ar a escrever programas maiores, pode ser que voc\u00ea passe mais tempo depurando. Mais c\u00f3digo significa mais possibilidades fazer erros e mais lugares para esconder defeitos. Uma forma de cortar o tempo de depura\u00e7\u00e3o \u00e9 \u201cdepurar por bisse\u00e7\u00e3o\u201d. Por exemplo, se h\u00e1 100 linhas no seu programa e voc\u00ea as verifica uma a uma, seriam 100 passos a tomar. Em vez disso, tente quebrar o problema pela metade. Olhe para o meio do programa, ou perto disso, para um valor intermedi\u00e1rio que possa verificar. Acrescente uma instru\u00e7\u00e3o print (ou outra coisa que tenha um efeito verific\u00e1vel) e execute o programa. Se a verifica\u00e7\u00e3o do ponto central for incorreta, deve haver um problema na primeira metade do programa. Se for correta, o problema est\u00e1 na segunda metade. Cada vez que executar uma verifica\u00e7\u00e3o assim, divida ao meio o n\u00famero de linhas a serem verificadas. Depois de seis passos (que \u00e9 menos de 100), voc\u00ea teria menos de uma ou duas linhas do c\u00f3digo para verificar, pelo menos em teoria. Na pr\u00e1tica, nem sempre \u00e9 claro o que representa o \u201cmeio do programa\u201d e nem sempre \u00e9 poss\u00edvel verific\u00e1-lo. N\u00e3o faz sentido contar linhas e encontrar o ponto central exato. Em vez disso, pense em lugares no programa onde poderia haver erros e lugares onde \u00e9 f\u00e1cil inserir um ponto de verifica\u00e7\u00e3o. Ent\u00e3o escolha um lugar onde as possibilidades s\u00e3o basicamente as mesmas de que o defeito esteja antes ou depois da verifica\u00e7\u00e3o. 7.8 - Gloss\u00e1rio reatribui\u00e7\u00e3o Atribuir um novo valor a uma vari\u00e1vel que j\u00e1 existe. atualiza\u00e7\u00e3o Uma atribui\u00e7\u00e3o onde o novo valor da vari\u00e1vel dependa do velho. inicializa\u00e7\u00e3o Uma atribui\u00e7\u00e3o que d\u00e1 um valor inicial a uma vari\u00e1vel que ser\u00e1 atualizada. incremento Uma atualiza\u00e7\u00e3o que aumenta o valor de uma vari\u00e1vel (normalmente por uma unidade). decremento Uma atualiza\u00e7\u00e3o que reduz o valor de uma vari\u00e1vel. itera\u00e7\u00e3o Execu\u00e7\u00e3o repetida de um grupo de instru\u00e7\u00f5es, usando uma chamada da fun\u00e7\u00e3o recursiva ou um loop. loop infinito Um loop no qual a condi\u00e7\u00e3o de t\u00e9rmino nunca \u00e9 satisfeita. algoritmo Um processo geral para resolver uma categoria de problemas. 7.9 - Exerc\u00edcios Exerc\u00edcio 7.1 Copie o loop de \u201cRa\u00edzes quadradas\u201d, na p\u00e1gina 111, e encapsule-o em uma fun\u00e7\u00e3o chamada mysqrt que receba a como par\u00e2metro, escolha um valor razo\u00e1vel de x e devolva uma estimativa da raiz quadrada de a. Para testar, escreva uma fun\u00e7\u00e3o denominada test_square_root , que exibe uma tabela como esta: a mysqrt(a) math.sqrt(a) diff - --------- ------------ ---- 1.0 1.0 1.0 0.0 2.0 1.41421356237 1.41421356237 2.22044604925e-16 3.0 1.73205080757 1.73205080757 0.0 4.0 2.0 2.0 0.0 5.0 2.2360679775 2.2360679775 0.0 6.0 2.44948974278 2.44948974278 0.0 7.0 2.64575131106 2.64575131106 0.0 8.0 2.82842712475 2.82842712475 4.4408920985e-16 9.0 3.0 3.0 0.0 A primeira coluna \u00e9 um n\u00famero, a ; a segunda coluna \u00e9 a raiz quadrada de a calculada com mysqrt ; a terceira coluna \u00e9 a raiz quadrada calculada por math.sqrt ; a quarta coluna \u00e9 o valor absoluto da diferen\u00e7a entre as duas estimativas. Exerc\u00edcio 7.2 A fun\u00e7\u00e3o integrada eval toma uma string e a avalia, usando o interpretador do Python. Por exemplo: >>> eval('1 + 2 * 3') 7 >>> import math >>> eval('math.sqrt(5)') 2.2360679774997898 >>> eval('type(math.pi)') <class 'float'> Escreva uma fun\u00e7\u00e3o chamada eval_loop que iterativamente pe\u00e7a uma entrada ao usu\u00e1rio, a avalie usando eval e exiba o resultado. Ela deve continuar at\u00e9 que o usu\u00e1rio digite done ; ent\u00e3o dever\u00e1 exibir o valor da \u00faltima express\u00e3o avaliada. Exerc\u00edcio 7.3 O matem\u00e1tico Srinivasa Ramanujan encontrou uma s\u00e9rie infinita que pode ser usada para gerar uma aproxima\u00e7\u00e3o num\u00e9rica de 1/\u03c0: Escreva uma fun\u00e7\u00e3o chamada estimate_pi que use esta f\u00f3rmula para computar e devolver uma estimativa de \u03c0. Voc\u00ea deve usar o loop while para calcular os termos da adi\u00e7\u00e3o at\u00e9 que o \u00faltimo termo seja menor que 1e-15 (que \u00e9 a nota\u00e7\u00e3o do Python para 10 ** 15 ). Voc\u00ea pode verificar o resultado comparando-o com math.pi .","title":"Cap\u00edtulo 7: Itera\u00e7\u00e3o"},{"location":"07-iteracao/#capitulo-7-iteracao","text":"Este cap\u00edtulo \u00e9 sobre a itera\u00e7\u00e3o, a capacidade de executar um bloco de instru\u00e7\u00f5es repetidamente. Vimos um tipo de itera\u00e7\u00e3o, usando a recursividade, em \u201cRecursividade\u201d, na p\u00e1gina 81. Vimos outro tipo, usando um loop for, em \u201cRepeti\u00e7\u00e3o simples\u201d, na p\u00e1gina 65. Neste cap\u00edtulo veremos ainda outro tipo, usando a instru\u00e7\u00e3o while. Por\u00e9m, primeiro quero falar um pouco mais sobre a atribui\u00e7\u00e3o de vari\u00e1veis.","title":"Cap\u00edtulo 7: Itera\u00e7\u00e3o"},{"location":"07-iteracao/#71-reatribuicao","text":"Pode ser que voc\u00ea j\u00e1 tenha descoberto que \u00e9 permitido fazer mais de uma atribui\u00e7\u00e3o para a mesma vari\u00e1vel. Uma nova atribui\u00e7\u00e3o faz uma vari\u00e1vel existente referir-se a um novo valor (e deixar de referir-se ao valor anterior). >>> x = 5 >>> x 5 >>> x = 7 >>> x 7 A primeira vez que exibimos x, seu valor \u00e9 5; na segunda vez, seu valor \u00e9 7. A Figura 7.1 mostra que a reatribui\u00e7\u00e3o parece um diagrama de estado. Neste ponto quero tratar de uma fonte comum de confus\u00e3o. Como o Python usa o sinal de igual (=) para atribui\u00e7\u00e3o, \u00e9 tentador interpretar uma afirma\u00e7\u00e3o como a = b como uma proposi\u00e7\u00e3o matem\u00e1tica de igualdade; isto \u00e9, a declara\u00e7\u00e3o de que a e b s\u00e3o iguais. Mas esta \u00e9 uma interpreta\u00e7\u00e3o equivocada. Em primeiro lugar, a igualdade \u00e9 uma rela\u00e7\u00e3o sim\u00e9trica e a atribui\u00e7\u00e3o n\u00e3o \u00e9. Por exemplo, na matem\u00e1tica, se a=7 ent\u00e3o 7=a. Mas no Python, a instru\u00e7\u00e3o a = 7 \u00e9 legal e 7 = a n\u00e3o \u00e9. Al\u00e9m disso, na matem\u00e1tica, uma proposi\u00e7\u00e3o de igualdade \u00e9 verdadeira ou falsa para sempre. Se a=b agora, ent\u00e3o a sempre ser\u00e1 igual a b. No Python, uma instru\u00e7\u00e3o de atribui\u00e7\u00e3o pode tornar duas vari\u00e1veis iguais, mas elas n\u00e3o precisam se manter assim: >>> a = 5 >>> b = a # a e b agora s\u00e3o iguais >>> a = 3 # a e b n\u00e3o s\u00e3o mais iguais >>> b 5 A terceira linha modifica o valor de a, mas n\u00e3o muda o valor de b, ent\u00e3o elas j\u00e1 n\u00e3o s\u00e3o iguais. A reatribui\u00e7\u00e3o de vari\u00e1veis muitas vezes \u00e9 \u00fatil, mas voc\u00ea deve us\u00e1-la com prud\u00eancia. Se os valores das vari\u00e1veis mudarem frequentemente, isso pode dificultar a leitura e depura\u00e7\u00e3o do c\u00f3digo. Figura 7.1 \u2013 Diagrama de estado. Figura 7.1 \u2013 Diagrama de estado da vari\u00e1vel x.","title":"7.1 - Reatribui\u00e7\u00e3o"},{"location":"07-iteracao/#72-atualizacao-de-variaveis","text":"Um tipo comum de reatribui\u00e7\u00e3o \u00e9 uma atualiza\u00e7\u00e3o, onde o novo valor da vari\u00e1vel depende do velho. >>> x = x + 1 Isso significa \u201cpegue o valor atual de x, acrescente um, e ent\u00e3o atualize x para o novo valor\u201d. Se voc\u00ea tentar atualizar uma vari\u00e1vel que n\u00e3o existe, recebe um erro porque o Python avalia o lado direito antes de atribuir um valor a x: >>> x = x + 1 NameError: name 'x' is not defined Antes de poder atualizar uma vari\u00e1vel \u00e9 preciso inicializ\u00e1-la, normalmente com uma atribui\u00e7\u00e3o simples: >>> x = 0 >>> x = x + 1 Atualizar uma vari\u00e1vel acrescentando 1 chama-se incremento; subtrair 1 chama-se decremento.","title":"7.2 - Atualiza\u00e7\u00e3o de vari\u00e1veis"},{"location":"07-iteracao/#73-instrucao-while","text":"Os computadores muitas vezes s\u00e3o usados para automatizar tarefas repetitivas. A repeti\u00e7\u00e3o de tarefas id\u00eanticas ou semelhantes sem fazer erros \u00e9 algo que os computadores fazem bem e as pessoas n\u00e3o. Em um programa de computador, a repeti\u00e7\u00e3o tamb\u00e9m \u00e9 chamada de itera\u00e7\u00e3o. J\u00e1 vimos duas fun\u00e7\u00f5es, countdown e print_n , que se repetem usando recursividade. Como a itera\u00e7\u00e3o \u00e9 bem comum, o Python fornece recursos de linguagem para facilit\u00e1-la. Um deles \u00e9 a instru\u00e7\u00e3o for que vimos em \u201cRepeti\u00e7\u00e3o simples\u201d, na p\u00e1gina 65. Voltaremos a isso mais adiante. Outra \u00e9 a instru\u00e7\u00e3o while . Aqui est\u00e1 uma vers\u00e3o de countdown que usa a instru\u00e7\u00e3o while : def countdown(n): while n > 0: print(n) n = n - 1 print('Blastoff!') Voc\u00ea at\u00e9 pode ler a instru\u00e7\u00e3o while como se fosse uma tradu\u00e7\u00e3o do ingl\u00eas. Significa \u201cEnquanto n for maior que 0, mostre o valor de n e ent\u00e3o decremente n . Quando chegar a 0, mostre a palavra Blastoff!\u201d Mais formalmente, aqui est\u00e1 o fluxo de execu\u00e7\u00e3o para uma instru\u00e7\u00e3o while: Determine se a condi\u00e7\u00e3o \u00e9 verdadeira ou falsa. Se for falsa, saia da instru\u00e7\u00e3o while e continue a execu\u00e7\u00e3o da pr\u00f3xima instru\u00e7\u00e3o. Se a condi\u00e7\u00e3o for verdadeira, execute o corpo e ent\u00e3o volte ao passo 1. Este tipo de fluxo chama-se loop (la\u00e7o), porque o terceiro passo faz um loop de volta ao topo. O corpo do loop deve mudar o valor de uma ou mais vari\u00e1veis para que, a certa altura, a condi\u00e7\u00e3o fique falsa e o loop termine. Sen\u00e3o o loop vai se repetir para sempre, o que \u00e9 chamado de loop infinito. Uma fonte infind\u00e1vel de divertimento para cientistas da computa\u00e7\u00e3o \u00e9 a observa\u00e7\u00e3o das instru\u00e7\u00f5es no xampu, \u201cFa\u00e7a espuma, enx\u00e1gue, repita\u201d, que s\u00e3o parte de um loop infinito. No caso de countdown, podemos provar que o loop termina: se n for zero ou negativo, o loop nunca \u00e9 executado. Sen\u00e3o, n fica cada vez menor ao passar pelo loop, at\u00e9 eventualmente chegar a 0. Para alguns outros loops, n\u00e3o \u00e9 t\u00e3o f\u00e1cil perceber isso. Por exemplo: def sequence(n): while n != 1: print(n) if n % 2 == 0: # n \u00e9 par n = n / 2 else: # n \u00e9 \u00edmpar n = n * 3 + 1 A condi\u00e7\u00e3o deste loop \u00e9 n != 1 , ent\u00e3o o loop continuar\u00e1 at\u00e9 que n seja 1, o que torna a condi\u00e7\u00e3o falsa. Cada vez que passa pelo loop, o programa produz o valor de n e ent\u00e3o verifica se \u00e9 par ou \u00edmpar. Se for par, n \u00e9 dividido por 2. Se for \u00edmpar, o valor de n \u00e9 substitu\u00eddo por n * 3 + 1 . Por exemplo, se o argumento passado a sequence for 3, os valores resultantes de n s\u00e3o 3, 10, 5, 16, 8, 4, 2, 1. Como n \u00e0s vezes aumenta e \u00e0s vezes diminui, n\u00e3o h\u00e1 nenhuma prova \u00f3bvia de que n chegar\u00e1 eventualmente a 1, ou que o programa terminar\u00e1. Para alguns valores de n , podemos provar o t\u00e9rmino. Por exemplo, se o valor inicial for uma pot\u00eancia de dois, n ser\u00e1 par cada vez que passar pelo loop at\u00e9 que chegue a 1. O exemplo anterior termina com uma sequ\u00eancia assim, que inicia com 16. A quest\u00e3o dif\u00edcil \u00e9 se podemos provar que este programa termina para todos os valores positivos de n . Por enquanto, ningu\u00e9m foi capaz de comprovar ou refutar isso! (Veja http://en.wikipedia.org/wiki/Collatz_conjecture.) Como um exerc\u00edcio, reescreva a fun\u00e7\u00e3o print_n de \u201cRecursividade\u201d, na p\u00e1gina 81, usando a itera\u00e7\u00e3o em vez da recursividade.","title":"7.3 - Instru\u00e7\u00e3o while"},{"location":"07-iteracao/#74-break","text":"\u00c0s vezes voc\u00ea n\u00e3o sabe que est\u00e1 na hora de terminar um loop at\u00e9 que j\u00e1 esteja na metade do corpo. Neste caso pode usar a instru\u00e7\u00e3o break para sair do loop. Por exemplo, suponha que voc\u00ea quer receber uma entrada do usu\u00e1rio at\u00e9 que este digite done. Voc\u00ea pode escrever: while True: line = input('> ') if line == 'done': break print(line) print('Done!') A condi\u00e7\u00e3o do loop \u00e9 True, que sempre \u00e9 verdade, ent\u00e3o o loop roda at\u00e9 que chegue \u00e0 instru\u00e7\u00e3o de interrup\u00e7\u00e3o. Cada vez que passa pelo loop, o programa apresenta ao usu\u00e1rio um colchete angular. Se o usu\u00e1rio digitar done, a instru\u00e7\u00e3o break sai do loop. Sen\u00e3o, o programa ecoa o que quer que o usu\u00e1rio digite e volta ao topo do loop. Aqui est\u00e1 uma amostra de execu\u00e7\u00e3o: > not done not done > done Done! Esta forma de escrever loops while \u00e9 comum porque podemos verificar a condi\u00e7\u00e3o em qualquer lugar do loop (n\u00e3o somente no topo) e podemos exprimir a condi\u00e7\u00e3o de parada afirmativamente (\u201cpare quando isto acontecer\u201d) em vez de negativamente (\u201ccontinue a seguir at\u00e9 que isto aconte\u00e7a\u201d).","title":"7.4 - break"},{"location":"07-iteracao/#75-raizes-quadradas","text":"Loops muitas vezes s\u00e3o usados em programas que calculam resultados num\u00e9ricos, come\u00e7ando com uma resposta aproximada e melhorando-a iterativamente. Por exemplo, uma forma de calcular ra\u00edzes quadradas \u00e9 o m\u00e9todo de Newton. Suponha que voc\u00ea queira saber a raiz quadrada de a. Se come\u00e7ar com quase qualquer estimativa, x, \u00e9 poss\u00edvel calcular uma estimativa melhor com a seguinte f\u00f3rmula: Por exemplo, se a for 4 e x for 3: >>> a = 4 >>> x = 3 >>> y = (x + a/x) / 2 >>> y 2.16666666667 O resultado \u00e9 mais pr\u00f3ximo \u00e0 resposta correta ( = 2). Se repetirmos o processo com a nova estimativa, chegamos ainda mais perto: >>> x = y >>> y = (x + a/x) / 2 >>> y 2.00641025641 Depois de algumas atualiza\u00e7\u00f5es, a estimativa \u00e9 quase exata: >>> x = y >>> y = (x + a/x) / 2 >>> y 2.00001024003 >>> x = y >>> y = (x + a/x) / 2 >>> y 2.00000000003 Em geral, n\u00e3o sabemos com anteced\u00eancia quantos passos s\u00e3o necess\u00e1rios para chegar \u00e0 resposta correta, mas sabemos quando chegamos l\u00e1 porque a estimativa para de mudar: >>> x = y >>> y = (x + a/x) / 2 >>> y 2.0 >>> x = y >>> y = (x + a/x) / 2 >>> y 2.0 Quando y == x, podemos parar. Aqui est\u00e1 um loop que come\u00e7a com uma estimativa inicial, x, e a melhora at\u00e9 que deixe de mudar: while True: print(x) y = (x + a/x) / 2 if y == x: break x = y Para a maior parte de valores de a funciona bem, mas pode ser perigoso testar a igualdade de um float. Os valores de ponto flutuante s\u00e3o aproximadamente corretos: a maioria dos n\u00fameros racionais, como 1/3, e n\u00fameros irracionais, como , n\u00e3o podem ser representados exatamente com um float. Em vez de verificar se x e y s\u00e3o exatamente iguais, \u00e9 mais seguro usar a fun\u00e7\u00e3o integrada abs para calcular o valor absoluto ou magnitude da diferen\u00e7a entre eles: if abs(y-x) < epsilon: break Onde epsilon tem um valor como 0.0000001, que determina a proximidade desejada entre x e y .","title":"7.5 - Ra\u00edzes quadradas"},{"location":"07-iteracao/#76-algoritmos","text":"O m\u00e9todo de Newton \u00e9 um exemplo de um algoritmo: um processo mec\u00e2nico para resolver uma categoria de problemas (neste caso, calcular ra\u00edzes quadradas). Para entender o que \u00e9 um algoritmo, pode ser \u00fatil come\u00e7ar com algo que n\u00e3o \u00e9 um algoritmo. Quando aprendeu a multiplicar n\u00fameros de um d\u00edgito, voc\u00ea provavelmente memorizou a tabuada. Ou seja, voc\u00ea memorizou 100 solu\u00e7\u00f5es espec\u00edficas. Este tipo de conhecimento n\u00e3o \u00e9 algor\u00edtmico. No entanto, se voc\u00ea foi \u201cpregui\u00e7oso\u201d, poderia ter aprendido alguns truques. Por exemplo, para encontrar o produto de n e 9, pode escrever n-1 como o primeiro d\u00edgito e 10-n como o segundo d\u00edgito. Este truque \u00e9 uma solu\u00e7\u00e3o geral para multiplicar qualquer n\u00famero de d\u00edgito \u00fanico por 9. Isto \u00e9 um algoritmo! De forma semelhante, as t\u00e9cnicas que aprendeu, como o transporte na adi\u00e7\u00e3o, o empr\u00e9stimo na subtra\u00e7\u00e3o e a divis\u00e3o longa s\u00e3o todos algoritmos. Uma das caracter\u00edsticas de algoritmos \u00e9 que eles n\u00e3o exigem intelig\u00eancia para serem executados. S\u00e3o processos mec\u00e2nicos, nos quais cada passo segue a partir do \u00faltimo, de acordo com um conjunto de regras simples. A execu\u00e7\u00e3o de algoritmos \u00e9 ma\u00e7ante, mas projet\u00e1-los \u00e9 interessante, intelectualmente desafiador e uma parte central da Ci\u00eancia da Computa\u00e7\u00e3o. Algumas coisas que as pessoas fazem naturalmente, sem dificuldade ou pensamento consciente, s\u00e3o as mais dif\u00edceis para exprimir algoritmicamente. A compreens\u00e3o de linguagem natural \u00e9 um bom exemplo. Todos n\u00f3s o fazemos, mas por enquanto ningu\u00e9m foi capaz de explicar como o fazemos, pelo menos n\u00e3o na forma de um algoritmo.","title":"7.6 - Algoritmos"},{"location":"07-iteracao/#77-depuracao","text":"Ao come\u00e7ar a escrever programas maiores, pode ser que voc\u00ea passe mais tempo depurando. Mais c\u00f3digo significa mais possibilidades fazer erros e mais lugares para esconder defeitos. Uma forma de cortar o tempo de depura\u00e7\u00e3o \u00e9 \u201cdepurar por bisse\u00e7\u00e3o\u201d. Por exemplo, se h\u00e1 100 linhas no seu programa e voc\u00ea as verifica uma a uma, seriam 100 passos a tomar. Em vez disso, tente quebrar o problema pela metade. Olhe para o meio do programa, ou perto disso, para um valor intermedi\u00e1rio que possa verificar. Acrescente uma instru\u00e7\u00e3o print (ou outra coisa que tenha um efeito verific\u00e1vel) e execute o programa. Se a verifica\u00e7\u00e3o do ponto central for incorreta, deve haver um problema na primeira metade do programa. Se for correta, o problema est\u00e1 na segunda metade. Cada vez que executar uma verifica\u00e7\u00e3o assim, divida ao meio o n\u00famero de linhas a serem verificadas. Depois de seis passos (que \u00e9 menos de 100), voc\u00ea teria menos de uma ou duas linhas do c\u00f3digo para verificar, pelo menos em teoria. Na pr\u00e1tica, nem sempre \u00e9 claro o que representa o \u201cmeio do programa\u201d e nem sempre \u00e9 poss\u00edvel verific\u00e1-lo. N\u00e3o faz sentido contar linhas e encontrar o ponto central exato. Em vez disso, pense em lugares no programa onde poderia haver erros e lugares onde \u00e9 f\u00e1cil inserir um ponto de verifica\u00e7\u00e3o. Ent\u00e3o escolha um lugar onde as possibilidades s\u00e3o basicamente as mesmas de que o defeito esteja antes ou depois da verifica\u00e7\u00e3o.","title":"7.7 - Depura\u00e7\u00e3o"},{"location":"07-iteracao/#78-glossario","text":"reatribui\u00e7\u00e3o Atribuir um novo valor a uma vari\u00e1vel que j\u00e1 existe. atualiza\u00e7\u00e3o Uma atribui\u00e7\u00e3o onde o novo valor da vari\u00e1vel dependa do velho. inicializa\u00e7\u00e3o Uma atribui\u00e7\u00e3o que d\u00e1 um valor inicial a uma vari\u00e1vel que ser\u00e1 atualizada. incremento Uma atualiza\u00e7\u00e3o que aumenta o valor de uma vari\u00e1vel (normalmente por uma unidade). decremento Uma atualiza\u00e7\u00e3o que reduz o valor de uma vari\u00e1vel. itera\u00e7\u00e3o Execu\u00e7\u00e3o repetida de um grupo de instru\u00e7\u00f5es, usando uma chamada da fun\u00e7\u00e3o recursiva ou um loop. loop infinito Um loop no qual a condi\u00e7\u00e3o de t\u00e9rmino nunca \u00e9 satisfeita. algoritmo Um processo geral para resolver uma categoria de problemas.","title":"7.8 - Gloss\u00e1rio"},{"location":"07-iteracao/#79-exercicios","text":"","title":"7.9 - Exerc\u00edcios"},{"location":"07-iteracao/#exercicio-71","text":"Copie o loop de \u201cRa\u00edzes quadradas\u201d, na p\u00e1gina 111, e encapsule-o em uma fun\u00e7\u00e3o chamada mysqrt que receba a como par\u00e2metro, escolha um valor razo\u00e1vel de x e devolva uma estimativa da raiz quadrada de a. Para testar, escreva uma fun\u00e7\u00e3o denominada test_square_root , que exibe uma tabela como esta: a mysqrt(a) math.sqrt(a) diff - --------- ------------ ---- 1.0 1.0 1.0 0.0 2.0 1.41421356237 1.41421356237 2.22044604925e-16 3.0 1.73205080757 1.73205080757 0.0 4.0 2.0 2.0 0.0 5.0 2.2360679775 2.2360679775 0.0 6.0 2.44948974278 2.44948974278 0.0 7.0 2.64575131106 2.64575131106 0.0 8.0 2.82842712475 2.82842712475 4.4408920985e-16 9.0 3.0 3.0 0.0 A primeira coluna \u00e9 um n\u00famero, a ; a segunda coluna \u00e9 a raiz quadrada de a calculada com mysqrt ; a terceira coluna \u00e9 a raiz quadrada calculada por math.sqrt ; a quarta coluna \u00e9 o valor absoluto da diferen\u00e7a entre as duas estimativas.","title":"Exerc\u00edcio 7.1"},{"location":"07-iteracao/#exercicio-72","text":"A fun\u00e7\u00e3o integrada eval toma uma string e a avalia, usando o interpretador do Python. Por exemplo: >>> eval('1 + 2 * 3') 7 >>> import math >>> eval('math.sqrt(5)') 2.2360679774997898 >>> eval('type(math.pi)') <class 'float'> Escreva uma fun\u00e7\u00e3o chamada eval_loop que iterativamente pe\u00e7a uma entrada ao usu\u00e1rio, a avalie usando eval e exiba o resultado. Ela deve continuar at\u00e9 que o usu\u00e1rio digite done ; ent\u00e3o dever\u00e1 exibir o valor da \u00faltima express\u00e3o avaliada.","title":"Exerc\u00edcio 7.2"},{"location":"07-iteracao/#exercicio-73","text":"O matem\u00e1tico Srinivasa Ramanujan encontrou uma s\u00e9rie infinita que pode ser usada para gerar uma aproxima\u00e7\u00e3o num\u00e9rica de 1/\u03c0: Escreva uma fun\u00e7\u00e3o chamada estimate_pi que use esta f\u00f3rmula para computar e devolver uma estimativa de \u03c0. Voc\u00ea deve usar o loop while para calcular os termos da adi\u00e7\u00e3o at\u00e9 que o \u00faltimo termo seja menor que 1e-15 (que \u00e9 a nota\u00e7\u00e3o do Python para 10 ** 15 ). Voc\u00ea pode verificar o resultado comparando-o com math.pi .","title":"Exerc\u00edcio 7.3"},{"location":"08-strings/","text":"Cap\u00edtulo 8: Strings Strings n\u00e3o s\u00e3o como n\u00fameros inteiros, de ponto flutuante ou booleanos. Uma string \u00e9 uma sequ\u00eancia, ou seja, uma cole\u00e7\u00e3o ordenada de outros valores. Neste cap\u00edtulo voc\u00ea ver\u00e1 como acessar os caracteres que comp\u00f5em uma string e aprender\u00e1 alguns m\u00e9todos que as strings oferecem. 8.1 - Uma string \u00e9 uma sequ\u00eancia Uma string \u00e9 uma sequ\u00eancia de caracteres. Voc\u00ea pode acessar um caractere de cada vez com o operador de colchete: >>> fruit = 'banana' >>> letter = fruit[1] A segunda instru\u00e7\u00e3o seleciona o caractere n\u00famero 1 de fruit e o atribui a letter. A express\u00e3o entre colchetes chama-se \u00edndice. O \u00edndice aponta qual caractere da sequ\u00eancia voc\u00ea quer (da\u00ed o nome). Mas pode ser que voc\u00ea n\u00e3o obtenha o que espera: >>> letter 'a' Para a maior parte das pessoas, a primeira letra de 'banana' \u00e9 b, n\u00e3o a. Mas para os cientistas da computa\u00e7\u00e3o, o \u00edndice \u00e9 uma refer\u00eancia do come\u00e7o da string, e a refer\u00eancia da primeira letra \u00e9 zero. >>> letter = fruit[0] >>> letter 'b' Ent\u00e3o b \u00e9 a 0\u00aa (\u201czer\u00e9sima\u201d) letra de 'banana', a \u00e9 a 1\u00aa (primeira) letra e n \u00e9 a 2\u00aa (segunda) letra. Voc\u00ea pode usar uma express\u00e3o que contenha vari\u00e1veis e operadores como \u00edndice: >>> i = 1 >>> fruit[i] 'a' >>> fruit[i+1] 'n' Por\u00e9m, o valor do \u00edndice tem que ser um n\u00famero inteiro. Se n\u00e3o for, \u00e9 isso que aparece: >>> letter = fruit[1.5] TypeError: string indices must be integers 8.2 - len len \u00e9 uma fun\u00e7\u00e3o integrada que devolve o n\u00famero de caracteres em uma string: >>> fruit = 'banana' >>> len(fruit) 6 Para obter a \u00faltima letra de uma string, pode parecer uma boa ideia tentar algo assim: >>> length = len(fruit) >>> last = fruit[length] IndexError: string index out of range A raz\u00e3o de haver um IndexError aqui \u00e9 que n\u00e3o h\u00e1 nenhuma letra em 'banana' com o \u00edndice 6. Como a contagem inicia no zero, as seis letras s\u00e3o numeradas de 0 a 5. Para obter o \u00faltimo caractere, voc\u00ea deve subtrair 1 de length: >>> last = fruit[length-1] >>> last 'a' Ou voc\u00ea pode usar \u00edndices negativos, que contam de tr\u00e1s para a frente a partir do fim da string. A express\u00e3o fruit[-1] apresenta a \u00faltima letra, fruit[-2] apresenta a segunda letra de tr\u00e1s para a frente, e assim por diante. 8.3 - Travessia com loop for Muitos c\u00e1lculos implicam o processamento de um caractere por vez em uma string. Muitas vezes come\u00e7am no in\u00edcio, selecionam um caractere por vez, fazem algo e continuam at\u00e9 o fim. Este modelo do processamento chama-se travessia. Um modo de escrever uma travessia \u00e9 com o loop while: index = 0 while index < len(fruit): letter = fruit[index] print(letter) index = index + 1 Este loop atravessa a string e exibe cada letra sozinha em uma linha. A condi\u00e7\u00e3o do loop \u00e9 index <len (fruit), ent\u00e3o quando index \u00e9 igual ao comprimento da string, a condi\u00e7\u00e3o \u00e9 falsa e o corpo do loop n\u00e3o \u00e9 mais executado. O \u00faltimo caractere acessado \u00e9 aquele com o \u00edndice len (fruit)-1, que \u00e9 o \u00faltimo caractere na string. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o que receba uma string como argumento e exiba as letras de tr\u00e1s para a frente, uma por linha. Outra forma de escrever uma travessia \u00e9 com um loop for: for letter in fruit: print(letter) Cada vez que o programa passar pelo loop, o caractere seguinte na string \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel letter. O loop continua at\u00e9 que n\u00e3o sobre nenhum caractere. O pr\u00f3ximo exemplo mostra como usar a concatena\u00e7\u00e3o (adi\u00e7\u00e3o de strings) e um loop for para gerar uma s\u00e9rie abeced\u00e1ria (isto \u00e9, em ordem alfab\u00e9tica). No livro de Robert McCloskey, Make Way for Ducklings (Abram caminho para os patinhos), os nomes dos patinhos s\u00e3o Jack, Kack, Lack, Mack, Nack, Ouack, Pack e Quack. Este loop produz estes nomes em ordem: prefixes = 'JKLMNOPQ' suffix = 'ack' for letter in prefixes: print(letter + suffix) A sa\u00edda \u00e9: Jack Kack Lack Mack Nack Oack Pack Qack Claro que n\u00e3o est\u00e1 exatamente certo porque \u201cOuack\u201d e \u201cQuack\u201d foram mal soletrados. Como exerc\u00edcio, altere o programa para corrigir este erro. 8.4 - Fatiamento de strings Um segmento de uma string \u00e9 chamado de fatia. Selecionar uma fatia \u00e9 como selecionar um caractere: >>> s = 'Monty Python' >>> s[0:5] 'Monty' >>> s[6:12] 'Python' O operador [n:m] retorna a parte da string do \u201cen\u00e9simo\u201d caractere ao \u201cem\u00e9simo\u201d caractere, incluindo o primeiro, mas excluindo o \u00faltimo. Este comportamento \u00e9 contraintuitivo, por\u00e9m pode ajudar a imaginar os \u00edndices que indicam a parte entre os caracteres, como na Figura 8.1. Figura 8.1 \u2013 \u00cdndices de fatias. Se voc\u00ea omitir o primeiro \u00edndice (antes dos dois pontos), a fatia come\u00e7a no in\u00edcio da string. Se omitir o segundo \u00edndice, a fatia vai ao fim da string: >>> fruit = 'banana' >>> fruit[:3] 'ban' >>> fruit[3:] 'ana' Se o primeiro \u00edndice for maior ou igual ao segundo, o resultado \u00e9 uma string vazia, representada por duas aspas: >>> fruit = 'banana' >>> fruit[3:3] '' Uma string vazia n\u00e3o cont\u00e9m nenhum caractere e tem o comprimento 0, fora isso, \u00e9 igual a qualquer outra string. Continuando este exemplo, o que voc\u00ea acha que fruit[:] significa? Teste e veja. 8.5 - Strings s\u00e3o imut\u00e1veis \u00c9 tentador usar o operador [] no lado esquerdo de uma atribui\u00e7\u00e3o, com a inten\u00e7\u00e3o de alterar um caractere em uma string. Por exemplo: >>> greeting = 'Hello, world!' >>> greeting[0] = 'J' TypeError: 'str' object does not support item assignment O \u201cobjeto\u201d neste caso \u00e9 a string e o \u201citem\u201d \u00e9 o caractere que voc\u00ea tentou atribuir. Por enquanto, um objeto \u00e9 a mesma coisa que um valor, mas refinaremos esta defini\u00e7\u00e3o mais adiante ( Objetos e valores , no cap\u00edtulo 10). A raz\u00e3o do erro \u00e9 que as strings s\u00e3o imut\u00e1veis, o que significa que voc\u00ea n\u00e3o pode alterar uma string existente. O melhor que voc\u00ea pode fazer \u00e9 criar uma string que seja uma varia\u00e7\u00e3o da original: >>> greeting = 'Hello, world!' >>> new_greeting = 'J' + greeting[1:] >>> new_greeting 'Jello, world!' Esse exemplo concatena uma nova primeira letra a uma fatia de greeting . N\u00e3o tem efeito sobre a string original. 8.6 - Buscando O que faz a seguinte fun\u00e7\u00e3o? def find(word, letter): index = 0 while index < len(word): if word[index] == letter: return index index = index + 1 return-1 De certo modo, find \u00e9 o inverso do operador [] . Em vez de tomar um \u00edndice e extrair o caractere correspondente, ele toma um caractere e encontra o \u00edndice onde aquele caractere aparece. Se o caractere n\u00e3o for encontrado, a fun\u00e7\u00e3o retorna -1. Esse \u00e9 o primeiro exemplo que vimos de uma instru\u00e7\u00e3o return dentro de um loop. Se word[index] == letter , a fun\u00e7\u00e3o sai do loop e retorna imediatamente. Se o caractere n\u00e3o aparecer na string, o programa sai do loop normalmente e devolve -1. Este modelo de c\u00e1lculo \u2013 atravessar uma sequ\u00eancia e retornar quando encontramos o que estamos procurando \u2013 chama-se busca. Como exerc\u00edcio, altere find para que tenha um terceiro par\u00e2metro: o \u00edndice em word onde deve come\u00e7ar a busca. 8.7 - Loop e contagem O seguinte programa conta o n\u00famero de vezes que a letra a aparece em uma string: word = 'banana' count = 0 for letter in word: if letter == 'a': count = count + 1 print(count) Este programa demonstra outro padr\u00e3o de computa\u00e7\u00e3o chamado contador. A vari\u00e1vel count \u00e9 inicializada com 0 e ent\u00e3o incrementada cada vez que um a \u00e9 encontrado. Ao sair do loop, count cont\u00e9m o resultado \u2013 o n\u00famero total de letras 'a' . Como exerc\u00edcio, encapsule este c\u00f3digo em uma fun\u00e7\u00e3o denominada count e generalize-o para que aceite a string e a letra como argumentos. Ent\u00e3o reescreva a fun\u00e7\u00e3o para que, em vez de atravessar a string, ela use a vers\u00e3o de tr\u00eas par\u00e2metros do find da se\u00e7\u00e3o anterior. 8.8 - M\u00e9todos de strings As strings oferecem m\u00e9todos que executam v\u00e1rias opera\u00e7\u00f5es \u00fateis. Um m\u00e9todo \u00e9 semelhante a uma fun\u00e7\u00e3o \u2013 toma argumentos e devolve um valor \u2013, mas a sintaxe \u00e9 diferente. Por exemplo, o m\u00e9todo upper recebe uma string e devolve uma nova string com todas as letras mai\u00fasculas. Em vez da sintaxe de fun\u00e7\u00e3o upper(word) , ela usa a sintaxe de m\u00e9todo word.upper() : >>> word = 'banana' >>> new_word = word.upper() >>> new_word 'BANANA' Esta forma de nota\u00e7\u00e3o de ponto especifica o nome do m\u00e9todo, upper e o nome da string, word , \u00e0 qual o m\u00e9todo ser\u00e1 aplicado. Os par\u00eanteses vazios indicam que este m\u00e9todo n\u00e3o toma nenhum argumento. Uma chamada de m\u00e9todo denomina-se invoca\u00e7\u00e3o; neste caso, dir\u00edamos que estamos invocando upper em word . E, na verdade, h\u00e1 um m\u00e9todo de string denominado find , que \u00e9 notavelmente semelhante \u00e0 fun\u00e7\u00e3o que escrevemos: >>> word = 'banana' >>> index = word.find('a') >>> index 1 Neste exemplo, invocamos find em word e passamos a letra que estamos procurando como um par\u00e2metro. Na verdade, o m\u00e9todo find \u00e9 mais geral que a nossa fun\u00e7\u00e3o; ele pode encontrar substrings, n\u00e3o apenas caracteres: >>> word.find('na') 2 Por padr\u00e3o, find inicia no come\u00e7o da string, mas pode receber um segundo argumento, o \u00edndice onde deve come\u00e7ar: >>> word.find('na', 3) 4 Este \u00e9 um exemplo de um argumento opcional. find tamb\u00e9m pode receber um terceiro argumento, o \u00edndice para onde deve parar: >>> name = 'bob' >>> name.find('b', 1, 2) -1 Esta busca falha porque 'b' n\u00e3o aparece no intervalo do \u00edndice de 1 a 2, n\u00e3o incluindo 2. Fazer buscas at\u00e9 (mas n\u00e3o incluindo) o segundo \u00edndice torna find similar ao operador de fatiamento. 8.9 - Operador in A palavra in \u00e9 um operador booleano que recebe duas strings e retorna True se a primeira aparecer como uma substring da segunda: >>> 'a' in 'banana' True >>> 'seed' in 'banana' False Por exemplo, a seguinte fun\u00e7\u00e3o imprime todas as letras de word1 que tamb\u00e9m aparecem em word2 : def in_both(word1, word2): for letter in word1: if letter in word2: print(letter) Com nomes de vari\u00e1veis bem escolhidos, o Python \u00e0s vezes pode ser lido como um texto em ingl\u00eas. Voc\u00ea pode ler este loop, \u201cpara (cada) letra em (a primeira) palavra, se (a) letra (aparecer) em (a segunda) palavra, exiba (a) letra\u201d. Veja o que \u00e9 apresentado ao se comparar ma\u00e7\u00e3s e laranjas: >>> in_both('apples', 'oranges') a e s 8.10 - Compara\u00e7\u00e3o de strings Os operadores relacionais funcionam em strings. Para ver se duas strings s\u00e3o iguais: if word == 'banana': print('All right, bananas.') Outras opera\u00e7\u00f5es relacionais s\u00e3o \u00fateis para colocar palavras em ordem alfab\u00e9tica: if word < 'banana': print('Your word, ' + word + ', comes before banana.') elif word > 'banana': print('Your word, ' + word + ', comes after banana.') else: print('All right, bananas.') O Python n\u00e3o lida com letras mai\u00fasculas e min\u00fasculas do mesmo jeito que as pessoas. Todas as letras mai\u00fasculas v\u00eam antes de todas as letras min\u00fasculas, portanto: Your word, Pineapple, comes before banana. Uma forma comum de lidar com este problema \u00e9 converter strings em um formato padr\u00e3o, como letras min\u00fasculas, antes de executar a compara\u00e7\u00e3o. Lembre-se disso caso tenha que se defender de um homem armado com um abacaxi. 8.11 - Depura\u00e7\u00e3o Ao usar \u00edndices para atravessar os valores em uma sequ\u00eancia, \u00e9 complicado acertar o come\u00e7o e o fim da travessia. Aqui est\u00e1 uma fun\u00e7\u00e3o que supostamente compara duas palavras e retorna True se uma das palavras for o reverso da outra, mas cont\u00e9m dois erros: def is_reverse(word1, word2): if len(word1) != len(word2): return False i = 0 j = len(word2) while j > 0: if word1[i] != word2[j]: return False i = i+1 j = j-1 return True A primeira instru\u00e7\u00e3o if verifica se as palavras t\u00eam o mesmo comprimento. Se n\u00e3o for o caso, podemos retornar False imediatamente. Do contr\u00e1rio, para o resto da fun\u00e7\u00e3o, podemos supor que as palavras tenham o mesmo comprimento. Este \u00e9 um exemplo do modelo de guardi\u00e3o em \u201cVerifica\u00e7\u00e3o de tipos\u201d, na p\u00e1gina 101. i e j s\u00e3o \u00edndices: i atravessa word1 para a frente, enquanto j atravessa word2 para tr\u00e1s. Se encontrarmos duas letras que n\u00e3o combinam, podemos retornar False imediatamente. Se terminarmos o loop inteiro e todas as letras corresponderem, retornamos True. Se testarmos esta fun\u00e7\u00e3o com as palavras \u201cpots\u201d e \u201cstop\u201d, esperamos o valor de retorno True, mas recebemos um IndexError: >>> is_reverse('pots', 'stop') ... File \"reverse.py\", line 15, in is_reverse if word1[i] != word2[j]: IndexError: string index out of range Para depurar este tipo de erro, minha primeira a\u00e7\u00e3o \u00e9 exibir os valores dos \u00edndices imediatamente antes da linha onde o erro aparece. while j > 0: print(i, j) # exibir aqui if word1[i] != word2[j]: return False i = i+1 j = j-1 Agora quando executo o programa novamente, recebo mais informa\u00e7\u00e3o: >>> is_reverse('pots', 'stop') 0 4 ... IndexError: string index out of range Na primeira vez que o programa passar pelo loop, o valor de j \u00e9 4, que est\u00e1 fora do intervalo da string 'pots'. O \u00edndice do \u00faltimo caractere \u00e9 3, ent\u00e3o o valor inicial de j deve ser len(word2)-1. Se corrigir esse erro e executar o programa novamente, recebo: >>> is_reverse('pots', 'stop') 0 3 1 2 2 1 True Desta vez, recebemos a resposta certa, mas parece que o loop s\u00f3 foi executado tr\u00eas vezes, o que \u00e9 suspeito. Para ter uma ideia melhor do que est\u00e1 acontecendo, \u00e9 \u00fatil desenhar um diagrama de estado. Durante a primeira itera\u00e7\u00e3o, o frame de is_reverse \u00e9 mostrado na Figura 8.2. 8.2 \u2013 Diagrama de estado de is_reverse. Tomei a liberdade de arrumar as vari\u00e1veis no frame e acrescentei linhas pontilhadas para mostrar que os valores de i e j indicam caracteres em word1 e word2. Come\u00e7ando com este diagrama, execute o programa em papel, alterando os valores de i e j durante cada itera\u00e7\u00e3o. Encontre e corrija o segundo erro desta fun\u00e7\u00e3o. 8.12 - Gloss\u00e1rio objeto Algo a que uma vari\u00e1vel pode se referir. Por enquanto, voc\u00ea pode usar \u201cobjeto\u201d e \u201cvalor\u201d de forma intercambi\u00e1vel. sequ\u00eancia Uma cole\u00e7\u00e3o ordenada de valores onde cada valor \u00e9 identificado por um \u00edndice de n\u00famero inteiro. item Um dos valores em uma sequ\u00eancia. \u00edndice Um valor inteiro usado para selecionar um item em uma sequ\u00eancia, como um caractere em uma string. No Python, os \u00edndices come\u00e7am em 0. fatia Parte de uma string especificada por um intervalo de \u00edndices. string vazia Uma string sem caracteres e de comprimento 0, representada por duas aspas. imut\u00e1vel A propriedade de uma sequ\u00eancia cujos itens n\u00e3o podem ser alterados. atravessar Repetir os itens em uma sequ\u00eancia, executando uma opera\u00e7\u00e3o semelhante em cada um. busca Um modelo de travessia que \u00e9 interrompido quando encontra o que est\u00e1 procurando. contador Uma vari\u00e1vel usada para contar algo, normalmente inicializada com zero e ent\u00e3o incrementada. invoca\u00e7\u00e3o Uma instru\u00e7\u00e3o que chama um m\u00e9todo. argumento opcional Um argumento de fun\u00e7\u00e3o ou m\u00e9todo que n\u00e3o \u00e9 necess\u00e1rio. 8.13 - Exerc\u00edcios Exerc\u00edcio 8.1 Leia a documenta\u00e7\u00e3o dos m\u00e9todos de strings em http://docs.python.org/3/library/stdtypes.html#string-methods. Pode ser uma boa ideia experimentar alguns deles para entender como funcionam. strip e replace s\u00e3o especialmente \u00fateis. A documenta\u00e7\u00e3o usa uma sintaxe que pode ser confusa. Por exemplo, em find(sub[, start[, end]]) , os colchetes indicam argumentos opcionais. Ent\u00e3o sub \u00e9 exigido, mas start \u00e9 opcional, e se voc\u00ea incluir start , ent\u00e3o end \u00e9 opcional. Exerc\u00edcio 8.2 H\u00e1 um m\u00e9todo de string chamado count , que \u00e9 semelhante \u00e0 fun\u00e7\u00e3o em \u201cLoop e contagem\u201d, na p\u00e1gina 123. Leia a documenta\u00e7\u00e3o deste m\u00e9todo e escreva uma invoca\u00e7\u00e3o que conte o n\u00famero de letras 'a' em 'banana'. Exerc\u00edcio 8.3 Uma fatia de string pode receber um terceiro \u00edndice que especifique o \u201ctamanho do passo\u201d; isto \u00e9, o n\u00famero de espa\u00e7os entre caracteres sucessivos. Um tamanho de passo 2 significa tomar um caractere e outro n\u00e3o; 3 significa tomar um e dois n\u00e3o etc. >>> fruit = 'banana' >>> fruit[0:5:2] 'bnn' Um tamanho de passo -1 atravessa a palavra de tr\u00e1s para a frente, ent\u00e3o a fatia [::-1] gera uma string invertida. Use isso para escrever uma vers\u00e3o de uma linha de is_palindrome do Exerc\u00edcio 6.3. Exerc\u00edcio 8.4 As seguintes fun\u00e7\u00f5es pretendem verificar se uma string cont\u00e9m alguma letra min\u00fascula, mas algumas delas est\u00e3o erradas. Para cada fun\u00e7\u00e3o, descreva o que ela faz (assumindo que o par\u00e2metro seja uma string). def any_lowercase1(s): for c in s: if c.islower(): return True else: return False def any_lowercase2(s): for c in s: if 'c'.islower(): return 'True' else: return 'False' def any_lowercase3(s): for c in s: flag = c.islower() return flag def any_lowercase4(s): flag = False for c in s: flag = flag or c.islower() return flag def any_lowercase5(s): for c in s: if not c.islower(): return False return True Exerc\u00edcio 8.5 Uma cifra de C\u00e9sar \u00e9 uma forma fraca de criptografia que implica \u201crotacionar\u201d cada letra por um n\u00famero fixo de lugares. Rotacionar uma letra significa desloc\u00e1-lo pelo alfabeto, voltando ao in\u00edcio se for necess\u00e1rio, portanto \u2018A\u2019 rotacionado por 3 \u00e9 \u2018D\u2019 e \u2018Z\u2019 rotacionado por 1 \u00e9 \u2018A\u2019. Para rotacionar uma palavra, fa\u00e7a cada letra se mover pela mesma quantidade de posi\u00e7\u00f5es. Por exemplo, \u201ccheer\u201d rotacionado por 7 \u00e9 \u201cjolly\u201d e \u201cmelon\u201d rotacionado por -10 \u00e9 \u201ccubed\u201d. No filme 2001: Uma odisseia no espa\u00e7o, o computador da nave chama-se HAL, que \u00e9 IBM rotacionado por -1. Escreva uma fun\u00e7\u00e3o chamada rotate_word que receba uma string e um n\u00famero inteiro como par\u00e2metros, e retorne uma nova string que cont\u00e9m as letras da string original rotacionadas pelo n\u00famero dado. Voc\u00ea pode usar a fun\u00e7\u00e3o integrada ord, que converte um caractere em um c\u00f3digo num\u00e9rico e chr, que converte c\u00f3digos num\u00e9ricos em caracteres. As letras do alfabeto s\u00e3o codificadas em ordem alfab\u00e9tica, ent\u00e3o, por exemplo: >>> ord('c') - ord('a') 2 Porque 'c' \u00e9 a \u201csegunda\u201d letra do alfabeto. Mas tenha cuidado: os c\u00f3digos num\u00e9ricos de letras mai\u00fasculas s\u00e3o diferentes. Piadas potencialmente ofensivas na internet \u00e0s vezes s\u00e3o codificadas em ROT13, que \u00e9 uma cifra de C\u00e9sar com rota\u00e7\u00e3o 13. Se n\u00e3o se ofender facilmente, encontre e decifre algumas delas.","title":"Cap\u00edtulo 8: Strings"},{"location":"08-strings/#capitulo-8-strings","text":"Strings n\u00e3o s\u00e3o como n\u00fameros inteiros, de ponto flutuante ou booleanos. Uma string \u00e9 uma sequ\u00eancia, ou seja, uma cole\u00e7\u00e3o ordenada de outros valores. Neste cap\u00edtulo voc\u00ea ver\u00e1 como acessar os caracteres que comp\u00f5em uma string e aprender\u00e1 alguns m\u00e9todos que as strings oferecem.","title":"Cap\u00edtulo 8: Strings"},{"location":"08-strings/#81-uma-string-e-uma-sequencia","text":"Uma string \u00e9 uma sequ\u00eancia de caracteres. Voc\u00ea pode acessar um caractere de cada vez com o operador de colchete: >>> fruit = 'banana' >>> letter = fruit[1] A segunda instru\u00e7\u00e3o seleciona o caractere n\u00famero 1 de fruit e o atribui a letter. A express\u00e3o entre colchetes chama-se \u00edndice. O \u00edndice aponta qual caractere da sequ\u00eancia voc\u00ea quer (da\u00ed o nome). Mas pode ser que voc\u00ea n\u00e3o obtenha o que espera: >>> letter 'a' Para a maior parte das pessoas, a primeira letra de 'banana' \u00e9 b, n\u00e3o a. Mas para os cientistas da computa\u00e7\u00e3o, o \u00edndice \u00e9 uma refer\u00eancia do come\u00e7o da string, e a refer\u00eancia da primeira letra \u00e9 zero. >>> letter = fruit[0] >>> letter 'b' Ent\u00e3o b \u00e9 a 0\u00aa (\u201czer\u00e9sima\u201d) letra de 'banana', a \u00e9 a 1\u00aa (primeira) letra e n \u00e9 a 2\u00aa (segunda) letra. Voc\u00ea pode usar uma express\u00e3o que contenha vari\u00e1veis e operadores como \u00edndice: >>> i = 1 >>> fruit[i] 'a' >>> fruit[i+1] 'n' Por\u00e9m, o valor do \u00edndice tem que ser um n\u00famero inteiro. Se n\u00e3o for, \u00e9 isso que aparece: >>> letter = fruit[1.5] TypeError: string indices must be integers","title":"8.1 - Uma string \u00e9 uma sequ\u00eancia"},{"location":"08-strings/#82-len","text":"len \u00e9 uma fun\u00e7\u00e3o integrada que devolve o n\u00famero de caracteres em uma string: >>> fruit = 'banana' >>> len(fruit) 6 Para obter a \u00faltima letra de uma string, pode parecer uma boa ideia tentar algo assim: >>> length = len(fruit) >>> last = fruit[length] IndexError: string index out of range A raz\u00e3o de haver um IndexError aqui \u00e9 que n\u00e3o h\u00e1 nenhuma letra em 'banana' com o \u00edndice 6. Como a contagem inicia no zero, as seis letras s\u00e3o numeradas de 0 a 5. Para obter o \u00faltimo caractere, voc\u00ea deve subtrair 1 de length: >>> last = fruit[length-1] >>> last 'a' Ou voc\u00ea pode usar \u00edndices negativos, que contam de tr\u00e1s para a frente a partir do fim da string. A express\u00e3o fruit[-1] apresenta a \u00faltima letra, fruit[-2] apresenta a segunda letra de tr\u00e1s para a frente, e assim por diante.","title":"8.2 - len"},{"location":"08-strings/#83-travessia-com-loop-for","text":"Muitos c\u00e1lculos implicam o processamento de um caractere por vez em uma string. Muitas vezes come\u00e7am no in\u00edcio, selecionam um caractere por vez, fazem algo e continuam at\u00e9 o fim. Este modelo do processamento chama-se travessia. Um modo de escrever uma travessia \u00e9 com o loop while: index = 0 while index < len(fruit): letter = fruit[index] print(letter) index = index + 1 Este loop atravessa a string e exibe cada letra sozinha em uma linha. A condi\u00e7\u00e3o do loop \u00e9 index <len (fruit), ent\u00e3o quando index \u00e9 igual ao comprimento da string, a condi\u00e7\u00e3o \u00e9 falsa e o corpo do loop n\u00e3o \u00e9 mais executado. O \u00faltimo caractere acessado \u00e9 aquele com o \u00edndice len (fruit)-1, que \u00e9 o \u00faltimo caractere na string. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o que receba uma string como argumento e exiba as letras de tr\u00e1s para a frente, uma por linha. Outra forma de escrever uma travessia \u00e9 com um loop for: for letter in fruit: print(letter) Cada vez que o programa passar pelo loop, o caractere seguinte na string \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel letter. O loop continua at\u00e9 que n\u00e3o sobre nenhum caractere. O pr\u00f3ximo exemplo mostra como usar a concatena\u00e7\u00e3o (adi\u00e7\u00e3o de strings) e um loop for para gerar uma s\u00e9rie abeced\u00e1ria (isto \u00e9, em ordem alfab\u00e9tica). No livro de Robert McCloskey, Make Way for Ducklings (Abram caminho para os patinhos), os nomes dos patinhos s\u00e3o Jack, Kack, Lack, Mack, Nack, Ouack, Pack e Quack. Este loop produz estes nomes em ordem: prefixes = 'JKLMNOPQ' suffix = 'ack' for letter in prefixes: print(letter + suffix) A sa\u00edda \u00e9: Jack Kack Lack Mack Nack Oack Pack Qack Claro que n\u00e3o est\u00e1 exatamente certo porque \u201cOuack\u201d e \u201cQuack\u201d foram mal soletrados. Como exerc\u00edcio, altere o programa para corrigir este erro.","title":"8.3 - Travessia com loop for"},{"location":"08-strings/#84-fatiamento-de-strings","text":"Um segmento de uma string \u00e9 chamado de fatia. Selecionar uma fatia \u00e9 como selecionar um caractere: >>> s = 'Monty Python' >>> s[0:5] 'Monty' >>> s[6:12] 'Python' O operador [n:m] retorna a parte da string do \u201cen\u00e9simo\u201d caractere ao \u201cem\u00e9simo\u201d caractere, incluindo o primeiro, mas excluindo o \u00faltimo. Este comportamento \u00e9 contraintuitivo, por\u00e9m pode ajudar a imaginar os \u00edndices que indicam a parte entre os caracteres, como na Figura 8.1. Figura 8.1 \u2013 \u00cdndices de fatias. Se voc\u00ea omitir o primeiro \u00edndice (antes dos dois pontos), a fatia come\u00e7a no in\u00edcio da string. Se omitir o segundo \u00edndice, a fatia vai ao fim da string: >>> fruit = 'banana' >>> fruit[:3] 'ban' >>> fruit[3:] 'ana' Se o primeiro \u00edndice for maior ou igual ao segundo, o resultado \u00e9 uma string vazia, representada por duas aspas: >>> fruit = 'banana' >>> fruit[3:3] '' Uma string vazia n\u00e3o cont\u00e9m nenhum caractere e tem o comprimento 0, fora isso, \u00e9 igual a qualquer outra string. Continuando este exemplo, o que voc\u00ea acha que fruit[:] significa? Teste e veja.","title":"8.4 - Fatiamento de strings"},{"location":"08-strings/#85-strings-sao-imutaveis","text":"\u00c9 tentador usar o operador [] no lado esquerdo de uma atribui\u00e7\u00e3o, com a inten\u00e7\u00e3o de alterar um caractere em uma string. Por exemplo: >>> greeting = 'Hello, world!' >>> greeting[0] = 'J' TypeError: 'str' object does not support item assignment O \u201cobjeto\u201d neste caso \u00e9 a string e o \u201citem\u201d \u00e9 o caractere que voc\u00ea tentou atribuir. Por enquanto, um objeto \u00e9 a mesma coisa que um valor, mas refinaremos esta defini\u00e7\u00e3o mais adiante ( Objetos e valores , no cap\u00edtulo 10). A raz\u00e3o do erro \u00e9 que as strings s\u00e3o imut\u00e1veis, o que significa que voc\u00ea n\u00e3o pode alterar uma string existente. O melhor que voc\u00ea pode fazer \u00e9 criar uma string que seja uma varia\u00e7\u00e3o da original: >>> greeting = 'Hello, world!' >>> new_greeting = 'J' + greeting[1:] >>> new_greeting 'Jello, world!' Esse exemplo concatena uma nova primeira letra a uma fatia de greeting . N\u00e3o tem efeito sobre a string original.","title":"8.5 - Strings s\u00e3o imut\u00e1veis"},{"location":"08-strings/#86-buscando","text":"O que faz a seguinte fun\u00e7\u00e3o? def find(word, letter): index = 0 while index < len(word): if word[index] == letter: return index index = index + 1 return-1 De certo modo, find \u00e9 o inverso do operador [] . Em vez de tomar um \u00edndice e extrair o caractere correspondente, ele toma um caractere e encontra o \u00edndice onde aquele caractere aparece. Se o caractere n\u00e3o for encontrado, a fun\u00e7\u00e3o retorna -1. Esse \u00e9 o primeiro exemplo que vimos de uma instru\u00e7\u00e3o return dentro de um loop. Se word[index] == letter , a fun\u00e7\u00e3o sai do loop e retorna imediatamente. Se o caractere n\u00e3o aparecer na string, o programa sai do loop normalmente e devolve -1. Este modelo de c\u00e1lculo \u2013 atravessar uma sequ\u00eancia e retornar quando encontramos o que estamos procurando \u2013 chama-se busca. Como exerc\u00edcio, altere find para que tenha um terceiro par\u00e2metro: o \u00edndice em word onde deve come\u00e7ar a busca.","title":"8.6 - Buscando"},{"location":"08-strings/#87-loop-e-contagem","text":"O seguinte programa conta o n\u00famero de vezes que a letra a aparece em uma string: word = 'banana' count = 0 for letter in word: if letter == 'a': count = count + 1 print(count) Este programa demonstra outro padr\u00e3o de computa\u00e7\u00e3o chamado contador. A vari\u00e1vel count \u00e9 inicializada com 0 e ent\u00e3o incrementada cada vez que um a \u00e9 encontrado. Ao sair do loop, count cont\u00e9m o resultado \u2013 o n\u00famero total de letras 'a' . Como exerc\u00edcio, encapsule este c\u00f3digo em uma fun\u00e7\u00e3o denominada count e generalize-o para que aceite a string e a letra como argumentos. Ent\u00e3o reescreva a fun\u00e7\u00e3o para que, em vez de atravessar a string, ela use a vers\u00e3o de tr\u00eas par\u00e2metros do find da se\u00e7\u00e3o anterior.","title":"8.7 - Loop e contagem"},{"location":"08-strings/#88-metodos-de-strings","text":"As strings oferecem m\u00e9todos que executam v\u00e1rias opera\u00e7\u00f5es \u00fateis. Um m\u00e9todo \u00e9 semelhante a uma fun\u00e7\u00e3o \u2013 toma argumentos e devolve um valor \u2013, mas a sintaxe \u00e9 diferente. Por exemplo, o m\u00e9todo upper recebe uma string e devolve uma nova string com todas as letras mai\u00fasculas. Em vez da sintaxe de fun\u00e7\u00e3o upper(word) , ela usa a sintaxe de m\u00e9todo word.upper() : >>> word = 'banana' >>> new_word = word.upper() >>> new_word 'BANANA' Esta forma de nota\u00e7\u00e3o de ponto especifica o nome do m\u00e9todo, upper e o nome da string, word , \u00e0 qual o m\u00e9todo ser\u00e1 aplicado. Os par\u00eanteses vazios indicam que este m\u00e9todo n\u00e3o toma nenhum argumento. Uma chamada de m\u00e9todo denomina-se invoca\u00e7\u00e3o; neste caso, dir\u00edamos que estamos invocando upper em word . E, na verdade, h\u00e1 um m\u00e9todo de string denominado find , que \u00e9 notavelmente semelhante \u00e0 fun\u00e7\u00e3o que escrevemos: >>> word = 'banana' >>> index = word.find('a') >>> index 1 Neste exemplo, invocamos find em word e passamos a letra que estamos procurando como um par\u00e2metro. Na verdade, o m\u00e9todo find \u00e9 mais geral que a nossa fun\u00e7\u00e3o; ele pode encontrar substrings, n\u00e3o apenas caracteres: >>> word.find('na') 2 Por padr\u00e3o, find inicia no come\u00e7o da string, mas pode receber um segundo argumento, o \u00edndice onde deve come\u00e7ar: >>> word.find('na', 3) 4 Este \u00e9 um exemplo de um argumento opcional. find tamb\u00e9m pode receber um terceiro argumento, o \u00edndice para onde deve parar: >>> name = 'bob' >>> name.find('b', 1, 2) -1 Esta busca falha porque 'b' n\u00e3o aparece no intervalo do \u00edndice de 1 a 2, n\u00e3o incluindo 2. Fazer buscas at\u00e9 (mas n\u00e3o incluindo) o segundo \u00edndice torna find similar ao operador de fatiamento.","title":"8.8 - M\u00e9todos de strings"},{"location":"08-strings/#89-operador-in","text":"A palavra in \u00e9 um operador booleano que recebe duas strings e retorna True se a primeira aparecer como uma substring da segunda: >>> 'a' in 'banana' True >>> 'seed' in 'banana' False Por exemplo, a seguinte fun\u00e7\u00e3o imprime todas as letras de word1 que tamb\u00e9m aparecem em word2 : def in_both(word1, word2): for letter in word1: if letter in word2: print(letter) Com nomes de vari\u00e1veis bem escolhidos, o Python \u00e0s vezes pode ser lido como um texto em ingl\u00eas. Voc\u00ea pode ler este loop, \u201cpara (cada) letra em (a primeira) palavra, se (a) letra (aparecer) em (a segunda) palavra, exiba (a) letra\u201d. Veja o que \u00e9 apresentado ao se comparar ma\u00e7\u00e3s e laranjas: >>> in_both('apples', 'oranges') a e s","title":"8.9 - Operador in"},{"location":"08-strings/#810-comparacao-de-strings","text":"Os operadores relacionais funcionam em strings. Para ver se duas strings s\u00e3o iguais: if word == 'banana': print('All right, bananas.') Outras opera\u00e7\u00f5es relacionais s\u00e3o \u00fateis para colocar palavras em ordem alfab\u00e9tica: if word < 'banana': print('Your word, ' + word + ', comes before banana.') elif word > 'banana': print('Your word, ' + word + ', comes after banana.') else: print('All right, bananas.') O Python n\u00e3o lida com letras mai\u00fasculas e min\u00fasculas do mesmo jeito que as pessoas. Todas as letras mai\u00fasculas v\u00eam antes de todas as letras min\u00fasculas, portanto: Your word, Pineapple, comes before banana. Uma forma comum de lidar com este problema \u00e9 converter strings em um formato padr\u00e3o, como letras min\u00fasculas, antes de executar a compara\u00e7\u00e3o. Lembre-se disso caso tenha que se defender de um homem armado com um abacaxi.","title":"8.10 - Compara\u00e7\u00e3o de strings"},{"location":"08-strings/#811-depuracao","text":"Ao usar \u00edndices para atravessar os valores em uma sequ\u00eancia, \u00e9 complicado acertar o come\u00e7o e o fim da travessia. Aqui est\u00e1 uma fun\u00e7\u00e3o que supostamente compara duas palavras e retorna True se uma das palavras for o reverso da outra, mas cont\u00e9m dois erros: def is_reverse(word1, word2): if len(word1) != len(word2): return False i = 0 j = len(word2) while j > 0: if word1[i] != word2[j]: return False i = i+1 j = j-1 return True A primeira instru\u00e7\u00e3o if verifica se as palavras t\u00eam o mesmo comprimento. Se n\u00e3o for o caso, podemos retornar False imediatamente. Do contr\u00e1rio, para o resto da fun\u00e7\u00e3o, podemos supor que as palavras tenham o mesmo comprimento. Este \u00e9 um exemplo do modelo de guardi\u00e3o em \u201cVerifica\u00e7\u00e3o de tipos\u201d, na p\u00e1gina 101. i e j s\u00e3o \u00edndices: i atravessa word1 para a frente, enquanto j atravessa word2 para tr\u00e1s. Se encontrarmos duas letras que n\u00e3o combinam, podemos retornar False imediatamente. Se terminarmos o loop inteiro e todas as letras corresponderem, retornamos True. Se testarmos esta fun\u00e7\u00e3o com as palavras \u201cpots\u201d e \u201cstop\u201d, esperamos o valor de retorno True, mas recebemos um IndexError: >>> is_reverse('pots', 'stop') ... File \"reverse.py\", line 15, in is_reverse if word1[i] != word2[j]: IndexError: string index out of range Para depurar este tipo de erro, minha primeira a\u00e7\u00e3o \u00e9 exibir os valores dos \u00edndices imediatamente antes da linha onde o erro aparece. while j > 0: print(i, j) # exibir aqui if word1[i] != word2[j]: return False i = i+1 j = j-1 Agora quando executo o programa novamente, recebo mais informa\u00e7\u00e3o: >>> is_reverse('pots', 'stop') 0 4 ... IndexError: string index out of range Na primeira vez que o programa passar pelo loop, o valor de j \u00e9 4, que est\u00e1 fora do intervalo da string 'pots'. O \u00edndice do \u00faltimo caractere \u00e9 3, ent\u00e3o o valor inicial de j deve ser len(word2)-1. Se corrigir esse erro e executar o programa novamente, recebo: >>> is_reverse('pots', 'stop') 0 3 1 2 2 1 True Desta vez, recebemos a resposta certa, mas parece que o loop s\u00f3 foi executado tr\u00eas vezes, o que \u00e9 suspeito. Para ter uma ideia melhor do que est\u00e1 acontecendo, \u00e9 \u00fatil desenhar um diagrama de estado. Durante a primeira itera\u00e7\u00e3o, o frame de is_reverse \u00e9 mostrado na Figura 8.2. 8.2 \u2013 Diagrama de estado de is_reverse. Tomei a liberdade de arrumar as vari\u00e1veis no frame e acrescentei linhas pontilhadas para mostrar que os valores de i e j indicam caracteres em word1 e word2. Come\u00e7ando com este diagrama, execute o programa em papel, alterando os valores de i e j durante cada itera\u00e7\u00e3o. Encontre e corrija o segundo erro desta fun\u00e7\u00e3o.","title":"8.11 - Depura\u00e7\u00e3o"},{"location":"08-strings/#812-glossario","text":"objeto Algo a que uma vari\u00e1vel pode se referir. Por enquanto, voc\u00ea pode usar \u201cobjeto\u201d e \u201cvalor\u201d de forma intercambi\u00e1vel. sequ\u00eancia Uma cole\u00e7\u00e3o ordenada de valores onde cada valor \u00e9 identificado por um \u00edndice de n\u00famero inteiro. item Um dos valores em uma sequ\u00eancia. \u00edndice Um valor inteiro usado para selecionar um item em uma sequ\u00eancia, como um caractere em uma string. No Python, os \u00edndices come\u00e7am em 0. fatia Parte de uma string especificada por um intervalo de \u00edndices. string vazia Uma string sem caracteres e de comprimento 0, representada por duas aspas. imut\u00e1vel A propriedade de uma sequ\u00eancia cujos itens n\u00e3o podem ser alterados. atravessar Repetir os itens em uma sequ\u00eancia, executando uma opera\u00e7\u00e3o semelhante em cada um. busca Um modelo de travessia que \u00e9 interrompido quando encontra o que est\u00e1 procurando. contador Uma vari\u00e1vel usada para contar algo, normalmente inicializada com zero e ent\u00e3o incrementada. invoca\u00e7\u00e3o Uma instru\u00e7\u00e3o que chama um m\u00e9todo. argumento opcional Um argumento de fun\u00e7\u00e3o ou m\u00e9todo que n\u00e3o \u00e9 necess\u00e1rio.","title":"8.12 - Gloss\u00e1rio"},{"location":"08-strings/#813-exercicios","text":"","title":"8.13 - Exerc\u00edcios"},{"location":"08-strings/#exercicio-81","text":"Leia a documenta\u00e7\u00e3o dos m\u00e9todos de strings em http://docs.python.org/3/library/stdtypes.html#string-methods. Pode ser uma boa ideia experimentar alguns deles para entender como funcionam. strip e replace s\u00e3o especialmente \u00fateis. A documenta\u00e7\u00e3o usa uma sintaxe que pode ser confusa. Por exemplo, em find(sub[, start[, end]]) , os colchetes indicam argumentos opcionais. Ent\u00e3o sub \u00e9 exigido, mas start \u00e9 opcional, e se voc\u00ea incluir start , ent\u00e3o end \u00e9 opcional.","title":"Exerc\u00edcio 8.1"},{"location":"08-strings/#exercicio-82","text":"H\u00e1 um m\u00e9todo de string chamado count , que \u00e9 semelhante \u00e0 fun\u00e7\u00e3o em \u201cLoop e contagem\u201d, na p\u00e1gina 123. Leia a documenta\u00e7\u00e3o deste m\u00e9todo e escreva uma invoca\u00e7\u00e3o que conte o n\u00famero de letras 'a' em 'banana'.","title":"Exerc\u00edcio 8.2"},{"location":"08-strings/#exercicio-83","text":"Uma fatia de string pode receber um terceiro \u00edndice que especifique o \u201ctamanho do passo\u201d; isto \u00e9, o n\u00famero de espa\u00e7os entre caracteres sucessivos. Um tamanho de passo 2 significa tomar um caractere e outro n\u00e3o; 3 significa tomar um e dois n\u00e3o etc. >>> fruit = 'banana' >>> fruit[0:5:2] 'bnn' Um tamanho de passo -1 atravessa a palavra de tr\u00e1s para a frente, ent\u00e3o a fatia [::-1] gera uma string invertida. Use isso para escrever uma vers\u00e3o de uma linha de is_palindrome do Exerc\u00edcio 6.3.","title":"Exerc\u00edcio 8.3"},{"location":"08-strings/#exercicio-84","text":"As seguintes fun\u00e7\u00f5es pretendem verificar se uma string cont\u00e9m alguma letra min\u00fascula, mas algumas delas est\u00e3o erradas. Para cada fun\u00e7\u00e3o, descreva o que ela faz (assumindo que o par\u00e2metro seja uma string). def any_lowercase1(s): for c in s: if c.islower(): return True else: return False def any_lowercase2(s): for c in s: if 'c'.islower(): return 'True' else: return 'False' def any_lowercase3(s): for c in s: flag = c.islower() return flag def any_lowercase4(s): flag = False for c in s: flag = flag or c.islower() return flag def any_lowercase5(s): for c in s: if not c.islower(): return False return True","title":"Exerc\u00edcio 8.4"},{"location":"08-strings/#exercicio-85","text":"Uma cifra de C\u00e9sar \u00e9 uma forma fraca de criptografia que implica \u201crotacionar\u201d cada letra por um n\u00famero fixo de lugares. Rotacionar uma letra significa desloc\u00e1-lo pelo alfabeto, voltando ao in\u00edcio se for necess\u00e1rio, portanto \u2018A\u2019 rotacionado por 3 \u00e9 \u2018D\u2019 e \u2018Z\u2019 rotacionado por 1 \u00e9 \u2018A\u2019. Para rotacionar uma palavra, fa\u00e7a cada letra se mover pela mesma quantidade de posi\u00e7\u00f5es. Por exemplo, \u201ccheer\u201d rotacionado por 7 \u00e9 \u201cjolly\u201d e \u201cmelon\u201d rotacionado por -10 \u00e9 \u201ccubed\u201d. No filme 2001: Uma odisseia no espa\u00e7o, o computador da nave chama-se HAL, que \u00e9 IBM rotacionado por -1. Escreva uma fun\u00e7\u00e3o chamada rotate_word que receba uma string e um n\u00famero inteiro como par\u00e2metros, e retorne uma nova string que cont\u00e9m as letras da string original rotacionadas pelo n\u00famero dado. Voc\u00ea pode usar a fun\u00e7\u00e3o integrada ord, que converte um caractere em um c\u00f3digo num\u00e9rico e chr, que converte c\u00f3digos num\u00e9ricos em caracteres. As letras do alfabeto s\u00e3o codificadas em ordem alfab\u00e9tica, ent\u00e3o, por exemplo: >>> ord('c') - ord('a') 2 Porque 'c' \u00e9 a \u201csegunda\u201d letra do alfabeto. Mas tenha cuidado: os c\u00f3digos num\u00e9ricos de letras mai\u00fasculas s\u00e3o diferentes. Piadas potencialmente ofensivas na internet \u00e0s vezes s\u00e3o codificadas em ROT13, que \u00e9 uma cifra de C\u00e9sar com rota\u00e7\u00e3o 13. Se n\u00e3o se ofender facilmente, encontre e decifre algumas delas.","title":"Exerc\u00edcio 8.5"},{"location":"09-caso-palavras/","text":"Cap\u00edtulo 9: Estudo de caso: jogos de palavras Este cap\u00edtulo apresenta o segundo estudo de caso que envolve solucionar quebra-cabe\u00e7as usando palavras com certas propriedades. Por exemplo, encontraremos os pal\u00edndromos mais longos em ingl\u00eas e procuraremos palavras cujas letras apare\u00e7am em ordem alfab\u00e9tica. E apresentarei outro plano de desenvolvimento de programa: a redu\u00e7\u00e3o a um problema resolvido anteriormente. 9.1 - Leitura de listas de palavras Para os exerc\u00edcios deste cap\u00edtulo vamos usar uma lista de palavras em ingl\u00eas. H\u00e1 muitas listas de palavras dispon\u00edveis na internet, mas a mais conveniente ao nosso prop\u00f3sito \u00e9 uma das listas de palavras disponibilizadas em dom\u00ednio p\u00fablico por Grady Ward como parte do projeto lexical Moby (ver http://wikipedia.org/wiki/Moby_Project). \u00c9 uma lista de 113.809 palavras cruzadas oficiais; isto \u00e9, as palavras que se consideram v\u00e1lidas em quebra-cabe\u00e7as de palavras cruzadas e outros jogos de palavras. Na cole\u00e7\u00e3o Moby, o nome do arquivo \u00e9 113809of.fic; voc\u00ea pode baixar uma c\u00f3pia, com um nome mais simples como words.txt, de http://thinkpython2.com/code/words.txt. Este arquivo est\u00e1 em texto simples, ent\u00e3o voc\u00ea pode abri-lo com um editor de texto, mas tamb\u00e9m pode l\u00ea-lo no Python. A fun\u00e7\u00e3o integrada open recebe o nome do arquivo como um par\u00e2metro e retorna um objeto de arquivo que voc\u00ea pode usar para ler o arquivo. >>> fin = open('words.txt') fin \u00e9 um nome comum de objeto de arquivo usado para entrada de dados. O objeto de arquivo oferece v\u00e1rios m\u00e9todos de leitura, inclusive readline, que l\u00ea caracteres no arquivo at\u00e9 chegar a um comando de nova linha, devolvendo o resultado como uma string: >>> fin.readline() 'aa\\r\\n' A primeira palavra nesta lista espec\u00edfica \u00e9 \u201caa\u201d, uma esp\u00e9cie de lava. A sequ\u00eancia '\\r\\n' representa dois caracteres que representam espa\u00e7os em branco (whitespace), um retorno de carro e uma nova linha, que separa esta palavra da seguinte. O objeto de arquivo grava a posi\u00e7\u00e3o em que est\u00e1 no arquivo, ent\u00e3o se voc\u00ea chamar readline mais uma vez, receber\u00e1 a seguinte palavra: >>> fin.readline() 'aah\\r\\n' A palavra seguinte \u00e9 \u201caah\u201d, uma palavra perfeitamente leg\u00edtima, ent\u00e3o pare de olhar para mim desse jeito. Ou, se \u00e9 o whitespace que est\u00e1 incomodando voc\u00ea, podemos nos livrar dele com o m\u00e9todo de string strip : >>> line = fin.readline() >>> word = line.strip() >>> word 'aahed' Voc\u00ea tamb\u00e9m pode usar um objeto de arquivo como parte de um loop for . Este programa l\u00ea words.txt e imprime cada palavra, uma por linha: fin = open('words.txt') for line in fin: word = line.strip() print(word) 9.2 - Exerc\u00edcios H\u00e1 solu\u00e7\u00f5es para estes exerc\u00edcios na pr\u00f3xima se\u00e7\u00e3o. Mas \u00e9 bom voc\u00ea tentar fazer cada um antes de ver as solu\u00e7\u00f5es. Exerc\u00edcio 9.1 Escreva um programa que leia words.txt e imprima apenas as palavras com mais de 20 caracteres (sem contar whitespace). Exerc\u00edcio 9.2 Em 1939, Ernest Vincent Wright publicou uma novela de 50.000 palavras, chamada Gadsby, que n\u00e3o cont\u00e9m a letra \u201ce\u201d. Como o \u201ce\u201d \u00e9 a letra mais comum em ingl\u00eas, isso n\u00e3o \u00e9 algo f\u00e1cil de fazer. Na verdade, \u00e9 dif\u00edcil at\u00e9 construir um \u00fanico pensamento sem usar o s\u00edmbolo mais comum do idioma. No in\u00edcio \u00e9 lento, mas com prud\u00eancia e horas de treino, vai ficando cada vez mais f\u00e1cil. Muito bem, agora eu vou parar. Escreva uma fun\u00e7\u00e3o chamada has_no_e que retorne True se a palavra dada n\u00e3o tiver a letra \u201ce\u201d nela. Altere seu programa na se\u00e7\u00e3o anterior para imprimir apenas as palavras que n\u00e3o t\u00eam \u201ce\u201d e calcule a porcentagem de palavras na lista que n\u00e3o t\u00eam \u201ce\u201d. Exerc\u00edcio 9.3 Escreva uma fun\u00e7\u00e3o chamada avoids que receba uma palavra e uma s\u00e9rie de letras proibidas, e retorne True se a palavra n\u00e3o usar nenhuma das letras proibidas. Altere o c\u00f3digo para que o usu\u00e1rio digite uma s\u00e9rie de letras proibidas e o programa imprima o n\u00famero de palavras que n\u00e3o cont\u00eam nenhuma delas. Voc\u00ea pode encontrar uma combina\u00e7\u00e3o de cinco letras proibidas que exclua o menor n\u00famero poss\u00edvel de palavras? Exerc\u00edcio 9.4 Escreva uma fun\u00e7\u00e3o chamada uses_only que receba uma palavra e uma s\u00e9rie de letras e retorne True , se a palavra s\u00f3 contiver letras da lista. Voc\u00ea pode fazer uma frase usando s\u00f3 as letras acefhlo? Que n\u00e3o seja \u201cHoe alfalfa?\u201d Exerc\u00edcio 9.5 Escreva uma fun\u00e7\u00e3o chamada uses_all que receba uma palavra e uma s\u00e9rie de letras obrigat\u00f3rias e retorne True se a palavra usar todas as letras obrigat\u00f3rias pelo menos uma vez. Quantas palavras usam todas as vogais (aeiou)? E que tal aeiouy? Exerc\u00edcio 9.6 Escreva uma fun\u00e7\u00e3o chamada is_abecedarian que retorne True se as letras numa palavra aparecerem em ordem alfab\u00e9tica (tudo bem se houver letras duplas). Quantas palavras em ordem alfab\u00e9tica existem? 9.3 - Busca Todos os exerc\u00edcios na se\u00e7\u00e3o anterior t\u00eam algo em comum; eles podem ser resolvidos com o modelo de busca que vimos em Buscando . O exemplo mais simples \u00e9: def has_no_e(word): for letter in word: if letter == 'e': return False return True O loop for atravessa os caracteres em word. Se encontrarmos a letra \u201ce\u201d, podemos retornar False imediatamente; se n\u00e3o for o caso, temos que ir \u00e0 letra seguinte. Se sairmos do loop normalmente, isso quer dizer que n\u00e3o encontramos um \u201ce\u201d, ent\u00e3o retornamos True. Voc\u00ea pode escrever esta fun\u00e7\u00e3o de forma mais concisa usando o operador in, mas comecei com esta vers\u00e3o porque ela demonstra a l\u00f3gica do modelo de busca. avoids \u00e9 uma vers\u00e3o mais geral de has_no_e , mas tem a mesma estrutura: def avoids(word, forbidden): for letter in word: if letter in forbidden: return False return True Podemos retornar False logo que encontrarmos uma letra proibida; se chegarmos ao fim do loop, retornamos True . uses_only \u00e9 semelhante, exceto pelo sentido da condi\u00e7\u00e3o, que se inverte: def uses_only(word, available): for letter in word: if letter not in available: return False return True Em vez de uma lista de letras proibidas, temos uma lista de letras dispon\u00edveis. Se encontrarmos uma letra em word que n\u00e3o est\u00e1 em available , podemos retornar False . uses_all \u00e9 semelhante, mas invertemos a fun\u00e7\u00e3o da palavra e a string de letras: def uses_all(word, required): for letter in required: if letter not in word: return False return True Em vez de atravessar as letras em word , o loop atravessa as letras obrigat\u00f3rias. Se alguma das letras obrigat\u00f3rias n\u00e3o aparecer na palavra, podemos retornar False . Se voc\u00ea realmente estivesse pensando como um cientista da computa\u00e7\u00e3o, teria reconhecido que uses_all foi um exemplo de um problema resolvido anteriormente e escreveria: def uses_all(word, required): return uses_only(required, word) Esse \u00e9 um exemplo de um plano de desenvolvimento de programa chamado redu\u00e7\u00e3o a um problema resolvido anteriormente , ou seja, voc\u00ea reconhece o problema no qual est\u00e1 trabalhando como um exemplo de um problema j\u00e1 resolvido e aplica uma solu\u00e7\u00e3o existente. 9.4 - Loop com \u00edndices Escrevi as fun\u00e7\u00f5es na se\u00e7\u00e3o anterior com loops for porque eu s\u00f3 precisava dos caracteres nas strings; n\u00e3o precisava fazer nada com os \u00edndices. Para is_abecedarian temos que comparar letras adjacentes, o que \u00e9 um pouco complicado para o loop for: def is_abecedarian(word): previous = word[0] for c in word: if c < previous: return False previous = c return True Uma alternativa \u00e9 usar a recursividade: def is_abecedarian(word): if len(word) <= 1: return True if word[0] > word[1]: return False return is_abecedarian(word[1:]) Outra op\u00e7\u00e3o \u00e9 usar um loop while : def is_abecedarian(word): i = 0 while i < len(word)-1: if word[i+1] < word[i]: return False i = i+1 return True O loop come\u00e7a com i == 0 e termina quando i == len(word)-1 . Cada vez que passa pelo loop, o programa compara o \u201ci-\u00e9simo\u201d caractere (que voc\u00ea pode considerar o caractere atual) com o caractere de posi\u00e7\u00e3o i+1 (que pode ser considerado o caractere seguinte). Se o pr\u00f3ximo caractere for de uma posi\u00e7\u00e3o anterior (alfabeticamente anterior) \u00e0 atual, ent\u00e3o descobrimos uma quebra na tend\u00eancia alfab\u00e9tica, e retornamos False . Se chegarmos ao fim do loop sem encontrar uma quebra, ent\u00e3o a palavra passa no teste. Para convencer-se de que o loop termina corretamente, considere um exemplo como 'flossy' . O comprimento da palavra \u00e9 6, ent\u00e3o o loop \u00e9 executado pela \u00faltima vez quando i for igual a 4, que \u00e9 o \u00edndice do segundo caractere de tr\u00e1s para frente. Na \u00faltima itera\u00e7\u00e3o, o programa compara o pen\u00faltimo caractere com o \u00faltimo, que \u00e9 o que queremos. Aqui est\u00e1 uma vers\u00e3o de is_palindrome (veja o Exerc\u00edcio 6.3) que usa dois \u00edndices: um come\u00e7a no in\u00edcio e aumenta; o outro come\u00e7a no final e diminui. def is_palindrome(word): i = 0 j = len(word)-1 while i<j: if word[i] != word[j]: return False i = i+1 j = j-1 return True Ou podemos reduzir a um problema resolvido anteriormente e escrever: def is_palindrome(word): return is_reverse(word, word) Usando is_reverse da se\u00e7\u00e3o 8.11. 9.5 - Depura\u00e7\u00e3o Testar programas \u00e9 dif\u00edcil. As fun\u00e7\u00f5es neste cap\u00edtulo s\u00e3o relativamente f\u00e1ceis para testar porque \u00e9 poss\u00edvel verificar os resultados \u00e0 m\u00e3o. Ainda assim, pode ser dif\u00edcil ou at\u00e9 imposs\u00edvel escolher um grupo de palavras que teste todos os erros poss\u00edveis. Tomando has_no_e como exemplo, h\u00e1 dois casos \u00f3bvios para verificar: as palavras que t\u00eam um \u2018e\u2019 devem retornar False, e as palavras que n\u00e3o t\u00eam devem retornar True. N\u00e3o dever\u00e1 ser um problema pensar em um exemplo de cada uma. Dentro de cada caso, h\u00e1 alguns subcasos menos \u00f3bvios. Entre as palavras que t\u00eam um \u201ce\u201d, voc\u00ea deve testar palavras com um \u201ce\u201d no come\u00e7o, no fim e em algum lugar no meio. Voc\u00ea deve testar palavras longas, palavras curtas e palavras muito curtas, como a string vazia. A string vazia \u00e9 um exemplo de um caso especial, n\u00e3o \u00f3bvio, onde erros muitas vezes espreitam. Al\u00e9m dos casos de teste que voc\u00ea gerar, tamb\u00e9m pode ser uma boa ideia testar seu programa com uma lista de palavras como words.txt. Ao analisar a sa\u00edda, pode ser que os erros apare\u00e7am, mas tenha cuidado: voc\u00ea pode pegar um tipo de erro (palavras que n\u00e3o deveriam ser inclu\u00eddas, mas foram) e n\u00e3o outro (palavras que deveriam ser inclu\u00eddas, mas n\u00e3o foram). Em geral, o teste pode ajudar a encontrar bugs, mas n\u00e3o \u00e9 f\u00e1cil gerar um bom conjunto de casos de teste, e, mesmo se conseguir, n\u00e3o h\u00e1 como ter certeza de que o programa est\u00e1 correto. Segundo um lend\u00e1rio cientista da computa\u00e7\u00e3o: Testar programas pode ser usado para mostrar a presen\u00e7a de bugs, mas nunca para mostrar a aus\u00eancia deles! \u2013 Edsger W. Dijkstra 9.6 - Gloss\u00e1rio objeto de arquivo Um valor que representa um arquivo aberto. redu\u00e7\u00e3o a um problema resolvido anteriormente Um modo de resolver um problema expressando-o como uma inst\u00e2ncia de um problema resolvido anteriormente. caso especial Um caso de teste que \u00e9 at\u00edpico ou n\u00e3o \u00e9 \u00f3bvio (e com probabilidade menor de ser tratado corretamente). 9.7 - Exerc\u00edcios Exerc\u00edcio 9.7 Esta pergunta \u00e9 baseada em um quebra-cabe\u00e7a veiculado em um programa de r\u00e1dio chamado Car Talk (http://www.cartalk.com/content/puzzlers): D\u00ea uma palavra com tr\u00eas letras duplas consecutivas. Vou dar exemplos de palavras que quase cumprem a condi\u00e7\u00e3o, mas n\u00e3o chegam l\u00e1. Por exemplo, a palavra committee, c-o-m-m-i-t-t-e-e. Seria perfeita se n\u00e3o fosse aquele \u2018i\u2019 que se meteu ali no meio. Ou Mississippi: M-i-s-s-i-s-s-i-p-p-i. Se pudesse tirar aqueles \u2018is\u2019, daria certo. Mas h\u00e1 uma palavra que tem tr\u00eas pares consecutivos de letras e, que eu saiba, pode ser a \u00fanica palavra que existe. \u00c9 claro que provavelmente haja mais umas 500, mas s\u00f3 consigo pensar nessa. Qual \u00e9 a palavra? Escreva um programa que a encontre. Solu\u00e7\u00e3o: http://thinkpython2.com/code/cartalk1.py. Exerc\u00edcio 9.8 Aqui est\u00e1 outro quebra-cabe\u00e7a do programa Car Talk (http://www.cartalk.com/content/puzzlers): \u201cEstava dirigindo outro dia e percebi algo no hod\u00f4metro que chamou a minha aten\u00e7\u00e3o. Como a maior parte dos hod\u00f4metros, ele mostra seis d\u00edgitos, apenas em milhas inteiras. Por exemplo, se o meu carro tivesse 300.000 milhas, eu veria 3-0-0-0-0-0. \u201cAgora, o que vi naquele dia foi muito interessante. Notei que os \u00faltimos 4 d\u00edgitos eram um pal\u00edndromo; isto \u00e9, podiam ser lidos da mesma forma no sentido correto e no sentido inverso. Por exemplo, 5-4-4-5 \u00e9 um pal\u00edndromo, ent\u00e3o no meu hod\u00f4metro poderia ser 3-1-5-4-4-5. \u201cUma milha depois, os \u00faltimos 5 n\u00fameros formaram um pal\u00edndromo. Por exemplo, poderia ser 3-6-5-4-5-6. Uma milha depois disso, os 4 n\u00fameros do meio, dentro dos 6, formavam um pal\u00edndromo. E adivinhe s\u00f3? Um milha depois, todos os 6 formavam um pal\u00edndromo! \u201cA pergunta \u00e9: o que estava no hod\u00f4metro quando olhei primeiro?\u201d Escreva um programa Python que teste todos os n\u00fameros de seis d\u00edgitos e imprima qualquer n\u00famero que satisfa\u00e7a essas condi\u00e7\u00f5es. Solu\u00e7\u00e3o: http://thinkpython2.com/code/cartalk2.py. Exerc\u00edcio 9.9 Aqui est\u00e1 outro problema do Car Talk que voc\u00ea pode resolver com uma busca (http://www.cartalk.com/content/puzzlers): \u201cH\u00e1 pouco tempo recebi uma visita da minha m\u00e3e e percebemos que os dois d\u00edgitos que comp\u00f5em a minha idade, quando invertidos, representavam a idade dela. Por exemplo, se ela tem 73 anos, eu tenho 37 anos. Ficamos imaginando com que frequ\u00eancia isto aconteceu nos anos anteriores, mas acabamos mudando de assunto e n\u00e3o chegamos a uma resposta. \u201cQuando cheguei em casa, cheguei \u00e0 conclus\u00e3o de que os d\u00edgitos das nossas idades tinham sido revers\u00edveis seis vezes at\u00e9 ent\u00e3o. Tamb\u00e9m percebi que, se tiv\u00e9ssemos sorte, isso aconteceria novamente dali a alguns anos, e se f\u00f4ssemos muito sortudos, aconteceria mais uma vez depois disso. Em outras palavras, aconteceria 8 vezes no total. Ent\u00e3o a pergunta \u00e9: quantos anos tenho agora?\u201d Escreva um programa em Python que busque solu\u00e7\u00f5es para esse problema. Dica: pode ser uma boa ideia usar o m\u00e9todo de string zfill.","title":"Cap\u00edtulo 9: Estudo de caso: jogos de palavras"},{"location":"09-caso-palavras/#capitulo-9-estudo-de-caso-jogos-de-palavras","text":"Este cap\u00edtulo apresenta o segundo estudo de caso que envolve solucionar quebra-cabe\u00e7as usando palavras com certas propriedades. Por exemplo, encontraremos os pal\u00edndromos mais longos em ingl\u00eas e procuraremos palavras cujas letras apare\u00e7am em ordem alfab\u00e9tica. E apresentarei outro plano de desenvolvimento de programa: a redu\u00e7\u00e3o a um problema resolvido anteriormente.","title":"Cap\u00edtulo 9: Estudo de caso: jogos de palavras"},{"location":"09-caso-palavras/#91-leitura-de-listas-de-palavras","text":"Para os exerc\u00edcios deste cap\u00edtulo vamos usar uma lista de palavras em ingl\u00eas. H\u00e1 muitas listas de palavras dispon\u00edveis na internet, mas a mais conveniente ao nosso prop\u00f3sito \u00e9 uma das listas de palavras disponibilizadas em dom\u00ednio p\u00fablico por Grady Ward como parte do projeto lexical Moby (ver http://wikipedia.org/wiki/Moby_Project). \u00c9 uma lista de 113.809 palavras cruzadas oficiais; isto \u00e9, as palavras que se consideram v\u00e1lidas em quebra-cabe\u00e7as de palavras cruzadas e outros jogos de palavras. Na cole\u00e7\u00e3o Moby, o nome do arquivo \u00e9 113809of.fic; voc\u00ea pode baixar uma c\u00f3pia, com um nome mais simples como words.txt, de http://thinkpython2.com/code/words.txt. Este arquivo est\u00e1 em texto simples, ent\u00e3o voc\u00ea pode abri-lo com um editor de texto, mas tamb\u00e9m pode l\u00ea-lo no Python. A fun\u00e7\u00e3o integrada open recebe o nome do arquivo como um par\u00e2metro e retorna um objeto de arquivo que voc\u00ea pode usar para ler o arquivo. >>> fin = open('words.txt') fin \u00e9 um nome comum de objeto de arquivo usado para entrada de dados. O objeto de arquivo oferece v\u00e1rios m\u00e9todos de leitura, inclusive readline, que l\u00ea caracteres no arquivo at\u00e9 chegar a um comando de nova linha, devolvendo o resultado como uma string: >>> fin.readline() 'aa\\r\\n' A primeira palavra nesta lista espec\u00edfica \u00e9 \u201caa\u201d, uma esp\u00e9cie de lava. A sequ\u00eancia '\\r\\n' representa dois caracteres que representam espa\u00e7os em branco (whitespace), um retorno de carro e uma nova linha, que separa esta palavra da seguinte. O objeto de arquivo grava a posi\u00e7\u00e3o em que est\u00e1 no arquivo, ent\u00e3o se voc\u00ea chamar readline mais uma vez, receber\u00e1 a seguinte palavra: >>> fin.readline() 'aah\\r\\n' A palavra seguinte \u00e9 \u201caah\u201d, uma palavra perfeitamente leg\u00edtima, ent\u00e3o pare de olhar para mim desse jeito. Ou, se \u00e9 o whitespace que est\u00e1 incomodando voc\u00ea, podemos nos livrar dele com o m\u00e9todo de string strip : >>> line = fin.readline() >>> word = line.strip() >>> word 'aahed' Voc\u00ea tamb\u00e9m pode usar um objeto de arquivo como parte de um loop for . Este programa l\u00ea words.txt e imprime cada palavra, uma por linha: fin = open('words.txt') for line in fin: word = line.strip() print(word)","title":"9.1 - Leitura de listas de palavras"},{"location":"09-caso-palavras/#92-exercicios","text":"H\u00e1 solu\u00e7\u00f5es para estes exerc\u00edcios na pr\u00f3xima se\u00e7\u00e3o. Mas \u00e9 bom voc\u00ea tentar fazer cada um antes de ver as solu\u00e7\u00f5es.","title":"9.2 - Exerc\u00edcios"},{"location":"09-caso-palavras/#exercicio-91","text":"Escreva um programa que leia words.txt e imprima apenas as palavras com mais de 20 caracteres (sem contar whitespace).","title":"Exerc\u00edcio 9.1"},{"location":"09-caso-palavras/#exercicio-92","text":"Em 1939, Ernest Vincent Wright publicou uma novela de 50.000 palavras, chamada Gadsby, que n\u00e3o cont\u00e9m a letra \u201ce\u201d. Como o \u201ce\u201d \u00e9 a letra mais comum em ingl\u00eas, isso n\u00e3o \u00e9 algo f\u00e1cil de fazer. Na verdade, \u00e9 dif\u00edcil at\u00e9 construir um \u00fanico pensamento sem usar o s\u00edmbolo mais comum do idioma. No in\u00edcio \u00e9 lento, mas com prud\u00eancia e horas de treino, vai ficando cada vez mais f\u00e1cil. Muito bem, agora eu vou parar. Escreva uma fun\u00e7\u00e3o chamada has_no_e que retorne True se a palavra dada n\u00e3o tiver a letra \u201ce\u201d nela. Altere seu programa na se\u00e7\u00e3o anterior para imprimir apenas as palavras que n\u00e3o t\u00eam \u201ce\u201d e calcule a porcentagem de palavras na lista que n\u00e3o t\u00eam \u201ce\u201d.","title":"Exerc\u00edcio 9.2"},{"location":"09-caso-palavras/#exercicio-93","text":"Escreva uma fun\u00e7\u00e3o chamada avoids que receba uma palavra e uma s\u00e9rie de letras proibidas, e retorne True se a palavra n\u00e3o usar nenhuma das letras proibidas. Altere o c\u00f3digo para que o usu\u00e1rio digite uma s\u00e9rie de letras proibidas e o programa imprima o n\u00famero de palavras que n\u00e3o cont\u00eam nenhuma delas. Voc\u00ea pode encontrar uma combina\u00e7\u00e3o de cinco letras proibidas que exclua o menor n\u00famero poss\u00edvel de palavras?","title":"Exerc\u00edcio 9.3"},{"location":"09-caso-palavras/#exercicio-94","text":"Escreva uma fun\u00e7\u00e3o chamada uses_only que receba uma palavra e uma s\u00e9rie de letras e retorne True , se a palavra s\u00f3 contiver letras da lista. Voc\u00ea pode fazer uma frase usando s\u00f3 as letras acefhlo? Que n\u00e3o seja \u201cHoe alfalfa?\u201d","title":"Exerc\u00edcio 9.4"},{"location":"09-caso-palavras/#exercicio-95","text":"Escreva uma fun\u00e7\u00e3o chamada uses_all que receba uma palavra e uma s\u00e9rie de letras obrigat\u00f3rias e retorne True se a palavra usar todas as letras obrigat\u00f3rias pelo menos uma vez. Quantas palavras usam todas as vogais (aeiou)? E que tal aeiouy?","title":"Exerc\u00edcio 9.5"},{"location":"09-caso-palavras/#exercicio-96","text":"Escreva uma fun\u00e7\u00e3o chamada is_abecedarian que retorne True se as letras numa palavra aparecerem em ordem alfab\u00e9tica (tudo bem se houver letras duplas). Quantas palavras em ordem alfab\u00e9tica existem?","title":"Exerc\u00edcio 9.6"},{"location":"09-caso-palavras/#93-busca","text":"Todos os exerc\u00edcios na se\u00e7\u00e3o anterior t\u00eam algo em comum; eles podem ser resolvidos com o modelo de busca que vimos em Buscando . O exemplo mais simples \u00e9: def has_no_e(word): for letter in word: if letter == 'e': return False return True O loop for atravessa os caracteres em word. Se encontrarmos a letra \u201ce\u201d, podemos retornar False imediatamente; se n\u00e3o for o caso, temos que ir \u00e0 letra seguinte. Se sairmos do loop normalmente, isso quer dizer que n\u00e3o encontramos um \u201ce\u201d, ent\u00e3o retornamos True. Voc\u00ea pode escrever esta fun\u00e7\u00e3o de forma mais concisa usando o operador in, mas comecei com esta vers\u00e3o porque ela demonstra a l\u00f3gica do modelo de busca. avoids \u00e9 uma vers\u00e3o mais geral de has_no_e , mas tem a mesma estrutura: def avoids(word, forbidden): for letter in word: if letter in forbidden: return False return True Podemos retornar False logo que encontrarmos uma letra proibida; se chegarmos ao fim do loop, retornamos True . uses_only \u00e9 semelhante, exceto pelo sentido da condi\u00e7\u00e3o, que se inverte: def uses_only(word, available): for letter in word: if letter not in available: return False return True Em vez de uma lista de letras proibidas, temos uma lista de letras dispon\u00edveis. Se encontrarmos uma letra em word que n\u00e3o est\u00e1 em available , podemos retornar False . uses_all \u00e9 semelhante, mas invertemos a fun\u00e7\u00e3o da palavra e a string de letras: def uses_all(word, required): for letter in required: if letter not in word: return False return True Em vez de atravessar as letras em word , o loop atravessa as letras obrigat\u00f3rias. Se alguma das letras obrigat\u00f3rias n\u00e3o aparecer na palavra, podemos retornar False . Se voc\u00ea realmente estivesse pensando como um cientista da computa\u00e7\u00e3o, teria reconhecido que uses_all foi um exemplo de um problema resolvido anteriormente e escreveria: def uses_all(word, required): return uses_only(required, word) Esse \u00e9 um exemplo de um plano de desenvolvimento de programa chamado redu\u00e7\u00e3o a um problema resolvido anteriormente , ou seja, voc\u00ea reconhece o problema no qual est\u00e1 trabalhando como um exemplo de um problema j\u00e1 resolvido e aplica uma solu\u00e7\u00e3o existente.","title":"9.3 - Busca"},{"location":"09-caso-palavras/#94-loop-com-indices","text":"Escrevi as fun\u00e7\u00f5es na se\u00e7\u00e3o anterior com loops for porque eu s\u00f3 precisava dos caracteres nas strings; n\u00e3o precisava fazer nada com os \u00edndices. Para is_abecedarian temos que comparar letras adjacentes, o que \u00e9 um pouco complicado para o loop for: def is_abecedarian(word): previous = word[0] for c in word: if c < previous: return False previous = c return True Uma alternativa \u00e9 usar a recursividade: def is_abecedarian(word): if len(word) <= 1: return True if word[0] > word[1]: return False return is_abecedarian(word[1:]) Outra op\u00e7\u00e3o \u00e9 usar um loop while : def is_abecedarian(word): i = 0 while i < len(word)-1: if word[i+1] < word[i]: return False i = i+1 return True O loop come\u00e7a com i == 0 e termina quando i == len(word)-1 . Cada vez que passa pelo loop, o programa compara o \u201ci-\u00e9simo\u201d caractere (que voc\u00ea pode considerar o caractere atual) com o caractere de posi\u00e7\u00e3o i+1 (que pode ser considerado o caractere seguinte). Se o pr\u00f3ximo caractere for de uma posi\u00e7\u00e3o anterior (alfabeticamente anterior) \u00e0 atual, ent\u00e3o descobrimos uma quebra na tend\u00eancia alfab\u00e9tica, e retornamos False . Se chegarmos ao fim do loop sem encontrar uma quebra, ent\u00e3o a palavra passa no teste. Para convencer-se de que o loop termina corretamente, considere um exemplo como 'flossy' . O comprimento da palavra \u00e9 6, ent\u00e3o o loop \u00e9 executado pela \u00faltima vez quando i for igual a 4, que \u00e9 o \u00edndice do segundo caractere de tr\u00e1s para frente. Na \u00faltima itera\u00e7\u00e3o, o programa compara o pen\u00faltimo caractere com o \u00faltimo, que \u00e9 o que queremos. Aqui est\u00e1 uma vers\u00e3o de is_palindrome (veja o Exerc\u00edcio 6.3) que usa dois \u00edndices: um come\u00e7a no in\u00edcio e aumenta; o outro come\u00e7a no final e diminui. def is_palindrome(word): i = 0 j = len(word)-1 while i<j: if word[i] != word[j]: return False i = i+1 j = j-1 return True Ou podemos reduzir a um problema resolvido anteriormente e escrever: def is_palindrome(word): return is_reverse(word, word) Usando is_reverse da se\u00e7\u00e3o 8.11.","title":"9.4 - Loop com \u00edndices"},{"location":"09-caso-palavras/#95-depuracao","text":"Testar programas \u00e9 dif\u00edcil. As fun\u00e7\u00f5es neste cap\u00edtulo s\u00e3o relativamente f\u00e1ceis para testar porque \u00e9 poss\u00edvel verificar os resultados \u00e0 m\u00e3o. Ainda assim, pode ser dif\u00edcil ou at\u00e9 imposs\u00edvel escolher um grupo de palavras que teste todos os erros poss\u00edveis. Tomando has_no_e como exemplo, h\u00e1 dois casos \u00f3bvios para verificar: as palavras que t\u00eam um \u2018e\u2019 devem retornar False, e as palavras que n\u00e3o t\u00eam devem retornar True. N\u00e3o dever\u00e1 ser um problema pensar em um exemplo de cada uma. Dentro de cada caso, h\u00e1 alguns subcasos menos \u00f3bvios. Entre as palavras que t\u00eam um \u201ce\u201d, voc\u00ea deve testar palavras com um \u201ce\u201d no come\u00e7o, no fim e em algum lugar no meio. Voc\u00ea deve testar palavras longas, palavras curtas e palavras muito curtas, como a string vazia. A string vazia \u00e9 um exemplo de um caso especial, n\u00e3o \u00f3bvio, onde erros muitas vezes espreitam. Al\u00e9m dos casos de teste que voc\u00ea gerar, tamb\u00e9m pode ser uma boa ideia testar seu programa com uma lista de palavras como words.txt. Ao analisar a sa\u00edda, pode ser que os erros apare\u00e7am, mas tenha cuidado: voc\u00ea pode pegar um tipo de erro (palavras que n\u00e3o deveriam ser inclu\u00eddas, mas foram) e n\u00e3o outro (palavras que deveriam ser inclu\u00eddas, mas n\u00e3o foram). Em geral, o teste pode ajudar a encontrar bugs, mas n\u00e3o \u00e9 f\u00e1cil gerar um bom conjunto de casos de teste, e, mesmo se conseguir, n\u00e3o h\u00e1 como ter certeza de que o programa est\u00e1 correto. Segundo um lend\u00e1rio cientista da computa\u00e7\u00e3o: Testar programas pode ser usado para mostrar a presen\u00e7a de bugs, mas nunca para mostrar a aus\u00eancia deles! \u2013 Edsger W. Dijkstra","title":"9.5 - Depura\u00e7\u00e3o"},{"location":"09-caso-palavras/#96-glossario","text":"objeto de arquivo Um valor que representa um arquivo aberto. redu\u00e7\u00e3o a um problema resolvido anteriormente Um modo de resolver um problema expressando-o como uma inst\u00e2ncia de um problema resolvido anteriormente. caso especial Um caso de teste que \u00e9 at\u00edpico ou n\u00e3o \u00e9 \u00f3bvio (e com probabilidade menor de ser tratado corretamente).","title":"9.6 - Gloss\u00e1rio"},{"location":"09-caso-palavras/#97-exercicios","text":"","title":"9.7 - Exerc\u00edcios"},{"location":"09-caso-palavras/#exercicio-97","text":"Esta pergunta \u00e9 baseada em um quebra-cabe\u00e7a veiculado em um programa de r\u00e1dio chamado Car Talk (http://www.cartalk.com/content/puzzlers): D\u00ea uma palavra com tr\u00eas letras duplas consecutivas. Vou dar exemplos de palavras que quase cumprem a condi\u00e7\u00e3o, mas n\u00e3o chegam l\u00e1. Por exemplo, a palavra committee, c-o-m-m-i-t-t-e-e. Seria perfeita se n\u00e3o fosse aquele \u2018i\u2019 que se meteu ali no meio. Ou Mississippi: M-i-s-s-i-s-s-i-p-p-i. Se pudesse tirar aqueles \u2018is\u2019, daria certo. Mas h\u00e1 uma palavra que tem tr\u00eas pares consecutivos de letras e, que eu saiba, pode ser a \u00fanica palavra que existe. \u00c9 claro que provavelmente haja mais umas 500, mas s\u00f3 consigo pensar nessa. Qual \u00e9 a palavra? Escreva um programa que a encontre. Solu\u00e7\u00e3o: http://thinkpython2.com/code/cartalk1.py.","title":"Exerc\u00edcio 9.7"},{"location":"09-caso-palavras/#exercicio-98","text":"Aqui est\u00e1 outro quebra-cabe\u00e7a do programa Car Talk (http://www.cartalk.com/content/puzzlers): \u201cEstava dirigindo outro dia e percebi algo no hod\u00f4metro que chamou a minha aten\u00e7\u00e3o. Como a maior parte dos hod\u00f4metros, ele mostra seis d\u00edgitos, apenas em milhas inteiras. Por exemplo, se o meu carro tivesse 300.000 milhas, eu veria 3-0-0-0-0-0. \u201cAgora, o que vi naquele dia foi muito interessante. Notei que os \u00faltimos 4 d\u00edgitos eram um pal\u00edndromo; isto \u00e9, podiam ser lidos da mesma forma no sentido correto e no sentido inverso. Por exemplo, 5-4-4-5 \u00e9 um pal\u00edndromo, ent\u00e3o no meu hod\u00f4metro poderia ser 3-1-5-4-4-5. \u201cUma milha depois, os \u00faltimos 5 n\u00fameros formaram um pal\u00edndromo. Por exemplo, poderia ser 3-6-5-4-5-6. Uma milha depois disso, os 4 n\u00fameros do meio, dentro dos 6, formavam um pal\u00edndromo. E adivinhe s\u00f3? Um milha depois, todos os 6 formavam um pal\u00edndromo! \u201cA pergunta \u00e9: o que estava no hod\u00f4metro quando olhei primeiro?\u201d Escreva um programa Python que teste todos os n\u00fameros de seis d\u00edgitos e imprima qualquer n\u00famero que satisfa\u00e7a essas condi\u00e7\u00f5es. Solu\u00e7\u00e3o: http://thinkpython2.com/code/cartalk2.py.","title":"Exerc\u00edcio 9.8"},{"location":"09-caso-palavras/#exercicio-99","text":"Aqui est\u00e1 outro problema do Car Talk que voc\u00ea pode resolver com uma busca (http://www.cartalk.com/content/puzzlers): \u201cH\u00e1 pouco tempo recebi uma visita da minha m\u00e3e e percebemos que os dois d\u00edgitos que comp\u00f5em a minha idade, quando invertidos, representavam a idade dela. Por exemplo, se ela tem 73 anos, eu tenho 37 anos. Ficamos imaginando com que frequ\u00eancia isto aconteceu nos anos anteriores, mas acabamos mudando de assunto e n\u00e3o chegamos a uma resposta. \u201cQuando cheguei em casa, cheguei \u00e0 conclus\u00e3o de que os d\u00edgitos das nossas idades tinham sido revers\u00edveis seis vezes at\u00e9 ent\u00e3o. Tamb\u00e9m percebi que, se tiv\u00e9ssemos sorte, isso aconteceria novamente dali a alguns anos, e se f\u00f4ssemos muito sortudos, aconteceria mais uma vez depois disso. Em outras palavras, aconteceria 8 vezes no total. Ent\u00e3o a pergunta \u00e9: quantos anos tenho agora?\u201d Escreva um programa em Python que busque solu\u00e7\u00f5es para esse problema. Dica: pode ser uma boa ideia usar o m\u00e9todo de string zfill.","title":"Exerc\u00edcio 9.9"},{"location":"10-listas/","text":"Cap\u00edtulo 10: Listas Este cap\u00edtulo apresenta um dos tipos integrados mais \u00fateis do Python: listas. Voc\u00ea tamb\u00e9m aprender\u00e1 mais sobre objetos e o que pode acontecer quando o mesmo objeto tem mais de um nome. 10.1 - Uma lista \u00e9 uma sequ\u00eancia Como uma string, uma lista \u00e9 uma sequ\u00eancia de valores. Em uma string, os valores s\u00e3o caracteres; em uma lista, eles podem ser de qualquer tipo. Os valores em uma lista s\u00e3o chamados de elementos, ou, algumas vezes, de itens. H\u00e1 v\u00e1rias formas para criar uma lista; a mais simples \u00e9 colocar os elementos entre colchetes ( [ e ] ): [10, 20, 30, 40] ['crunchy frog', 'ram bladder', 'lark vomit'] O primeiro exemplo \u00e9 uma lista de quatro n\u00fameros inteiros. O segundo \u00e9 uma lista de tr\u00eas strings. Os elementos de uma lista n\u00e3o precisam ser do mesmo tipo. A lista seguinte cont\u00e9m uma string, um n\u00famero de ponto flutuante, um n\u00famero inteiro e (olhe s\u00f3!) outra lista: ['spam', 2.0, 5, [10, 20]] Uma lista dentro de outra lista \u00e9 uma lista aninhada. Uma lista que n\u00e3o cont\u00e9m elementos \u00e9 chamada de lista vazia; voc\u00ea pode criar uma com colchetes vazios []. Como j\u00e1 se poderia esperar, podemos atribuir uma lista de valores a vari\u00e1veis: >>> cheeses = ['Cheddar', 'Edam', 'Gouda'] >>> numbers = [42, 123] >>> empty = [] >>> print(cheeses, numbers, empty) ['Cheddar', 'Edam', 'Gouda'] [42, 123] [] 10.2 - Listas s\u00e3o mut\u00e1veis A sintaxe para acessar os elementos de uma lista \u00e9 a mesma que para acessar os caracteres de uma string: o operador de colchete. A express\u00e3o dentro dos colchetes especifica o \u00edndice. Lembre-se de que os \u00edndices come\u00e7am em 0: >>> cheeses[0] 'Cheddar' Diferente das strings, listas s\u00e3o mut\u00e1veis. Quando o operador de colchete aparece do lado esquerdo de uma atribui\u00e7\u00e3o, ele identifica o elemento da lista que ser\u00e1 atribu\u00eddo: >>> numbers = [42, 123] >>> numbers[1] = 5 >>> numbers [42, 5] O primeiro elemento de numbers, que costumava ser 123, agora \u00e9 5. A Figura 10.1 mostra o diagrama de estado para cheeses, numbers e empty. Figura 10.1 \u2013 Diagrama de estado de tr\u00eas listas. As listas s\u00e3o representadas pelas caixas com a palavra \u201clista\u201d fora delas e os elementos da lista dentro delas. cheeses refere-se a uma lista com tr\u00eas elementos indexados como 0, 1 e 2. numbers cont\u00e9m dois elementos e o diagrama mostra que o valor do segundo elemento foi reatribu\u00eddo de 123 para 5. empty refere-se a uma lista sem elementos. \u00cdndices de listas funcionam da mesma forma que os \u00edndices de strings: Qualquer express\u00e3o de n\u00fameros inteiros pode ser usada como \u00edndice. Se tentar ler ou escrever um elemento que n\u00e3o existe, voc\u00ea recebe um IndexError. Se um \u00edndice tiver um valor negativo, ele conta de tr\u00e1s para a frente, a partir do final da lista. O operador in tamb\u00e9m funciona com listas: >>> cheeses = ['Cheddar', 'Edam', 'Gouda'] >>> 'Edam' in cheeses True >>> 'Brie' in cheeses False 10.3 - Percorrendo uma lista A forma mais comum de percorrer os elementos em uma lista \u00e9 com um loop for. A sintaxe \u00e9 a mesma que a das strings: for cheese in cheeses: print(cheese) Isso funciona bem se voc\u00ea precisa apenas ler os elementos da lista. Mas se voc\u00ea quer escrever ou atualizar os elementos, voc\u00ea precisa dos \u00edndices. Uma forma comum de fazer isso \u00e9 combinar as fun\u00e7\u00f5es integradas range e len: for i in range(len(numbers)): numbers[i] = numbers[i] * 2 Este loop percorre a lista e atualiza cada elemento. len retorna o n\u00famero de elementos na lista. range retorna uma lista de \u00edndices de 0 a n-1, em que n \u00e9 o comprimento da lista. Cada vez que passa pelo loop, i recebe o \u00edndice do pr\u00f3ximo elemento. A instru\u00e7\u00e3o de atribui\u00e7\u00e3o no corpo usa i para ler o valor antigo do elemento e atribuir o novo valor. Um loop for que passe por uma lista vazia nunca executa o corpo: for x in []: print('This never happens.') Apesar de uma lista poder conter outra lista, a lista aninhada ainda conta como um \u00fanico elemento. O comprimento desta lista \u00e9 quatro: ['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]] 10.4 - Opera\u00e7\u00f5es com listas O operador + concatena listas: >>> a = [1, 2, 3] >>> b = [4, 5, 6] >>> c = a + b >>> c [1, 2, 3, 4, 5, 6] O operador * repete a lista um dado n\u00famero de vezes: >>> [0] * 4 [0, 0, 0, 0] >>> [1, 2, 3] * 3 [1, 2, 3, 1, 2, 3, 1, 2, 3] O primeiro exemplo repete [0] quatro vezes. O segundo exemplo repete a lista [1, 2, 3] tr\u00eas vezes. 10.5 - Fatias de listas O operador de fatiamento tamb\u00e9m funciona com listas: >>> t = ['a', 'b', 'c', 'd', 'e', 'f'] >>> t[1:3] ['b', 'c'] >>> t[:4] ['a', 'b', 'c', 'd'] >>> t[3:] ['d', 'e', 'f'] Se voc\u00ea omitir o primeiro \u00edndice, a fatia come\u00e7a no in\u00edcio. Se voc\u00ea omitir o segundo, a fatia vai at\u00e9 o final. Se voc\u00ea omitir ambos, a fatia \u00e9 uma c\u00f3pia da lista inteira. >>> t[:] ['a', 'b', 'c', 'd', 'e', 'f'] Como as listas s\u00e3o mut\u00e1veis, pode ser \u00fatil fazer uma c\u00f3pia antes de executar opera\u00e7\u00f5es que as alterem. Um operador de fatia \u00e0 esquerda de uma atribui\u00e7\u00e3o pode atualizar v\u00e1rios elementos: >>> t = ['a', 'b', 'c', 'd', 'e', 'f'] >>> t[1:3] = ['x', 'y'] >>> t ['a', 'x', 'y', 'd', 'e', 'f'] 10.6 - M\u00e9todos de listas O Python oferece m\u00e9todos que operam em listas. Por exemplo, append adiciona um novo elemento ao fim de uma lista: >>> t = ['a', 'b', 'c'] >>> t.append('d') >>> t ['a', 'b', 'c', 'd'] extend toma uma lista como argumento e adiciona todos os elementos: >>> t1 = ['a', 'b', 'c'] >>> t2 = ['d', 'e'] >>> t1.extend(t2) >>> t1 ['a', 'b', 'c', 'd', 'e'] Este exemplo deixa t2 intocado. sort classifica os elementos da lista em ordem ascendente: >>> t = ['d', 'c', 'e', 'b', 'a'] >>> t.sort() >>> t ['a', 'b', 'c', 'd', 'e'] A maior parte dos m\u00e9todos de listas s\u00e3o nulos; eles alteram a lista e retornam None. Se voc\u00ea escrever t = t.sort() por acidente, ficar\u00e1 desapontado com o resultado. 10.7 - Mapeamento, filtragem e redu\u00e7\u00e3o Para somar o total de todos os n\u00fameros em uma lista, voc\u00ea pode usar um loop como esse: def add_all(t): total = 0 for x in t: total += x return total total \u00e9 inicializado com 0. Cada vez que o programa passa pelo loop, x recebe um elemento da lista. O operador += oferece uma forma curta de atualizar uma vari\u00e1vel. Esta instru\u00e7\u00e3o de atribui\u00e7\u00e3o aumentada, total += x \u00e9 equivalente a total = total + x No decorrer da execu\u00e7\u00e3o do loop, total acumula a soma dos elementos; uma vari\u00e1vel usada desta forma \u00e0s vezes \u00e9 chamada de acumuladora. Somar todos elementos de uma lista \u00e9 uma opera\u00e7\u00e3o t\u00e3o comum que o Python a oferece como uma fun\u00e7\u00e3o integrada, sum : >>> t = [1, 2, 3] >>> sum(t) 6 Uma opera\u00e7\u00e3o como essa, que combina uma sequ\u00eancia de elementos em um \u00fanico valor, \u00e0s vezes \u00e9 chamada de redu\u00e7\u00e3o. Algumas vezes voc\u00ea quer percorrer uma lista enquanto cria outra. Por exemplo, a fun\u00e7\u00e3o seguinte recebe uma lista de strings e retorna uma nova lista que cont\u00e9m strings com letras mai\u00fasculas: def capitalize_all(t): res = [] for s in t: res.append(s.capitalize()) return res res \u00e9 inicializado com uma lista vazia; cada vez que o programa passa pelo loop, acrescentamos o pr\u00f3ximo elemento. Ent\u00e3o res \u00e9 outro tipo de acumulador. Uma opera\u00e7\u00e3o como capitalize_all \u00e0s vezes \u00e9 chamada de mapeamento porque ela \u201cmapeia\u201d uma fun\u00e7\u00e3o (nesse caso o m\u00e9todo capitalize ) sobre cada um dos elementos em uma sequ\u00eancia. Outra opera\u00e7\u00e3o comum \u00e9 selecionar alguns dos elementos de uma lista e retornar uma sublista. Por exemplo, a fun\u00e7\u00e3o seguinte recebe uma lista de strings e retorna uma lista que cont\u00e9m apenas strings em letra mai\u00fascula: def only_upper(t): res = [] for s in t: if s.isupper(): res.append(s) return res isupper \u00e9 um m\u00e9todo de string que retorna True se a string contiver apenas letras mai\u00fasculas. Uma opera\u00e7\u00e3o como only_upper \u00e9 chamada de filtragem porque filtra alguns dos elementos e desconsidera outros. As opera\u00e7\u00f5es de lista mais comuns podem ser expressas como uma combina\u00e7\u00e3o de mapeamento, filtragem e redu\u00e7\u00e3o. 10.8 - Como excluir elementos H\u00e1 v\u00e1rias formas de excluir elementos de uma lista. Se souber o \u00edndice do elemento que procura, voc\u00ea pode usar pop : >>> t = ['a', 'b', 'c'] >>> x = t.pop(1) >>> t ['a', 'c'] >>> x 'b' pop altera a lista e retorna o elemento que foi exclu\u00eddo. Se voc\u00ea n\u00e3o incluir um \u00edndice, ele exclui e retorna o \u00faltimo elemento. Se n\u00e3o precisar do valor removido, voc\u00ea pode usar a instru\u00e7\u00e3o del : >>> t = ['a', 'b', 'c'] >>> del t[1] >>> t ['a', 'c'] Se souber o elemento que quer excluir (mas n\u00e3o o \u00edndice), voc\u00ea pode usar remove : >>> t = ['a', 'b', 'c'] >>> t.remove('b') >>> t ['a', 'c'] O valor devolvido por remove \u00e9 None . Para remover mais de um elemento, voc\u00ea pode usar del com um \u00edndice de fatia: >>> t = ['a', 'b', 'c', 'd', 'e', 'f'] >>> del t[1:5] >>> t ['a', 'f'] Como sempre, a fatia seleciona todos os elementos at\u00e9, mas n\u00e3o incluindo, o segundo \u00edndice. 10.9 - Listas e strings Uma string \u00e9 uma sequ\u00eancia de caracteres e uma lista \u00e9 uma sequ\u00eancia de valores, mas uma lista de caracteres n\u00e3o \u00e9 a mesma coisa que uma string. Para converter uma string em uma lista de caracteres, voc\u00ea pode usar list: >>> s = 'spam' >>> t = list(s) >>> t ['s', 'p', 'a', 'm'] Como list \u00e9 o nome de uma fun\u00e7\u00e3o integrada, voc\u00ea deve evitar us\u00e1-lo como nome de vari\u00e1vel. Tamb\u00e9m evito usar l porque parece demais com 1. \u00c9 por isso que uso t . A fun\u00e7\u00e3o list quebra uma string em letras individuais. Se voc\u00ea quiser quebrar uma string em palavras, voc\u00ea pode usar o m\u00e9todo split : >>> s = 'pining for the fjords' >>> t = s.split() >>> t ['pining', 'for', 'the', 'fjords'] Um argumento opcional chamado delimiter especifica quais caracteres podem ser usados para demonstrar os limites das palavras. O exemplo seguinte usa um h\u00edfen como delimitador: >>> s = 'spam-spam-spam' >>> delimiter = '-' >>> t = s.split(delimiter) >>> t ['spam', 'spam', 'spam'] join \u00e9 o contr\u00e1rio de split . Ele toma uma lista de strings e concatena os elementos. join \u00e9 um m\u00e9todo de string, ent\u00e3o \u00e9 preciso invoc\u00e1-lo no delimitador e passar a lista como par\u00e2metro: >>> t = ['pining', 'for', 'the', 'fjords'] >>> delimiter = ' ' >>> s = delimiter.join(t) >>> s 'pining for the fjords' Nesse caso, o delimitador \u00e9 um caractere de espa\u00e7o, ent\u00e3o join coloca um espa\u00e7o entre as palavras. Para concatenar strings sem espa\u00e7os, voc\u00ea pode usar a string vazia '' , como delimitador. 10.10 - Objetos e valores Se executarmos essas instru\u00e7\u00f5es de atribui\u00e7\u00e3o: a = 'banana' b = 'banana' Sabemos que a e b se referem a uma string, mas n\u00e3o sabemos se elas se referem \u00e0 mesma string. H\u00e1 dois estados poss\u00edveis, mostrados na Figura 10.2. Figura 10.2 \u2013 Diagramas de estado poss\u00edveis com duas vari\u00e1veis. Em um caso, a e b se referem a dois objetos diferentes que t\u00eam o mesmo valor. No segundo caso, elas se referem ao mesmo objeto. Para verificar se duas vari\u00e1veis se referem ao mesmo objeto, voc\u00ea pode usar o operador is: >>> a = 'banana' >>> b = 'banana' >>> a is b True Nesse exemplo, o Python criou apenas um objeto de string e tanto a quanto b se referem a ele. Mas quando voc\u00ea cria duas listas, voc\u00ea tem dois objetos: >>> a = [1, 2, 3] >>> b = [1, 2, 3] >>> a is b False Ent\u00e3o o diagrama de estado fica igual ao da Figura 10.3. Figura 10.3 \u2013 Diagrama de estado com vari\u00e1veis associadas a listas distintas, de mesmo valor. Nesse caso, dir\u00edamos que as duas listas s\u00e3o equivalentes, porque elas t\u00eam os mesmos elementos, mas n\u00e3o id\u00eanticas, porque elas n\u00e3o s\u00e3o o mesmo objeto. Se dois objetos forem id\u00eanticos, eles tamb\u00e9m s\u00e3o equivalentes, mas se eles forem equivalentes, n\u00e3o s\u00e3o necessariamente id\u00eanticos. At\u00e9 agora, temos usado \u201cobjeto\u201d e \u201cvalor\u201d de forma intercambi\u00e1vel, mas \u00e9 mais exato dizer que um objeto tem um valor. Se avaliar [1, 2, 3], voc\u00ea tem um objeto de lista cujo valor \u00e9 uma sequ\u00eancia de n\u00fameros inteiros. Se outra lista tem os mesmos elementos, dizemos que tem o mesmo valor, mas n\u00e3o \u00e9 o mesmo objeto. 10.11 - Alias Se a se refere a um objeto e voc\u00ea atribui b = a, ent\u00e3o ambas as vari\u00e1veis se referem ao mesmo objeto. >>> a = [1, 2, 3] >>> b = a >>> b is a True O diagrama de estado ficar\u00e1 igual \u00e0 Figura 10.4. Figura 10.4 \u2013 Diagrama de estado com duas vari\u00e1veis associadas \u00e0 mesma lista. A associa\u00e7\u00e3o de uma vari\u00e1vel com um objeto \u00e9 chamada de refer\u00eancia. Neste exemplo, h\u00e1 duas refer\u00eancias ao mesmo objeto. Um objeto com mais de uma refer\u00eancia tem mais de um nome, ent\u00e3o dizemos que o objeto tem um alias. Se o objeto com alias \u00e9 mut\u00e1vel, altera\u00e7\u00f5es feitas em um alias afetam o outro tamb\u00e9m. >>> b[0] = 42 >>> a [42, 2, 3] Apesar de esse comportamento poder ser \u00fatil, ele \u00e9 pass\u00edvel de erros. Em geral, \u00e9 mais seguro evitar usar alias ao trabalhar com objetos mut\u00e1veis. Para objetos imut\u00e1veis como strings, usar alias n\u00e3o \u00e9 um problema t\u00e3o grande. Neste exemplo: a = 'banana' b = 'banana' Quase nunca faz diferen\u00e7a se a e b se referem \u00e0 mesma string ou n\u00e3o. 10.12 - Argumentos de listas Ao passar uma lista a uma fun\u00e7\u00e3o, a fun\u00e7\u00e3o recebe uma refer\u00eancia \u00e0 lista. Se a fun\u00e7\u00e3o alterar a lista, quem faz a chamada v\u00ea a mudan\u00e7a. Por exemplo, delete_head remove o primeiro elemento de uma lista: def delete_head(t): del t[0] Ela \u00e9 usada assim: >>> letters = ['a', 'b', 'c'] >>> delete_head(letters) >>> letters ['b', 'c'] O par\u00e2metro t e a vari\u00e1vel letters s\u00e3o alias para o mesmo objeto. O diagrama da pilha fica igual ao da Figura 10.5. Figura 10.5 \u2013 Diagrama da pilha: __main__ e delete_head compartilham refer\u00eancias \u00e0 mesma lista. Como a lista \u00e9 compartilhada por dois frames, desenhei-a entre eles. \u00c9 importante distinguir entre opera\u00e7\u00f5es que alteram listas e opera\u00e7\u00f5es que criam novas listas. Por exemplo, o m\u00e9todo append altera a lista, mas o operador + cria uma nova lista: >>> t1 = [1, 2] >>> t2 = t1.append(3) >>> t1 [1, 2, 3] >>> t2 None Note que append altera a lista e retorna None (na realidade, o console do Python omite o None da sa\u00edda, mas voc\u00ea pode conferir usando t2 is None ). >>> t3 = t1 + [4] >>> t1 [1, 2, 3] >>> t3 [1, 2, 3, 4] >>> t1 O operador + cria uma nova lista e deixa a lista original inalterada. Essa diferen\u00e7a \u00e9 importante quando voc\u00ea escreve fun\u00e7\u00f5es que devem alterar listas. Por exemplo, esta fun\u00e7\u00e3o n\u00e3o remove a cabe\u00e7a de uma lista: def bad_delete_head(t): t = t[1:] # ERRADO! O operador de fatia cria uma nova lista e a atribui\u00e7\u00e3o faz t se referir a ela, mas isso n\u00e3o afeta quem faz chamada. >>> t4 = [1, 2, 3] >>> bad_delete_head(t4) >>> t4 [1, 2, 3] No in\u00edcio de bad_delete_head , t e t4 se referem \u00e0 mesma lista. No final, t se refere a uma nova lista, mas t4 ainda se refere \u00e0 lista original, inalterada. Uma alternativa \u00e9 escrever uma fun\u00e7\u00e3o que crie e retorne uma nova lista. Por exemplo, tail retorna tudo, exceto o primeiro elemento de uma lista: def tail(t): return t[1:] Esta fun\u00e7\u00e3o deixa a lista original inalterada. Ela \u00e9 usada assim: >>> letters = ['a', 'b', 'c'] >>> rest = tail(letters) >>> rest ['b', 'c'] 10.13 - Depura\u00e7\u00e3o O uso descuidado de listas (e de outros objetos mut\u00e1veis) pode levar a longas horas de depura\u00e7\u00e3o. Aqui est\u00e3o algumas armadilhas comuns e formas de evit\u00e1-las: A maior parte dos m\u00e9todos de listas alteram o argumento e retornam None. Isto \u00e9 o oposto dos m\u00e9todos de strings, que retornam uma nova string e deixam a original intocada. Se voc\u00ea est\u00e1 acostumado a escrever c\u00f3digo de strings desta forma: word = word.strip() \u00c9 tentador escrever c\u00f3digo de listas como este: t = t.sort() # ERRADO! Como sort retorna None, a pr\u00f3xima opera\u00e7\u00e3o que voc\u00ea executar com t provavelmente vai falhar. Antes de usar m\u00e9todos e operadores de listas, voc\u00ea deve ler a documenta\u00e7\u00e3o com cuidado e test\u00e1-los no modo interativo. Escolha o termo e fique com ele. Parte do problema com listas \u00e9 que h\u00e1 muitas formas de fazer coisas com elas. Por exemplo, para remover um elemento de uma lista voc\u00ea pode usar pop, remove, del ou at\u00e9 uma atribui\u00e7\u00e3o de fatia. Para adicionar um elemento voc\u00ea pode usar o m\u00e9todo append ou o operador +. Assumindo que t \u00e9 uma lista e x \u00e9 um elemento da lista, isto est\u00e1 correto: t.append(x) t = t + [x] t += [x] E isto est\u00e1 errado: t.append([x]) # ERRADO! t = t.append(x) # ERRADO! t + [x] # ERRADO! t = t + x # ERRADO! Experimente cada um desses exemplos no modo interativo para conferir se voc\u00ea entendeu o que fazem. Note que apenas o \u00faltimo causa um erro de tempo de execu\u00e7\u00e3o; os outros tr\u00eas s\u00e3o legais, mas eles fazem a coisa errada. Fa\u00e7a c\u00f3pias para evitar o uso de alias. Se quiser usar um m\u00e9todo como sort, que altera o argumento, mas precisa manter a lista original, voc\u00ea pode fazer uma c\u00f3pia: >>> t = [3, 1, 2] >>> t2 = t[:] >>> t2.sort() >>> t [3, 1, 2] >>> t2 [1, 2, 3] Neste exemplo voc\u00ea poderia usar tamb\u00e9m a fun\u00e7\u00e3o integrada sorted, que retorna uma nova lista classificada e deixa a original intocada. >>> t2 = sorted(t) >>> t [3, 1, 2] >>> t2 [1, 2, 3] 10.14 - Gloss\u00e1rio lista Uma sequ\u00eancia de valores. elemento Um dos valores em uma lista (ou outra sequ\u00eancia), tamb\u00e9m chamado de item. lista aninhada Uma lista que \u00e9 um elemento de outra lista. acumuladora Vari\u00e1vel usada em um loop para adicionar ou acumular um resultado. atribui\u00e7\u00e3o aumentada Instru\u00e7\u00e3o que atualiza o valor de uma vari\u00e1vel usando um operador como +=. redu\u00e7\u00e3o Padr\u00e3o de processamento que atravessa uma sequ\u00eancia e acumula os elementos em um \u00fanico resultado. mapeamento Padr\u00e3o de processamento que atravessa uma sequ\u00eancia e executa uma opera\u00e7\u00e3o em cada elemento. filtragem Padr\u00e3o de processamento que atravessa uma lista e seleciona os elementos que satisfazem algum crit\u00e9rio. objeto Algo a que uma vari\u00e1vel pode se referir. Um objeto tem um tipo e um valor. equivalente Ter o mesmo valor. id\u00eantico Ser o mesmo objeto (o que implica equival\u00eancia). refer\u00eancia Associa\u00e7\u00e3o entre uma vari\u00e1vel e seu valor. alias Uma circunst\u00e2ncia onde duas ou mais vari\u00e1veis se referem ao mesmo objeto. delimitador Um caractere ou uma string usada para indicar onde uma string deve ser dividida. 10.15 - Exerc\u00edcios Voc\u00ea pode baixar as solu\u00e7\u00f5es para estes exerc\u00edcios em http://thinkpython2.com/code/list_exercises.py. Exerc\u00edcio 10.1 Escreva uma fun\u00e7\u00e3o chamada nested_sum que receba uma lista de listas de n\u00fameros inteiros e adicione os elementos de todas as listas aninhadas. Por exemplo: >>> t = [[1, 2], [3], [4, 5, 6]] >>> nested_sum(t) 21 Exerc\u00edcio 10.2 Escreva uma fun\u00e7\u00e3o chamada cumsum que receba uma lista de n\u00fameros e retorne a soma cumulativa; isto \u00e9, uma nova lista onde o i-\u00e9simo elemento \u00e9 a soma dos primeiros i+1 elementos da lista original. Por exemplo: >>> t = [1, 2, 3] >>> cumsum(t) [1, 3, 6] Exerc\u00edcio 10.3 Escreva uma fun\u00e7\u00e3o chamada middle que receba uma lista e retorne uma nova lista com todos os elementos originais, exceto os primeiros e os \u00faltimos elementos. Por exemplo: >>> t = [1, 2, 3, 4] >>> middle(t) [2, 3] Exerc\u00edcio 10.4 Escreva uma fun\u00e7\u00e3o chamada chop que tome uma lista alterando-a para remover o primeiro e o \u00faltimo elementos, e retorne None. Por exemplo: >>> t = [1, 2, 3, 4] >>> chop(t) >>> t [2, 3] Exerc\u00edcio 10.5 Escreva uma fun\u00e7\u00e3o chamada is_sorted que tome uma lista como par\u00e2metro e retorne True se a lista estiver classificada em ordem ascendente, e False se n\u00e3o for o caso. Por exemplo: >>> is_sorted([1, 2, 2]) True >>> is_sorted(['b', 'a']) False Exerc\u00edcio 10.6 Duas palavras s\u00e3o anagramas se voc\u00ea puder soletrar uma rearranjando as letras da outra. Escreva uma fun\u00e7\u00e3o chamada is_anagram que tome duas strings e retorne True se forem anagramas. Exerc\u00edcio 10.7 Escreva uma fun\u00e7\u00e3o chamada has_duplicates que tome uma lista e retorne True se houver algum elemento que apare\u00e7a mais de uma vez. Ela n\u00e3o deve modificar a lista original. Exerc\u00edcio 10.8 Este exerc\u00edcio pertence ao assim chamado Paradoxo de anivers\u00e1rio, sobre o qual voc\u00ea pode ler em http://en.wikipedia.org/wiki/Birthday_paradox. Se h\u00e1 23 alunos na sua sala, quais s\u00e3o as chances de dois deles fazerem anivers\u00e1rio no mesmo dia? Voc\u00ea pode estimar esta probabilidade gerando amostras aleat\u00f3rias de 23 dias de anivers\u00e1rio e verificando as correspond\u00eancias. Dica: voc\u00ea pode gerar anivers\u00e1rios aleat\u00f3rios com a fun\u00e7\u00e3o randint no m\u00f3dulo random. Se quiser, voc\u00ea pode baixar minha solu\u00e7\u00e3o em http://thinkpython2.com/code/birthday.py. Exerc\u00edcio 10.9 Escreva uma fun\u00e7\u00e3o que leia o arquivo words.txt e construa uma lista com um elemento por palavra. Escreva duas vers\u00f5es desta fun\u00e7\u00e3o, uma usando o m\u00e9todo append e outra usando a express\u00e3o t = t + [x] . Qual leva mais tempo para ser executada? Por qu\u00ea? Solu\u00e7\u00e3o: http://thinkpython2.com/code/wordlist.py. Exerc\u00edcio 10.10 Para verificar se uma palavra est\u00e1 na lista de palavras, voc\u00ea pode usar o operador in, mas isso seria lento porque pesquisaria as palavras em ordem. Como as palavras est\u00e3o em ordem alfab\u00e9tica, podemos acelerar as coisas com uma busca por bisse\u00e7\u00e3o (tamb\u00e9m conhecida como pesquisa bin\u00e1ria), que \u00e9 semelhante ao que voc\u00ea faz quando procura uma palavra no dicion\u00e1rio. Voc\u00ea come\u00e7a no meio e verifica se a palavra que est\u00e1 procurando vem antes da palavra no meio da lista. Se for o caso, procura na primeira metade da lista. Se n\u00e3o, procura na segunda metade. De qualquer forma, voc\u00ea corta o espa\u00e7o de busca restante pela metade. Se a lista de palavras tiver 113.809 palavras, o programa seguir\u00e1 uns 17 passos para encontrar a palavra ou concluir que n\u00e3o est\u00e1 l\u00e1. Escreva uma fun\u00e7\u00e3o chamada in_bisect que receba uma lista ordenada, um valor-alvo e devolva o \u00edndice do valor na lista se ele estiver l\u00e1, ou None se n\u00e3o estiver. Ou voc\u00ea pode ler a documenta\u00e7\u00e3o do m\u00f3dulo bisect e us\u00e1-lo! Solu\u00e7\u00e3o: http://thinkpython2.com/code/inlist.py. Exerc\u00edcio 10.11 Duas palavras s\u00e3o um \u201cpar inverso\u201d se uma for o contr\u00e1rio da outra. Escreva um programa que encontre todos os pares inversos na lista de palavras. Solu\u00e7\u00e3o: http://thinkpython2.com/code/reverse_pair.py. Exerc\u00edcio 10.12 Duas palavras \u201cinterligam-se\u201d quando, ao tomarmos letras alternadas de cada uma, formamos uma palavra nova. Por exemplo, \u201cshoe\u201d e \u201ccold\u201d interligam-se para formar \u201cschooled\u201d. Solu\u00e7\u00e3o: http://thinkpython2.com/code/interlock.py. Cr\u00e9dito: este exerc\u00edcio foi inspirado por um exemplo em http://puzzlers.org. Escreva um programa que encontre todos os pares de palavras que se interligam. Dica: n\u00e3o enumere todos os pares! Voc\u00ea pode encontrar palavras que sejam interligadas de tr\u00eas em tr\u00eas; isto \u00e9, cada terceira letra forma uma palavra, come\u00e7ando da primeira, segunda ou terceira?","title":"Cap\u00edtulo 10: Listas"},{"location":"10-listas/#capitulo-10-listas","text":"Este cap\u00edtulo apresenta um dos tipos integrados mais \u00fateis do Python: listas. Voc\u00ea tamb\u00e9m aprender\u00e1 mais sobre objetos e o que pode acontecer quando o mesmo objeto tem mais de um nome.","title":"Cap\u00edtulo 10: Listas"},{"location":"10-listas/#101-uma-lista-e-uma-sequencia","text":"Como uma string, uma lista \u00e9 uma sequ\u00eancia de valores. Em uma string, os valores s\u00e3o caracteres; em uma lista, eles podem ser de qualquer tipo. Os valores em uma lista s\u00e3o chamados de elementos, ou, algumas vezes, de itens. H\u00e1 v\u00e1rias formas para criar uma lista; a mais simples \u00e9 colocar os elementos entre colchetes ( [ e ] ): [10, 20, 30, 40] ['crunchy frog', 'ram bladder', 'lark vomit'] O primeiro exemplo \u00e9 uma lista de quatro n\u00fameros inteiros. O segundo \u00e9 uma lista de tr\u00eas strings. Os elementos de uma lista n\u00e3o precisam ser do mesmo tipo. A lista seguinte cont\u00e9m uma string, um n\u00famero de ponto flutuante, um n\u00famero inteiro e (olhe s\u00f3!) outra lista: ['spam', 2.0, 5, [10, 20]] Uma lista dentro de outra lista \u00e9 uma lista aninhada. Uma lista que n\u00e3o cont\u00e9m elementos \u00e9 chamada de lista vazia; voc\u00ea pode criar uma com colchetes vazios []. Como j\u00e1 se poderia esperar, podemos atribuir uma lista de valores a vari\u00e1veis: >>> cheeses = ['Cheddar', 'Edam', 'Gouda'] >>> numbers = [42, 123] >>> empty = [] >>> print(cheeses, numbers, empty) ['Cheddar', 'Edam', 'Gouda'] [42, 123] []","title":"10.1 - Uma lista \u00e9 uma sequ\u00eancia"},{"location":"10-listas/#102-listas-sao-mutaveis","text":"A sintaxe para acessar os elementos de uma lista \u00e9 a mesma que para acessar os caracteres de uma string: o operador de colchete. A express\u00e3o dentro dos colchetes especifica o \u00edndice. Lembre-se de que os \u00edndices come\u00e7am em 0: >>> cheeses[0] 'Cheddar' Diferente das strings, listas s\u00e3o mut\u00e1veis. Quando o operador de colchete aparece do lado esquerdo de uma atribui\u00e7\u00e3o, ele identifica o elemento da lista que ser\u00e1 atribu\u00eddo: >>> numbers = [42, 123] >>> numbers[1] = 5 >>> numbers [42, 5] O primeiro elemento de numbers, que costumava ser 123, agora \u00e9 5. A Figura 10.1 mostra o diagrama de estado para cheeses, numbers e empty. Figura 10.1 \u2013 Diagrama de estado de tr\u00eas listas. As listas s\u00e3o representadas pelas caixas com a palavra \u201clista\u201d fora delas e os elementos da lista dentro delas. cheeses refere-se a uma lista com tr\u00eas elementos indexados como 0, 1 e 2. numbers cont\u00e9m dois elementos e o diagrama mostra que o valor do segundo elemento foi reatribu\u00eddo de 123 para 5. empty refere-se a uma lista sem elementos. \u00cdndices de listas funcionam da mesma forma que os \u00edndices de strings: Qualquer express\u00e3o de n\u00fameros inteiros pode ser usada como \u00edndice. Se tentar ler ou escrever um elemento que n\u00e3o existe, voc\u00ea recebe um IndexError. Se um \u00edndice tiver um valor negativo, ele conta de tr\u00e1s para a frente, a partir do final da lista. O operador in tamb\u00e9m funciona com listas: >>> cheeses = ['Cheddar', 'Edam', 'Gouda'] >>> 'Edam' in cheeses True >>> 'Brie' in cheeses False","title":"10.2 - Listas s\u00e3o mut\u00e1veis"},{"location":"10-listas/#103-percorrendo-uma-lista","text":"A forma mais comum de percorrer os elementos em uma lista \u00e9 com um loop for. A sintaxe \u00e9 a mesma que a das strings: for cheese in cheeses: print(cheese) Isso funciona bem se voc\u00ea precisa apenas ler os elementos da lista. Mas se voc\u00ea quer escrever ou atualizar os elementos, voc\u00ea precisa dos \u00edndices. Uma forma comum de fazer isso \u00e9 combinar as fun\u00e7\u00f5es integradas range e len: for i in range(len(numbers)): numbers[i] = numbers[i] * 2 Este loop percorre a lista e atualiza cada elemento. len retorna o n\u00famero de elementos na lista. range retorna uma lista de \u00edndices de 0 a n-1, em que n \u00e9 o comprimento da lista. Cada vez que passa pelo loop, i recebe o \u00edndice do pr\u00f3ximo elemento. A instru\u00e7\u00e3o de atribui\u00e7\u00e3o no corpo usa i para ler o valor antigo do elemento e atribuir o novo valor. Um loop for que passe por uma lista vazia nunca executa o corpo: for x in []: print('This never happens.') Apesar de uma lista poder conter outra lista, a lista aninhada ainda conta como um \u00fanico elemento. O comprimento desta lista \u00e9 quatro: ['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]","title":"10.3 - Percorrendo uma lista"},{"location":"10-listas/#104-operacoes-com-listas","text":"O operador + concatena listas: >>> a = [1, 2, 3] >>> b = [4, 5, 6] >>> c = a + b >>> c [1, 2, 3, 4, 5, 6] O operador * repete a lista um dado n\u00famero de vezes: >>> [0] * 4 [0, 0, 0, 0] >>> [1, 2, 3] * 3 [1, 2, 3, 1, 2, 3, 1, 2, 3] O primeiro exemplo repete [0] quatro vezes. O segundo exemplo repete a lista [1, 2, 3] tr\u00eas vezes.","title":"10.4 - Opera\u00e7\u00f5es com listas"},{"location":"10-listas/#105-fatias-de-listas","text":"O operador de fatiamento tamb\u00e9m funciona com listas: >>> t = ['a', 'b', 'c', 'd', 'e', 'f'] >>> t[1:3] ['b', 'c'] >>> t[:4] ['a', 'b', 'c', 'd'] >>> t[3:] ['d', 'e', 'f'] Se voc\u00ea omitir o primeiro \u00edndice, a fatia come\u00e7a no in\u00edcio. Se voc\u00ea omitir o segundo, a fatia vai at\u00e9 o final. Se voc\u00ea omitir ambos, a fatia \u00e9 uma c\u00f3pia da lista inteira. >>> t[:] ['a', 'b', 'c', 'd', 'e', 'f'] Como as listas s\u00e3o mut\u00e1veis, pode ser \u00fatil fazer uma c\u00f3pia antes de executar opera\u00e7\u00f5es que as alterem. Um operador de fatia \u00e0 esquerda de uma atribui\u00e7\u00e3o pode atualizar v\u00e1rios elementos: >>> t = ['a', 'b', 'c', 'd', 'e', 'f'] >>> t[1:3] = ['x', 'y'] >>> t ['a', 'x', 'y', 'd', 'e', 'f']","title":"10.5 - Fatias de listas"},{"location":"10-listas/#106-metodos-de-listas","text":"O Python oferece m\u00e9todos que operam em listas. Por exemplo, append adiciona um novo elemento ao fim de uma lista: >>> t = ['a', 'b', 'c'] >>> t.append('d') >>> t ['a', 'b', 'c', 'd'] extend toma uma lista como argumento e adiciona todos os elementos: >>> t1 = ['a', 'b', 'c'] >>> t2 = ['d', 'e'] >>> t1.extend(t2) >>> t1 ['a', 'b', 'c', 'd', 'e'] Este exemplo deixa t2 intocado. sort classifica os elementos da lista em ordem ascendente: >>> t = ['d', 'c', 'e', 'b', 'a'] >>> t.sort() >>> t ['a', 'b', 'c', 'd', 'e'] A maior parte dos m\u00e9todos de listas s\u00e3o nulos; eles alteram a lista e retornam None. Se voc\u00ea escrever t = t.sort() por acidente, ficar\u00e1 desapontado com o resultado.","title":"10.6 - M\u00e9todos de listas"},{"location":"10-listas/#107-mapeamento-filtragem-e-reducao","text":"Para somar o total de todos os n\u00fameros em uma lista, voc\u00ea pode usar um loop como esse: def add_all(t): total = 0 for x in t: total += x return total total \u00e9 inicializado com 0. Cada vez que o programa passa pelo loop, x recebe um elemento da lista. O operador += oferece uma forma curta de atualizar uma vari\u00e1vel. Esta instru\u00e7\u00e3o de atribui\u00e7\u00e3o aumentada, total += x \u00e9 equivalente a total = total + x No decorrer da execu\u00e7\u00e3o do loop, total acumula a soma dos elementos; uma vari\u00e1vel usada desta forma \u00e0s vezes \u00e9 chamada de acumuladora. Somar todos elementos de uma lista \u00e9 uma opera\u00e7\u00e3o t\u00e3o comum que o Python a oferece como uma fun\u00e7\u00e3o integrada, sum : >>> t = [1, 2, 3] >>> sum(t) 6 Uma opera\u00e7\u00e3o como essa, que combina uma sequ\u00eancia de elementos em um \u00fanico valor, \u00e0s vezes \u00e9 chamada de redu\u00e7\u00e3o. Algumas vezes voc\u00ea quer percorrer uma lista enquanto cria outra. Por exemplo, a fun\u00e7\u00e3o seguinte recebe uma lista de strings e retorna uma nova lista que cont\u00e9m strings com letras mai\u00fasculas: def capitalize_all(t): res = [] for s in t: res.append(s.capitalize()) return res res \u00e9 inicializado com uma lista vazia; cada vez que o programa passa pelo loop, acrescentamos o pr\u00f3ximo elemento. Ent\u00e3o res \u00e9 outro tipo de acumulador. Uma opera\u00e7\u00e3o como capitalize_all \u00e0s vezes \u00e9 chamada de mapeamento porque ela \u201cmapeia\u201d uma fun\u00e7\u00e3o (nesse caso o m\u00e9todo capitalize ) sobre cada um dos elementos em uma sequ\u00eancia. Outra opera\u00e7\u00e3o comum \u00e9 selecionar alguns dos elementos de uma lista e retornar uma sublista. Por exemplo, a fun\u00e7\u00e3o seguinte recebe uma lista de strings e retorna uma lista que cont\u00e9m apenas strings em letra mai\u00fascula: def only_upper(t): res = [] for s in t: if s.isupper(): res.append(s) return res isupper \u00e9 um m\u00e9todo de string que retorna True se a string contiver apenas letras mai\u00fasculas. Uma opera\u00e7\u00e3o como only_upper \u00e9 chamada de filtragem porque filtra alguns dos elementos e desconsidera outros. As opera\u00e7\u00f5es de lista mais comuns podem ser expressas como uma combina\u00e7\u00e3o de mapeamento, filtragem e redu\u00e7\u00e3o.","title":"10.7 - Mapeamento, filtragem e redu\u00e7\u00e3o"},{"location":"10-listas/#108-como-excluir-elementos","text":"H\u00e1 v\u00e1rias formas de excluir elementos de uma lista. Se souber o \u00edndice do elemento que procura, voc\u00ea pode usar pop : >>> t = ['a', 'b', 'c'] >>> x = t.pop(1) >>> t ['a', 'c'] >>> x 'b' pop altera a lista e retorna o elemento que foi exclu\u00eddo. Se voc\u00ea n\u00e3o incluir um \u00edndice, ele exclui e retorna o \u00faltimo elemento. Se n\u00e3o precisar do valor removido, voc\u00ea pode usar a instru\u00e7\u00e3o del : >>> t = ['a', 'b', 'c'] >>> del t[1] >>> t ['a', 'c'] Se souber o elemento que quer excluir (mas n\u00e3o o \u00edndice), voc\u00ea pode usar remove : >>> t = ['a', 'b', 'c'] >>> t.remove('b') >>> t ['a', 'c'] O valor devolvido por remove \u00e9 None . Para remover mais de um elemento, voc\u00ea pode usar del com um \u00edndice de fatia: >>> t = ['a', 'b', 'c', 'd', 'e', 'f'] >>> del t[1:5] >>> t ['a', 'f'] Como sempre, a fatia seleciona todos os elementos at\u00e9, mas n\u00e3o incluindo, o segundo \u00edndice.","title":"10.8 - Como excluir elementos"},{"location":"10-listas/#109-listas-e-strings","text":"Uma string \u00e9 uma sequ\u00eancia de caracteres e uma lista \u00e9 uma sequ\u00eancia de valores, mas uma lista de caracteres n\u00e3o \u00e9 a mesma coisa que uma string. Para converter uma string em uma lista de caracteres, voc\u00ea pode usar list: >>> s = 'spam' >>> t = list(s) >>> t ['s', 'p', 'a', 'm'] Como list \u00e9 o nome de uma fun\u00e7\u00e3o integrada, voc\u00ea deve evitar us\u00e1-lo como nome de vari\u00e1vel. Tamb\u00e9m evito usar l porque parece demais com 1. \u00c9 por isso que uso t . A fun\u00e7\u00e3o list quebra uma string em letras individuais. Se voc\u00ea quiser quebrar uma string em palavras, voc\u00ea pode usar o m\u00e9todo split : >>> s = 'pining for the fjords' >>> t = s.split() >>> t ['pining', 'for', 'the', 'fjords'] Um argumento opcional chamado delimiter especifica quais caracteres podem ser usados para demonstrar os limites das palavras. O exemplo seguinte usa um h\u00edfen como delimitador: >>> s = 'spam-spam-spam' >>> delimiter = '-' >>> t = s.split(delimiter) >>> t ['spam', 'spam', 'spam'] join \u00e9 o contr\u00e1rio de split . Ele toma uma lista de strings e concatena os elementos. join \u00e9 um m\u00e9todo de string, ent\u00e3o \u00e9 preciso invoc\u00e1-lo no delimitador e passar a lista como par\u00e2metro: >>> t = ['pining', 'for', 'the', 'fjords'] >>> delimiter = ' ' >>> s = delimiter.join(t) >>> s 'pining for the fjords' Nesse caso, o delimitador \u00e9 um caractere de espa\u00e7o, ent\u00e3o join coloca um espa\u00e7o entre as palavras. Para concatenar strings sem espa\u00e7os, voc\u00ea pode usar a string vazia '' , como delimitador.","title":"10.9 - Listas e strings"},{"location":"10-listas/#1010-objetos-e-valores","text":"Se executarmos essas instru\u00e7\u00f5es de atribui\u00e7\u00e3o: a = 'banana' b = 'banana' Sabemos que a e b se referem a uma string, mas n\u00e3o sabemos se elas se referem \u00e0 mesma string. H\u00e1 dois estados poss\u00edveis, mostrados na Figura 10.2. Figura 10.2 \u2013 Diagramas de estado poss\u00edveis com duas vari\u00e1veis. Em um caso, a e b se referem a dois objetos diferentes que t\u00eam o mesmo valor. No segundo caso, elas se referem ao mesmo objeto. Para verificar se duas vari\u00e1veis se referem ao mesmo objeto, voc\u00ea pode usar o operador is: >>> a = 'banana' >>> b = 'banana' >>> a is b True Nesse exemplo, o Python criou apenas um objeto de string e tanto a quanto b se referem a ele. Mas quando voc\u00ea cria duas listas, voc\u00ea tem dois objetos: >>> a = [1, 2, 3] >>> b = [1, 2, 3] >>> a is b False Ent\u00e3o o diagrama de estado fica igual ao da Figura 10.3. Figura 10.3 \u2013 Diagrama de estado com vari\u00e1veis associadas a listas distintas, de mesmo valor. Nesse caso, dir\u00edamos que as duas listas s\u00e3o equivalentes, porque elas t\u00eam os mesmos elementos, mas n\u00e3o id\u00eanticas, porque elas n\u00e3o s\u00e3o o mesmo objeto. Se dois objetos forem id\u00eanticos, eles tamb\u00e9m s\u00e3o equivalentes, mas se eles forem equivalentes, n\u00e3o s\u00e3o necessariamente id\u00eanticos. At\u00e9 agora, temos usado \u201cobjeto\u201d e \u201cvalor\u201d de forma intercambi\u00e1vel, mas \u00e9 mais exato dizer que um objeto tem um valor. Se avaliar [1, 2, 3], voc\u00ea tem um objeto de lista cujo valor \u00e9 uma sequ\u00eancia de n\u00fameros inteiros. Se outra lista tem os mesmos elementos, dizemos que tem o mesmo valor, mas n\u00e3o \u00e9 o mesmo objeto.","title":"10.10 - Objetos e valores"},{"location":"10-listas/#1011-alias","text":"Se a se refere a um objeto e voc\u00ea atribui b = a, ent\u00e3o ambas as vari\u00e1veis se referem ao mesmo objeto. >>> a = [1, 2, 3] >>> b = a >>> b is a True O diagrama de estado ficar\u00e1 igual \u00e0 Figura 10.4. Figura 10.4 \u2013 Diagrama de estado com duas vari\u00e1veis associadas \u00e0 mesma lista. A associa\u00e7\u00e3o de uma vari\u00e1vel com um objeto \u00e9 chamada de refer\u00eancia. Neste exemplo, h\u00e1 duas refer\u00eancias ao mesmo objeto. Um objeto com mais de uma refer\u00eancia tem mais de um nome, ent\u00e3o dizemos que o objeto tem um alias. Se o objeto com alias \u00e9 mut\u00e1vel, altera\u00e7\u00f5es feitas em um alias afetam o outro tamb\u00e9m. >>> b[0] = 42 >>> a [42, 2, 3] Apesar de esse comportamento poder ser \u00fatil, ele \u00e9 pass\u00edvel de erros. Em geral, \u00e9 mais seguro evitar usar alias ao trabalhar com objetos mut\u00e1veis. Para objetos imut\u00e1veis como strings, usar alias n\u00e3o \u00e9 um problema t\u00e3o grande. Neste exemplo: a = 'banana' b = 'banana' Quase nunca faz diferen\u00e7a se a e b se referem \u00e0 mesma string ou n\u00e3o.","title":"10.11 - Alias"},{"location":"10-listas/#1012-argumentos-de-listas","text":"Ao passar uma lista a uma fun\u00e7\u00e3o, a fun\u00e7\u00e3o recebe uma refer\u00eancia \u00e0 lista. Se a fun\u00e7\u00e3o alterar a lista, quem faz a chamada v\u00ea a mudan\u00e7a. Por exemplo, delete_head remove o primeiro elemento de uma lista: def delete_head(t): del t[0] Ela \u00e9 usada assim: >>> letters = ['a', 'b', 'c'] >>> delete_head(letters) >>> letters ['b', 'c'] O par\u00e2metro t e a vari\u00e1vel letters s\u00e3o alias para o mesmo objeto. O diagrama da pilha fica igual ao da Figura 10.5. Figura 10.5 \u2013 Diagrama da pilha: __main__ e delete_head compartilham refer\u00eancias \u00e0 mesma lista. Como a lista \u00e9 compartilhada por dois frames, desenhei-a entre eles. \u00c9 importante distinguir entre opera\u00e7\u00f5es que alteram listas e opera\u00e7\u00f5es que criam novas listas. Por exemplo, o m\u00e9todo append altera a lista, mas o operador + cria uma nova lista: >>> t1 = [1, 2] >>> t2 = t1.append(3) >>> t1 [1, 2, 3] >>> t2 None Note que append altera a lista e retorna None (na realidade, o console do Python omite o None da sa\u00edda, mas voc\u00ea pode conferir usando t2 is None ). >>> t3 = t1 + [4] >>> t1 [1, 2, 3] >>> t3 [1, 2, 3, 4] >>> t1 O operador + cria uma nova lista e deixa a lista original inalterada. Essa diferen\u00e7a \u00e9 importante quando voc\u00ea escreve fun\u00e7\u00f5es que devem alterar listas. Por exemplo, esta fun\u00e7\u00e3o n\u00e3o remove a cabe\u00e7a de uma lista: def bad_delete_head(t): t = t[1:] # ERRADO! O operador de fatia cria uma nova lista e a atribui\u00e7\u00e3o faz t se referir a ela, mas isso n\u00e3o afeta quem faz chamada. >>> t4 = [1, 2, 3] >>> bad_delete_head(t4) >>> t4 [1, 2, 3] No in\u00edcio de bad_delete_head , t e t4 se referem \u00e0 mesma lista. No final, t se refere a uma nova lista, mas t4 ainda se refere \u00e0 lista original, inalterada. Uma alternativa \u00e9 escrever uma fun\u00e7\u00e3o que crie e retorne uma nova lista. Por exemplo, tail retorna tudo, exceto o primeiro elemento de uma lista: def tail(t): return t[1:] Esta fun\u00e7\u00e3o deixa a lista original inalterada. Ela \u00e9 usada assim: >>> letters = ['a', 'b', 'c'] >>> rest = tail(letters) >>> rest ['b', 'c']","title":"10.12 - Argumentos de listas"},{"location":"10-listas/#1013-depuracao","text":"O uso descuidado de listas (e de outros objetos mut\u00e1veis) pode levar a longas horas de depura\u00e7\u00e3o. Aqui est\u00e3o algumas armadilhas comuns e formas de evit\u00e1-las: A maior parte dos m\u00e9todos de listas alteram o argumento e retornam None. Isto \u00e9 o oposto dos m\u00e9todos de strings, que retornam uma nova string e deixam a original intocada. Se voc\u00ea est\u00e1 acostumado a escrever c\u00f3digo de strings desta forma: word = word.strip() \u00c9 tentador escrever c\u00f3digo de listas como este: t = t.sort() # ERRADO! Como sort retorna None, a pr\u00f3xima opera\u00e7\u00e3o que voc\u00ea executar com t provavelmente vai falhar. Antes de usar m\u00e9todos e operadores de listas, voc\u00ea deve ler a documenta\u00e7\u00e3o com cuidado e test\u00e1-los no modo interativo. Escolha o termo e fique com ele. Parte do problema com listas \u00e9 que h\u00e1 muitas formas de fazer coisas com elas. Por exemplo, para remover um elemento de uma lista voc\u00ea pode usar pop, remove, del ou at\u00e9 uma atribui\u00e7\u00e3o de fatia. Para adicionar um elemento voc\u00ea pode usar o m\u00e9todo append ou o operador +. Assumindo que t \u00e9 uma lista e x \u00e9 um elemento da lista, isto est\u00e1 correto: t.append(x) t = t + [x] t += [x] E isto est\u00e1 errado: t.append([x]) # ERRADO! t = t.append(x) # ERRADO! t + [x] # ERRADO! t = t + x # ERRADO! Experimente cada um desses exemplos no modo interativo para conferir se voc\u00ea entendeu o que fazem. Note que apenas o \u00faltimo causa um erro de tempo de execu\u00e7\u00e3o; os outros tr\u00eas s\u00e3o legais, mas eles fazem a coisa errada. Fa\u00e7a c\u00f3pias para evitar o uso de alias. Se quiser usar um m\u00e9todo como sort, que altera o argumento, mas precisa manter a lista original, voc\u00ea pode fazer uma c\u00f3pia: >>> t = [3, 1, 2] >>> t2 = t[:] >>> t2.sort() >>> t [3, 1, 2] >>> t2 [1, 2, 3] Neste exemplo voc\u00ea poderia usar tamb\u00e9m a fun\u00e7\u00e3o integrada sorted, que retorna uma nova lista classificada e deixa a original intocada. >>> t2 = sorted(t) >>> t [3, 1, 2] >>> t2 [1, 2, 3]","title":"10.13 - Depura\u00e7\u00e3o"},{"location":"10-listas/#1014-glossario","text":"lista Uma sequ\u00eancia de valores. elemento Um dos valores em uma lista (ou outra sequ\u00eancia), tamb\u00e9m chamado de item. lista aninhada Uma lista que \u00e9 um elemento de outra lista. acumuladora Vari\u00e1vel usada em um loop para adicionar ou acumular um resultado. atribui\u00e7\u00e3o aumentada Instru\u00e7\u00e3o que atualiza o valor de uma vari\u00e1vel usando um operador como +=. redu\u00e7\u00e3o Padr\u00e3o de processamento que atravessa uma sequ\u00eancia e acumula os elementos em um \u00fanico resultado. mapeamento Padr\u00e3o de processamento que atravessa uma sequ\u00eancia e executa uma opera\u00e7\u00e3o em cada elemento. filtragem Padr\u00e3o de processamento que atravessa uma lista e seleciona os elementos que satisfazem algum crit\u00e9rio. objeto Algo a que uma vari\u00e1vel pode se referir. Um objeto tem um tipo e um valor. equivalente Ter o mesmo valor. id\u00eantico Ser o mesmo objeto (o que implica equival\u00eancia). refer\u00eancia Associa\u00e7\u00e3o entre uma vari\u00e1vel e seu valor. alias Uma circunst\u00e2ncia onde duas ou mais vari\u00e1veis se referem ao mesmo objeto. delimitador Um caractere ou uma string usada para indicar onde uma string deve ser dividida.","title":"10.14 - Gloss\u00e1rio"},{"location":"10-listas/#1015-exercicios","text":"Voc\u00ea pode baixar as solu\u00e7\u00f5es para estes exerc\u00edcios em http://thinkpython2.com/code/list_exercises.py.","title":"10.15 - Exerc\u00edcios"},{"location":"10-listas/#exercicio-101","text":"Escreva uma fun\u00e7\u00e3o chamada nested_sum que receba uma lista de listas de n\u00fameros inteiros e adicione os elementos de todas as listas aninhadas. Por exemplo: >>> t = [[1, 2], [3], [4, 5, 6]] >>> nested_sum(t) 21","title":"Exerc\u00edcio 10.1"},{"location":"10-listas/#exercicio-102","text":"Escreva uma fun\u00e7\u00e3o chamada cumsum que receba uma lista de n\u00fameros e retorne a soma cumulativa; isto \u00e9, uma nova lista onde o i-\u00e9simo elemento \u00e9 a soma dos primeiros i+1 elementos da lista original. Por exemplo: >>> t = [1, 2, 3] >>> cumsum(t) [1, 3, 6]","title":"Exerc\u00edcio 10.2"},{"location":"10-listas/#exercicio-103","text":"Escreva uma fun\u00e7\u00e3o chamada middle que receba uma lista e retorne uma nova lista com todos os elementos originais, exceto os primeiros e os \u00faltimos elementos. Por exemplo: >>> t = [1, 2, 3, 4] >>> middle(t) [2, 3]","title":"Exerc\u00edcio 10.3"},{"location":"10-listas/#exercicio-104","text":"Escreva uma fun\u00e7\u00e3o chamada chop que tome uma lista alterando-a para remover o primeiro e o \u00faltimo elementos, e retorne None. Por exemplo: >>> t = [1, 2, 3, 4] >>> chop(t) >>> t [2, 3]","title":"Exerc\u00edcio 10.4"},{"location":"10-listas/#exercicio-105","text":"Escreva uma fun\u00e7\u00e3o chamada is_sorted que tome uma lista como par\u00e2metro e retorne True se a lista estiver classificada em ordem ascendente, e False se n\u00e3o for o caso. Por exemplo: >>> is_sorted([1, 2, 2]) True >>> is_sorted(['b', 'a']) False","title":"Exerc\u00edcio 10.5"},{"location":"10-listas/#exercicio-106","text":"Duas palavras s\u00e3o anagramas se voc\u00ea puder soletrar uma rearranjando as letras da outra. Escreva uma fun\u00e7\u00e3o chamada is_anagram que tome duas strings e retorne True se forem anagramas.","title":"Exerc\u00edcio 10.6"},{"location":"10-listas/#exercicio-107","text":"Escreva uma fun\u00e7\u00e3o chamada has_duplicates que tome uma lista e retorne True se houver algum elemento que apare\u00e7a mais de uma vez. Ela n\u00e3o deve modificar a lista original.","title":"Exerc\u00edcio 10.7"},{"location":"10-listas/#exercicio-108","text":"Este exerc\u00edcio pertence ao assim chamado Paradoxo de anivers\u00e1rio, sobre o qual voc\u00ea pode ler em http://en.wikipedia.org/wiki/Birthday_paradox. Se h\u00e1 23 alunos na sua sala, quais s\u00e3o as chances de dois deles fazerem anivers\u00e1rio no mesmo dia? Voc\u00ea pode estimar esta probabilidade gerando amostras aleat\u00f3rias de 23 dias de anivers\u00e1rio e verificando as correspond\u00eancias. Dica: voc\u00ea pode gerar anivers\u00e1rios aleat\u00f3rios com a fun\u00e7\u00e3o randint no m\u00f3dulo random. Se quiser, voc\u00ea pode baixar minha solu\u00e7\u00e3o em http://thinkpython2.com/code/birthday.py.","title":"Exerc\u00edcio 10.8"},{"location":"10-listas/#exercicio-109","text":"Escreva uma fun\u00e7\u00e3o que leia o arquivo words.txt e construa uma lista com um elemento por palavra. Escreva duas vers\u00f5es desta fun\u00e7\u00e3o, uma usando o m\u00e9todo append e outra usando a express\u00e3o t = t + [x] . Qual leva mais tempo para ser executada? Por qu\u00ea? Solu\u00e7\u00e3o: http://thinkpython2.com/code/wordlist.py.","title":"Exerc\u00edcio 10.9"},{"location":"10-listas/#exercicio-1010","text":"Para verificar se uma palavra est\u00e1 na lista de palavras, voc\u00ea pode usar o operador in, mas isso seria lento porque pesquisaria as palavras em ordem. Como as palavras est\u00e3o em ordem alfab\u00e9tica, podemos acelerar as coisas com uma busca por bisse\u00e7\u00e3o (tamb\u00e9m conhecida como pesquisa bin\u00e1ria), que \u00e9 semelhante ao que voc\u00ea faz quando procura uma palavra no dicion\u00e1rio. Voc\u00ea come\u00e7a no meio e verifica se a palavra que est\u00e1 procurando vem antes da palavra no meio da lista. Se for o caso, procura na primeira metade da lista. Se n\u00e3o, procura na segunda metade. De qualquer forma, voc\u00ea corta o espa\u00e7o de busca restante pela metade. Se a lista de palavras tiver 113.809 palavras, o programa seguir\u00e1 uns 17 passos para encontrar a palavra ou concluir que n\u00e3o est\u00e1 l\u00e1. Escreva uma fun\u00e7\u00e3o chamada in_bisect que receba uma lista ordenada, um valor-alvo e devolva o \u00edndice do valor na lista se ele estiver l\u00e1, ou None se n\u00e3o estiver. Ou voc\u00ea pode ler a documenta\u00e7\u00e3o do m\u00f3dulo bisect e us\u00e1-lo! Solu\u00e7\u00e3o: http://thinkpython2.com/code/inlist.py.","title":"Exerc\u00edcio 10.10"},{"location":"10-listas/#exercicio-1011","text":"Duas palavras s\u00e3o um \u201cpar inverso\u201d se uma for o contr\u00e1rio da outra. Escreva um programa que encontre todos os pares inversos na lista de palavras. Solu\u00e7\u00e3o: http://thinkpython2.com/code/reverse_pair.py.","title":"Exerc\u00edcio 10.11"},{"location":"10-listas/#exercicio-1012","text":"Duas palavras \u201cinterligam-se\u201d quando, ao tomarmos letras alternadas de cada uma, formamos uma palavra nova. Por exemplo, \u201cshoe\u201d e \u201ccold\u201d interligam-se para formar \u201cschooled\u201d. Solu\u00e7\u00e3o: http://thinkpython2.com/code/interlock.py. Cr\u00e9dito: este exerc\u00edcio foi inspirado por um exemplo em http://puzzlers.org. Escreva um programa que encontre todos os pares de palavras que se interligam. Dica: n\u00e3o enumere todos os pares! Voc\u00ea pode encontrar palavras que sejam interligadas de tr\u00eas em tr\u00eas; isto \u00e9, cada terceira letra forma uma palavra, come\u00e7ando da primeira, segunda ou terceira?","title":"Exerc\u00edcio 10.12"},{"location":"11-dicionarios/","text":"Cap\u00edtulo 11: Dicion\u00e1rios Este cap\u00edtulo apresenta outro tipo integrado chamado dicion\u00e1rio. Dicion\u00e1rios s\u00e3o um dos melhores recursos do Python; eles s\u00e3o os blocos de montar de muitos algoritmos eficientes e elegantes. 11.1 - Um dicion\u00e1rio \u00e9 um mapeamento Um dicion\u00e1rio se parece com uma lista, mas \u00e9 mais geral. Em uma lista, os \u00edndices t\u00eam que ser n\u00fameros inteiros; em um dicion\u00e1rio, eles podem ser de (quase) qualquer tipo. Um dicion\u00e1rio cont\u00e9m uma cole\u00e7\u00e3o de \u00edndices, que se chamam chaves e uma cole\u00e7\u00e3o de valores. Cada chave \u00e9 associada com um \u00fanico valor. A associa\u00e7\u00e3o de uma chave e um valor chama-se par chave-valor ou item. Em linguagem matem\u00e1tica, um dicion\u00e1rio representa um mapeamento de chaves a valores, para que voc\u00ea possa dizer que cada chave \u201cmostra o mapa a\u201d um valor. Como exemplo, vamos construir um dicion\u00e1rio que faz o mapa de palavras do ingl\u00eas ao espanhol, portanto as chaves e os valores s\u00e3o todos strings. A fun\u00e7\u00e3o dict cria um novo dicion\u00e1rio sem itens. Como dict \u00e9 o nome de uma fun\u00e7\u00e3o integrada, voc\u00ea deve evitar us\u00e1-lo como nome de vari\u00e1vel. >>> eng2sp = dict() >>> eng2sp {} As chaves {} representam um dicion\u00e1rio vazio. Para acrescentar itens ao dicion\u00e1rio, voc\u00ea pode usar colchetes: >>> eng2sp['one'] = 'uno' Esta linha cria um item que mapeia da chave 'one' ao valor 'uno'. Se imprimirmos o dicion\u00e1rio novamente, vemos um par chave-valor com dois pontos entre a chave e o valor: >>> eng2sp {'one': 'uno'} Este formato de sa\u00edda tamb\u00e9m \u00e9 um formato de entrada. Por exemplo, voc\u00ea pode criar um dicion\u00e1rio com tr\u00eas itens: >>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'} Por\u00e9m, se exibir eng2sp , pode se surpreender: >>> eng2sp {'one': 'uno', 'three': 'tres', 'two': 'dos'} A ordem dos pares chave-valor pode n\u00e3o ser a mesma. Se voc\u00ea digitar o mesmo exemplo no seu computador, pode receber um resultado diferente. Em geral, a ordem dos itens em um dicion\u00e1rio \u00e9 imprevis\u00edvel. No entanto, isso n\u00e3o \u00e9 um problema porque os elementos de um dicion\u00e1rio nunca s\u00e3o indexados com \u00edndices de n\u00fameros inteiros. Em vez disso, voc\u00ea usa as chaves para procurar os valores correspondentes: >>> eng2sp['two'] 'dos' A chave 'two' sempre mapeia ao valor 'dos' , assim a ordem dos itens n\u00e3o importa. Se a chave n\u00e3o estiver no dicion\u00e1rio, voc\u00ea recebe uma exce\u00e7\u00e3o: >>> eng2sp['four'] KeyError: 'four' A fun\u00e7\u00e3o len \u00e9 compat\u00edvel com dicion\u00e1rios; ela devolve o n\u00famero de pares chave-valor: >>> len(eng2sp) 3 O operador in funciona em dicion\u00e1rios tamb\u00e9m; ele acusa se algo aparece como chave no dicion\u00e1rio (aparecer como valor n\u00e3o \u00e9 o suficiente). >>> 'one' in eng2sp True >>> 'uno' in eng2sp False Para ver se algo aparece como um valor em um dicion\u00e1rio, voc\u00ea pode usar o m\u00e9todo values , que devolve uma cole\u00e7\u00e3o de valores, e ent\u00e3o usar o operador in : >>> vals = eng2sp.values() >>> 'uno' in vals True O operador in usa algoritmos diferentes para listas e dicion\u00e1rios. Para listas, ele procura os elementos da lista em ordem, como descrito em \u201cBusca\u201d, na p\u00e1gina 123. Conforme a lista torna-se mais longa, o tempo de busca tamb\u00e9m fica proporcionalmente mais longo. Para dicion\u00e1rios, o Python usa um algoritmo chamado hashtable (tabela de dispers\u00e3o), que tem uma propriedade not\u00e1vel: o operador in leva praticamente o mesmo tempo na busca, n\u00e3o importa quantos itens estejam no dicion\u00e1rio. Eu explico como isso \u00e9 poss\u00edvel em \u201cHashtables\u201d, na p\u00e1gina 302, mas a explica\u00e7\u00e3o pode n\u00e3o fazer sentido at\u00e9 que voc\u00ea tenha lido mais alguns cap\u00edtulos. 11.2 - Um dicion\u00e1rio como uma cole\u00e7\u00e3o de contadores Suponha que voc\u00ea receba uma string e queira contar quantas vezes cada letra aparece nela. H\u00e1 v\u00e1rios modos de fazer isso: Voc\u00ea pode criar 26 vari\u00e1veis, uma para cada letra do alfabeto. Ent\u00e3o pode atravessar a string e, para cada caractere, incrementar o contador correspondente, provavelmente usando uma condicional encadeada. Voc\u00ea pode criar uma lista com 26 elementos. Ent\u00e3o pode converter cada caractere em um n\u00famero (com a fun\u00e7\u00e3o integrada ord), usar o n\u00famero como \u00edndice na lista e incrementar o respectivo contador. Voc\u00ea pode criar um dicion\u00e1rio com caracteres como chaves e contadores como valores correspondentes. Na primeira vez que visse um caractere, voc\u00ea acrescentaria um item ao dicion\u00e1rio. Depois disso, incrementaria o valor de um item existente. Cada uma dessas op\u00e7\u00f5es executa o mesmo c\u00e1lculo, mas o implementa de forma diferente. Uma implementa\u00e7\u00e3o \u00e9 um modo de executar um c\u00e1lculo; algumas implementa\u00e7\u00f5es s\u00e3o melhores que outras. Por exemplo, uma vantagem da implementa\u00e7\u00e3o de dicion\u00e1rios \u00e9 que n\u00e3o precisamos saber de antem\u00e3o quais letras aparecem na string e s\u00f3 \u00e9 preciso criar espa\u00e7o para as letras que realmente venham a aparecer. O c\u00f3digo poderia ser assim: def histogram(s): d = dict() for c in s: if c not in d: d[c] = 1 else: d[c] += 1 return d O nome da fun\u00e7\u00e3o \u00e9 histogram , um termo estat\u00edstico para uma cole\u00e7\u00e3o de contadores (ou frequ\u00eancias). A primeira linha da fun\u00e7\u00e3o cria um dicion\u00e1rio vazio. O loop for atravessa a string. Cada vez que passa pelo loop, se o caractere c n\u00e3o estiver no dicion\u00e1rio, criamos um item com a chave c e o valor inicial 1 (pois j\u00e1 vimos esta letra uma vez). Se o c j\u00e1 estiver no dicion\u00e1rio, incrementamos d [c]. Funciona assim: >>> h = histogram('brontosaurus') >>> h {'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1} O histograma indica que as letras 'a' e 'b' aparecem uma vez; 'o' aparece duas vezes, e assim por diante. Os dicion\u00e1rios t\u00eam um m\u00e9todo chamado get , que toma uma chave e um valor padr\u00e3o. Se a chave aparecer no dicion\u00e1rio, get retorna o valor correspondente; se n\u00e3o for o caso, ele retorna o valor padr\u00e3o. Por exemplo: >>> h = histogram('a') >>> h {'a': 1} >>> h.get('a', 0) 1 >>> h.get('b', 0) 0 Como exerc\u00edcio, use o get para escrever a fun\u00e7\u00e3o histogram de forma mais concisa. Tente eliminar a instru\u00e7\u00e3o if . 11.3 - Loop e dicion\u00e1rios Se usar um dicion\u00e1rio em uma instru\u00e7\u00e3o for , ela percorre as chaves do dicion\u00e1rio. Por exemplo, print_hist exibe cada chave e o valor correspondente: def print_hist(h): for c in h: print(c, h[c]) Isso \u00e9 o que aparece: >>> h = histogram('parrot') >>> print_hist(h) a 1 p 1 r 2 t 1 o 1 Novamente, as chaves n\u00e3o est\u00e3o em nenhuma ordem determinada. Para atravessar as chaves em ordem ascendente, voc\u00ea pode usar a fun\u00e7\u00e3o integrada sorted : >>> for key in sorted(h): ... print(key, h[key]) a 1 o 1 p 1 r 2 t 1 11.4 - Busca reversa Considerando um dicion\u00e1rio d e uma chave k , \u00e9 f\u00e1cil encontrar o valor correspondente v = d [k] . Esta opera\u00e7\u00e3o chama-se busca. Mas e se voc\u00ea tiver v e quiser encontrar k ? Voc\u00ea tem dois problemas: em primeiro lugar, pode haver mais de uma chave que esteja mapeada ao valor v . Dependendo da aplica\u00e7\u00e3o, quem sabe voc\u00ea pode escolher um, ou talvez tenha de fazer uma lista que contenha todos eles. Em segundo lugar, n\u00e3o h\u00e1 sintaxe simples para fazer uma busca reversa; \u00e9 preciso procurar. Aqui est\u00e1 uma fun\u00e7\u00e3o que recebe um valor e retorna a primeira chave mapeada ao valor dado: def reverse_lookup(d, v): for k in d: if d[k] == v: return k raise LookupError() Essa fun\u00e7\u00e3o \u00e9 mais um exemplo do padr\u00e3o de busca, mas usa um recurso que ainda n\u00e3o t\u00ednhamos visto: raise . A instru\u00e7\u00e3o raise causa uma exce\u00e7\u00e3o; neste caso, causa um LookupError , que \u00e9 uma exce\u00e7\u00e3o integrada, usada para indicar que uma opera\u00e7\u00e3o de busca falhou. Se chegarmos ao fim do loop significa que v n\u00e3o aparece no dicion\u00e1rio como um valor, portanto apresentaremos uma exce\u00e7\u00e3o. Aqui est\u00e1 um exemplo de uma busca reversa bem sucedida: >>> h = histogram('parrot') >>> k = reverse_lookup(h, 2) >>> k 'r' E uma mal sucedida: >>> k = reverse_lookup(h, 3) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 5, in reverse_lookup LookupError O efeito causado por voc\u00ea ao apresentar uma exce\u00e7\u00e3o \u00e9 igual ao causado pelo Python quando faz o mesmo: ele exibe um traceback e uma mensagem de erro. A instru\u00e7\u00e3o raise pode receber uma mensagem de erro detalhada como argumento opcional. Por exemplo: >>> raise LookupError('value does not appear in the dictionary') Traceback (most recent call last): File \"<stdin>\", line 1, in ? LookupError: value does not appear in the dictionary Uma busca reversa \u00e9 muito mais lenta que uma busca no sentido normal; se for preciso faz\u00ea-lo muitas vezes, ou se o dicion\u00e1rio ficar muito grande, o desempenho do seu programa ser\u00e1 prejudicado. 11.5 - Dicion\u00e1rios e listas As listas podem aparecer como valores em um dicion\u00e1rio. Por exemplo, se voc\u00ea receber um dicion\u00e1rio que mapeie letras e frequ\u00eancias, \u00e9 uma boa ideia invert\u00ea-lo; isto \u00e9, crie um dicion\u00e1rio que mapeie de frequ\u00eancias a letras. Como pode haver v\u00e1rias letras com a mesma frequ\u00eancia, cada valor no dicion\u00e1rio invertido deve ser uma lista de letras. Aqui est\u00e1 uma fun\u00e7\u00e3o que inverte um dicion\u00e1rio: def invert_dict(d): inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] else: inverse[val].append(key) return inverse Cada vez que o programa passar pelo loop, a key recebe uma chave de d e val recebe o valor correspondente. Se val n\u00e3o estiver em inverse significa que n\u00e3o foi vista antes, ent\u00e3o criamos um item e o inicializamos com um item avulso (em ingl\u00eas, singleton, uma lista que cont\u00e9m um \u00fanico elemento). Se n\u00e3o for o caso \u00e9 porque vimos esse valor antes, ent\u00e3o acrescentamos a chave correspondente \u00e0 lista. Aqui est\u00e1 um exemplo: >>> hist = histogram('parrot') >>> hist {'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1} >>> inverse = invert_dict(hist) >>> inverse {1: ['a', 'p', 't', 'o'], 2: ['r']} A Figura 11.1 \u00e9 um diagrama de estado mostrando hist e inverse. Um dicion\u00e1rio \u00e9 representado como uma caixa com o tipo dict acima dela e os pares chave-valor no interior. Se os valores forem n\u00fameros inteiros, de ponto flutuante ou strings, desenho-os dentro da caixa, mas normalmente prefiro desenhar listas do lado de fora, para manter o diagrama simples. Figura 11.1 \u2013 Diagrama de estado de um dicion\u00e1rio e seu inverso. As listas podem ser valores em um dicion\u00e1rio, como mostra este exemplo, mas n\u00e3o podem ser chaves. Isso \u00e9 o que acontece se voc\u00ea tentar: >>> t = [1, 2, 3] >>> d = dict() >>> d[t] = 'oops' Traceback (most recent call last): File \"<stdin>\", line 1, in ? TypeError: list objects are unhashable J\u00e1 mencionei que um dicion\u00e1rio \u00e9 implementado usando uma hashtable e isso significa que \u00e9 preciso que as chaves possam ser hashable (que seja poss\u00edvel computar seu hash, e que este valor de hash seja imut\u00e1vel). hash \u00e9 uma fun\u00e7\u00e3o que recebe um valor (de qualquer tipo) e devolve um n\u00famero inteiro. Dicion\u00e1rios usam esses n\u00fameros inteiros, chamados valores hash , para guardar e buscar pares chave-valor. Este sistema funciona perfeitamente se as chaves forem imut\u00e1veis. Por\u00e9m, se as chaves s\u00e3o mut\u00e1veis, como listas, coisas ruins acontecem. Por exemplo, quando voc\u00ea cria um par chave-valor, o Python guarda a chave na posi\u00e7\u00e3o correspondente. Se voc\u00ea modificar a chave e ent\u00e3o guard\u00e1-la novamente, ela iria para uma posi\u00e7\u00e3o diferente. Nesse caso, voc\u00ea poderia ter duas entradas para a mesma chave, ou pode n\u00e3o conseguir encontrar uma chave. De qualquer forma, o dicion\u00e1rio n\u00e3o funcionaria corretamente. \u00c9 por isso que as chaves t\u00eam de ser hashable, e tipos mut\u00e1veis como listas, n\u00e3o s\u00e3o. A forma mais simples de resolver esta limita\u00e7\u00e3o \u00e9 usar tuplas, que ser\u00e3o vistas no pr\u00f3ximo cap\u00edtulo. Como os dicion\u00e1rios s\u00e3o mut\u00e1veis, eles n\u00e3o podem ser usados como chaves, mas podem ser usados como valores. 11.6 - Memos Se usou a fun\u00e7\u00e3o de fibonacci em \u201cMais um exemplo\u201d, na p\u00e1gina 101, pode ter notado que quanto maior o argumento dado mais tempo a fun\u00e7\u00e3o leva para ser executada. Al\u00e9m disso, o tempo de execu\u00e7\u00e3o aumenta rapidamente. Para entender por que, considere a Figura 11.2, que mostra o gr\u00e1fico de chamada de fibonacci com n=4. Figura 11.2 \u2013 Gr\u00e1fico de chamada para fibonacci . Um gr\u00e1fico de chamada mostra um conjunto de frames de fun\u00e7\u00e3o, com linhas que unem cada frame aos frames das fun\u00e7\u00f5es que chama. Na parte de cima do gr\u00e1fico, fibonacci com n=4 chama fibonacci com n=3 e n=2 . Por sua vez, fibonacci com n=3 chama fibonacci com n=2 e n=1 . E assim por diante. Conte quantas vezes fibonacci(0) e fibonacci(1) s\u00e3o chamadas. Essa \u00e9 uma solu\u00e7\u00e3o ineficiente para o problema, e piora conforme o argumento se torna maior. Uma solu\u00e7\u00e3o \u00e9 acompanhar os valores que j\u00e1 foram calculados, guardando-os em um dicion\u00e1rio. Um valor calculado anteriormente que \u00e9 guardado para uso posterior \u00e9 chamado de memo. Aqui est\u00e1 uma vers\u00e3o com memos de fibonacci : known = {0:0, 1:1} def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res known \u00e9 um dicion\u00e1rio que monitora os n\u00fameros de Fibonacci que j\u00e1 conhecemos. Come\u00e7a com dois itens: 0 mapeia a 0 e 1 mapeia a 1. Sempre que fibonacci \u00e9 chamada, ela verifica known . Se o resultado j\u00e1 estiver l\u00e1, pode voltar imediatamente. Se n\u00e3o for o caso, \u00e9 preciso calcular o novo valor, acrescent\u00e1-lo ao dicion\u00e1rio e devolv\u00ea-lo. Se voc\u00ea executar essa vers\u00e3o de fibonacci e a comparar com a original, descobrir\u00e1 que \u00e9 muito mais r\u00e1pida. 11.7 - Vari\u00e1veis globais No exemplo anterior, known \u00e9 criada fora da fun\u00e7\u00e3o, ent\u00e3o pertence ao frame especial chamado __main__ . As vari\u00e1veis em __main__ \u00e0s vezes s\u00e3o chamadas de globais, porque podem ser acessadas de qualquer fun\u00e7\u00e3o. Em contraste com as vari\u00e1veis locais, que desaparecem quando sua fun\u00e7\u00e3o termina, as vari\u00e1veis globais persistem de uma chamada da fun\u00e7\u00e3o \u00e0 seguinte. \u00c9 comum usar vari\u00e1veis globais para flags ; isto \u00e9, vari\u00e1veis booleanas que indicam (\u201cflag\u201d) se uma condi\u00e7\u00e3o \u00e9 verdadeira. Por exemplo, alguns programas usam um flag denominado verbose para controlar o n\u00edvel de detalhe da sa\u00edda: verbose = True def example1(): if verbose: print('Running example1') Se tentar reatribuir uma vari\u00e1vel global, voc\u00ea pode se surpreender. O pr\u00f3ximo exemplo mostra como acompanhar se a fun\u00e7\u00e3o foi chamada: been_called = False def example2(): been_called = True # ERRADO Por\u00e9m, se execut\u00e1-la, voc\u00ea ver\u00e1 que o valor de been_called n\u00e3o se altera. O problema \u00e9 que example2 cria uma nova vari\u00e1vel local chamada been_called . A vari\u00e1vel local some quando a fun\u00e7\u00e3o termina e n\u00e3o tem efeito sobre a vari\u00e1vel global. Para reatribuir uma vari\u00e1vel global dentro de uma fun\u00e7\u00e3o \u00e9 preciso declarar a vari\u00e1vel como global antes de us\u00e1-la: been_called = False def example2(): global been_called been_called = True A instru\u00e7\u00e3o global diz ao interpretador algo como \u201cNesta fun\u00e7\u00e3o, quando digo been_called , estou falando da vari\u00e1vel global; n\u00e3o crie uma local\u201d. Aqui est\u00e1 um exemplo que tenta atualizar uma vari\u00e1vel global: count = 0 def example3(): count = count + 1 # ERRADO Se execut\u00e1-la, voc\u00ea recebe: UnboundLocalError: local variable 'count' referenced before assignment O Python sup\u00f5e que count seja local, e dentro desta suposi\u00e7\u00e3o, a vari\u00e1vel est\u00e1 sendo lida antes de ser escrita. A solu\u00e7\u00e3o, mais uma vez, \u00e9 declarar count como global: def example3(): global count count += 1 Se uma vari\u00e1vel global se referir a um valor mut\u00e1vel, voc\u00ea pode alterar o valor sem declarar a vari\u00e1vel: known = {0:0, 1:1} def example4(): known[2] = 1 Ent\u00e3o voc\u00ea pode adicionar, retirar e substituir elementos de uma lista global ou dicion\u00e1rio, mas se quiser reatribuir a vari\u00e1vel, precisa declar\u00e1-la: def example5(): global known known = dict() As vari\u00e1veis globais podem ser \u00fateis, mas se voc\u00ea tiver muitas delas e alter\u00e1-las com frequ\u00eancia, isso poder\u00e1 dificultar a depura\u00e7\u00e3o do programa. 11.8 - Depura\u00e7\u00e3o Ao trabalhar com conjuntos de dados maiores, depurar exibindo e verificando a sa\u00edda \u00e0 m\u00e3o pode ser trabalhoso. Aqui est\u00e3o algumas sugest\u00f5es para depurar grandes conjuntos de dados: Reduza a entrada Se for poss\u00edvel, reduza o tamanho do conjunto de dados. Por exemplo, se o programa l\u00ea um arquivo de texto, comece com apenas as 10 primeiras linhas, ou com o menor exemplo que puder encontrar. Voc\u00ea pode editar os pr\u00f3prios arquivos ou alterar o programa para que leia s\u00f3 as primeiras n linhas (\u00e9 melhor). Se houver um erro, voc\u00ea pode reduzir n ao menor valor que manifeste o erro, e ent\u00e3o aument\u00e1-lo gradativamente at\u00e9 encontrar e corrigir o erro. Verifique os resumos e tipos Em vez de imprimir e verificar o conjunto de dados inteiro, pense em exibir resumos dos dados: por exemplo, o n\u00famero de itens em um dicion\u00e1rio ou o total de uma lista de n\u00fameros. Uma causa comum de erros em tempo de execu\u00e7\u00e3o s\u00e3o valores de tipo incompat\u00edvel. Para depurar essa esp\u00e9cie de erro, muitas vezes basta exibir o tipo de um valor. Crie autoverifica\u00e7\u00f5es \u00c9 poss\u00edvel escrever o c\u00f3digo para verificar erros automaticamente. Por exemplo, se estiver calculando a m\u00e9dia de uma lista de n\u00fameros, voc\u00ea pode verificar se o resultado n\u00e3o \u00e9 mais alto que o maior elemento da lista ou mais baixo que o menor. Isso \u00e9 chamado de \u201cverifica\u00e7\u00e3o de sanidade\u201d porque descobre resultados \u201cinsanos\u201d. Outro tipo de verifica\u00e7\u00e3o compara os resultados de dois c\u00e1lculos diferentes para ver se s\u00e3o consistentes. Isso \u00e9 chamado de \u201cverifica\u00e7\u00e3o de consist\u00eancia\u201d. Formate a sa\u00edda A formata\u00e7\u00e3o da sa\u00edda para depura\u00e7\u00e3o pode facilitar a busca de erros. Vimos um exemplo em \u201cDepura\u00e7\u00e3o\u201d, na p\u00e1gina 172. O m\u00f3dulo `pprint` apresenta uma fun\u00e7\u00e3o `pprint` que exibe tipos integrados em um formato mais leg\u00edvel para humanos (`pprint` \u00e9 a abrevia\u00e7\u00e3o de \u201cpretty print\u201d (bela exibi\u00e7\u00e3o)). Refor\u00e7ando, o tempo que voc\u00ea passar construindo o scaffolding (o andaime) pode reduzir o tempo de depura\u00e7\u00e3o. 11.9 - Gloss\u00e1rio mapeamento Rela\u00e7\u00e3o na qual cada elemento de um conjunto corresponde a um elemento de outro conjunto. dicion\u00e1rio Mapeamento de chaves aos seus valores correspondentes. par chave-valor Representa\u00e7\u00e3o do mapeamento de uma chave a um valor. item Em um dicion\u00e1rio, outro nome para um par chave-valor. chave Objeto que aparece em um dicion\u00e1rio como a primeira parte de um par chave-valor. valor Objeto que aparece em um dicion\u00e1rio como a segunda parte de um par chave-valor. Isso \u00e9 mais espec\u00edfico que o nosso uso anterior da palavra \u201cvalor\u201d. implementa\u00e7\u00e3o Uma forma de executar um c\u00e1lculo. hashtable Algoritmo usado para implementar dicion\u00e1rios de Python. fun\u00e7\u00e3o hash Fun\u00e7\u00e3o usada por uma hashtable para calcular a posi\u00e7\u00e3o de uma chave. hashable Um tipo que tem uma fun\u00e7\u00e3o hash. Tipos imut\u00e1veis como n\u00fameros inteiros, de ponto flutuante e strings s\u00e3o hashable; tipos mut\u00e1veis, como listas e dicion\u00e1rios, n\u00e3o s\u00e3o. busca Opera\u00e7\u00e3o de dicion\u00e1rio que recebe uma chave e encontra o valor correspondente. busca reversa Opera\u00e7\u00e3o de dicion\u00e1rio que recebe um valor e encontra uma ou v\u00e1rias chaves que o mapeiem. instru\u00e7\u00e3o raise Instru\u00e7\u00e3o que (deliberadamente) causa uma exce\u00e7\u00e3o. item avulso (singleton) Uma lista (ou outra sequ\u00eancia) com um \u00fanico elemento. gr\u00e1fico de chamada Um diagrama que mostra cada frame criado durante a execu\u00e7\u00e3o de um programa, com uma flecha apontando quem chama a quem \u00e9 chamado. memo Valor j\u00e1 calculado, guardado para n\u00e3o ter que fazer o mesmo c\u00e1lculo no futuro. vari\u00e1vel global Vari\u00e1vel definida fora de uma fun\u00e7\u00e3o. As vari\u00e1veis globais podem ser acessadas de qualquer fun\u00e7\u00e3o. instru\u00e7\u00e3o global Instru\u00e7\u00e3o que declara um nome de vari\u00e1vel global. flag Vari\u00e1vel booleana usada para indicar se uma condi\u00e7\u00e3o \u00e9 verdadeira. declara\u00e7\u00e3o Instru\u00e7\u00e3o tal como global, que diz ao interpretador algo a respeito de uma vari\u00e1vel. 11.10 - Exerc\u00edcios Exerc\u00edcio 11.1 Escreva uma fun\u00e7\u00e3o que leia as palavras em words.txt e guarde-as como chaves em um dicion\u00e1rio. N\u00e3o importa quais s\u00e3o os valores. Ent\u00e3o voc\u00ea pode usar o operador in como uma forma r\u00e1pida de verificar se uma string est\u00e1 no dicion\u00e1rio. Se fez o Exerc\u00edcio 10.10, voc\u00ea pode comparar a velocidade desta implementa\u00e7\u00e3o com o operador in de listas e a busca por bisse\u00e7\u00e3o. Exerc\u00edcio 11.2 Leia a documenta\u00e7\u00e3o do m\u00e9todo de dicion\u00e1rio setdefault e use-o para escrever uma vers\u00e3o mais concisa de invert_dict. Solu\u00e7\u00e3o: http://thinkpython2.com/code/invert_dict.py. Exerc\u00edcio 11.3 Memorize a fun\u00e7\u00e3o de Ackermann do Exerc\u00edcio 6.2 e veja se a memoriza\u00e7\u00e3o permite avaliar a fun\u00e7\u00e3o com argumentos maiores. Dica: n\u00e3o. Solu\u00e7\u00e3o: http://thinkpython2.com/code/ackermann_memo.py. Exerc\u00edcio 11.4 Se fez o Exerc\u00edcio 10.7, voc\u00ea j\u00e1 tem uma fun\u00e7\u00e3o chamada has_duplicates, que recebe uma lista como par\u00e2metro e retorna True se houver algum objeto que aparece mais de uma vez na lista. Use um dicion\u00e1rio para escrever uma vers\u00e3o mais r\u00e1pida e simples de has_duplicates. Solu\u00e7\u00e3o: http://thinkpython2.com/code/has_duplicates.py. Exerc\u00edcio 11.5 Duas palavras s\u00e3o \u201cpares rotacionados\u201d se for poss\u00edvel rotacionar um deles e chegar ao outro (ver rotate_word no Exerc\u00edcio 8.5). Escreva um programa que leia uma lista de palavras e encontre todos os pares rotacionados. Solu\u00e7\u00e3o: http://thinkpython2.com/code/rotate_pairs.py. Exerc\u00edcio 11.6 Aqui est\u00e1 outro quebra-cabe\u00e7a do programa Car Talk (http://www.cartalk.com/content/puzzlers): Ele foi enviado por Dan O\u2019Leary. Dan descobriu uma palavra comum, com uma s\u00edlaba e cinco letras que tem a seguinte propriedade \u00fanica. Ao removermos a primeira letra, as letras restantes formam um hom\u00f3fono da palavra original, que \u00e9 uma palavra que soa exatamente da mesma forma. Substitua a primeira letra, isto \u00e9, coloque-a de volta, retire a segunda letra e o resultado \u00e9 um outro hom\u00f3fono da palavra original. E a pergunta \u00e9, qual \u00e9 a palavra? Agora vou dar um exemplo que n\u00e3o funciona. Vamos usar a palavra de cinco letras, \u2018wrack\u2019 (mover, eliminar). W-R-A-C-K, como na express\u00e3o \u2018wrack with pain\u2019 (se contorcer de dor). Se eu retirar a primeira letra, sobra uma palavra de quatro letras, \u2018R-A-C-K\u2019 (galhada). Como na frase, \u2018Holy cow, did you see the rack on that buck! It must have been a nine-pointer!\u2019 (\u2018Minha nossa, voc\u00ea viu a galhada daquele cervo! Deve ter nove pontas!\u2019). \u00c9 um hom\u00f3fono perfeito. Se puser o \u2018w\u2019 de volta e retirar o \u2018r\u2019 em vez disso, sobra a palavra \u2018wack\u2019, que \u00e9 uma palavra de verdade, mas n\u00e3o \u00e9 um hom\u00f3fono das outras duas palavras. Mas h\u00e1 pelo menos uma palavra que Dan e eu conhecemos, que produz dois hom\u00f3fonos se voc\u00ea retirar qualquer uma das duas primeiras letras, e duas novas palavras de quatro letras s\u00e3o formadas. A pergunta \u00e9, qual \u00e9 a palavra? Voc\u00ea pode usar o dicion\u00e1rio do Exerc\u00edcio 11.1 para verificar se uma string est\u00e1 na lista de palavras. Para verificar se duas palavras s\u00e3o hom\u00f3fonas, voc\u00ea pode usar o Dicion\u00e1rio de pron\u00fancia CMU. Ele pode ser baixado em http://www.speech.cs.cmu.edu/cgi-bin/cmudict ou em http://thinkpython2.com/code/c06d. Voc\u00ea tamb\u00e9m pode baixar http://thinkpy thon2.com/code/pronounce.py, que tem uma fun\u00e7\u00e3o chamada read_dictionary , que l\u00ea o dicion\u00e1rio de pron\u00fancia e retorna um dicion\u00e1rio de Python que mapeia cada palavra a uma string que descreve sua pron\u00fancia prim\u00e1ria. Escreva um programa que liste todas as palavras que resolvem o quebra-cabe\u00e7a. Solu\u00e7\u00e3o: http://thinkpython2.com/code/homophone.py.","title":"Cap\u00edtulo 11: Dicion\u00e1rios"},{"location":"11-dicionarios/#capitulo-11-dicionarios","text":"Este cap\u00edtulo apresenta outro tipo integrado chamado dicion\u00e1rio. Dicion\u00e1rios s\u00e3o um dos melhores recursos do Python; eles s\u00e3o os blocos de montar de muitos algoritmos eficientes e elegantes.","title":"Cap\u00edtulo 11: Dicion\u00e1rios"},{"location":"11-dicionarios/#111-um-dicionario-e-um-mapeamento","text":"Um dicion\u00e1rio se parece com uma lista, mas \u00e9 mais geral. Em uma lista, os \u00edndices t\u00eam que ser n\u00fameros inteiros; em um dicion\u00e1rio, eles podem ser de (quase) qualquer tipo. Um dicion\u00e1rio cont\u00e9m uma cole\u00e7\u00e3o de \u00edndices, que se chamam chaves e uma cole\u00e7\u00e3o de valores. Cada chave \u00e9 associada com um \u00fanico valor. A associa\u00e7\u00e3o de uma chave e um valor chama-se par chave-valor ou item. Em linguagem matem\u00e1tica, um dicion\u00e1rio representa um mapeamento de chaves a valores, para que voc\u00ea possa dizer que cada chave \u201cmostra o mapa a\u201d um valor. Como exemplo, vamos construir um dicion\u00e1rio que faz o mapa de palavras do ingl\u00eas ao espanhol, portanto as chaves e os valores s\u00e3o todos strings. A fun\u00e7\u00e3o dict cria um novo dicion\u00e1rio sem itens. Como dict \u00e9 o nome de uma fun\u00e7\u00e3o integrada, voc\u00ea deve evitar us\u00e1-lo como nome de vari\u00e1vel. >>> eng2sp = dict() >>> eng2sp {} As chaves {} representam um dicion\u00e1rio vazio. Para acrescentar itens ao dicion\u00e1rio, voc\u00ea pode usar colchetes: >>> eng2sp['one'] = 'uno' Esta linha cria um item que mapeia da chave 'one' ao valor 'uno'. Se imprimirmos o dicion\u00e1rio novamente, vemos um par chave-valor com dois pontos entre a chave e o valor: >>> eng2sp {'one': 'uno'} Este formato de sa\u00edda tamb\u00e9m \u00e9 um formato de entrada. Por exemplo, voc\u00ea pode criar um dicion\u00e1rio com tr\u00eas itens: >>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'} Por\u00e9m, se exibir eng2sp , pode se surpreender: >>> eng2sp {'one': 'uno', 'three': 'tres', 'two': 'dos'} A ordem dos pares chave-valor pode n\u00e3o ser a mesma. Se voc\u00ea digitar o mesmo exemplo no seu computador, pode receber um resultado diferente. Em geral, a ordem dos itens em um dicion\u00e1rio \u00e9 imprevis\u00edvel. No entanto, isso n\u00e3o \u00e9 um problema porque os elementos de um dicion\u00e1rio nunca s\u00e3o indexados com \u00edndices de n\u00fameros inteiros. Em vez disso, voc\u00ea usa as chaves para procurar os valores correspondentes: >>> eng2sp['two'] 'dos' A chave 'two' sempre mapeia ao valor 'dos' , assim a ordem dos itens n\u00e3o importa. Se a chave n\u00e3o estiver no dicion\u00e1rio, voc\u00ea recebe uma exce\u00e7\u00e3o: >>> eng2sp['four'] KeyError: 'four' A fun\u00e7\u00e3o len \u00e9 compat\u00edvel com dicion\u00e1rios; ela devolve o n\u00famero de pares chave-valor: >>> len(eng2sp) 3 O operador in funciona em dicion\u00e1rios tamb\u00e9m; ele acusa se algo aparece como chave no dicion\u00e1rio (aparecer como valor n\u00e3o \u00e9 o suficiente). >>> 'one' in eng2sp True >>> 'uno' in eng2sp False Para ver se algo aparece como um valor em um dicion\u00e1rio, voc\u00ea pode usar o m\u00e9todo values , que devolve uma cole\u00e7\u00e3o de valores, e ent\u00e3o usar o operador in : >>> vals = eng2sp.values() >>> 'uno' in vals True O operador in usa algoritmos diferentes para listas e dicion\u00e1rios. Para listas, ele procura os elementos da lista em ordem, como descrito em \u201cBusca\u201d, na p\u00e1gina 123. Conforme a lista torna-se mais longa, o tempo de busca tamb\u00e9m fica proporcionalmente mais longo. Para dicion\u00e1rios, o Python usa um algoritmo chamado hashtable (tabela de dispers\u00e3o), que tem uma propriedade not\u00e1vel: o operador in leva praticamente o mesmo tempo na busca, n\u00e3o importa quantos itens estejam no dicion\u00e1rio. Eu explico como isso \u00e9 poss\u00edvel em \u201cHashtables\u201d, na p\u00e1gina 302, mas a explica\u00e7\u00e3o pode n\u00e3o fazer sentido at\u00e9 que voc\u00ea tenha lido mais alguns cap\u00edtulos.","title":"11.1 - Um dicion\u00e1rio \u00e9 um mapeamento"},{"location":"11-dicionarios/#112-um-dicionario-como-uma-colecao-de-contadores","text":"Suponha que voc\u00ea receba uma string e queira contar quantas vezes cada letra aparece nela. H\u00e1 v\u00e1rios modos de fazer isso: Voc\u00ea pode criar 26 vari\u00e1veis, uma para cada letra do alfabeto. Ent\u00e3o pode atravessar a string e, para cada caractere, incrementar o contador correspondente, provavelmente usando uma condicional encadeada. Voc\u00ea pode criar uma lista com 26 elementos. Ent\u00e3o pode converter cada caractere em um n\u00famero (com a fun\u00e7\u00e3o integrada ord), usar o n\u00famero como \u00edndice na lista e incrementar o respectivo contador. Voc\u00ea pode criar um dicion\u00e1rio com caracteres como chaves e contadores como valores correspondentes. Na primeira vez que visse um caractere, voc\u00ea acrescentaria um item ao dicion\u00e1rio. Depois disso, incrementaria o valor de um item existente. Cada uma dessas op\u00e7\u00f5es executa o mesmo c\u00e1lculo, mas o implementa de forma diferente. Uma implementa\u00e7\u00e3o \u00e9 um modo de executar um c\u00e1lculo; algumas implementa\u00e7\u00f5es s\u00e3o melhores que outras. Por exemplo, uma vantagem da implementa\u00e7\u00e3o de dicion\u00e1rios \u00e9 que n\u00e3o precisamos saber de antem\u00e3o quais letras aparecem na string e s\u00f3 \u00e9 preciso criar espa\u00e7o para as letras que realmente venham a aparecer. O c\u00f3digo poderia ser assim: def histogram(s): d = dict() for c in s: if c not in d: d[c] = 1 else: d[c] += 1 return d O nome da fun\u00e7\u00e3o \u00e9 histogram , um termo estat\u00edstico para uma cole\u00e7\u00e3o de contadores (ou frequ\u00eancias). A primeira linha da fun\u00e7\u00e3o cria um dicion\u00e1rio vazio. O loop for atravessa a string. Cada vez que passa pelo loop, se o caractere c n\u00e3o estiver no dicion\u00e1rio, criamos um item com a chave c e o valor inicial 1 (pois j\u00e1 vimos esta letra uma vez). Se o c j\u00e1 estiver no dicion\u00e1rio, incrementamos d [c]. Funciona assim: >>> h = histogram('brontosaurus') >>> h {'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1} O histograma indica que as letras 'a' e 'b' aparecem uma vez; 'o' aparece duas vezes, e assim por diante. Os dicion\u00e1rios t\u00eam um m\u00e9todo chamado get , que toma uma chave e um valor padr\u00e3o. Se a chave aparecer no dicion\u00e1rio, get retorna o valor correspondente; se n\u00e3o for o caso, ele retorna o valor padr\u00e3o. Por exemplo: >>> h = histogram('a') >>> h {'a': 1} >>> h.get('a', 0) 1 >>> h.get('b', 0) 0 Como exerc\u00edcio, use o get para escrever a fun\u00e7\u00e3o histogram de forma mais concisa. Tente eliminar a instru\u00e7\u00e3o if .","title":"11.2 - Um dicion\u00e1rio como uma cole\u00e7\u00e3o de contadores"},{"location":"11-dicionarios/#113-loop-e-dicionarios","text":"Se usar um dicion\u00e1rio em uma instru\u00e7\u00e3o for , ela percorre as chaves do dicion\u00e1rio. Por exemplo, print_hist exibe cada chave e o valor correspondente: def print_hist(h): for c in h: print(c, h[c]) Isso \u00e9 o que aparece: >>> h = histogram('parrot') >>> print_hist(h) a 1 p 1 r 2 t 1 o 1 Novamente, as chaves n\u00e3o est\u00e3o em nenhuma ordem determinada. Para atravessar as chaves em ordem ascendente, voc\u00ea pode usar a fun\u00e7\u00e3o integrada sorted : >>> for key in sorted(h): ... print(key, h[key]) a 1 o 1 p 1 r 2 t 1","title":"11.3 - Loop e dicion\u00e1rios"},{"location":"11-dicionarios/#114-busca-reversa","text":"Considerando um dicion\u00e1rio d e uma chave k , \u00e9 f\u00e1cil encontrar o valor correspondente v = d [k] . Esta opera\u00e7\u00e3o chama-se busca. Mas e se voc\u00ea tiver v e quiser encontrar k ? Voc\u00ea tem dois problemas: em primeiro lugar, pode haver mais de uma chave que esteja mapeada ao valor v . Dependendo da aplica\u00e7\u00e3o, quem sabe voc\u00ea pode escolher um, ou talvez tenha de fazer uma lista que contenha todos eles. Em segundo lugar, n\u00e3o h\u00e1 sintaxe simples para fazer uma busca reversa; \u00e9 preciso procurar. Aqui est\u00e1 uma fun\u00e7\u00e3o que recebe um valor e retorna a primeira chave mapeada ao valor dado: def reverse_lookup(d, v): for k in d: if d[k] == v: return k raise LookupError() Essa fun\u00e7\u00e3o \u00e9 mais um exemplo do padr\u00e3o de busca, mas usa um recurso que ainda n\u00e3o t\u00ednhamos visto: raise . A instru\u00e7\u00e3o raise causa uma exce\u00e7\u00e3o; neste caso, causa um LookupError , que \u00e9 uma exce\u00e7\u00e3o integrada, usada para indicar que uma opera\u00e7\u00e3o de busca falhou. Se chegarmos ao fim do loop significa que v n\u00e3o aparece no dicion\u00e1rio como um valor, portanto apresentaremos uma exce\u00e7\u00e3o. Aqui est\u00e1 um exemplo de uma busca reversa bem sucedida: >>> h = histogram('parrot') >>> k = reverse_lookup(h, 2) >>> k 'r' E uma mal sucedida: >>> k = reverse_lookup(h, 3) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 5, in reverse_lookup LookupError O efeito causado por voc\u00ea ao apresentar uma exce\u00e7\u00e3o \u00e9 igual ao causado pelo Python quando faz o mesmo: ele exibe um traceback e uma mensagem de erro. A instru\u00e7\u00e3o raise pode receber uma mensagem de erro detalhada como argumento opcional. Por exemplo: >>> raise LookupError('value does not appear in the dictionary') Traceback (most recent call last): File \"<stdin>\", line 1, in ? LookupError: value does not appear in the dictionary Uma busca reversa \u00e9 muito mais lenta que uma busca no sentido normal; se for preciso faz\u00ea-lo muitas vezes, ou se o dicion\u00e1rio ficar muito grande, o desempenho do seu programa ser\u00e1 prejudicado.","title":"11.4 - Busca reversa"},{"location":"11-dicionarios/#115-dicionarios-e-listas","text":"As listas podem aparecer como valores em um dicion\u00e1rio. Por exemplo, se voc\u00ea receber um dicion\u00e1rio que mapeie letras e frequ\u00eancias, \u00e9 uma boa ideia invert\u00ea-lo; isto \u00e9, crie um dicion\u00e1rio que mapeie de frequ\u00eancias a letras. Como pode haver v\u00e1rias letras com a mesma frequ\u00eancia, cada valor no dicion\u00e1rio invertido deve ser uma lista de letras. Aqui est\u00e1 uma fun\u00e7\u00e3o que inverte um dicion\u00e1rio: def invert_dict(d): inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] else: inverse[val].append(key) return inverse Cada vez que o programa passar pelo loop, a key recebe uma chave de d e val recebe o valor correspondente. Se val n\u00e3o estiver em inverse significa que n\u00e3o foi vista antes, ent\u00e3o criamos um item e o inicializamos com um item avulso (em ingl\u00eas, singleton, uma lista que cont\u00e9m um \u00fanico elemento). Se n\u00e3o for o caso \u00e9 porque vimos esse valor antes, ent\u00e3o acrescentamos a chave correspondente \u00e0 lista. Aqui est\u00e1 um exemplo: >>> hist = histogram('parrot') >>> hist {'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1} >>> inverse = invert_dict(hist) >>> inverse {1: ['a', 'p', 't', 'o'], 2: ['r']} A Figura 11.1 \u00e9 um diagrama de estado mostrando hist e inverse. Um dicion\u00e1rio \u00e9 representado como uma caixa com o tipo dict acima dela e os pares chave-valor no interior. Se os valores forem n\u00fameros inteiros, de ponto flutuante ou strings, desenho-os dentro da caixa, mas normalmente prefiro desenhar listas do lado de fora, para manter o diagrama simples. Figura 11.1 \u2013 Diagrama de estado de um dicion\u00e1rio e seu inverso. As listas podem ser valores em um dicion\u00e1rio, como mostra este exemplo, mas n\u00e3o podem ser chaves. Isso \u00e9 o que acontece se voc\u00ea tentar: >>> t = [1, 2, 3] >>> d = dict() >>> d[t] = 'oops' Traceback (most recent call last): File \"<stdin>\", line 1, in ? TypeError: list objects are unhashable J\u00e1 mencionei que um dicion\u00e1rio \u00e9 implementado usando uma hashtable e isso significa que \u00e9 preciso que as chaves possam ser hashable (que seja poss\u00edvel computar seu hash, e que este valor de hash seja imut\u00e1vel). hash \u00e9 uma fun\u00e7\u00e3o que recebe um valor (de qualquer tipo) e devolve um n\u00famero inteiro. Dicion\u00e1rios usam esses n\u00fameros inteiros, chamados valores hash , para guardar e buscar pares chave-valor. Este sistema funciona perfeitamente se as chaves forem imut\u00e1veis. Por\u00e9m, se as chaves s\u00e3o mut\u00e1veis, como listas, coisas ruins acontecem. Por exemplo, quando voc\u00ea cria um par chave-valor, o Python guarda a chave na posi\u00e7\u00e3o correspondente. Se voc\u00ea modificar a chave e ent\u00e3o guard\u00e1-la novamente, ela iria para uma posi\u00e7\u00e3o diferente. Nesse caso, voc\u00ea poderia ter duas entradas para a mesma chave, ou pode n\u00e3o conseguir encontrar uma chave. De qualquer forma, o dicion\u00e1rio n\u00e3o funcionaria corretamente. \u00c9 por isso que as chaves t\u00eam de ser hashable, e tipos mut\u00e1veis como listas, n\u00e3o s\u00e3o. A forma mais simples de resolver esta limita\u00e7\u00e3o \u00e9 usar tuplas, que ser\u00e3o vistas no pr\u00f3ximo cap\u00edtulo. Como os dicion\u00e1rios s\u00e3o mut\u00e1veis, eles n\u00e3o podem ser usados como chaves, mas podem ser usados como valores.","title":"11.5 - Dicion\u00e1rios e listas"},{"location":"11-dicionarios/#116-memos","text":"Se usou a fun\u00e7\u00e3o de fibonacci em \u201cMais um exemplo\u201d, na p\u00e1gina 101, pode ter notado que quanto maior o argumento dado mais tempo a fun\u00e7\u00e3o leva para ser executada. Al\u00e9m disso, o tempo de execu\u00e7\u00e3o aumenta rapidamente. Para entender por que, considere a Figura 11.2, que mostra o gr\u00e1fico de chamada de fibonacci com n=4. Figura 11.2 \u2013 Gr\u00e1fico de chamada para fibonacci . Um gr\u00e1fico de chamada mostra um conjunto de frames de fun\u00e7\u00e3o, com linhas que unem cada frame aos frames das fun\u00e7\u00f5es que chama. Na parte de cima do gr\u00e1fico, fibonacci com n=4 chama fibonacci com n=3 e n=2 . Por sua vez, fibonacci com n=3 chama fibonacci com n=2 e n=1 . E assim por diante. Conte quantas vezes fibonacci(0) e fibonacci(1) s\u00e3o chamadas. Essa \u00e9 uma solu\u00e7\u00e3o ineficiente para o problema, e piora conforme o argumento se torna maior. Uma solu\u00e7\u00e3o \u00e9 acompanhar os valores que j\u00e1 foram calculados, guardando-os em um dicion\u00e1rio. Um valor calculado anteriormente que \u00e9 guardado para uso posterior \u00e9 chamado de memo. Aqui est\u00e1 uma vers\u00e3o com memos de fibonacci : known = {0:0, 1:1} def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res known \u00e9 um dicion\u00e1rio que monitora os n\u00fameros de Fibonacci que j\u00e1 conhecemos. Come\u00e7a com dois itens: 0 mapeia a 0 e 1 mapeia a 1. Sempre que fibonacci \u00e9 chamada, ela verifica known . Se o resultado j\u00e1 estiver l\u00e1, pode voltar imediatamente. Se n\u00e3o for o caso, \u00e9 preciso calcular o novo valor, acrescent\u00e1-lo ao dicion\u00e1rio e devolv\u00ea-lo. Se voc\u00ea executar essa vers\u00e3o de fibonacci e a comparar com a original, descobrir\u00e1 que \u00e9 muito mais r\u00e1pida.","title":"11.6 - Memos"},{"location":"11-dicionarios/#117-variaveis-globais","text":"No exemplo anterior, known \u00e9 criada fora da fun\u00e7\u00e3o, ent\u00e3o pertence ao frame especial chamado __main__ . As vari\u00e1veis em __main__ \u00e0s vezes s\u00e3o chamadas de globais, porque podem ser acessadas de qualquer fun\u00e7\u00e3o. Em contraste com as vari\u00e1veis locais, que desaparecem quando sua fun\u00e7\u00e3o termina, as vari\u00e1veis globais persistem de uma chamada da fun\u00e7\u00e3o \u00e0 seguinte. \u00c9 comum usar vari\u00e1veis globais para flags ; isto \u00e9, vari\u00e1veis booleanas que indicam (\u201cflag\u201d) se uma condi\u00e7\u00e3o \u00e9 verdadeira. Por exemplo, alguns programas usam um flag denominado verbose para controlar o n\u00edvel de detalhe da sa\u00edda: verbose = True def example1(): if verbose: print('Running example1') Se tentar reatribuir uma vari\u00e1vel global, voc\u00ea pode se surpreender. O pr\u00f3ximo exemplo mostra como acompanhar se a fun\u00e7\u00e3o foi chamada: been_called = False def example2(): been_called = True # ERRADO Por\u00e9m, se execut\u00e1-la, voc\u00ea ver\u00e1 que o valor de been_called n\u00e3o se altera. O problema \u00e9 que example2 cria uma nova vari\u00e1vel local chamada been_called . A vari\u00e1vel local some quando a fun\u00e7\u00e3o termina e n\u00e3o tem efeito sobre a vari\u00e1vel global. Para reatribuir uma vari\u00e1vel global dentro de uma fun\u00e7\u00e3o \u00e9 preciso declarar a vari\u00e1vel como global antes de us\u00e1-la: been_called = False def example2(): global been_called been_called = True A instru\u00e7\u00e3o global diz ao interpretador algo como \u201cNesta fun\u00e7\u00e3o, quando digo been_called , estou falando da vari\u00e1vel global; n\u00e3o crie uma local\u201d. Aqui est\u00e1 um exemplo que tenta atualizar uma vari\u00e1vel global: count = 0 def example3(): count = count + 1 # ERRADO Se execut\u00e1-la, voc\u00ea recebe: UnboundLocalError: local variable 'count' referenced before assignment O Python sup\u00f5e que count seja local, e dentro desta suposi\u00e7\u00e3o, a vari\u00e1vel est\u00e1 sendo lida antes de ser escrita. A solu\u00e7\u00e3o, mais uma vez, \u00e9 declarar count como global: def example3(): global count count += 1 Se uma vari\u00e1vel global se referir a um valor mut\u00e1vel, voc\u00ea pode alterar o valor sem declarar a vari\u00e1vel: known = {0:0, 1:1} def example4(): known[2] = 1 Ent\u00e3o voc\u00ea pode adicionar, retirar e substituir elementos de uma lista global ou dicion\u00e1rio, mas se quiser reatribuir a vari\u00e1vel, precisa declar\u00e1-la: def example5(): global known known = dict() As vari\u00e1veis globais podem ser \u00fateis, mas se voc\u00ea tiver muitas delas e alter\u00e1-las com frequ\u00eancia, isso poder\u00e1 dificultar a depura\u00e7\u00e3o do programa.","title":"11.7 - Vari\u00e1veis globais"},{"location":"11-dicionarios/#118-depuracao","text":"Ao trabalhar com conjuntos de dados maiores, depurar exibindo e verificando a sa\u00edda \u00e0 m\u00e3o pode ser trabalhoso. Aqui est\u00e3o algumas sugest\u00f5es para depurar grandes conjuntos de dados: Reduza a entrada Se for poss\u00edvel, reduza o tamanho do conjunto de dados. Por exemplo, se o programa l\u00ea um arquivo de texto, comece com apenas as 10 primeiras linhas, ou com o menor exemplo que puder encontrar. Voc\u00ea pode editar os pr\u00f3prios arquivos ou alterar o programa para que leia s\u00f3 as primeiras n linhas (\u00e9 melhor). Se houver um erro, voc\u00ea pode reduzir n ao menor valor que manifeste o erro, e ent\u00e3o aument\u00e1-lo gradativamente at\u00e9 encontrar e corrigir o erro. Verifique os resumos e tipos Em vez de imprimir e verificar o conjunto de dados inteiro, pense em exibir resumos dos dados: por exemplo, o n\u00famero de itens em um dicion\u00e1rio ou o total de uma lista de n\u00fameros. Uma causa comum de erros em tempo de execu\u00e7\u00e3o s\u00e3o valores de tipo incompat\u00edvel. Para depurar essa esp\u00e9cie de erro, muitas vezes basta exibir o tipo de um valor. Crie autoverifica\u00e7\u00f5es \u00c9 poss\u00edvel escrever o c\u00f3digo para verificar erros automaticamente. Por exemplo, se estiver calculando a m\u00e9dia de uma lista de n\u00fameros, voc\u00ea pode verificar se o resultado n\u00e3o \u00e9 mais alto que o maior elemento da lista ou mais baixo que o menor. Isso \u00e9 chamado de \u201cverifica\u00e7\u00e3o de sanidade\u201d porque descobre resultados \u201cinsanos\u201d. Outro tipo de verifica\u00e7\u00e3o compara os resultados de dois c\u00e1lculos diferentes para ver se s\u00e3o consistentes. Isso \u00e9 chamado de \u201cverifica\u00e7\u00e3o de consist\u00eancia\u201d. Formate a sa\u00edda A formata\u00e7\u00e3o da sa\u00edda para depura\u00e7\u00e3o pode facilitar a busca de erros. Vimos um exemplo em \u201cDepura\u00e7\u00e3o\u201d, na p\u00e1gina 172. O m\u00f3dulo `pprint` apresenta uma fun\u00e7\u00e3o `pprint` que exibe tipos integrados em um formato mais leg\u00edvel para humanos (`pprint` \u00e9 a abrevia\u00e7\u00e3o de \u201cpretty print\u201d (bela exibi\u00e7\u00e3o)). Refor\u00e7ando, o tempo que voc\u00ea passar construindo o scaffolding (o andaime) pode reduzir o tempo de depura\u00e7\u00e3o.","title":"11.8 - Depura\u00e7\u00e3o"},{"location":"11-dicionarios/#119-glossario","text":"mapeamento Rela\u00e7\u00e3o na qual cada elemento de um conjunto corresponde a um elemento de outro conjunto. dicion\u00e1rio Mapeamento de chaves aos seus valores correspondentes. par chave-valor Representa\u00e7\u00e3o do mapeamento de uma chave a um valor. item Em um dicion\u00e1rio, outro nome para um par chave-valor. chave Objeto que aparece em um dicion\u00e1rio como a primeira parte de um par chave-valor. valor Objeto que aparece em um dicion\u00e1rio como a segunda parte de um par chave-valor. Isso \u00e9 mais espec\u00edfico que o nosso uso anterior da palavra \u201cvalor\u201d. implementa\u00e7\u00e3o Uma forma de executar um c\u00e1lculo. hashtable Algoritmo usado para implementar dicion\u00e1rios de Python. fun\u00e7\u00e3o hash Fun\u00e7\u00e3o usada por uma hashtable para calcular a posi\u00e7\u00e3o de uma chave. hashable Um tipo que tem uma fun\u00e7\u00e3o hash. Tipos imut\u00e1veis como n\u00fameros inteiros, de ponto flutuante e strings s\u00e3o hashable; tipos mut\u00e1veis, como listas e dicion\u00e1rios, n\u00e3o s\u00e3o. busca Opera\u00e7\u00e3o de dicion\u00e1rio que recebe uma chave e encontra o valor correspondente. busca reversa Opera\u00e7\u00e3o de dicion\u00e1rio que recebe um valor e encontra uma ou v\u00e1rias chaves que o mapeiem. instru\u00e7\u00e3o raise Instru\u00e7\u00e3o que (deliberadamente) causa uma exce\u00e7\u00e3o. item avulso (singleton) Uma lista (ou outra sequ\u00eancia) com um \u00fanico elemento. gr\u00e1fico de chamada Um diagrama que mostra cada frame criado durante a execu\u00e7\u00e3o de um programa, com uma flecha apontando quem chama a quem \u00e9 chamado. memo Valor j\u00e1 calculado, guardado para n\u00e3o ter que fazer o mesmo c\u00e1lculo no futuro. vari\u00e1vel global Vari\u00e1vel definida fora de uma fun\u00e7\u00e3o. As vari\u00e1veis globais podem ser acessadas de qualquer fun\u00e7\u00e3o. instru\u00e7\u00e3o global Instru\u00e7\u00e3o que declara um nome de vari\u00e1vel global. flag Vari\u00e1vel booleana usada para indicar se uma condi\u00e7\u00e3o \u00e9 verdadeira. declara\u00e7\u00e3o Instru\u00e7\u00e3o tal como global, que diz ao interpretador algo a respeito de uma vari\u00e1vel.","title":"11.9 - Gloss\u00e1rio"},{"location":"11-dicionarios/#1110-exercicios","text":"","title":"11.10 - Exerc\u00edcios"},{"location":"11-dicionarios/#exercicio-111","text":"Escreva uma fun\u00e7\u00e3o que leia as palavras em words.txt e guarde-as como chaves em um dicion\u00e1rio. N\u00e3o importa quais s\u00e3o os valores. Ent\u00e3o voc\u00ea pode usar o operador in como uma forma r\u00e1pida de verificar se uma string est\u00e1 no dicion\u00e1rio. Se fez o Exerc\u00edcio 10.10, voc\u00ea pode comparar a velocidade desta implementa\u00e7\u00e3o com o operador in de listas e a busca por bisse\u00e7\u00e3o.","title":"Exerc\u00edcio 11.1"},{"location":"11-dicionarios/#exercicio-112","text":"Leia a documenta\u00e7\u00e3o do m\u00e9todo de dicion\u00e1rio setdefault e use-o para escrever uma vers\u00e3o mais concisa de invert_dict. Solu\u00e7\u00e3o: http://thinkpython2.com/code/invert_dict.py.","title":"Exerc\u00edcio 11.2"},{"location":"11-dicionarios/#exercicio-113","text":"Memorize a fun\u00e7\u00e3o de Ackermann do Exerc\u00edcio 6.2 e veja se a memoriza\u00e7\u00e3o permite avaliar a fun\u00e7\u00e3o com argumentos maiores. Dica: n\u00e3o. Solu\u00e7\u00e3o: http://thinkpython2.com/code/ackermann_memo.py.","title":"Exerc\u00edcio 11.3"},{"location":"11-dicionarios/#exercicio-114","text":"Se fez o Exerc\u00edcio 10.7, voc\u00ea j\u00e1 tem uma fun\u00e7\u00e3o chamada has_duplicates, que recebe uma lista como par\u00e2metro e retorna True se houver algum objeto que aparece mais de uma vez na lista. Use um dicion\u00e1rio para escrever uma vers\u00e3o mais r\u00e1pida e simples de has_duplicates. Solu\u00e7\u00e3o: http://thinkpython2.com/code/has_duplicates.py.","title":"Exerc\u00edcio 11.4"},{"location":"11-dicionarios/#exercicio-115","text":"Duas palavras s\u00e3o \u201cpares rotacionados\u201d se for poss\u00edvel rotacionar um deles e chegar ao outro (ver rotate_word no Exerc\u00edcio 8.5). Escreva um programa que leia uma lista de palavras e encontre todos os pares rotacionados. Solu\u00e7\u00e3o: http://thinkpython2.com/code/rotate_pairs.py.","title":"Exerc\u00edcio 11.5"},{"location":"11-dicionarios/#exercicio-116","text":"Aqui est\u00e1 outro quebra-cabe\u00e7a do programa Car Talk (http://www.cartalk.com/content/puzzlers): Ele foi enviado por Dan O\u2019Leary. Dan descobriu uma palavra comum, com uma s\u00edlaba e cinco letras que tem a seguinte propriedade \u00fanica. Ao removermos a primeira letra, as letras restantes formam um hom\u00f3fono da palavra original, que \u00e9 uma palavra que soa exatamente da mesma forma. Substitua a primeira letra, isto \u00e9, coloque-a de volta, retire a segunda letra e o resultado \u00e9 um outro hom\u00f3fono da palavra original. E a pergunta \u00e9, qual \u00e9 a palavra? Agora vou dar um exemplo que n\u00e3o funciona. Vamos usar a palavra de cinco letras, \u2018wrack\u2019 (mover, eliminar). W-R-A-C-K, como na express\u00e3o \u2018wrack with pain\u2019 (se contorcer de dor). Se eu retirar a primeira letra, sobra uma palavra de quatro letras, \u2018R-A-C-K\u2019 (galhada). Como na frase, \u2018Holy cow, did you see the rack on that buck! It must have been a nine-pointer!\u2019 (\u2018Minha nossa, voc\u00ea viu a galhada daquele cervo! Deve ter nove pontas!\u2019). \u00c9 um hom\u00f3fono perfeito. Se puser o \u2018w\u2019 de volta e retirar o \u2018r\u2019 em vez disso, sobra a palavra \u2018wack\u2019, que \u00e9 uma palavra de verdade, mas n\u00e3o \u00e9 um hom\u00f3fono das outras duas palavras. Mas h\u00e1 pelo menos uma palavra que Dan e eu conhecemos, que produz dois hom\u00f3fonos se voc\u00ea retirar qualquer uma das duas primeiras letras, e duas novas palavras de quatro letras s\u00e3o formadas. A pergunta \u00e9, qual \u00e9 a palavra? Voc\u00ea pode usar o dicion\u00e1rio do Exerc\u00edcio 11.1 para verificar se uma string est\u00e1 na lista de palavras. Para verificar se duas palavras s\u00e3o hom\u00f3fonas, voc\u00ea pode usar o Dicion\u00e1rio de pron\u00fancia CMU. Ele pode ser baixado em http://www.speech.cs.cmu.edu/cgi-bin/cmudict ou em http://thinkpython2.com/code/c06d. Voc\u00ea tamb\u00e9m pode baixar http://thinkpy thon2.com/code/pronounce.py, que tem uma fun\u00e7\u00e3o chamada read_dictionary , que l\u00ea o dicion\u00e1rio de pron\u00fancia e retorna um dicion\u00e1rio de Python que mapeia cada palavra a uma string que descreve sua pron\u00fancia prim\u00e1ria. Escreva um programa que liste todas as palavras que resolvem o quebra-cabe\u00e7a. Solu\u00e7\u00e3o: http://thinkpython2.com/code/homophone.py.","title":"Exerc\u00edcio 11.6"},{"location":"12-tuplas/","text":"Cap\u00edtulo 12: Tuplas Este cap\u00edtulo apresenta mais um tipo integrado, a tupla, e descreve como as listas, os dicion\u00e1rios e as tuplas trabalham juntos. Al\u00e9m disso, apresento um recurso \u00fatil para listas de argumentos de comprimento vari\u00e1vel: os operadores gather e scatter. Uma observa\u00e7\u00e3o: n\u00e3o h\u00e1 consenso sobre como pronunciar \u201ctuple\u201d (em ingl\u00eas). Algumas pessoas dizem \u201ctuhple\u201d, que rima com \u201csupple\u201d. Por\u00e9m, no contexto da programa\u00e7\u00e3o, a maioria das pessoas diz \u201ctoo-ple\u201d, que rima com \u201cquadruple\u201d. 12.1 - Tuplas s\u00e3o imut\u00e1veis Uma tupla \u00e9 uma sequ\u00eancia de valores. Os valores podem ser de qualquer tipo, e podem ser indexados por n\u00fameros inteiros, portanto, nesse sentido, as tuplas s\u00e3o muito parecidas com as listas. A diferen\u00e7a importante \u00e9 que as tuplas s\u00e3o imut\u00e1veis. Sintaticamente, uma tupla \u00e9 uma lista de valores separados por v\u00edrgulas: >>> t = 'a', 'b', 'c', 'd', 'e' Embora n\u00e3o seja sempre necess\u00e1rio, \u00e9 comum colocar tuplas entre par\u00eanteses: >>> t = ('a', 'b', 'c', 'd', 'e') Para criar uma tupla com um \u00fanico elemento, \u00e9 preciso incluir uma v\u00edrgula final: >>> t1 = 'a', >>> type(t1) <class 'tuple'> Um \u00fanico valor entre par\u00eanteses n\u00e3o \u00e9 uma tupla: >>> t2 = ('a') >>> type(t2) <class 'str'> Outra forma de criar uma tupla \u00e9 com a fun\u00e7\u00e3o integrada tuple . Sem argumentos, cria uma tupla vazia: >>> t = tuple() >>> t () Se os argumentos forem uma sequ\u00eancia (string, lista ou tupla), o resultado \u00e9 uma tupla com os elementos da sequ\u00eancia: >>> t = tuple('lupins') >>> t ('l', 'u', 'p', 'i', 'n', 's') Como tuple \u00e9 o nome de uma fun\u00e7\u00e3o integrada, voc\u00ea deve evitar us\u00e1-lo como nome de vari\u00e1vel. A maior parte dos operadores de lista tamb\u00e9m funciona em tuplas. O operador de colchetes indexa um elemento: >>> t = ('a', 'b', 'c', 'd', 'e') >>> t[0] 'a' E o operador de fatia seleciona v\u00e1rios elementos: >>> t[1:3] ('b', 'c') Entretanto, se tentar alterar um dos elementos da tupla, vai receber um erro: >>> t[0] = 'A' TypeError: object doesn't support item assignment Como tuplas s\u00e3o imut\u00e1veis, voc\u00ea n\u00e3o pode alterar os elementos, mas pode substituir uma tupla por outra: >>> t = ('A',) + t[1:] >>> t ('A', 'b', 'c', 'd', 'e') Essa instru\u00e7\u00e3o faz uma nova tupla e ent\u00e3o a atribui a t . Os operadores relacionais funcionam com tuplas e outras sequ\u00eancias; o Python come\u00e7a comparando o primeiro elemento de cada sequ\u00eancia. Se forem iguais, vai para os pr\u00f3ximos elementos, e assim por diante, at\u00e9 que encontre elementos que sejam diferentes. Os elementos subsequentes n\u00e3o s\u00e3o considerados (mesmo se forem muito grandes). >>> (0, 1, 2) < (0, 3, 4) True >>> (0, 1, 2000000) < (0, 3, 4) True 12.2 - Atribui\u00e7\u00e3o de tuplas Muitas vezes, \u00e9 \u00fatil trocar os valores de duas vari\u00e1veis. Com a atribui\u00e7\u00e3o convencional, \u00e9 preciso usar uma vari\u00e1vel tempor\u00e1ria. Por exemplo, trocar a e b. >>> temp = a >>> a = b >>> b = temp Essa solu\u00e7\u00e3o \u00e9 trabalhosa; a atribui\u00e7\u00e3o de tuplas \u00e9 mais elegante: >>> a, b = b, a O lado esquerdo \u00e9 uma tupla de vari\u00e1veis; o lado direito \u00e9 uma tupla de express\u00f5es. Cada valor \u00e9 atribu\u00eddo \u00e0 sua respectiva vari\u00e1vel. Todas as express\u00f5es no lado direito s\u00e3o avaliadas antes de todas as atribui\u00e7\u00f5es. O n\u00famero de vari\u00e1veis \u00e0 esquerda e o n\u00famero de valores \u00e0 direita precisam ser iguais: >>> a, b = 1, 2, 3 ValueError: too many values to unpack De forma geral, o lado direito pode ter qualquer tipo de sequ\u00eancia (string, lista ou tupla). Por exemplo, para dividir um endere\u00e7o de email em um nome de usu\u00e1rio e um dom\u00ednio, voc\u00ea poderia escrever: >>> addr = 'monty@python.org' >>> uname, domain = addr.split('@') O valor de retorno do split \u00e9 uma lista com dois elementos; o primeiro elemento \u00e9 atribu\u00eddo a uname , o segundo a domain : >>> uname 'monty' >>> domain 'python.org' 12.3 - Tuplas como valores de retorno Falando estritamente, uma fun\u00e7\u00e3o s\u00f3 pode retornar um valor, mas se o valor for uma tupla, o efeito \u00e9 o mesmo que retornar valores m\u00faltiplos. Por exemplo, se voc\u00ea quiser dividir dois n\u00fameros inteiros e calcular o quociente e resto, n\u00e3o \u00e9 eficiente calcular x/y e depois x%y. \u00c9 melhor calcular ambos ao mesmo tempo. A fun\u00e7\u00e3o integrada divmod toma dois argumentos e devolve uma tupla de dois valores: o quociente e o resto. Voc\u00ea pode guardar o resultado como uma tupla: >>> t = divmod(7, 3) >>> t (2, 1) Ou usar a atribui\u00e7\u00e3o de tuplas para guardar os elementos separadamente: >>> quot, rem = divmod(7, 3) >>> quot 2 >>> rem 1 Aqui est\u00e1 um exemplo de fun\u00e7\u00e3o que retorna uma tupla: def min_max(t): return min(t), max(t) max e min s\u00e3o fun\u00e7\u00f5es integradas que encontram os maiores e menores elementos de uma sequ\u00eancia. min_max calcula ambos e retorna uma tupla de dois valores. 12.4 - Tuplas com argumentos de comprimento vari\u00e1vel As fun\u00e7\u00f5es podem receber um n\u00famero vari\u00e1vel de argumentos. Um nome de par\u00e2metro que comece com * re\u00fane v\u00e1rios argumentos em uma tupla. Por exemplo, printall recebe qualquer n\u00famero de argumentos e os exibe: def printall(*args): print(args) O par\u00e2metro com o prefixo * pode ter qualquer nome que voc\u00ea goste, mas args \u00e9 o convencional. \u00c9 assim que a fun\u00e7\u00e3o funciona: >>> printall(1, 2.0, '3') (1, 2.0, '3') O complemento de reunir \u00e9 espalhar. Se voc\u00ea tiver uma sequ\u00eancia de valores e quiser pass\u00e1-la a uma fun\u00e7\u00e3o como argumentos m\u00faltiplos, pode usar o operador * . Por exemplo, o divmod recebe exatamente dois argumentos; ele n\u00e3o funciona com uma tupla: >>> t = (7, 3) >>> divmod(t) TypeError: divmod expected 2 arguments, got 1 No entanto, se voc\u00ea espalhar a tupla, a\u00ed funciona: >>> divmod(*t) (2, 1) Muitas das fun\u00e7\u00f5es integradas usam tuplas com argumentos de comprimento vari\u00e1vel. Por exemplo, max e min podem receber qualquer n\u00famero de argumentos: >>> max(1, 2, 3) 3 Mas sum, n\u00e3o: >>> sum(1, 2, 3) TypeError: sum expected at most 2 arguments, got 3 Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada sumall que receba qualquer n\u00famero de argumentos e retorne a soma deles. 12.5 - Listas e tuplas zip \u00e9 uma fun\u00e7\u00e3o integrada que recebe duas ou mais sequ\u00eancias e devolve uma lista de tuplas onde cada tupla cont\u00e9m um elemento de cada sequ\u00eancia. O nome da fun\u00e7\u00e3o tem a ver com o z\u00edper, que se junta e encaixa duas carreiras de dentes. Este exemplo encaixa uma string e uma lista: >>> s = 'abc' >>> t = [0, 1, 2] >>> zip(s, t) <zip object at 0x7f7d0a9e7c48> O resultado \u00e9 um objeto zip que sabe como percorrer os pares. O uso mais comum de zip \u00e9 em um loop for : >>> for pair in zip(s, t): ... print(pair) ... ('a', 0) ('b', 1) ('c', 2) Um objeto zip \u00e9 um tipo de iterador, ou seja, qualquer objeto que percorre ou itera sobre uma sequ\u00eancia. Iteradores s\u00e3o semelhantes a listas em alguns aspectos, mas, ao contr\u00e1rio de listas, n\u00e3o \u00e9 poss\u00edvel usar um \u00edndice para selecionar um elemento de um iterador. Se quiser usar operadores e m\u00e9todos de lista, voc\u00ea pode usar um objeto zip para fazer uma lista: >>> list(zip(s, t)) [('a', 0), ('b', 1), ('c', 2)] O resultado \u00e9 uma lista de tuplas; neste exemplo, cada tupla cont\u00e9m um caractere da string e o elemento correspondente da lista. Se as sequ\u00eancias n\u00e3o forem do mesmo comprimento, o resultado tem o comprimento da mais curta: >>> list(zip('Anne', 'Elk')) [('A', 'E'), ('n', 'l'), ('n', 'k')] Voc\u00ea pode usar a atribui\u00e7\u00e3o de tuplas em um loop for para atravessar uma lista de tuplas: t = [('a', 0), ('b', 1), ('c', 2)] for letter, number in t: print(number, letter) Cada vez que o programa passa pelo loop, o Python seleciona a pr\u00f3xima tupla na lista e atribui os elementos letter e number. A sa\u00edda deste loop \u00e9: 0 a 1 b 2 c Se combinar zip , for e atribui\u00e7\u00e3o de tuplas, voc\u00ea pode fazer uma express\u00e3o \u00fatil para percorrer duas (ou mais) sequ\u00eancias ao mesmo tempo. Por exemplo, has_match recebe duas sequ\u00eancias, t1 e t2 e retorna True se houver um \u00edndice i tal que t1[i] == t2[i] : def has_match(t1, t2): for x, y in zip(t1, t2): if x == y: return True return False Se precisar atravessar os elementos de uma sequ\u00eancia e seus \u00edndices, voc\u00ea pode usar a fun\u00e7\u00e3o integrada enumerate : for index, element in enumerate('abc'): print(index, element) O resultado de enumerate \u00e9 um objeto enumerate , que itera sobre uma sequ\u00eancia de pares; cada par cont\u00e9m um \u00edndice (come\u00e7ando de 0) e um elemento da sequ\u00eancia dada. Neste exemplo, a sa\u00edda \u00e9 0 a 1 b 2 c De novo. 12.6 - Dicion\u00e1rios e tuplas Os dicion\u00e1rios t\u00eam um m\u00e9todo chamado items que devolve uma sequ\u00eancia de tuplas, onde cada tupla \u00e9 um par chave-valor: >>> d = {'a':0, 'b':1, 'c':2} >>> t = d.items() >>> t dict_items([('c', 2), ('a', 0), ('b', 1)]) O resultado \u00e9 um objeto dict_items , que \u00e9 um iterador que percorre os pares chave-valor. Voc\u00ea pode us\u00e1-lo em um loop for , desta forma: >>> for key, value in d.items(): ... print(key, value) ... c 2 a 0 b 1 Como se poderia esperar de um dicion\u00e1rio, os itens n\u00e3o est\u00e3o em nenhuma ordem em particular. Indo em outra dire\u00e7\u00e3o, voc\u00ea pode usar uma lista de tuplas para inicializar um novo dicion\u00e1rio: >>> t = [('a', 0), ('c', 2), ('b', 1)] >>> d = dict(t) >>> d {'a': 0, 'c': 2, 'b': 1} Combinar dict com zip produz uma forma concisa de criar um dicion\u00e1rio: >>> d = dict(zip('abc', range(3))) >>> d {'a': 0, 'c': 2, 'b': 1} O m\u00e9todo de dicion\u00e1rio update tamb\u00e9m recebe uma lista de tuplas e as adiciona, como pares chave-valor, a um dicion\u00e1rio existente. \u00c9 comum usar tuplas como chaves em dicion\u00e1rios (principalmente porque voc\u00ea n\u00e3o pode usar listas). Por exemplo, uma lista telef\u00f4nica poderia mapear pares de sobrenome e primeiro nome a n\u00fameros de telefone. Supondo que tenhamos definido last, first e number, podemos escrever: directory[last, first] = number A express\u00e3o entre chaves \u00e9 uma tupla. Podemos usar atribui\u00e7\u00e3o de tuplas para atravessar este dicion\u00e1rio: for last, first in directory: print(first, last, directory[last,first]) Este loop atravessa as chaves em directory, que s\u00e3o tuplas. Ele atribui os elementos de cada tupla para last e first , e ent\u00e3o exibe o nome e n\u00famero de telefone correspondente. H\u00e1 duas formas de representar tuplas em um diagrama de estado. A vers\u00e3o mais detalhada mostra os \u00edndices e elementos como aparecem em uma lista. Por exemplo, a tupla ('Cleese', 'John') apareceria como na Figura 12.1. Figura 12.1 \u2013 Diagrama de estado de uma tupla. No entanto, em um diagrama maior, voc\u00ea pode querer omitir os detalhes. Por exemplo, um diagrama da lista telef\u00f4nica poderia ser como o da Figura 12.2. Figura 12.2 \u2013 Diagrama de estado de um dicion\u00e1rio com chaves do tipo tupla. Aqui as tuplas s\u00e3o mostradas usando a sintaxe do Python para simplificar o gr\u00e1fico. O n\u00famero de telefone no diagrama \u00e9 a linha de reclama\u00e7\u00f5es da BBC, ent\u00e3o, por favor, n\u00e3o ligue para l\u00e1. 12.7 - Sequ\u00eancias de sequ\u00eancias Eu me concentrei em listas de tuplas, mas quase todos os exemplos neste cap\u00edtulo tamb\u00e9m funcionam com listas de listas, tuplas de tuplas e tuplas de listas. Para evitar enumerar as combina\u00e7\u00f5es poss\u00edveis, \u00e0s vezes \u00e9 mais f\u00e1cil falar sobre sequ\u00eancias de sequ\u00eancias. Em muitos contextos, os tipos diferentes de sequ\u00eancias (strings, listas e tuplas) podem ser usados de forma intercambi\u00e1vel. Ent\u00e3o, como escolher uma em vez da outra? Para come\u00e7ar com o \u00f3bvio, as strings s\u00e3o mais limitadas que outras sequ\u00eancias porque os elementos t\u00eam de ser caracteres. Tamb\u00e9m s\u00e3o imut\u00e1veis. Se precisar da capacidade de alterar caracteres em uma string (em vez de criar outra string) voc\u00ea pode querer usar uma lista de caracteres. As listas s\u00e3o mais comuns que as tuplas, principalmente porque s\u00e3o mut\u00e1veis. Mas h\u00e1 alguns casos em que voc\u00ea pode preferir tuplas: Em alguns contextos, como em uma instru\u00e7\u00e3o return , \u00e9 sintaticamente mais simples criar uma tupla que uma lista. Se quiser usar uma sequ\u00eancia como uma chave de dicion\u00e1rio, \u00e9 preciso usar um tipo imut\u00e1vel como uma tupla ou string. Se estiver passando uma sequ\u00eancia como um argumento a uma fun\u00e7\u00e3o, usar tuplas reduz o potencial de comportamento inesperado devido a alias. Como tuplas s\u00e3o imut\u00e1veis, elas n\u00e3o fornecem m\u00e9todos como sort e reverse , que alteram listas existentes. Por\u00e9m, o Python fornece a fun\u00e7\u00e3o integrada sorted , que recebe qualquer sequ\u00eancia e retorna uma nova lista com os mesmos elementos ordenados, e reversed , que recebe uma sequ\u00eancia e retorna um iterador que percorre a lista em ordem reversa. 12.8 - Depura\u00e7\u00e3o As listas, os dicion\u00e1rios e as tuplas s\u00e3o exemplos de estruturas de dados; neste cap\u00edtulo estamos come\u00e7ando a ver estruturas de dados compostas, como as listas de tuplas ou dicion\u00e1rios que cont\u00eam tuplas como chaves e listas como valores. As estruturas de dados compostas s\u00e3o \u00fateis, mas s\u00e3o propensas ao que chamo de erros de forma; isto \u00e9, erros causados quando uma estrutura de dados tem o tipo, tamanho ou estrutura incorretos. Por exemplo, se voc\u00ea estiver esperando uma lista com um n\u00famero inteiro e eu der apenas o n\u00famero inteiro (n\u00e3o em uma lista), n\u00e3o vai funcionar. Para ajudar a depurar esses tipos de erro, escrevi um m\u00f3dulo chamado structshape , que fornece uma fun\u00e7\u00e3o, tamb\u00e9m chamada structshape , que recebe qualquer tipo de estrutura de dados como argumento e retorna uma string, que resume sua forma. Voc\u00ea pode baix\u00e1-la em http://thinkpython2.com/code/structshape.py. Aqui est\u00e1 o resultado de uma lista simples: >>> from structshape import structshape >>> t = [1, 2, 3] >>> structshape(t) 'list of 3 int' Um programa mais sofisticado pode escrever \u201clist of 3 ints\u201d, mas \u00e9 mais f\u00e1cil n\u00e3o lidar com plurais. Aqui est\u00e1 uma lista de listas: >>> t2 = [[1,2], [3,4], [5,6]] >>> structshape(t2) 'list of 3 list of 2 int' Se os elementos da lista n\u00e3o forem do mesmo tipo, structshape os agrupa, na ordem, por tipo: >>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9] >>> structshape(t3) 'list of (3 int, float, 2 str, 2 list of int, int)' Aqui est\u00e1 uma lista de tuplas: >>> s = 'abc' >>> lt = list(zip(t, s)) >>> structshape(lt) 'list of 3 tuple of (int, str)' E aqui est\u00e1 um dicion\u00e1rio com tr\u00eas itens que mapeia n\u00fameros inteiros a strings: >>> d = dict(lt) >>> structshape(d) 'dict of 3 int->str' Se estiver com problemas para monitorar suas estruturas de dados, o structshape pode ajudar. 12.9 - Gloss\u00e1rio tupla Sequ\u00eancia imut\u00e1vel de elementos. atribui\u00e7\u00e3o de tupla Atribui\u00e7\u00e3o com uma sequ\u00eancia no lado direito e uma tupla de vari\u00e1veis \u00e0 esquerda. O lado direito \u00e9 avaliado e ent\u00e3o seus elementos s\u00e3o atribu\u00eddos \u00e0s vari\u00e1veis \u00e0 esquerda. gather Opera\u00e7\u00e3o para montar uma tupla com argumento de comprimento vari\u00e1vel. scatter Opera\u00e7\u00e3o para tratar uma sequ\u00eancia como uma lista de argumentos. objeto zip O resultado de chamar uma fun\u00e7\u00e3o integrada zip; um objeto que se repete por uma sequ\u00eancia de tuplas. iterador Objeto que pode se repetir por uma sequ\u00eancia, mas que n\u00e3o oferece operadores de lista e m\u00e9todos. estrutura de dados Cole\u00e7\u00e3o de valores relacionados, muitas vezes organizados em listas, dicion\u00e1rios, tuplas etc. erro de forma Erro causado pelo fato de o valor ter a forma incorreta; isto \u00e9, tipo ou tamanho incorreto. 12.10 - Exerc\u00edcios Exerc\u00edcio 12.1 Escreva uma fun\u00e7\u00e3o chamada most_frequent que receba uma string e exiba as letras em ordem decrescente de frequ\u00eancia. Encontre amostras de texto de v\u00e1rios idiomas diferentes e veja como a frequ\u00eancia das letras varia entre os idiomas. Compare seus resultados com as tabelas em http://en.wikipedia.org/wiki/Letter_frequencies. Solu\u00e7\u00e3o: http://thinkpython2.com/code/most_frequent.py. Exerc\u00edcio 12.2 Mais anagramas! Escreva um programa que leia uma lista de palavras de um arquivo (veja \u201cLeitura de listas de palavras\u201d, na p\u00e1gina 133) e imprima todos os conjuntos de palavras que s\u00e3o anagramas. Aqui est\u00e1 um exemplo de como a sa\u00edda pode parecer: ['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled'] ['retainers', 'ternaries'] ['generating', 'greatening'] ['resmelts', 'smelters', 'termless'] Dica: voc\u00ea pode querer construir um dicion\u00e1rio que mapeie uma cole\u00e7\u00e3o de letras a uma lista de palavras que podem ser soletradas com essas letras. A pergunta \u00e9: como representar a cole\u00e7\u00e3o de letras de forma que possa ser usada como uma chave? Altere o programa anterior para que exiba a lista mais longa de anagramas primeiro, seguido pela segunda mais longa, e assim por diante. No Scrabble, um \u201cbingo\u201d \u00e9 quando voc\u00ea joga todas as sete pe\u00e7as na sua estante, junto com uma pe\u00e7a no tabuleiro, para formar uma palavra de oito letras. Que cole\u00e7\u00e3o de oito letras forma o maior n\u00famero poss\u00edvel de bingos? Dica: h\u00e1 sete. Solu\u00e7\u00e3o: http://thinkpython2.com/code/anagram_sets.py. Exerc\u00edcio 12.3 Duas palavras formam um \u201cpar de met\u00e1tese\u201d se voc\u00ea puder transformar uma na outra trocando duas letras, por exemplo, \u201cconverse\u201d e \u201cconserve\u201d. Escreva um programa que descubra todos os pares de met\u00e1tese no dicion\u00e1rio. Dica: n\u00e3o teste todos os pares de palavras e n\u00e3o teste todas as trocas poss\u00edveis. Solu\u00e7\u00e3o: http://thinkpython2.com/code/metathesis.py. Cr\u00e9dito: este exerc\u00edcio foi inspirado por um exemplo em http://puzzlers.org. Exerc\u00edcio 12.4 Aqui est\u00e1 outro quebra-cabe\u00e7a do programa Car Talk (http://www.cartalk.com/content/puzzlers): Qual \u00e9 a palavra inglesa mais longa, que permanece uma palavra inglesa v\u00e1lida, conforme vai removendo suas letras, uma ap\u00f3s a outra? Agora, as letras podem ser retiradas do fim ou do meio, mas voc\u00ea n\u00e3o pode reajustar nenhuma delas. Cada vez que remove uma letra, voc\u00ea acaba com outra palavra inglesa. Se fizer isto, eventualmente voc\u00ea acabar\u00e1 com uma letra e isso tamb\u00e9m ser\u00e1 uma palavra inglesa; uma encontrada no dicion\u00e1rio. Quero saber qual \u00e9 a palavra mais longa e quantas letras tem? Vou dar um pequeno exemplo modesto: Sprite. Ok? Voc\u00ea come\u00e7a com sprite, tira uma letra do interior da palavra, tira o r, e ficamos com a palavra spite, ent\u00e3o tiramos o e do fim, ficamos com spit, tiramos o s, ficamos com pit, it e I. Escreva um programa que encontre todas as palavras que podem ser reduzidas desta forma, e ent\u00e3o encontre a mais longa. Este exerc\u00edcio \u00e9 um pouco mais desafiador que a maioria, ent\u00e3o aqui est\u00e3o algumas sugest\u00f5es: Voc\u00ea pode querer escrever uma fun\u00e7\u00e3o que receba uma palavra e calcule uma lista de todas as palavras que podem ser formadas retirando uma letra. Esses s\u00e3o os \u201cfilhos\u201d da palavra. Recursivamente, uma palavra \u00e9 redut\u00edvel se algum de seus filhos for redut\u00edvel. Como caso base, voc\u00ea pode considerar a string vazia redut\u00edvel. A lista de palavras que forneci, words.txt, n\u00e3o cont\u00e9m palavras de uma letra s\u00f3. Portanto, voc\u00ea pode querer acrescentar \u201cI\u201d, \u201ca\u201d, e a string vazia. Para melhorar o desempenho do seu programa, voc\u00ea pode querer memorizar as palavras conhecidas por serem redut\u00edveis. Solu\u00e7\u00e3o: http://thinkpython2.com/code/reducible.py.","title":"Cap\u00edtulo 12: Tuplas"},{"location":"12-tuplas/#capitulo-12-tuplas","text":"Este cap\u00edtulo apresenta mais um tipo integrado, a tupla, e descreve como as listas, os dicion\u00e1rios e as tuplas trabalham juntos. Al\u00e9m disso, apresento um recurso \u00fatil para listas de argumentos de comprimento vari\u00e1vel: os operadores gather e scatter. Uma observa\u00e7\u00e3o: n\u00e3o h\u00e1 consenso sobre como pronunciar \u201ctuple\u201d (em ingl\u00eas). Algumas pessoas dizem \u201ctuhple\u201d, que rima com \u201csupple\u201d. Por\u00e9m, no contexto da programa\u00e7\u00e3o, a maioria das pessoas diz \u201ctoo-ple\u201d, que rima com \u201cquadruple\u201d.","title":"Cap\u00edtulo 12: Tuplas"},{"location":"12-tuplas/#121-tuplas-sao-imutaveis","text":"Uma tupla \u00e9 uma sequ\u00eancia de valores. Os valores podem ser de qualquer tipo, e podem ser indexados por n\u00fameros inteiros, portanto, nesse sentido, as tuplas s\u00e3o muito parecidas com as listas. A diferen\u00e7a importante \u00e9 que as tuplas s\u00e3o imut\u00e1veis. Sintaticamente, uma tupla \u00e9 uma lista de valores separados por v\u00edrgulas: >>> t = 'a', 'b', 'c', 'd', 'e' Embora n\u00e3o seja sempre necess\u00e1rio, \u00e9 comum colocar tuplas entre par\u00eanteses: >>> t = ('a', 'b', 'c', 'd', 'e') Para criar uma tupla com um \u00fanico elemento, \u00e9 preciso incluir uma v\u00edrgula final: >>> t1 = 'a', >>> type(t1) <class 'tuple'> Um \u00fanico valor entre par\u00eanteses n\u00e3o \u00e9 uma tupla: >>> t2 = ('a') >>> type(t2) <class 'str'> Outra forma de criar uma tupla \u00e9 com a fun\u00e7\u00e3o integrada tuple . Sem argumentos, cria uma tupla vazia: >>> t = tuple() >>> t () Se os argumentos forem uma sequ\u00eancia (string, lista ou tupla), o resultado \u00e9 uma tupla com os elementos da sequ\u00eancia: >>> t = tuple('lupins') >>> t ('l', 'u', 'p', 'i', 'n', 's') Como tuple \u00e9 o nome de uma fun\u00e7\u00e3o integrada, voc\u00ea deve evitar us\u00e1-lo como nome de vari\u00e1vel. A maior parte dos operadores de lista tamb\u00e9m funciona em tuplas. O operador de colchetes indexa um elemento: >>> t = ('a', 'b', 'c', 'd', 'e') >>> t[0] 'a' E o operador de fatia seleciona v\u00e1rios elementos: >>> t[1:3] ('b', 'c') Entretanto, se tentar alterar um dos elementos da tupla, vai receber um erro: >>> t[0] = 'A' TypeError: object doesn't support item assignment Como tuplas s\u00e3o imut\u00e1veis, voc\u00ea n\u00e3o pode alterar os elementos, mas pode substituir uma tupla por outra: >>> t = ('A',) + t[1:] >>> t ('A', 'b', 'c', 'd', 'e') Essa instru\u00e7\u00e3o faz uma nova tupla e ent\u00e3o a atribui a t . Os operadores relacionais funcionam com tuplas e outras sequ\u00eancias; o Python come\u00e7a comparando o primeiro elemento de cada sequ\u00eancia. Se forem iguais, vai para os pr\u00f3ximos elementos, e assim por diante, at\u00e9 que encontre elementos que sejam diferentes. Os elementos subsequentes n\u00e3o s\u00e3o considerados (mesmo se forem muito grandes). >>> (0, 1, 2) < (0, 3, 4) True >>> (0, 1, 2000000) < (0, 3, 4) True","title":"12.1 - Tuplas s\u00e3o imut\u00e1veis"},{"location":"12-tuplas/#122-atribuicao-de-tuplas","text":"Muitas vezes, \u00e9 \u00fatil trocar os valores de duas vari\u00e1veis. Com a atribui\u00e7\u00e3o convencional, \u00e9 preciso usar uma vari\u00e1vel tempor\u00e1ria. Por exemplo, trocar a e b. >>> temp = a >>> a = b >>> b = temp Essa solu\u00e7\u00e3o \u00e9 trabalhosa; a atribui\u00e7\u00e3o de tuplas \u00e9 mais elegante: >>> a, b = b, a O lado esquerdo \u00e9 uma tupla de vari\u00e1veis; o lado direito \u00e9 uma tupla de express\u00f5es. Cada valor \u00e9 atribu\u00eddo \u00e0 sua respectiva vari\u00e1vel. Todas as express\u00f5es no lado direito s\u00e3o avaliadas antes de todas as atribui\u00e7\u00f5es. O n\u00famero de vari\u00e1veis \u00e0 esquerda e o n\u00famero de valores \u00e0 direita precisam ser iguais: >>> a, b = 1, 2, 3 ValueError: too many values to unpack De forma geral, o lado direito pode ter qualquer tipo de sequ\u00eancia (string, lista ou tupla). Por exemplo, para dividir um endere\u00e7o de email em um nome de usu\u00e1rio e um dom\u00ednio, voc\u00ea poderia escrever: >>> addr = 'monty@python.org' >>> uname, domain = addr.split('@') O valor de retorno do split \u00e9 uma lista com dois elementos; o primeiro elemento \u00e9 atribu\u00eddo a uname , o segundo a domain : >>> uname 'monty' >>> domain 'python.org'","title":"12.2 - Atribui\u00e7\u00e3o de tuplas"},{"location":"12-tuplas/#123-tuplas-como-valores-de-retorno","text":"Falando estritamente, uma fun\u00e7\u00e3o s\u00f3 pode retornar um valor, mas se o valor for uma tupla, o efeito \u00e9 o mesmo que retornar valores m\u00faltiplos. Por exemplo, se voc\u00ea quiser dividir dois n\u00fameros inteiros e calcular o quociente e resto, n\u00e3o \u00e9 eficiente calcular x/y e depois x%y. \u00c9 melhor calcular ambos ao mesmo tempo. A fun\u00e7\u00e3o integrada divmod toma dois argumentos e devolve uma tupla de dois valores: o quociente e o resto. Voc\u00ea pode guardar o resultado como uma tupla: >>> t = divmod(7, 3) >>> t (2, 1) Ou usar a atribui\u00e7\u00e3o de tuplas para guardar os elementos separadamente: >>> quot, rem = divmod(7, 3) >>> quot 2 >>> rem 1 Aqui est\u00e1 um exemplo de fun\u00e7\u00e3o que retorna uma tupla: def min_max(t): return min(t), max(t) max e min s\u00e3o fun\u00e7\u00f5es integradas que encontram os maiores e menores elementos de uma sequ\u00eancia. min_max calcula ambos e retorna uma tupla de dois valores.","title":"12.3 - Tuplas como valores de retorno"},{"location":"12-tuplas/#124-tuplas-com-argumentos-de-comprimento-variavel","text":"As fun\u00e7\u00f5es podem receber um n\u00famero vari\u00e1vel de argumentos. Um nome de par\u00e2metro que comece com * re\u00fane v\u00e1rios argumentos em uma tupla. Por exemplo, printall recebe qualquer n\u00famero de argumentos e os exibe: def printall(*args): print(args) O par\u00e2metro com o prefixo * pode ter qualquer nome que voc\u00ea goste, mas args \u00e9 o convencional. \u00c9 assim que a fun\u00e7\u00e3o funciona: >>> printall(1, 2.0, '3') (1, 2.0, '3') O complemento de reunir \u00e9 espalhar. Se voc\u00ea tiver uma sequ\u00eancia de valores e quiser pass\u00e1-la a uma fun\u00e7\u00e3o como argumentos m\u00faltiplos, pode usar o operador * . Por exemplo, o divmod recebe exatamente dois argumentos; ele n\u00e3o funciona com uma tupla: >>> t = (7, 3) >>> divmod(t) TypeError: divmod expected 2 arguments, got 1 No entanto, se voc\u00ea espalhar a tupla, a\u00ed funciona: >>> divmod(*t) (2, 1) Muitas das fun\u00e7\u00f5es integradas usam tuplas com argumentos de comprimento vari\u00e1vel. Por exemplo, max e min podem receber qualquer n\u00famero de argumentos: >>> max(1, 2, 3) 3 Mas sum, n\u00e3o: >>> sum(1, 2, 3) TypeError: sum expected at most 2 arguments, got 3 Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada sumall que receba qualquer n\u00famero de argumentos e retorne a soma deles.","title":"12.4 - Tuplas com argumentos de comprimento vari\u00e1vel"},{"location":"12-tuplas/#125-listas-e-tuplas","text":"zip \u00e9 uma fun\u00e7\u00e3o integrada que recebe duas ou mais sequ\u00eancias e devolve uma lista de tuplas onde cada tupla cont\u00e9m um elemento de cada sequ\u00eancia. O nome da fun\u00e7\u00e3o tem a ver com o z\u00edper, que se junta e encaixa duas carreiras de dentes. Este exemplo encaixa uma string e uma lista: >>> s = 'abc' >>> t = [0, 1, 2] >>> zip(s, t) <zip object at 0x7f7d0a9e7c48> O resultado \u00e9 um objeto zip que sabe como percorrer os pares. O uso mais comum de zip \u00e9 em um loop for : >>> for pair in zip(s, t): ... print(pair) ... ('a', 0) ('b', 1) ('c', 2) Um objeto zip \u00e9 um tipo de iterador, ou seja, qualquer objeto que percorre ou itera sobre uma sequ\u00eancia. Iteradores s\u00e3o semelhantes a listas em alguns aspectos, mas, ao contr\u00e1rio de listas, n\u00e3o \u00e9 poss\u00edvel usar um \u00edndice para selecionar um elemento de um iterador. Se quiser usar operadores e m\u00e9todos de lista, voc\u00ea pode usar um objeto zip para fazer uma lista: >>> list(zip(s, t)) [('a', 0), ('b', 1), ('c', 2)] O resultado \u00e9 uma lista de tuplas; neste exemplo, cada tupla cont\u00e9m um caractere da string e o elemento correspondente da lista. Se as sequ\u00eancias n\u00e3o forem do mesmo comprimento, o resultado tem o comprimento da mais curta: >>> list(zip('Anne', 'Elk')) [('A', 'E'), ('n', 'l'), ('n', 'k')] Voc\u00ea pode usar a atribui\u00e7\u00e3o de tuplas em um loop for para atravessar uma lista de tuplas: t = [('a', 0), ('b', 1), ('c', 2)] for letter, number in t: print(number, letter) Cada vez que o programa passa pelo loop, o Python seleciona a pr\u00f3xima tupla na lista e atribui os elementos letter e number. A sa\u00edda deste loop \u00e9: 0 a 1 b 2 c Se combinar zip , for e atribui\u00e7\u00e3o de tuplas, voc\u00ea pode fazer uma express\u00e3o \u00fatil para percorrer duas (ou mais) sequ\u00eancias ao mesmo tempo. Por exemplo, has_match recebe duas sequ\u00eancias, t1 e t2 e retorna True se houver um \u00edndice i tal que t1[i] == t2[i] : def has_match(t1, t2): for x, y in zip(t1, t2): if x == y: return True return False Se precisar atravessar os elementos de uma sequ\u00eancia e seus \u00edndices, voc\u00ea pode usar a fun\u00e7\u00e3o integrada enumerate : for index, element in enumerate('abc'): print(index, element) O resultado de enumerate \u00e9 um objeto enumerate , que itera sobre uma sequ\u00eancia de pares; cada par cont\u00e9m um \u00edndice (come\u00e7ando de 0) e um elemento da sequ\u00eancia dada. Neste exemplo, a sa\u00edda \u00e9 0 a 1 b 2 c De novo.","title":"12.5 - Listas e tuplas"},{"location":"12-tuplas/#126-dicionarios-e-tuplas","text":"Os dicion\u00e1rios t\u00eam um m\u00e9todo chamado items que devolve uma sequ\u00eancia de tuplas, onde cada tupla \u00e9 um par chave-valor: >>> d = {'a':0, 'b':1, 'c':2} >>> t = d.items() >>> t dict_items([('c', 2), ('a', 0), ('b', 1)]) O resultado \u00e9 um objeto dict_items , que \u00e9 um iterador que percorre os pares chave-valor. Voc\u00ea pode us\u00e1-lo em um loop for , desta forma: >>> for key, value in d.items(): ... print(key, value) ... c 2 a 0 b 1 Como se poderia esperar de um dicion\u00e1rio, os itens n\u00e3o est\u00e3o em nenhuma ordem em particular. Indo em outra dire\u00e7\u00e3o, voc\u00ea pode usar uma lista de tuplas para inicializar um novo dicion\u00e1rio: >>> t = [('a', 0), ('c', 2), ('b', 1)] >>> d = dict(t) >>> d {'a': 0, 'c': 2, 'b': 1} Combinar dict com zip produz uma forma concisa de criar um dicion\u00e1rio: >>> d = dict(zip('abc', range(3))) >>> d {'a': 0, 'c': 2, 'b': 1} O m\u00e9todo de dicion\u00e1rio update tamb\u00e9m recebe uma lista de tuplas e as adiciona, como pares chave-valor, a um dicion\u00e1rio existente. \u00c9 comum usar tuplas como chaves em dicion\u00e1rios (principalmente porque voc\u00ea n\u00e3o pode usar listas). Por exemplo, uma lista telef\u00f4nica poderia mapear pares de sobrenome e primeiro nome a n\u00fameros de telefone. Supondo que tenhamos definido last, first e number, podemos escrever: directory[last, first] = number A express\u00e3o entre chaves \u00e9 uma tupla. Podemos usar atribui\u00e7\u00e3o de tuplas para atravessar este dicion\u00e1rio: for last, first in directory: print(first, last, directory[last,first]) Este loop atravessa as chaves em directory, que s\u00e3o tuplas. Ele atribui os elementos de cada tupla para last e first , e ent\u00e3o exibe o nome e n\u00famero de telefone correspondente. H\u00e1 duas formas de representar tuplas em um diagrama de estado. A vers\u00e3o mais detalhada mostra os \u00edndices e elementos como aparecem em uma lista. Por exemplo, a tupla ('Cleese', 'John') apareceria como na Figura 12.1. Figura 12.1 \u2013 Diagrama de estado de uma tupla. No entanto, em um diagrama maior, voc\u00ea pode querer omitir os detalhes. Por exemplo, um diagrama da lista telef\u00f4nica poderia ser como o da Figura 12.2. Figura 12.2 \u2013 Diagrama de estado de um dicion\u00e1rio com chaves do tipo tupla. Aqui as tuplas s\u00e3o mostradas usando a sintaxe do Python para simplificar o gr\u00e1fico. O n\u00famero de telefone no diagrama \u00e9 a linha de reclama\u00e7\u00f5es da BBC, ent\u00e3o, por favor, n\u00e3o ligue para l\u00e1.","title":"12.6 - Dicion\u00e1rios e tuplas"},{"location":"12-tuplas/#127-sequencias-de-sequencias","text":"Eu me concentrei em listas de tuplas, mas quase todos os exemplos neste cap\u00edtulo tamb\u00e9m funcionam com listas de listas, tuplas de tuplas e tuplas de listas. Para evitar enumerar as combina\u00e7\u00f5es poss\u00edveis, \u00e0s vezes \u00e9 mais f\u00e1cil falar sobre sequ\u00eancias de sequ\u00eancias. Em muitos contextos, os tipos diferentes de sequ\u00eancias (strings, listas e tuplas) podem ser usados de forma intercambi\u00e1vel. Ent\u00e3o, como escolher uma em vez da outra? Para come\u00e7ar com o \u00f3bvio, as strings s\u00e3o mais limitadas que outras sequ\u00eancias porque os elementos t\u00eam de ser caracteres. Tamb\u00e9m s\u00e3o imut\u00e1veis. Se precisar da capacidade de alterar caracteres em uma string (em vez de criar outra string) voc\u00ea pode querer usar uma lista de caracteres. As listas s\u00e3o mais comuns que as tuplas, principalmente porque s\u00e3o mut\u00e1veis. Mas h\u00e1 alguns casos em que voc\u00ea pode preferir tuplas: Em alguns contextos, como em uma instru\u00e7\u00e3o return , \u00e9 sintaticamente mais simples criar uma tupla que uma lista. Se quiser usar uma sequ\u00eancia como uma chave de dicion\u00e1rio, \u00e9 preciso usar um tipo imut\u00e1vel como uma tupla ou string. Se estiver passando uma sequ\u00eancia como um argumento a uma fun\u00e7\u00e3o, usar tuplas reduz o potencial de comportamento inesperado devido a alias. Como tuplas s\u00e3o imut\u00e1veis, elas n\u00e3o fornecem m\u00e9todos como sort e reverse , que alteram listas existentes. Por\u00e9m, o Python fornece a fun\u00e7\u00e3o integrada sorted , que recebe qualquer sequ\u00eancia e retorna uma nova lista com os mesmos elementos ordenados, e reversed , que recebe uma sequ\u00eancia e retorna um iterador que percorre a lista em ordem reversa.","title":"12.7 - Sequ\u00eancias de sequ\u00eancias"},{"location":"12-tuplas/#128-depuracao","text":"As listas, os dicion\u00e1rios e as tuplas s\u00e3o exemplos de estruturas de dados; neste cap\u00edtulo estamos come\u00e7ando a ver estruturas de dados compostas, como as listas de tuplas ou dicion\u00e1rios que cont\u00eam tuplas como chaves e listas como valores. As estruturas de dados compostas s\u00e3o \u00fateis, mas s\u00e3o propensas ao que chamo de erros de forma; isto \u00e9, erros causados quando uma estrutura de dados tem o tipo, tamanho ou estrutura incorretos. Por exemplo, se voc\u00ea estiver esperando uma lista com um n\u00famero inteiro e eu der apenas o n\u00famero inteiro (n\u00e3o em uma lista), n\u00e3o vai funcionar. Para ajudar a depurar esses tipos de erro, escrevi um m\u00f3dulo chamado structshape , que fornece uma fun\u00e7\u00e3o, tamb\u00e9m chamada structshape , que recebe qualquer tipo de estrutura de dados como argumento e retorna uma string, que resume sua forma. Voc\u00ea pode baix\u00e1-la em http://thinkpython2.com/code/structshape.py. Aqui est\u00e1 o resultado de uma lista simples: >>> from structshape import structshape >>> t = [1, 2, 3] >>> structshape(t) 'list of 3 int' Um programa mais sofisticado pode escrever \u201clist of 3 ints\u201d, mas \u00e9 mais f\u00e1cil n\u00e3o lidar com plurais. Aqui est\u00e1 uma lista de listas: >>> t2 = [[1,2], [3,4], [5,6]] >>> structshape(t2) 'list of 3 list of 2 int' Se os elementos da lista n\u00e3o forem do mesmo tipo, structshape os agrupa, na ordem, por tipo: >>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9] >>> structshape(t3) 'list of (3 int, float, 2 str, 2 list of int, int)' Aqui est\u00e1 uma lista de tuplas: >>> s = 'abc' >>> lt = list(zip(t, s)) >>> structshape(lt) 'list of 3 tuple of (int, str)' E aqui est\u00e1 um dicion\u00e1rio com tr\u00eas itens que mapeia n\u00fameros inteiros a strings: >>> d = dict(lt) >>> structshape(d) 'dict of 3 int->str' Se estiver com problemas para monitorar suas estruturas de dados, o structshape pode ajudar.","title":"12.8 - Depura\u00e7\u00e3o"},{"location":"12-tuplas/#129-glossario","text":"tupla Sequ\u00eancia imut\u00e1vel de elementos. atribui\u00e7\u00e3o de tupla Atribui\u00e7\u00e3o com uma sequ\u00eancia no lado direito e uma tupla de vari\u00e1veis \u00e0 esquerda. O lado direito \u00e9 avaliado e ent\u00e3o seus elementos s\u00e3o atribu\u00eddos \u00e0s vari\u00e1veis \u00e0 esquerda. gather Opera\u00e7\u00e3o para montar uma tupla com argumento de comprimento vari\u00e1vel. scatter Opera\u00e7\u00e3o para tratar uma sequ\u00eancia como uma lista de argumentos. objeto zip O resultado de chamar uma fun\u00e7\u00e3o integrada zip; um objeto que se repete por uma sequ\u00eancia de tuplas. iterador Objeto que pode se repetir por uma sequ\u00eancia, mas que n\u00e3o oferece operadores de lista e m\u00e9todos. estrutura de dados Cole\u00e7\u00e3o de valores relacionados, muitas vezes organizados em listas, dicion\u00e1rios, tuplas etc. erro de forma Erro causado pelo fato de o valor ter a forma incorreta; isto \u00e9, tipo ou tamanho incorreto.","title":"12.9 - Gloss\u00e1rio"},{"location":"12-tuplas/#1210-exercicios","text":"","title":"12.10 - Exerc\u00edcios"},{"location":"12-tuplas/#exercicio-121","text":"Escreva uma fun\u00e7\u00e3o chamada most_frequent que receba uma string e exiba as letras em ordem decrescente de frequ\u00eancia. Encontre amostras de texto de v\u00e1rios idiomas diferentes e veja como a frequ\u00eancia das letras varia entre os idiomas. Compare seus resultados com as tabelas em http://en.wikipedia.org/wiki/Letter_frequencies. Solu\u00e7\u00e3o: http://thinkpython2.com/code/most_frequent.py.","title":"Exerc\u00edcio 12.1"},{"location":"12-tuplas/#exercicio-122","text":"Mais anagramas! Escreva um programa que leia uma lista de palavras de um arquivo (veja \u201cLeitura de listas de palavras\u201d, na p\u00e1gina 133) e imprima todos os conjuntos de palavras que s\u00e3o anagramas. Aqui est\u00e1 um exemplo de como a sa\u00edda pode parecer: ['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled'] ['retainers', 'ternaries'] ['generating', 'greatening'] ['resmelts', 'smelters', 'termless'] Dica: voc\u00ea pode querer construir um dicion\u00e1rio que mapeie uma cole\u00e7\u00e3o de letras a uma lista de palavras que podem ser soletradas com essas letras. A pergunta \u00e9: como representar a cole\u00e7\u00e3o de letras de forma que possa ser usada como uma chave? Altere o programa anterior para que exiba a lista mais longa de anagramas primeiro, seguido pela segunda mais longa, e assim por diante. No Scrabble, um \u201cbingo\u201d \u00e9 quando voc\u00ea joga todas as sete pe\u00e7as na sua estante, junto com uma pe\u00e7a no tabuleiro, para formar uma palavra de oito letras. Que cole\u00e7\u00e3o de oito letras forma o maior n\u00famero poss\u00edvel de bingos? Dica: h\u00e1 sete. Solu\u00e7\u00e3o: http://thinkpython2.com/code/anagram_sets.py.","title":"Exerc\u00edcio 12.2"},{"location":"12-tuplas/#exercicio-123","text":"Duas palavras formam um \u201cpar de met\u00e1tese\u201d se voc\u00ea puder transformar uma na outra trocando duas letras, por exemplo, \u201cconverse\u201d e \u201cconserve\u201d. Escreva um programa que descubra todos os pares de met\u00e1tese no dicion\u00e1rio. Dica: n\u00e3o teste todos os pares de palavras e n\u00e3o teste todas as trocas poss\u00edveis. Solu\u00e7\u00e3o: http://thinkpython2.com/code/metathesis.py. Cr\u00e9dito: este exerc\u00edcio foi inspirado por um exemplo em http://puzzlers.org.","title":"Exerc\u00edcio 12.3"},{"location":"12-tuplas/#exercicio-124","text":"Aqui est\u00e1 outro quebra-cabe\u00e7a do programa Car Talk (http://www.cartalk.com/content/puzzlers): Qual \u00e9 a palavra inglesa mais longa, que permanece uma palavra inglesa v\u00e1lida, conforme vai removendo suas letras, uma ap\u00f3s a outra? Agora, as letras podem ser retiradas do fim ou do meio, mas voc\u00ea n\u00e3o pode reajustar nenhuma delas. Cada vez que remove uma letra, voc\u00ea acaba com outra palavra inglesa. Se fizer isto, eventualmente voc\u00ea acabar\u00e1 com uma letra e isso tamb\u00e9m ser\u00e1 uma palavra inglesa; uma encontrada no dicion\u00e1rio. Quero saber qual \u00e9 a palavra mais longa e quantas letras tem? Vou dar um pequeno exemplo modesto: Sprite. Ok? Voc\u00ea come\u00e7a com sprite, tira uma letra do interior da palavra, tira o r, e ficamos com a palavra spite, ent\u00e3o tiramos o e do fim, ficamos com spit, tiramos o s, ficamos com pit, it e I. Escreva um programa que encontre todas as palavras que podem ser reduzidas desta forma, e ent\u00e3o encontre a mais longa. Este exerc\u00edcio \u00e9 um pouco mais desafiador que a maioria, ent\u00e3o aqui est\u00e3o algumas sugest\u00f5es: Voc\u00ea pode querer escrever uma fun\u00e7\u00e3o que receba uma palavra e calcule uma lista de todas as palavras que podem ser formadas retirando uma letra. Esses s\u00e3o os \u201cfilhos\u201d da palavra. Recursivamente, uma palavra \u00e9 redut\u00edvel se algum de seus filhos for redut\u00edvel. Como caso base, voc\u00ea pode considerar a string vazia redut\u00edvel. A lista de palavras que forneci, words.txt, n\u00e3o cont\u00e9m palavras de uma letra s\u00f3. Portanto, voc\u00ea pode querer acrescentar \u201cI\u201d, \u201ca\u201d, e a string vazia. Para melhorar o desempenho do seu programa, voc\u00ea pode querer memorizar as palavras conhecidas por serem redut\u00edveis. Solu\u00e7\u00e3o: http://thinkpython2.com/code/reducible.py.","title":"Exerc\u00edcio 12.4"},{"location":"13-caso-estruturas/","text":"Cap\u00edtulo 13: Estudo de caso: sele\u00e7\u00e3o de estrutura de dados Neste ponto voc\u00ea j\u00e1 aprendeu sobre as principais estruturas de dados do Python, e viu alguns algoritmos que as usam. Se quiser saber mais sobre algoritmos, pode ler o Cap\u00edtulo 21. Mas isso n\u00e3o \u00e9 necess\u00e1rio para continuar, pode l\u00ea-lo a qualquer momento em que tenha interesse. Este cap\u00edtulo apresenta um estudo de caso com exerc\u00edcios que fazem pensar sobre a escolha de estruturas de dados e pr\u00e1ticas de uso delas. 13.1 - An\u00e1lise de frequ\u00eancia de palavras Como de h\u00e1bito, voc\u00ea deve pelo menos tentar fazer os exerc\u00edcios antes de ler as minhas solu\u00e7\u00f5es. Exerc\u00edcio 13.1 Escreva um programa que leia um arquivo, quebre cada linha em palavras, remova os espa\u00e7os em branco e a pontua\u00e7\u00e3o das palavras, e as converta em letras min\u00fasculas. Dica: O m\u00f3dulo string oferece uma string chamada whitespace , que cont\u00e9m espa\u00e7o, tab, newline etc., e punctuation , que cont\u00e9m os caracteres de pontua\u00e7\u00e3o. Vamos ver se conseguimos fazer o Python falar palavr\u00f5es: >>> import string >>> string.punctuation '!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~' Al\u00e9m disso, voc\u00ea pode usar os m\u00e9todos de string, strip, replace e translate. Exerc\u00edcio 13.2 Acesse o Projeto Gutenberg (http://gutenberg.org) e baixe seu livro favorito em dom\u00ednio p\u00fablico em formato de texto simples. Altere seu programa do exerc\u00edcio anterior para ler o livro que voc\u00ea baixou, pulando as informa\u00e7\u00f5es do cabe\u00e7alho no in\u00edcio do arquivo e processando o resto das palavras como antes. Ent\u00e3o altere o programa para contar o n\u00famero total de palavras no livro e o n\u00famero de vezes que cada palavra \u00e9 usada. Exiba o n\u00famero de palavras diferentes usadas no livro. Compare livros diferentes de autores diferentes, escritos em eras diferentes. Que autor usa o vocabul\u00e1rio mais extenso? Exerc\u00edcio 13.3 Altere o programa do exerc\u00edcio anterior para exibir as 20 palavras mais frequentes do livro. Exerc\u00edcio 13.4 Altere o programa anterior para ler uma lista de palavras (ver \u201cLeitura de listas de palavras\u201d, na p\u00e1gina 133) e ent\u00e3o exiba todas as palavras do livro que n\u00e3o est\u00e3o na lista de palavras. Quantas delas s\u00e3o erros ortogr\u00e1ficos? Quantas delas s\u00e3o palavras comuns que deveriam estar na lista de palavras, e quantas s\u00e3o muito obscuras? 13.2 - N\u00fameros aleat\u00f3rios Com as mesmas entradas, a maior parte dos programas gera as mesmas sa\u00eddas a cada vez, ent\u00e3o eles s\u00e3o chamados de deterministas. Determinismo normalmente \u00e9 uma coisa boa, j\u00e1 que esperamos que o mesmo c\u00e1lculo produza o mesmo resultado. Para algumas aplica\u00e7\u00f5es, entretanto, queremos que o computador seja imprevis\u00edvel. Os jogos s\u00e3o um exemplo \u00f3bvio, mas h\u00e1 outros. Fazer um programa n\u00e3o determinista de verdade \u00e9 dif\u00edcil; mas h\u00e1 formas de, pelo menos, faz\u00ea-los parecer que n\u00e3o s\u00e3o. Uma delas \u00e9 usar algoritmos que geram n\u00fameros pseudoaleat\u00f3rios. Os n\u00fameros pseudoaleat\u00f3rios n\u00e3o s\u00e3o aleat\u00f3rios mesmo porque s\u00e3o gerados por um c\u00e1lculo determinista, mas \u00e9 quase imposs\u00edvel distingui-los dos aleat\u00f3rios s\u00f3 olhando para os n\u00fameros. O m\u00f3dulo random fornece fun\u00e7\u00f5es que geram n\u00fameros pseudoaleat\u00f3rios (que chamarei apenas de \u201caleat\u00f3rios\u201d daqui em diante). A fun\u00e7\u00e3o random retorna um n\u00famero de ponto flutuante entre 0,0 e 1,0 (incluindo 0,0, mas n\u00e3o 1,0). Cada vez que random \u00e9 chamada, voc\u00ea recebe o pr\u00f3ximo n\u00famero em uma longa s\u00e9rie. Para ver uma amostra, execute este loop: import random for i in range(10): x = random.random() print(x) A fun\u00e7\u00e3o randint recebe os par\u00e2metros low e high e retorna um n\u00famero inteiro entre low e high (inclusive ambos): >>> random.randint(5, 10) 5 >>> random.randint(5, 10) 9 Para escolher aleatoriamente um elemento de uma sequ\u00eancia, voc\u00ea pode usar choice: >>> t = [1, 2, 3] >>> random.choice(t) 2 >>> random.choice(t) 3 O m\u00f3dulo random tamb\u00e9m fornece fun\u00e7\u00f5es para gerar valores aleat\u00f3rios de distribui\u00e7\u00f5es cont\u00ednuas, incluindo gaussianas, exponenciais, gamma e algumas outras. Exerc\u00edcio 13.5 Escreva uma fun\u00e7\u00e3o chamada choose_from_hist que receba um histograma como definido em \u201cUm dicion\u00e1rio como uma cole\u00e7\u00e3o de contadores\u201d, na p\u00e1gina 163, e retorne um valor aleat\u00f3rio do histograma, escolhido por probabilidade em propor\u00e7\u00e3o \u00e0 frequ\u00eancia. Por exemplo, para este histograma: >>> t = ['a', 'a', 'b'] >>> hist = histogram(t) >>> hist {'a': 2, 'b': 1} sua fun\u00e7\u00e3o deve retornar 'a' com a probabilidade de 2/3 e 'b' com a probabilidade 1/3. 13.3 - Histograma de palavras \u00c9 uma boa ideia tentar fazer os exerc\u00edcios anteriores antes de continuar. Voc\u00ea pode baixar minha solu\u00e7\u00e3o em http://thinkpython2.com/code/analyze_book1.py. Tamb\u00e9m vai precisar de http://thinkpython2.com/code/emma.txt. Aqui est\u00e1 um programa que l\u00ea um arquivo e constr\u00f3i um histograma das palavras no arquivo: import string def process_file(filename): hist = dict() fp = open(filename) for line in fp: process_line(line, hist) return hist def process_line(line, hist): line = line.replace('-', ' ') for word in line.split(): word = word.strip(string.punctuation + string.whitespace) word = word.lower() hist[word] = hist.get(word, 0) + 1 hist = process_file('emma.txt') Este programa l\u00ea emma.txt , que cont\u00e9m o texto de Emma , de Jane Austen. process_file faz o loop pelas linhas do arquivo, passando-as uma a uma para process_line . O histograma hist est\u00e1 sendo usado como um acumulador. process_line usa o m\u00e9todo de string replace para substituir hifens por espa\u00e7os antes de usar split para quebrar a linha em uma lista de strings. Ele atravessa a lista de palavras e usa strip e lower para retirar a pontua\u00e7\u00e3o e converter tudo em letras min\u00fasculas. (Dizer que as strings \u201cs\u00e3o convertidas\u201d \u00e9 uma forma simples de explicar a coisa; lembre-se de que as strings s\u00e3o imut\u00e1veis, ent\u00e3o m\u00e9todos como strip e lower retornam novas strings.) Finalmente, process_line atualiza o histograma, criando um novo item ou incrementando um existente. Para contar o n\u00famero total de palavras no arquivo, podemos somar as frequ\u00eancias no histograma: def total_words(hist): return sum(hist.values()) O n\u00famero de palavras diferentes \u00e9 somente o n\u00famero de itens no dicion\u00e1rio: def different_words(hist): return len(hist) Aqui est\u00e1 o c\u00f3digo para exibir os resultados: print('Total number of words:', total_words(hist)) print('Number of different words:', different_words(hist)) E os resultados: Total number of words: 161080 Number of different words: 7214 13.4 - Palavras mais comuns Para encontrar as palavras mais comuns, podemos fazer uma lista de tuplas, onde cada tupla contenha uma palavra e a sua frequ\u00eancia, e ordenar a lista. A fun\u00e7\u00e3o seguinte recebe um histograma e retorna uma lista de tuplas de palavras e frequ\u00eancias: def most_common(hist): t = [] for key, value in hist.items(): t.append((value, key)) t.sort(reverse=True) return t Em cada tupla, a frequ\u00eancia aparece primeiro, ent\u00e3o a lista resultante \u00e9 ordenada por frequ\u00eancia. Aqui est\u00e1 um loop que imprime as 10 palavras mais comuns: t = most_common(hist) print('The most common words are:') for freq, word in t[:10]: print(word, freq, sep='\\\\t') Uso o argumento de palavra-chave sep para que print use um caractere tab como separador, em vez de um espa\u00e7o, assim a segunda coluna fica alinhada verticalmente. Aqui est\u00e3o os resultados de Emma: The most common words are: to 5242 the 5205 and 4897 of 4295 i 3191 a 3130 it 2529 her 2483 was 2400 she 2364 Este c\u00f3digo pode ser simplificado usando o par\u00e2metro key da fun\u00e7\u00e3o sort . Se tiver curiosidade, pode ler sobre ele em https://wiki.python.org/moin/HowTo/Sorting. 13.5 - Par\u00e2metros opcionais Vimos fun\u00e7\u00f5es integradas e m\u00e9todos que recebem argumentos opcionais. \u00c9 poss\u00edvel escrever fun\u00e7\u00f5es definidas pelos programadores com argumentos opcionais, tamb\u00e9m. Por exemplo, aqui est\u00e1 uma fun\u00e7\u00e3o que exibe as palavras mais comuns em um histograma: def print_most_common(hist, num=10): t = most_common(hist) print('The most common words are:') for freq, word in t[:num]: print(word, freq, sep='\\\\t') O primeiro par\u00e2metro \u00e9 necess\u00e1rio; o segundo \u00e9 opcional. O valor padr\u00e3o de num \u00e9 10. Se voc\u00ea s\u00f3 fornecer um argumento: print_most_common(hist) num recebe o valor padr\u00e3o. Se fornecer dois argumentos: print_most_common(hist, 20) num recebe o valor do argumento em vez disso. Em outras palavras, o argumento opcional ignora o valor padr\u00e3o. Se uma fun\u00e7\u00e3o tem ambos os par\u00e2metros obrigat\u00f3rio e opcional, todos os par\u00e2metros necess\u00e1rios t\u00eam que vir primeiro, seguidos pelos opcionais. 13.6 - Subtra\u00e7\u00e3o de dicion\u00e1rio Encontrar as palavras do livro que n\u00e3o est\u00e3o na lista de palavras de words.txt \u00e9 um problema que voc\u00ea pode reconhecer como subtra\u00e7\u00e3o de conjuntos; isto \u00e9, queremos encontrar todas as palavras de um conjunto (as palavras no livro) que n\u00e3o est\u00e3o no outro (as palavras na lista). subtract recebe os dicion\u00e1rios d1 e d2 e devolve um novo dicion\u00e1rio que cont\u00e9m todas as chaves de d1 que n\u00e3o est\u00e3o em d2 . Como n\u00e3o nos preocupamos com os valores, estabelecemos todos como None : def subtract(d1, d2): res = dict() for key in d1: if key not in d2: res[key] = None return res Para encontrar as palavras no livro que n\u00e3o est\u00e3o em words.txt, podemos usar process_file para construir um histograma para words.txt, e ent\u00e3o subtrair: words = process_file('words.txt') diff = subtract(hist, words) print(\"Words in the book that aren't in the word list:\") for word in diff: print(word, end=' ') Aqui est\u00e3o alguns resultados de Emma: Words in the book that aren't in the word list: rencontre jane's blanche woodhouses disingenuousness friend's venice apartment ... Algumas dessas palavras s\u00e3o nomes e possessivos. Os outros, como \u201crencontre\u201d, j\u00e1 n\u00e3o s\u00e3o de uso comum. Mas algumas s\u00e3o palavras comuns que realmente deveriam estar na lista! Exerc\u00edcio 13.6 O Python fornece uma estrutura de dados chamada set , que fornece muitas opera\u00e7\u00f5es de conjunto. Voc\u00ea pode ler sobre elas em \u201cConjuntos\u201d, na p\u00e1gina 274, ou ler a documenta\u00e7\u00e3o em http://docs.python.org/3/library/stdtypes.html#types-set. Escreva um programa que use a subtra\u00e7\u00e3o de conjuntos para encontrar palavras no livro que n\u00e3o est\u00e3o na lista de palavras. Solu\u00e7\u00e3o: http://thinkpython2.com/code/analyze_book2.py. 13.7 - Palavras aleat\u00f3rias Para escolher uma palavra aleat\u00f3ria do histograma, o algoritmo mais simples \u00e9 construir uma lista com v\u00e1rias c\u00f3pias de cada palavra, segundo a frequ\u00eancia observada, e ent\u00e3o escolher da lista: def random_word(h): t = [] for word, freq in h.items(): t.extend([word] * freq) return random.choice(t) A express\u00e3o [word] * freq cria uma lista com freq c\u00f3pias da string word . O m\u00e9todo extend \u00e9 similar a append , exceto pelo argumento, que \u00e9 uma sequ\u00eancia. Esse algoritmo funciona, mas n\u00e3o \u00e9 muito eficiente; cada vez que voc\u00ea escolhe uma palavra aleat\u00f3ria, ele reconstr\u00f3i a lista, que \u00e9 t\u00e3o grande quanto o livro original. Uma melhoria \u00f3bvia \u00e9 construir a lista uma vez e ent\u00e3o fazer sele\u00e7\u00f5es m\u00faltiplas, mas a lista ainda \u00e9 grande. Uma alternativa \u00e9: Usar keys para conseguir uma lista das palavras no livro. Construir uma lista que contenha a soma cumulativa das frequ\u00eancias das palavras (veja o Exerc\u00edcio 10.2). O \u00faltimo item desta lista \u00e9 o n\u00famero total de palavras no livro, n. Escolher um n\u00famero aleat\u00f3rio de 1 a n. Use uma pesquisa de bisse\u00e7\u00e3o (veja o Exerc\u00edcio 10.10) para encontrar o \u00edndice onde o n\u00famero aleat\u00f3rio seria inserido na soma cumulativa. Usar o \u00edndice para encontrar a palavra correspondente na lista de palavras. Exerc\u00edcio 13.7 Escreva um programa que use este algoritmo para escolher uma palavra aleat\u00f3ria do livro. Solu\u00e7\u00e3o: http://thinkpython2.com/code/analyze_book3.py. 13.8 - An\u00e1lise de Markov Se escolher palavras do livro aleatoriamente, voc\u00ea pode at\u00e9 captar certo sentido a partir do vocabul\u00e1rio, mas provavelmente n\u00e3o vai conseguir uma senten\u00e7a completa: this the small regard harriet which knightley's it most things Uma s\u00e9rie de palavras aleat\u00f3rias raramente faz sentido porque n\u00e3o h\u00e1 nenhuma rela\u00e7\u00e3o entre palavras sucessivas. Por exemplo, em uma senten\u00e7a de verdade voc\u00ea esperaria que um artigo como \u201co\u201d fosse seguido de um adjetivo ou um substantivo, e provavelmente n\u00e3o um verbo ou adv\u00e9rbio. Uma forma de medir estes tipos de rela\u00e7\u00f5es \u00e9 a an\u00e1lise de Markov, que caracteriza, para uma dada sequ\u00eancia de palavras, o que poderia vir a seguir, segundo a probabilidade. Por exemplo, a can\u00e7\u00e3o \u201cEric, the Half a Bee\u201d come\u00e7a assim: Half a bee, philosophically, Must, ipso facto, half not be. But half the bee has got to be Vis a vis, its entity. D\u2019you see? But can a bee be said to be Or not to be an entire bee When half the bee is not a bee Due to some ancient injury? Nesse texto, a frase \u201chalf the\u201d sempre \u00e9 seguida pela palavra \u201cbee\u201d, mas a frase \u201cthe bee\u201d pode ser seguida por \u201chas\u201d ou \u201cis\u201d. O resultado da an\u00e1lise de Markov \u00e9 um mapeamento de cada prefixo (como \u201chalf the\u201d e \u201cthe bee\u201d) a todos os sufixos poss\u00edveis (como \u201chas\u201d e \u201cis\u201d). Com este mapeamento voc\u00ea pode gerar um texto aleat\u00f3rio, come\u00e7ando com qualquer prefixo e escolhendo a esmo entre os sufixos poss\u00edveis. Em seguida, voc\u00ea pode combinar o fim do prefixo e o novo sufixo para formar o pr\u00f3ximo prefixo e repetir. Por exemplo, se voc\u00ea come\u00e7ar com o prefixo \u201cHalf a\u201d, ent\u00e3o a pr\u00f3xima palavra tem que ser \u201cbee\u201d, porque o prefixo s\u00f3 aparece uma vez no texto. O prefixo seguinte \u00e9 \u201ca bee\u201d, ent\u00e3o o pr\u00f3ximo sufixo poderia ser \u201cphilosophically\u201d, \u201cbe\u201d ou \u201cdue\u201d. Neste exemplo, o comprimento do prefixo \u00e9 sempre dois, mas voc\u00ea pode fazer a an\u00e1lise de Markov com qualquer comprimento de prefixo. Exerc\u00edcio 13.8 An\u00e1lise de Markov: a) Escreva um programa que leia o texto de um arquivo e execute a an\u00e1lise de Markov. O resultado deve ser um dicion\u00e1rio que mapeie prefixos a uma cole\u00e7\u00e3o de poss\u00edveis sufixos. A cole\u00e7\u00e3o pode ser uma lista, tupla ou dicion\u00e1rio; voc\u00ea \u00e9 que dever\u00e1 fazer a escolha adequada. Voc\u00ea pode testar seu programa com um comprimento de prefixo 2, mas deve escrever o programa de forma que seja f\u00e1cil testar outros comprimentos. b) Acrescente uma fun\u00e7\u00e3o ao programa anterior para gerar texto aleat\u00f3rio baseado na an\u00e1lise de Markov. Aqui est\u00e1 um exemplo de exemplo de Emma com o comprimento de prefixo 2. He was very clever, be it sweetness or be angry, ashamed or only amused, at such a stroke. She had never thought of Hannah till you were never meant for me?\u201d \u201cI cannot make speeches, Emma:\u201d he soon cut it all himself. Para este exemplo, deixei a pontua\u00e7\u00e3o anexada \u00e0s palavras. O resultado \u00e9 quase sintaticamente correto, mas n\u00e3o exatamente. Semanticamente, quase faz sentido, mas n\u00e3o exatamente. O que acontece se voc\u00ea aumentar o comprimento dos prefixos? O texto aleat\u00f3rio faz mais sentido? c) Uma vez que o seu programa esteja funcionando, voc\u00ea pode querer tentar uma mistura: se combinar o texto de dois ou mais livros, o texto aleat\u00f3rio gerado misturar\u00e1 o vocabul\u00e1rio e frases das fontes de formas interessantes. Cr\u00e9dito: este estudo de caso \u00e9 baseado em um exemplo de Kernighan and Pike, The Practice of Programming, Addison-Wesley, 1999. \u00c9 uma boa ideia tentar fazer este exerc\u00edcio antes de continuar; depois voc\u00ea pode baixar a minha solu\u00e7\u00e3o em http://thinkpython2.com/code/markov.py. Tamb\u00e9m vai precisar de http://thinkpython2.com/code/emma.txt. 13.9 - Estruturas de dados Usar an\u00e1lise de Markov para gerar o texto aleat\u00f3rio \u00e9 divertido, mas tamb\u00e9m h\u00e1 uma raz\u00e3o para este exerc\u00edcio: a sele\u00e7\u00e3o da estrutura de dados. Na sua solu\u00e7\u00e3o para os exerc\u00edcios anteriores, voc\u00ea teve que selecionar: como representar os prefixos; como representar a cole\u00e7\u00e3o de sufixos poss\u00edveis; como representar o mapeamento de cada prefixo \u00e0 cole\u00e7\u00e3o de poss\u00edveis sufixos. O \u00faltimo \u00e9 f\u00e1cil: um dicion\u00e1rio \u00e9 a escolha \u00f3bvia para um mapeamento de chaves a valores correspondentes. Para os prefixos, as op\u00e7\u00f5es mais \u00f3bvias s\u00e3o strings, listas de strings ou tuplas de strings. Para os sufixos, uma op\u00e7\u00e3o \u00e9 uma lista; outra \u00e9 um histograma (dicion\u00e1rio). Como voc\u00ea deve escolher? O primeiro passo \u00e9 pensar nas opera\u00e7\u00f5es que voc\u00ea vai precisar implementar para cada estrutura de dados. Para os prefixos, \u00e9 preciso poder retirar palavras do come\u00e7o e acrescentar no fim. Por exemplo, se o prefixo atual \u00e9 \u201cHalf a\u201d e a pr\u00f3xima palavra \u00e9 \u201cbee\u201d, voc\u00ea tem que poder formar o pr\u00f3ximo prefixo, \u201ca bee\u201d. Sua primeira escolha pode ser uma lista, pois \u00e9 f\u00e1cil acrescentar e retirar elementos, mas tamb\u00e9m precisamos poder usar os prefixos como chaves em um dicion\u00e1rio, para excluir listas. Com tuplas, voc\u00ea n\u00e3o pode acrescentar ou retirar, mas pode usar o operador de adi\u00e7\u00e3o para formar uma nova tupla: def shift(prefix, word): return prefix[1:] + (word,) shift recebe uma tupla de palavras, prefix, e uma string, word, e forma uma nova tupla que tem todas as palavras em prefix, exceto a primeira e word adicionada no final. Para a cole\u00e7\u00e3o de sufixos, as opera\u00e7\u00f5es que precisamos executar incluem a soma de um novo sufixo (ou aumento da frequ\u00eancia de um existente), e a escolha de um sufixo aleat\u00f3rio. Acrescentar um novo sufixo \u00e9 igualmente f\u00e1cil para a implementa\u00e7\u00e3o da lista ou do histograma. Escolher um elemento aleat\u00f3rio de uma lista \u00e9 f\u00e1cil; escolher de um histograma \u00e9 mais dif\u00edcil de fazer de forma eficiente (ver o Exerc\u00edcio 13.7). Por enquanto, falamos principalmente sobre a facilidade de implementa\u00e7\u00e3o, mas h\u00e1 outros fatores a considerar na escolha das estruturas de dados. Um deles \u00e9 o tempo de execu\u00e7\u00e3o. \u00c0s vezes, h\u00e1 uma raz\u00e3o te\u00f3rica para esperar que uma estrutura de dados seja mais r\u00e1pida que outra; por exemplo, eu mencionei que o operador in \u00e9 mais r\u00e1pido para dicion\u00e1rios que para listas, pelo menos quando o n\u00famero de elementos \u00e9 grande. Por\u00e9m, muitas vezes n\u00e3o se sabe de antem\u00e3o qual implementa\u00e7\u00e3o ser\u00e1 mais r\u00e1pida. Uma op\u00e7\u00e3o \u00e9 implementar ambas e ver qual \u00e9 melhor. Esta abordagem \u00e9 chamada de benchmarking. Uma alternativa pr\u00e1tica \u00e9 escolher a estrutura de dados mais f\u00e1cil para implementar, e ent\u00e3o ver se \u00e9 r\u00e1pida o suficiente para a aplica\u00e7\u00e3o desejada. Se for o caso, n\u00e3o \u00e9 preciso continuar. Do contr\u00e1rio, h\u00e1 ferramentas, como o m\u00f3dulo profile, que podem identificar os lugares em um programa que tomam mais tempo de execu\u00e7\u00e3o. Outro fator a considerar \u00e9 o espa\u00e7o de armazenamento. Por exemplo, usar um histograma para a cole\u00e7\u00e3o de sufixos pode tomar menos espa\u00e7o porque s\u00f3 \u00e9 preciso armazenar cada palavra uma vez, n\u00e3o importa quantas vezes apare\u00e7a no texto. Em alguns casos, a economia de espa\u00e7o tamb\u00e9m pode fazer o seu programa rodar mais r\u00e1pido e, em casos extremos, seu programa pode simplesmente nem rodar se ficar sem mem\u00f3ria. Por\u00e9m, para muitas aplica\u00e7\u00f5es, o espa\u00e7o \u00e9 uma considera\u00e7\u00e3o secund\u00e1ria depois do tempo de execu\u00e7\u00e3o. Um \u00faltimo coment\u00e1rio: nessa discuss\u00e3o, a ideia impl\u00edcita \u00e9 que devemos usar uma estrutura de dados tanto para an\u00e1lise como para gera\u00e7\u00e3o. Entretanto, como essas fases s\u00e3o separadas, tamb\u00e9m seria poss\u00edvel usar uma estrutura para a an\u00e1lise e ent\u00e3o convert\u00ea-la em outra estrutura para a gera\u00e7\u00e3o. Isso seria uma vantagem se o tempo poupado durante a gera\u00e7\u00e3o excedesse o tempo decorrido na convers\u00e3o. 13.10 - Depura\u00e7\u00e3o Quando estiver depurando um programa, especialmente se estiver trabalhando em um erro dif\u00edcil, h\u00e1 cinco coisas que voc\u00ea pode tentar: Leitura Examine seu c\u00f3digo, leia-o para voc\u00ea mesmo e verifique se diz o que voc\u00ea pensou em dizer. Execu\u00e7\u00e3o Experimente fazer altera\u00e7\u00f5es e executar vers\u00f5es diferentes. Muitas vezes, ao se expor a coisa certa no lugar certo do programa, o problema fica \u00f3bvio, mas pode ser necess\u00e1rio construir o scaffolding. Rumina\u00e7\u00e3o Pense por algum tempo! Qual \u00e9 o tipo do erro: de sintaxe, de tempo de execu\u00e7\u00e3o ou sem\u00e2ntico? Quais informa\u00e7\u00f5es voc\u00ea consegue obter a partir das mensagens de erro, ou da sa\u00edda do programa? Que tipo de erro pode causar o problema que est\u00e1 vendo? O que voc\u00ea mudou por \u00faltimo, antes que o problema aparecesse? Conversa com o pato de borracha (rubberducking) Ao explicar o problema a algu\u00e9m, \u00e0s vezes voc\u00ea consegue encontrar a resposta antes de terminar a explica\u00e7\u00e3o. Muitas vezes, n\u00e3o \u00e9 preciso nem haver outra pessoa; voc\u00ea pode falar at\u00e9 com um pato de borracha. E essa \u00e9 a origem de uma estrat\u00e9gia bem conhecida chamada de depura\u00e7\u00e3o do pato de borracha. N\u00e3o estou inventando isso, veja https://en.wikipedia.org/wiki/Rubber_duck_debugging. Retirada Em um determinado ponto, a melhor coisa a fazer \u00e9 voltar atr\u00e1s e desfazer as altera\u00e7\u00f5es recentes, at\u00e9 chegar de volta a um programa que funcione e que voc\u00ea entenda. Ent\u00e3o voc\u00ea pode come\u00e7ar a reconstruir. Programadores iniciantes \u00e0s vezes ficam presos em uma dessas atividades e esquecem das outras. Cada atividade vem com o seu pr\u00f3prio modo de falha. Por exemplo, a leitura do seu c\u00f3digo pode ajudar se o problema \u00e9 um erro tipogr\u00e1fico, mas n\u00e3o se o problema for conceitual. Se voc\u00ea n\u00e3o entende o que o seu programa faz, pode l\u00ea-lo cem vezes e nunca ver\u00e1 o erro, porque o erro est\u00e1 na sua cabe\u00e7a. Fazer experi\u00eancias pode ajudar, especialmente se voc\u00ea executar testes pequenos e simples. No entanto, se executar experi\u00eancias sem pensar ou ler seu c\u00f3digo, pode cair em um padr\u00e3o que chamo de \u201cprograma\u00e7\u00e3o aleat\u00f3ria\u201d, que \u00e9 o processo de fazer altera\u00e7\u00f5es aleat\u00f3rias at\u00e9 que o programa fa\u00e7a a coisa certa. Obviamente, a programa\u00e7\u00e3o aleat\u00f3ria pode levar muito tempo. \u00c9 preciso pensar um pouco. A depura\u00e7\u00e3o \u00e9 como ci\u00eancia experimental. Deve haver pelo menos uma hip\u00f3tese sobre qual \u00e9 o problema. Se houver duas ou mais possibilidades, tente pensar em um teste que eliminaria uma delas. N\u00e3o obstante, at\u00e9 as melhores t\u00e9cnicas de depura\u00e7\u00e3o falhar\u00e3o se houver erros demais, ou se o c\u00f3digo que est\u00e1 tentando corrigir for grande e complicado demais. \u00c0s vezes, a melhor op\u00e7\u00e3o \u00e9 voltar atr\u00e1s, simplificando o programa at\u00e9 chegar a algo que funcione e que voc\u00ea entenda. Programadores iniciantes muitas vezes relutam em voltar atr\u00e1s porque n\u00e3o suportam a ideia de eliminar sequer uma linha de c\u00f3digo (mesmo se estiver errada). Para voc\u00ea se sentir melhor, copie seu programa em outro arquivo antes de come\u00e7ar a desmont\u00e1-lo. Ent\u00e3o voc\u00ea pode copiar as partes de volta, uma a uma. Encontrar um erro dif\u00edcil exige leitura, execu\u00e7\u00e3o, rumina\u00e7\u00e3o, e, \u00e0s vezes, a retirada. Se empacar em alguma dessas atividades, tente as outras. 13.11 - Gloss\u00e1rio determinista Relativo a um programa que faz a mesma coisa cada vez que \u00e9 executado, se receber as mesmas entradas. pseudoaleat\u00f3rio Relativo a uma sequ\u00eancia de n\u00fameros que parecem ser aleat\u00f3rios, mas que s\u00e3o gerados por um programa determinista. valor padr\u00e3o Valor dado a um par\u00e2metro opcional se n\u00e3o houver nenhum argumento. ignorar (override) Substituir um valor padr\u00e3o por um argumento. benchmarking Processo de escolha entre estruturas de dados pela implementa\u00e7\u00e3o de alternativas e testes em uma amostra de entradas poss\u00edveis. depura\u00e7\u00e3o do pato de borracha Depurar explicando o problema a um objeto inanimado como um pato de borracha. Articular o problema pode ajudar a resolv\u00ea-lo, mesmo se o pato de borracha n\u00e3o conhecer Python. 13.12 - Exerc\u00edcios Exerc\u00edcio 13.9 A \u201cclassifica\u00e7\u00e3o\u201d de uma palavra \u00e9 a sua posi\u00e7\u00e3o em uma lista de palavras classificadas por frequ\u00eancia: a palavra mais comum tem a classifica\u00e7\u00e3o 1, a segunda mais comum \u00e9 2 etc. A lei de Zipf descreve a rela\u00e7\u00e3o entre classifica\u00e7\u00f5es e frequ\u00eancias das palavras em linguagens naturais (http://en.wikipedia.org/wiki/Zipf's_law). Ela prev\u00ea especificamente que a frequ\u00eancia, f, da palavra com classifica\u00e7\u00e3o r \u00e9: f = cr\u2212s onde s e c s\u00e3o par\u00e2metros que dependem do idioma e do texto. Se voc\u00ea tomar o logaritmo de ambos os lados desta equa\u00e7\u00e3o, obt\u00e9m: log f = log c \u2212 s log r Se voc\u00ea tra\u00e7ar o log de f contra o log de r, ter\u00e1 uma linha reta com uma eleva\u00e7\u00e3o -s e interceptar o log de c. Escreva um programa que leia um texto em um arquivo, conte as frequ\u00eancias das palavras e exiba uma linha para cada palavra, em ordem descendente da frequ\u00eancia, com log de f e log de r. Use o programa gr\u00e1fico de sua escolha para tra\u00e7ar os resultados e verifique se formam uma linha reta. Voc\u00ea pode estimar o valor de s? Solu\u00e7\u00e3o: http://thinkpython2.com/code/zipf.py. Para executar a minha solu\u00e7\u00e3o, voc\u00ea vai precisar do m\u00f3dulo de gr\u00e1ficos matplotlib . Se voc\u00ea instalou o Anaconda, j\u00e1 tem o matplotlib ; se n\u00e3o tiver, \u00e9 preciso instal\u00e1-lo.","title":"Cap\u00edtulo 13: Estudo de caso: sele\u00e7\u00e3o de estrutura de dados"},{"location":"13-caso-estruturas/#capitulo-13-estudo-de-caso-selecao-de-estrutura-de-dados","text":"Neste ponto voc\u00ea j\u00e1 aprendeu sobre as principais estruturas de dados do Python, e viu alguns algoritmos que as usam. Se quiser saber mais sobre algoritmos, pode ler o Cap\u00edtulo 21. Mas isso n\u00e3o \u00e9 necess\u00e1rio para continuar, pode l\u00ea-lo a qualquer momento em que tenha interesse. Este cap\u00edtulo apresenta um estudo de caso com exerc\u00edcios que fazem pensar sobre a escolha de estruturas de dados e pr\u00e1ticas de uso delas.","title":"Cap\u00edtulo 13: Estudo de caso: sele\u00e7\u00e3o de estrutura de dados"},{"location":"13-caso-estruturas/#131-analise-de-frequencia-de-palavras","text":"Como de h\u00e1bito, voc\u00ea deve pelo menos tentar fazer os exerc\u00edcios antes de ler as minhas solu\u00e7\u00f5es.","title":"13.1 - An\u00e1lise de frequ\u00eancia de palavras"},{"location":"13-caso-estruturas/#exercicio-131","text":"Escreva um programa que leia um arquivo, quebre cada linha em palavras, remova os espa\u00e7os em branco e a pontua\u00e7\u00e3o das palavras, e as converta em letras min\u00fasculas. Dica: O m\u00f3dulo string oferece uma string chamada whitespace , que cont\u00e9m espa\u00e7o, tab, newline etc., e punctuation , que cont\u00e9m os caracteres de pontua\u00e7\u00e3o. Vamos ver se conseguimos fazer o Python falar palavr\u00f5es: >>> import string >>> string.punctuation '!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~' Al\u00e9m disso, voc\u00ea pode usar os m\u00e9todos de string, strip, replace e translate.","title":"Exerc\u00edcio 13.1"},{"location":"13-caso-estruturas/#exercicio-132","text":"Acesse o Projeto Gutenberg (http://gutenberg.org) e baixe seu livro favorito em dom\u00ednio p\u00fablico em formato de texto simples. Altere seu programa do exerc\u00edcio anterior para ler o livro que voc\u00ea baixou, pulando as informa\u00e7\u00f5es do cabe\u00e7alho no in\u00edcio do arquivo e processando o resto das palavras como antes. Ent\u00e3o altere o programa para contar o n\u00famero total de palavras no livro e o n\u00famero de vezes que cada palavra \u00e9 usada. Exiba o n\u00famero de palavras diferentes usadas no livro. Compare livros diferentes de autores diferentes, escritos em eras diferentes. Que autor usa o vocabul\u00e1rio mais extenso?","title":"Exerc\u00edcio 13.2"},{"location":"13-caso-estruturas/#exercicio-133","text":"Altere o programa do exerc\u00edcio anterior para exibir as 20 palavras mais frequentes do livro.","title":"Exerc\u00edcio 13.3"},{"location":"13-caso-estruturas/#exercicio-134","text":"Altere o programa anterior para ler uma lista de palavras (ver \u201cLeitura de listas de palavras\u201d, na p\u00e1gina 133) e ent\u00e3o exiba todas as palavras do livro que n\u00e3o est\u00e3o na lista de palavras. Quantas delas s\u00e3o erros ortogr\u00e1ficos? Quantas delas s\u00e3o palavras comuns que deveriam estar na lista de palavras, e quantas s\u00e3o muito obscuras?","title":"Exerc\u00edcio 13.4"},{"location":"13-caso-estruturas/#132-numeros-aleatorios","text":"Com as mesmas entradas, a maior parte dos programas gera as mesmas sa\u00eddas a cada vez, ent\u00e3o eles s\u00e3o chamados de deterministas. Determinismo normalmente \u00e9 uma coisa boa, j\u00e1 que esperamos que o mesmo c\u00e1lculo produza o mesmo resultado. Para algumas aplica\u00e7\u00f5es, entretanto, queremos que o computador seja imprevis\u00edvel. Os jogos s\u00e3o um exemplo \u00f3bvio, mas h\u00e1 outros. Fazer um programa n\u00e3o determinista de verdade \u00e9 dif\u00edcil; mas h\u00e1 formas de, pelo menos, faz\u00ea-los parecer que n\u00e3o s\u00e3o. Uma delas \u00e9 usar algoritmos que geram n\u00fameros pseudoaleat\u00f3rios. Os n\u00fameros pseudoaleat\u00f3rios n\u00e3o s\u00e3o aleat\u00f3rios mesmo porque s\u00e3o gerados por um c\u00e1lculo determinista, mas \u00e9 quase imposs\u00edvel distingui-los dos aleat\u00f3rios s\u00f3 olhando para os n\u00fameros. O m\u00f3dulo random fornece fun\u00e7\u00f5es que geram n\u00fameros pseudoaleat\u00f3rios (que chamarei apenas de \u201caleat\u00f3rios\u201d daqui em diante). A fun\u00e7\u00e3o random retorna um n\u00famero de ponto flutuante entre 0,0 e 1,0 (incluindo 0,0, mas n\u00e3o 1,0). Cada vez que random \u00e9 chamada, voc\u00ea recebe o pr\u00f3ximo n\u00famero em uma longa s\u00e9rie. Para ver uma amostra, execute este loop: import random for i in range(10): x = random.random() print(x) A fun\u00e7\u00e3o randint recebe os par\u00e2metros low e high e retorna um n\u00famero inteiro entre low e high (inclusive ambos): >>> random.randint(5, 10) 5 >>> random.randint(5, 10) 9 Para escolher aleatoriamente um elemento de uma sequ\u00eancia, voc\u00ea pode usar choice: >>> t = [1, 2, 3] >>> random.choice(t) 2 >>> random.choice(t) 3 O m\u00f3dulo random tamb\u00e9m fornece fun\u00e7\u00f5es para gerar valores aleat\u00f3rios de distribui\u00e7\u00f5es cont\u00ednuas, incluindo gaussianas, exponenciais, gamma e algumas outras.","title":"13.2 - N\u00fameros aleat\u00f3rios"},{"location":"13-caso-estruturas/#exercicio-135","text":"Escreva uma fun\u00e7\u00e3o chamada choose_from_hist que receba um histograma como definido em \u201cUm dicion\u00e1rio como uma cole\u00e7\u00e3o de contadores\u201d, na p\u00e1gina 163, e retorne um valor aleat\u00f3rio do histograma, escolhido por probabilidade em propor\u00e7\u00e3o \u00e0 frequ\u00eancia. Por exemplo, para este histograma: >>> t = ['a', 'a', 'b'] >>> hist = histogram(t) >>> hist {'a': 2, 'b': 1} sua fun\u00e7\u00e3o deve retornar 'a' com a probabilidade de 2/3 e 'b' com a probabilidade 1/3.","title":"Exerc\u00edcio 13.5"},{"location":"13-caso-estruturas/#133-histograma-de-palavras","text":"\u00c9 uma boa ideia tentar fazer os exerc\u00edcios anteriores antes de continuar. Voc\u00ea pode baixar minha solu\u00e7\u00e3o em http://thinkpython2.com/code/analyze_book1.py. Tamb\u00e9m vai precisar de http://thinkpython2.com/code/emma.txt. Aqui est\u00e1 um programa que l\u00ea um arquivo e constr\u00f3i um histograma das palavras no arquivo: import string def process_file(filename): hist = dict() fp = open(filename) for line in fp: process_line(line, hist) return hist def process_line(line, hist): line = line.replace('-', ' ') for word in line.split(): word = word.strip(string.punctuation + string.whitespace) word = word.lower() hist[word] = hist.get(word, 0) + 1 hist = process_file('emma.txt') Este programa l\u00ea emma.txt , que cont\u00e9m o texto de Emma , de Jane Austen. process_file faz o loop pelas linhas do arquivo, passando-as uma a uma para process_line . O histograma hist est\u00e1 sendo usado como um acumulador. process_line usa o m\u00e9todo de string replace para substituir hifens por espa\u00e7os antes de usar split para quebrar a linha em uma lista de strings. Ele atravessa a lista de palavras e usa strip e lower para retirar a pontua\u00e7\u00e3o e converter tudo em letras min\u00fasculas. (Dizer que as strings \u201cs\u00e3o convertidas\u201d \u00e9 uma forma simples de explicar a coisa; lembre-se de que as strings s\u00e3o imut\u00e1veis, ent\u00e3o m\u00e9todos como strip e lower retornam novas strings.) Finalmente, process_line atualiza o histograma, criando um novo item ou incrementando um existente. Para contar o n\u00famero total de palavras no arquivo, podemos somar as frequ\u00eancias no histograma: def total_words(hist): return sum(hist.values()) O n\u00famero de palavras diferentes \u00e9 somente o n\u00famero de itens no dicion\u00e1rio: def different_words(hist): return len(hist) Aqui est\u00e1 o c\u00f3digo para exibir os resultados: print('Total number of words:', total_words(hist)) print('Number of different words:', different_words(hist)) E os resultados: Total number of words: 161080 Number of different words: 7214","title":"13.3 - Histograma de palavras"},{"location":"13-caso-estruturas/#134-palavras-mais-comuns","text":"Para encontrar as palavras mais comuns, podemos fazer uma lista de tuplas, onde cada tupla contenha uma palavra e a sua frequ\u00eancia, e ordenar a lista. A fun\u00e7\u00e3o seguinte recebe um histograma e retorna uma lista de tuplas de palavras e frequ\u00eancias: def most_common(hist): t = [] for key, value in hist.items(): t.append((value, key)) t.sort(reverse=True) return t Em cada tupla, a frequ\u00eancia aparece primeiro, ent\u00e3o a lista resultante \u00e9 ordenada por frequ\u00eancia. Aqui est\u00e1 um loop que imprime as 10 palavras mais comuns: t = most_common(hist) print('The most common words are:') for freq, word in t[:10]: print(word, freq, sep='\\\\t') Uso o argumento de palavra-chave sep para que print use um caractere tab como separador, em vez de um espa\u00e7o, assim a segunda coluna fica alinhada verticalmente. Aqui est\u00e3o os resultados de Emma: The most common words are: to 5242 the 5205 and 4897 of 4295 i 3191 a 3130 it 2529 her 2483 was 2400 she 2364 Este c\u00f3digo pode ser simplificado usando o par\u00e2metro key da fun\u00e7\u00e3o sort . Se tiver curiosidade, pode ler sobre ele em https://wiki.python.org/moin/HowTo/Sorting.","title":"13.4 - Palavras mais comuns"},{"location":"13-caso-estruturas/#135-parametros-opcionais","text":"Vimos fun\u00e7\u00f5es integradas e m\u00e9todos que recebem argumentos opcionais. \u00c9 poss\u00edvel escrever fun\u00e7\u00f5es definidas pelos programadores com argumentos opcionais, tamb\u00e9m. Por exemplo, aqui est\u00e1 uma fun\u00e7\u00e3o que exibe as palavras mais comuns em um histograma: def print_most_common(hist, num=10): t = most_common(hist) print('The most common words are:') for freq, word in t[:num]: print(word, freq, sep='\\\\t') O primeiro par\u00e2metro \u00e9 necess\u00e1rio; o segundo \u00e9 opcional. O valor padr\u00e3o de num \u00e9 10. Se voc\u00ea s\u00f3 fornecer um argumento: print_most_common(hist) num recebe o valor padr\u00e3o. Se fornecer dois argumentos: print_most_common(hist, 20) num recebe o valor do argumento em vez disso. Em outras palavras, o argumento opcional ignora o valor padr\u00e3o. Se uma fun\u00e7\u00e3o tem ambos os par\u00e2metros obrigat\u00f3rio e opcional, todos os par\u00e2metros necess\u00e1rios t\u00eam que vir primeiro, seguidos pelos opcionais.","title":"13.5 - Par\u00e2metros opcionais"},{"location":"13-caso-estruturas/#136-subtracao-de-dicionario","text":"Encontrar as palavras do livro que n\u00e3o est\u00e3o na lista de palavras de words.txt \u00e9 um problema que voc\u00ea pode reconhecer como subtra\u00e7\u00e3o de conjuntos; isto \u00e9, queremos encontrar todas as palavras de um conjunto (as palavras no livro) que n\u00e3o est\u00e3o no outro (as palavras na lista). subtract recebe os dicion\u00e1rios d1 e d2 e devolve um novo dicion\u00e1rio que cont\u00e9m todas as chaves de d1 que n\u00e3o est\u00e3o em d2 . Como n\u00e3o nos preocupamos com os valores, estabelecemos todos como None : def subtract(d1, d2): res = dict() for key in d1: if key not in d2: res[key] = None return res Para encontrar as palavras no livro que n\u00e3o est\u00e3o em words.txt, podemos usar process_file para construir um histograma para words.txt, e ent\u00e3o subtrair: words = process_file('words.txt') diff = subtract(hist, words) print(\"Words in the book that aren't in the word list:\") for word in diff: print(word, end=' ') Aqui est\u00e3o alguns resultados de Emma: Words in the book that aren't in the word list: rencontre jane's blanche woodhouses disingenuousness friend's venice apartment ... Algumas dessas palavras s\u00e3o nomes e possessivos. Os outros, como \u201crencontre\u201d, j\u00e1 n\u00e3o s\u00e3o de uso comum. Mas algumas s\u00e3o palavras comuns que realmente deveriam estar na lista!","title":"13.6 - Subtra\u00e7\u00e3o de dicion\u00e1rio"},{"location":"13-caso-estruturas/#exercicio-136","text":"O Python fornece uma estrutura de dados chamada set , que fornece muitas opera\u00e7\u00f5es de conjunto. Voc\u00ea pode ler sobre elas em \u201cConjuntos\u201d, na p\u00e1gina 274, ou ler a documenta\u00e7\u00e3o em http://docs.python.org/3/library/stdtypes.html#types-set. Escreva um programa que use a subtra\u00e7\u00e3o de conjuntos para encontrar palavras no livro que n\u00e3o est\u00e3o na lista de palavras. Solu\u00e7\u00e3o: http://thinkpython2.com/code/analyze_book2.py.","title":"Exerc\u00edcio 13.6"},{"location":"13-caso-estruturas/#137-palavras-aleatorias","text":"Para escolher uma palavra aleat\u00f3ria do histograma, o algoritmo mais simples \u00e9 construir uma lista com v\u00e1rias c\u00f3pias de cada palavra, segundo a frequ\u00eancia observada, e ent\u00e3o escolher da lista: def random_word(h): t = [] for word, freq in h.items(): t.extend([word] * freq) return random.choice(t) A express\u00e3o [word] * freq cria uma lista com freq c\u00f3pias da string word . O m\u00e9todo extend \u00e9 similar a append , exceto pelo argumento, que \u00e9 uma sequ\u00eancia. Esse algoritmo funciona, mas n\u00e3o \u00e9 muito eficiente; cada vez que voc\u00ea escolhe uma palavra aleat\u00f3ria, ele reconstr\u00f3i a lista, que \u00e9 t\u00e3o grande quanto o livro original. Uma melhoria \u00f3bvia \u00e9 construir a lista uma vez e ent\u00e3o fazer sele\u00e7\u00f5es m\u00faltiplas, mas a lista ainda \u00e9 grande. Uma alternativa \u00e9: Usar keys para conseguir uma lista das palavras no livro. Construir uma lista que contenha a soma cumulativa das frequ\u00eancias das palavras (veja o Exerc\u00edcio 10.2). O \u00faltimo item desta lista \u00e9 o n\u00famero total de palavras no livro, n. Escolher um n\u00famero aleat\u00f3rio de 1 a n. Use uma pesquisa de bisse\u00e7\u00e3o (veja o Exerc\u00edcio 10.10) para encontrar o \u00edndice onde o n\u00famero aleat\u00f3rio seria inserido na soma cumulativa. Usar o \u00edndice para encontrar a palavra correspondente na lista de palavras.","title":"13.7 - Palavras aleat\u00f3rias"},{"location":"13-caso-estruturas/#exercicio-137","text":"Escreva um programa que use este algoritmo para escolher uma palavra aleat\u00f3ria do livro. Solu\u00e7\u00e3o: http://thinkpython2.com/code/analyze_book3.py.","title":"Exerc\u00edcio 13.7"},{"location":"13-caso-estruturas/#138-analise-de-markov","text":"Se escolher palavras do livro aleatoriamente, voc\u00ea pode at\u00e9 captar certo sentido a partir do vocabul\u00e1rio, mas provavelmente n\u00e3o vai conseguir uma senten\u00e7a completa: this the small regard harriet which knightley's it most things Uma s\u00e9rie de palavras aleat\u00f3rias raramente faz sentido porque n\u00e3o h\u00e1 nenhuma rela\u00e7\u00e3o entre palavras sucessivas. Por exemplo, em uma senten\u00e7a de verdade voc\u00ea esperaria que um artigo como \u201co\u201d fosse seguido de um adjetivo ou um substantivo, e provavelmente n\u00e3o um verbo ou adv\u00e9rbio. Uma forma de medir estes tipos de rela\u00e7\u00f5es \u00e9 a an\u00e1lise de Markov, que caracteriza, para uma dada sequ\u00eancia de palavras, o que poderia vir a seguir, segundo a probabilidade. Por exemplo, a can\u00e7\u00e3o \u201cEric, the Half a Bee\u201d come\u00e7a assim: Half a bee, philosophically, Must, ipso facto, half not be. But half the bee has got to be Vis a vis, its entity. D\u2019you see? But can a bee be said to be Or not to be an entire bee When half the bee is not a bee Due to some ancient injury? Nesse texto, a frase \u201chalf the\u201d sempre \u00e9 seguida pela palavra \u201cbee\u201d, mas a frase \u201cthe bee\u201d pode ser seguida por \u201chas\u201d ou \u201cis\u201d. O resultado da an\u00e1lise de Markov \u00e9 um mapeamento de cada prefixo (como \u201chalf the\u201d e \u201cthe bee\u201d) a todos os sufixos poss\u00edveis (como \u201chas\u201d e \u201cis\u201d). Com este mapeamento voc\u00ea pode gerar um texto aleat\u00f3rio, come\u00e7ando com qualquer prefixo e escolhendo a esmo entre os sufixos poss\u00edveis. Em seguida, voc\u00ea pode combinar o fim do prefixo e o novo sufixo para formar o pr\u00f3ximo prefixo e repetir. Por exemplo, se voc\u00ea come\u00e7ar com o prefixo \u201cHalf a\u201d, ent\u00e3o a pr\u00f3xima palavra tem que ser \u201cbee\u201d, porque o prefixo s\u00f3 aparece uma vez no texto. O prefixo seguinte \u00e9 \u201ca bee\u201d, ent\u00e3o o pr\u00f3ximo sufixo poderia ser \u201cphilosophically\u201d, \u201cbe\u201d ou \u201cdue\u201d. Neste exemplo, o comprimento do prefixo \u00e9 sempre dois, mas voc\u00ea pode fazer a an\u00e1lise de Markov com qualquer comprimento de prefixo.","title":"13.8 - An\u00e1lise de Markov"},{"location":"13-caso-estruturas/#exercicio-138","text":"An\u00e1lise de Markov: a) Escreva um programa que leia o texto de um arquivo e execute a an\u00e1lise de Markov. O resultado deve ser um dicion\u00e1rio que mapeie prefixos a uma cole\u00e7\u00e3o de poss\u00edveis sufixos. A cole\u00e7\u00e3o pode ser uma lista, tupla ou dicion\u00e1rio; voc\u00ea \u00e9 que dever\u00e1 fazer a escolha adequada. Voc\u00ea pode testar seu programa com um comprimento de prefixo 2, mas deve escrever o programa de forma que seja f\u00e1cil testar outros comprimentos. b) Acrescente uma fun\u00e7\u00e3o ao programa anterior para gerar texto aleat\u00f3rio baseado na an\u00e1lise de Markov. Aqui est\u00e1 um exemplo de exemplo de Emma com o comprimento de prefixo 2. He was very clever, be it sweetness or be angry, ashamed or only amused, at such a stroke. She had never thought of Hannah till you were never meant for me?\u201d \u201cI cannot make speeches, Emma:\u201d he soon cut it all himself. Para este exemplo, deixei a pontua\u00e7\u00e3o anexada \u00e0s palavras. O resultado \u00e9 quase sintaticamente correto, mas n\u00e3o exatamente. Semanticamente, quase faz sentido, mas n\u00e3o exatamente. O que acontece se voc\u00ea aumentar o comprimento dos prefixos? O texto aleat\u00f3rio faz mais sentido? c) Uma vez que o seu programa esteja funcionando, voc\u00ea pode querer tentar uma mistura: se combinar o texto de dois ou mais livros, o texto aleat\u00f3rio gerado misturar\u00e1 o vocabul\u00e1rio e frases das fontes de formas interessantes. Cr\u00e9dito: este estudo de caso \u00e9 baseado em um exemplo de Kernighan and Pike, The Practice of Programming, Addison-Wesley, 1999. \u00c9 uma boa ideia tentar fazer este exerc\u00edcio antes de continuar; depois voc\u00ea pode baixar a minha solu\u00e7\u00e3o em http://thinkpython2.com/code/markov.py. Tamb\u00e9m vai precisar de http://thinkpython2.com/code/emma.txt.","title":"Exerc\u00edcio 13.8"},{"location":"13-caso-estruturas/#139-estruturas-de-dados","text":"Usar an\u00e1lise de Markov para gerar o texto aleat\u00f3rio \u00e9 divertido, mas tamb\u00e9m h\u00e1 uma raz\u00e3o para este exerc\u00edcio: a sele\u00e7\u00e3o da estrutura de dados. Na sua solu\u00e7\u00e3o para os exerc\u00edcios anteriores, voc\u00ea teve que selecionar: como representar os prefixos; como representar a cole\u00e7\u00e3o de sufixos poss\u00edveis; como representar o mapeamento de cada prefixo \u00e0 cole\u00e7\u00e3o de poss\u00edveis sufixos. O \u00faltimo \u00e9 f\u00e1cil: um dicion\u00e1rio \u00e9 a escolha \u00f3bvia para um mapeamento de chaves a valores correspondentes. Para os prefixos, as op\u00e7\u00f5es mais \u00f3bvias s\u00e3o strings, listas de strings ou tuplas de strings. Para os sufixos, uma op\u00e7\u00e3o \u00e9 uma lista; outra \u00e9 um histograma (dicion\u00e1rio). Como voc\u00ea deve escolher? O primeiro passo \u00e9 pensar nas opera\u00e7\u00f5es que voc\u00ea vai precisar implementar para cada estrutura de dados. Para os prefixos, \u00e9 preciso poder retirar palavras do come\u00e7o e acrescentar no fim. Por exemplo, se o prefixo atual \u00e9 \u201cHalf a\u201d e a pr\u00f3xima palavra \u00e9 \u201cbee\u201d, voc\u00ea tem que poder formar o pr\u00f3ximo prefixo, \u201ca bee\u201d. Sua primeira escolha pode ser uma lista, pois \u00e9 f\u00e1cil acrescentar e retirar elementos, mas tamb\u00e9m precisamos poder usar os prefixos como chaves em um dicion\u00e1rio, para excluir listas. Com tuplas, voc\u00ea n\u00e3o pode acrescentar ou retirar, mas pode usar o operador de adi\u00e7\u00e3o para formar uma nova tupla: def shift(prefix, word): return prefix[1:] + (word,) shift recebe uma tupla de palavras, prefix, e uma string, word, e forma uma nova tupla que tem todas as palavras em prefix, exceto a primeira e word adicionada no final. Para a cole\u00e7\u00e3o de sufixos, as opera\u00e7\u00f5es que precisamos executar incluem a soma de um novo sufixo (ou aumento da frequ\u00eancia de um existente), e a escolha de um sufixo aleat\u00f3rio. Acrescentar um novo sufixo \u00e9 igualmente f\u00e1cil para a implementa\u00e7\u00e3o da lista ou do histograma. Escolher um elemento aleat\u00f3rio de uma lista \u00e9 f\u00e1cil; escolher de um histograma \u00e9 mais dif\u00edcil de fazer de forma eficiente (ver o Exerc\u00edcio 13.7). Por enquanto, falamos principalmente sobre a facilidade de implementa\u00e7\u00e3o, mas h\u00e1 outros fatores a considerar na escolha das estruturas de dados. Um deles \u00e9 o tempo de execu\u00e7\u00e3o. \u00c0s vezes, h\u00e1 uma raz\u00e3o te\u00f3rica para esperar que uma estrutura de dados seja mais r\u00e1pida que outra; por exemplo, eu mencionei que o operador in \u00e9 mais r\u00e1pido para dicion\u00e1rios que para listas, pelo menos quando o n\u00famero de elementos \u00e9 grande. Por\u00e9m, muitas vezes n\u00e3o se sabe de antem\u00e3o qual implementa\u00e7\u00e3o ser\u00e1 mais r\u00e1pida. Uma op\u00e7\u00e3o \u00e9 implementar ambas e ver qual \u00e9 melhor. Esta abordagem \u00e9 chamada de benchmarking. Uma alternativa pr\u00e1tica \u00e9 escolher a estrutura de dados mais f\u00e1cil para implementar, e ent\u00e3o ver se \u00e9 r\u00e1pida o suficiente para a aplica\u00e7\u00e3o desejada. Se for o caso, n\u00e3o \u00e9 preciso continuar. Do contr\u00e1rio, h\u00e1 ferramentas, como o m\u00f3dulo profile, que podem identificar os lugares em um programa que tomam mais tempo de execu\u00e7\u00e3o. Outro fator a considerar \u00e9 o espa\u00e7o de armazenamento. Por exemplo, usar um histograma para a cole\u00e7\u00e3o de sufixos pode tomar menos espa\u00e7o porque s\u00f3 \u00e9 preciso armazenar cada palavra uma vez, n\u00e3o importa quantas vezes apare\u00e7a no texto. Em alguns casos, a economia de espa\u00e7o tamb\u00e9m pode fazer o seu programa rodar mais r\u00e1pido e, em casos extremos, seu programa pode simplesmente nem rodar se ficar sem mem\u00f3ria. Por\u00e9m, para muitas aplica\u00e7\u00f5es, o espa\u00e7o \u00e9 uma considera\u00e7\u00e3o secund\u00e1ria depois do tempo de execu\u00e7\u00e3o. Um \u00faltimo coment\u00e1rio: nessa discuss\u00e3o, a ideia impl\u00edcita \u00e9 que devemos usar uma estrutura de dados tanto para an\u00e1lise como para gera\u00e7\u00e3o. Entretanto, como essas fases s\u00e3o separadas, tamb\u00e9m seria poss\u00edvel usar uma estrutura para a an\u00e1lise e ent\u00e3o convert\u00ea-la em outra estrutura para a gera\u00e7\u00e3o. Isso seria uma vantagem se o tempo poupado durante a gera\u00e7\u00e3o excedesse o tempo decorrido na convers\u00e3o.","title":"13.9 - Estruturas de dados"},{"location":"13-caso-estruturas/#1310-depuracao","text":"Quando estiver depurando um programa, especialmente se estiver trabalhando em um erro dif\u00edcil, h\u00e1 cinco coisas que voc\u00ea pode tentar: Leitura Examine seu c\u00f3digo, leia-o para voc\u00ea mesmo e verifique se diz o que voc\u00ea pensou em dizer. Execu\u00e7\u00e3o Experimente fazer altera\u00e7\u00f5es e executar vers\u00f5es diferentes. Muitas vezes, ao se expor a coisa certa no lugar certo do programa, o problema fica \u00f3bvio, mas pode ser necess\u00e1rio construir o scaffolding. Rumina\u00e7\u00e3o Pense por algum tempo! Qual \u00e9 o tipo do erro: de sintaxe, de tempo de execu\u00e7\u00e3o ou sem\u00e2ntico? Quais informa\u00e7\u00f5es voc\u00ea consegue obter a partir das mensagens de erro, ou da sa\u00edda do programa? Que tipo de erro pode causar o problema que est\u00e1 vendo? O que voc\u00ea mudou por \u00faltimo, antes que o problema aparecesse? Conversa com o pato de borracha (rubberducking) Ao explicar o problema a algu\u00e9m, \u00e0s vezes voc\u00ea consegue encontrar a resposta antes de terminar a explica\u00e7\u00e3o. Muitas vezes, n\u00e3o \u00e9 preciso nem haver outra pessoa; voc\u00ea pode falar at\u00e9 com um pato de borracha. E essa \u00e9 a origem de uma estrat\u00e9gia bem conhecida chamada de depura\u00e7\u00e3o do pato de borracha. N\u00e3o estou inventando isso, veja https://en.wikipedia.org/wiki/Rubber_duck_debugging. Retirada Em um determinado ponto, a melhor coisa a fazer \u00e9 voltar atr\u00e1s e desfazer as altera\u00e7\u00f5es recentes, at\u00e9 chegar de volta a um programa que funcione e que voc\u00ea entenda. Ent\u00e3o voc\u00ea pode come\u00e7ar a reconstruir. Programadores iniciantes \u00e0s vezes ficam presos em uma dessas atividades e esquecem das outras. Cada atividade vem com o seu pr\u00f3prio modo de falha. Por exemplo, a leitura do seu c\u00f3digo pode ajudar se o problema \u00e9 um erro tipogr\u00e1fico, mas n\u00e3o se o problema for conceitual. Se voc\u00ea n\u00e3o entende o que o seu programa faz, pode l\u00ea-lo cem vezes e nunca ver\u00e1 o erro, porque o erro est\u00e1 na sua cabe\u00e7a. Fazer experi\u00eancias pode ajudar, especialmente se voc\u00ea executar testes pequenos e simples. No entanto, se executar experi\u00eancias sem pensar ou ler seu c\u00f3digo, pode cair em um padr\u00e3o que chamo de \u201cprograma\u00e7\u00e3o aleat\u00f3ria\u201d, que \u00e9 o processo de fazer altera\u00e7\u00f5es aleat\u00f3rias at\u00e9 que o programa fa\u00e7a a coisa certa. Obviamente, a programa\u00e7\u00e3o aleat\u00f3ria pode levar muito tempo. \u00c9 preciso pensar um pouco. A depura\u00e7\u00e3o \u00e9 como ci\u00eancia experimental. Deve haver pelo menos uma hip\u00f3tese sobre qual \u00e9 o problema. Se houver duas ou mais possibilidades, tente pensar em um teste que eliminaria uma delas. N\u00e3o obstante, at\u00e9 as melhores t\u00e9cnicas de depura\u00e7\u00e3o falhar\u00e3o se houver erros demais, ou se o c\u00f3digo que est\u00e1 tentando corrigir for grande e complicado demais. \u00c0s vezes, a melhor op\u00e7\u00e3o \u00e9 voltar atr\u00e1s, simplificando o programa at\u00e9 chegar a algo que funcione e que voc\u00ea entenda. Programadores iniciantes muitas vezes relutam em voltar atr\u00e1s porque n\u00e3o suportam a ideia de eliminar sequer uma linha de c\u00f3digo (mesmo se estiver errada). Para voc\u00ea se sentir melhor, copie seu programa em outro arquivo antes de come\u00e7ar a desmont\u00e1-lo. Ent\u00e3o voc\u00ea pode copiar as partes de volta, uma a uma. Encontrar um erro dif\u00edcil exige leitura, execu\u00e7\u00e3o, rumina\u00e7\u00e3o, e, \u00e0s vezes, a retirada. Se empacar em alguma dessas atividades, tente as outras.","title":"13.10 - Depura\u00e7\u00e3o"},{"location":"13-caso-estruturas/#1311-glossario","text":"determinista Relativo a um programa que faz a mesma coisa cada vez que \u00e9 executado, se receber as mesmas entradas. pseudoaleat\u00f3rio Relativo a uma sequ\u00eancia de n\u00fameros que parecem ser aleat\u00f3rios, mas que s\u00e3o gerados por um programa determinista. valor padr\u00e3o Valor dado a um par\u00e2metro opcional se n\u00e3o houver nenhum argumento. ignorar (override) Substituir um valor padr\u00e3o por um argumento. benchmarking Processo de escolha entre estruturas de dados pela implementa\u00e7\u00e3o de alternativas e testes em uma amostra de entradas poss\u00edveis. depura\u00e7\u00e3o do pato de borracha Depurar explicando o problema a um objeto inanimado como um pato de borracha. Articular o problema pode ajudar a resolv\u00ea-lo, mesmo se o pato de borracha n\u00e3o conhecer Python.","title":"13.11 - Gloss\u00e1rio"},{"location":"13-caso-estruturas/#1312-exercicios","text":"","title":"13.12 - Exerc\u00edcios"},{"location":"13-caso-estruturas/#exercicio-139","text":"A \u201cclassifica\u00e7\u00e3o\u201d de uma palavra \u00e9 a sua posi\u00e7\u00e3o em uma lista de palavras classificadas por frequ\u00eancia: a palavra mais comum tem a classifica\u00e7\u00e3o 1, a segunda mais comum \u00e9 2 etc. A lei de Zipf descreve a rela\u00e7\u00e3o entre classifica\u00e7\u00f5es e frequ\u00eancias das palavras em linguagens naturais (http://en.wikipedia.org/wiki/Zipf's_law). Ela prev\u00ea especificamente que a frequ\u00eancia, f, da palavra com classifica\u00e7\u00e3o r \u00e9: f = cr\u2212s onde s e c s\u00e3o par\u00e2metros que dependem do idioma e do texto. Se voc\u00ea tomar o logaritmo de ambos os lados desta equa\u00e7\u00e3o, obt\u00e9m: log f = log c \u2212 s log r Se voc\u00ea tra\u00e7ar o log de f contra o log de r, ter\u00e1 uma linha reta com uma eleva\u00e7\u00e3o -s e interceptar o log de c. Escreva um programa que leia um texto em um arquivo, conte as frequ\u00eancias das palavras e exiba uma linha para cada palavra, em ordem descendente da frequ\u00eancia, com log de f e log de r. Use o programa gr\u00e1fico de sua escolha para tra\u00e7ar os resultados e verifique se formam uma linha reta. Voc\u00ea pode estimar o valor de s? Solu\u00e7\u00e3o: http://thinkpython2.com/code/zipf.py. Para executar a minha solu\u00e7\u00e3o, voc\u00ea vai precisar do m\u00f3dulo de gr\u00e1ficos matplotlib . Se voc\u00ea instalou o Anaconda, j\u00e1 tem o matplotlib ; se n\u00e3o tiver, \u00e9 preciso instal\u00e1-lo.","title":"Exerc\u00edcio 13.9"},{"location":"14-arquivos/","text":"Cap\u00edtulo 14: Arquivos Este cap\u00edtulo apresenta a ideia de programas \u201cpersistentes\u201d, que mant\u00eam dados em armazenamento permanente, e mostra como usar tipos diferentes de armazenamento permanente, como arquivos e bancos de dados. 14.1 - Persist\u00eancia A maioria dos programas que vimos at\u00e9 agora s\u00e3o transit\u00f3rios, porque s\u00e3o executados por algum tempo e produzem alguma sa\u00edda, mas, quando terminam, seus dados desaparecem. Se executar o programa novamente, ele come\u00e7a novamente do zero. Outros programas s\u00e3o persistentes: rodam por muito tempo (ou todo o tempo); mant\u00eam pelo menos alguns dos seus dados em armazenamento permanente (uma unidade de disco r\u00edgido, por exemplo); e se s\u00e3o desligados e reiniciados, continuam de onde pararam. Exemplos de programas persistentes s\u00e3o sistemas operacionais, que rodam praticamente durante todo o tempo em que um computador est\u00e1 ligado, e servidores web, que rodam todo o tempo, esperando pedidos de entrada na rede. Uma das formas mais simples para programas manterem seus dados \u00e9 lendo e escrevendo arquivos de texto. J\u00e1 vimos programas que leem arquivos de texto; neste cap\u00edtulo veremos programas que os escrevem. Uma alternativa \u00e9 armazenar o estado do programa em um banco de dados. Neste cap\u00edtulo apresentarei um banco de dados simples e um m\u00f3dulo, pickle, que facilita o armazenamento de dados de programas. 14.2 - Leitura e escrita Um arquivo de texto \u00e9 uma sequ\u00eancia de caracteres armazenados em um meio permanente como uma unidade de disco r\u00edgido, pendrive ou CD-ROM. Vimos como abrir e ler um arquivo em \u201cLeitura de listas de palavras\u201d na p\u00e1gina 133. Para escrever um arquivo texto, \u00e9 preciso abri-lo com o modo 'w' como segundo par\u00e2metro: >>> fout = open('output.txt', 'w') Se o arquivo j\u00e1 existe, abri-lo em modo de escrita elimina os dados antigos e come\u00e7a tudo de novo, ent\u00e3o tenha cuidado! Se o arquivo n\u00e3o existir, \u00e9 criado um arquivo novo. open retorna um objeto de arquivo que fornece m\u00e9todos para trabalhar com o arquivo. O m\u00e9todo write p\u00f5e dados no arquivo: >>> line1 = \"This here's the wattle,\\n\" >>> fout.write(line1) 24 O valor devolvido \u00e9 o n\u00famero de caracteres que foram escritos. O objeto de arquivo monitora a posi\u00e7\u00e3o em que est\u00e1, ent\u00e3o se voc\u00ea chamar write novamente, os novos dados s\u00e3o acrescentados ao fim do arquivo: >>> line2 = \"the emblem of our land.\\n\" >>> fout.write(line2) 24 Ao terminar de escrever, voc\u00ea deve fechar o arquivo: >>> fout.close() Se n\u00e3o fechar o arquivo, ele \u00e9 fechado para voc\u00ea quando o programa termina. 14.3 - Operador de formata\u00e7\u00e3o O argumento de write tem que ser uma string, ent\u00e3o, se quisermos inserir outros valores em um arquivo, precisamos convert\u00ea-los em strings. O modo mais f\u00e1cil de fazer isso \u00e9 com str : >>> x = 52 >>> fout.write(str(x)) Uma alternativa \u00e9 usar o operador de formata\u00e7\u00e3o, % . Quando aplicado a n\u00fameros inteiros, % \u00e9 o operador de m\u00f3dulo. No entanto, quando o primeiro operando \u00e9 uma string, % \u00e9 o operador de formata\u00e7\u00e3o. O primeiro operando \u00e9 a string de formata\u00e7\u00e3o, que cont\u00e9m uma ou v\u00e1rias sequ\u00eancias de formata\u00e7\u00e3o que especificam como o segundo operando deve ser formatado. O resultado \u00e9 uma string. Por exemplo, a sequ\u00eancia de formata\u00e7\u00e3o '%d' significa que o segundo operando deve ser formatado como um n\u00famero inteiro decimal: >>> camels = 42 >>> '%d' % camels '42' O resultado \u00e9 a string '42' , que n\u00e3o deve ser confundida com o valor inteiro 42 . Uma sequ\u00eancia de formata\u00e7\u00e3o pode aparecer em qualquer lugar na string, ent\u00e3o voc\u00ea pode embutir um valor em uma senten\u00e7a: >>> 'I have spotted %d camels.' % camels 'I have spotted 42 camels.' Se houver mais de uma sequ\u00eancia de formata\u00e7\u00e3o na string, o segundo argumento tem que ser uma tupla. Cada sequ\u00eancia de formata\u00e7\u00e3o \u00e9 combinada com um elemento da tupla, nesta ordem. O seguinte exemplo usa '%d' para formatar um n\u00famero inteiro, '%g' para formatar um n\u00famero de ponto flutuante e '%s' para formatar qualquer objeto como uma string: >>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels') 'In 3 years I have spotted 0.1 camels.' O n\u00famero de elementos na tupla tem de corresponder ao n\u00famero de sequ\u00eancias de formata\u00e7\u00e3o na string. Al\u00e9m disso, os tipos dos elementos t\u00eam de corresponder \u00e0s sequ\u00eancias de formata\u00e7\u00e3o: >>> '%d %d %d' % (1, 2) TypeError: not enough arguments for format string >>> '%d' % 'dollars' TypeError: %d format: a number is required, not str No primeiro exemplo n\u00e3o h\u00e1 elementos suficientes; no segundo, o elemento \u00e9 do tipo incorreto. Para obter mais informa\u00e7\u00f5es sobre o operador de formato, veja https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting. Voc\u00ea pode ler sobre uma alternativa mais eficiente, o m\u00e9todo de formata\u00e7\u00e3o de strings, em https://docs.python.org/3/library/stdtypes.html#str.format. 14.4 - Nomes de arquivo e caminhos Os arquivos s\u00e3o organizados em diret\u00f3rios (tamb\u00e9m chamados de \u201cpastas\u201d). Cada programa em execu\u00e7\u00e3o tem um \u201cdiret\u00f3rio atual\u201d, que \u00e9 o diret\u00f3rio-padr\u00e3o da maior parte das opera\u00e7\u00f5es. Por exemplo, quando voc\u00ea abre um arquivo de leitura, Python o procura no diret\u00f3rio atual. O m\u00f3dulo os fornece fun\u00e7\u00f5es para trabalhar com arquivos e diret\u00f3rios (\u201cos\u201d \u00e9 a abrevia\u00e7\u00e3o de \u201csistema operacional\u201d em ingl\u00eas). os.getcwd devolve o nome do diret\u00f3rio atual: >>> import os >>> cwd = os.getcwd() >>> cwd '/home/dinsdale' cwd \u00e9 a abrevia\u00e7\u00e3o de \u201cdiret\u00f3rio de trabalho atual\u201d em ingl\u00eas. O resultado neste exemplo \u00e9 /home/dinsdale , que \u00e9 o diret\u00f3rio-padr\u00e3o de um usu\u00e1rio chamado \u201cdinsdale\u201d. Uma string como '/home/dinsdale' , que identifica um arquivo ou diret\u00f3rio, \u00e9 chamada de caminho (path). Um nome de arquivo simples, como memo.txt , tamb\u00e9m \u00e9 considerado um caminho, mas \u00e9 um caminho relativo, porque se relaciona ao diret\u00f3rio atual. Se o diret\u00f3rio atual \u00e9 /home/dinsdale , o nome de arquivo memo.txt se referiria a /home/dinsdale/memo.txt . Um caminho que come\u00e7a com / n\u00e3o depende do diret\u00f3rio atual; isso \u00e9 chamado de caminho absoluto. Para encontrar o caminho absoluto para um arquivo, voc\u00ea pode usar os.path.abspath : >>> os.path.abspath('memo.txt') '/home/dinsdale/memo.txt' os.path fornece outras fun\u00e7\u00f5es para trabalhar com nomes de arquivo e caminhos. Por exemplo, os.path.exists que verifica se um arquivo ou diret\u00f3rio existe: >>> os.path.exists('memo.txt') True Se existir, os.path.isdir verifica se \u00e9 um diret\u00f3rio: >>> os.path.isdir('memo.txt') False >>> os.path.isdir('/home/dinsdale') True De forma similar, os.path.isfile verifica se \u00e9 um arquivo. os.listdir retorna uma lista dos arquivos (e outros diret\u00f3rios) no diret\u00f3rio dado: >>> os.listdir(cwd) ['music', 'photos', 'memo.txt'] Para demonstrar essas fun\u00e7\u00f5es, o exemplo seguinte \u201cpasseia\u201d por um diret\u00f3rio, exibe os nomes de todos os arquivos e chama a si mesmo recursivamente em todos os diret\u00f3rios: def walk(dirname): for name in os.listdir(dirname): path = os.path.join(dirname, name) if os.path.isfile(path): print(path) else: walk(path) os.path.join recebe um diret\u00f3rio e um nome de arquivo e os une em um caminho completo. O m\u00f3dulo os fornece uma fun\u00e7\u00e3o chamada walk , que \u00e9 semelhante, s\u00f3 que mais vers\u00e1til. Como exerc\u00edcio, leia a documenta\u00e7\u00e3o e use-a para exibir os nomes dos arquivos em um diret\u00f3rio dado e seus subdiret\u00f3rios. Voc\u00ea pode baixar minha solu\u00e7\u00e3o em http://thinkpython2.com/code/walk.py. 14.5 - Captura de exce\u00e7\u00f5es Muitas coisas podem dar errado quando voc\u00ea tenta ler e escrever arquivos. Se tentar abrir um arquivo que n\u00e3o existe, voc\u00ea recebe um IOError : >>> fin = open('bad_file') IOError: [Errno 2] No such file or directory: 'bad\\_file' Se n\u00e3o tiver permiss\u00e3o para acessar um arquivo: >>> fout = open('/etc/passwd', 'w') PermissionError: [Errno 13] Permission denied: '/etc/passwd' E se tentar abrir um diret\u00f3rio para leitura, recebe >>> fin = open('/home') IsADirectoryError: [Errno 21] Is a directory: '/home' Para evitar esses erros, voc\u00ea pode usar fun\u00e7\u00f5es como os.path.exists e os.path.isfile , mas levaria muito tempo e c\u00f3digo para verificar todas as possibilidades (se \"Errno 21\" significa algo, pode ser que pelo menos 21 coisas podem dar errado). \u00c9 melhor ir em frente e tentar, e lidar com problemas se eles surgirem, que \u00e9 exatamente o que a instru\u00e7\u00e3o try faz. A sintaxe \u00e9 semelhante \u00e0 da instru\u00e7\u00e3o if\u2026else : try: fin = open('bad_file') except: print('Something went wrong.') O Python come\u00e7a executando a cl\u00e1usula try . Se tudo for bem, ele ignora a cl\u00e1usula except e prossegue. Se ocorrer uma exce\u00e7\u00e3o, o programa sai da cl\u00e1usula try e executa a cl\u00e1usula except . Lidar com exce\u00e7\u00f5es usando uma instru\u00e7\u00e3o try chama-se capturar uma exce\u00e7\u00e3o. Neste exemplo, a cl\u00e1usula except exibe uma mensagem de erro que n\u00e3o \u00e9 muito \u00fatil. Em geral, a captura de uma exce\u00e7\u00e3o oferece a oportunidade de corrigir o problema ou tentar novamente, ou, ao menos, de terminar o programa adequadamente. 14.6 - Bancos de dados Um banco de dados \u00e9 um arquivo organizado para armazenar dados. Muitos bancos de dados s\u00e3o organizados como um dicion\u00e1rio, porque mapeiam chaves a valores. A maior diferen\u00e7a entre um banco de dados e um dicion\u00e1rio \u00e9 que o banco de dados est\u00e1 em um disco (ou outro armazenamento permanente), portanto persiste depois que o programa termina. O m\u00f3dulo dbm fornece uma interface para criar e atualizar arquivos de banco de dados. Como exemplo, criarei um banco de dados que cont\u00e9m legendas de arquivos de imagem. Abrir um banco de dados \u00e9 semelhante \u00e0 abertura de outros arquivos: >>> import dbm >>> db = dbm.open('captions', 'c') O modo 'c' significa que o banco de dados deve ser criado, se ainda n\u00e3o existir. O resultado \u00e9 um objeto de banco de dados que pode ser usado (para a maior parte das opera\u00e7\u00f5es) como um dicion\u00e1rio. Quando voc\u00ea cria um novo item, dbm atualiza o arquivo de banco de dados: >>> db['cleese.png'] = 'Photo of John Cleese.' Quando voc\u00ea acessa um dos itens, dbm l\u00ea o arquivo: >>> db['cleese.png'] b'Photo of John Cleese.' O resultado \u00e9 um objeto bytes , o que explica o prefixo b . Um objeto bytes \u00e9 semelhante a uma string, em muitos aspectos. Quando voc\u00ea avan\u00e7ar no Python, a diferen\u00e7a se tornar\u00e1 importante, mas, por enquanto, podemos ignor\u00e1-la. Se fizer outra atribui\u00e7\u00e3o a uma chave existente, o dbm substitui o valor antigo: >>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.' >>> db['cleese.png'] b'Photo of John Cleese doing a silly walk.' Alguns m\u00e9todos de dicion\u00e1rio, como keys e items, n\u00e3o funcionam com objetos de banco de dados. No entanto, a itera\u00e7\u00e3o com um loop for , sim: for key in db: print(key, db[key]) Como em outros arquivos, voc\u00ea deve fechar o banco de dados quando terminar: >>> db.close() 14.7 - Usando o Pickle Uma limita\u00e7\u00e3o de dbm \u00e9 que as chaves e os valores t\u00eam que ser strings ou bytes. Se tentar usar algum outro tipo, vai receber um erro. O m\u00f3dulo pickle pode ajudar. Ele traduz quase qualquer tipo de objeto em uma string conveniente para o armazenamento em um banco de dados, e ent\u00e3o traduz strings de volta em objetos. pickle.dumps recebe um objeto como par\u00e2metro e retorna uma representa\u00e7\u00e3o de string: >>> import pickle >>> t = [1, 2, 3] >>> pickle.dumps(t) b'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.' O formato n\u00e3o \u00e9 \u00f3bvio para leitores humanos; o objetivo \u00e9 que seja f\u00e1cil para o pickle interpretar. pickle.loads reconstitui o objeto: >>> t1 = [1, 2, 3] >>> s = pickle.dumps(t1) >>> t2 = pickle.loads(s) >>> t2 [1, 2, 3] Embora o novo objeto tenha o mesmo valor que o antigo, n\u00e3o \u00e9 (em geral) o mesmo objeto: >>> t1 == t2 True >>> t1 is t2 False Em outras palavras, usar o pickle.dumps e pickle.loads tem o mesmo efeito que copiar o objeto. Voc\u00ea pode usar o pickle para guardar vari\u00e1veis que n\u00e3o s\u00e3o strings em um banco de dados. Na verdade, esta combina\u00e7\u00e3o \u00e9 t\u00e3o comum que foi encapsulada em um m\u00f3dulo chamado shelve . 14.8 - Pipes A maior parte dos sistemas operacionais fornece uma interface de linha de comando, conhecida como shell. Shells normalmente fornecem comandos para navegar nos sistemas de arquivos e executar programas. Por exemplo, em Unix voc\u00ea pode alterar diret\u00f3rios com cd , exibir o conte\u00fado de um diret\u00f3rio com ls e abrir um navegador web digitando (por exemplo) firefox . Qualquer programa que possa ser aberto no shell tamb\u00e9m pode ser aberto no Python usando um objeto pipe, que representa um programa em execu\u00e7\u00e3o. Por exemplo, o comando Unix ls -l normalmente exibe o conte\u00fado do diret\u00f3rio atual no formato longo. Voc\u00ea pode abrir ls com os.popen[1] : >>> cmd = 'ls -l' >>> fp = os.popen(cmd) O argumento \u00e9 uma string que cont\u00e9m um comando shell. O valor de retorno \u00e9 um objeto que se comporta como um arquivo aberto. \u00c9 poss\u00edvel ler a sa\u00edda do processo ls uma linha por vez com readline ou receber tudo de uma vez com read: >>> res = fp.read() Ao terminar, feche o pipe como se fosse um arquivo: >>> stat = fp.close() >>> print(stat) None O valor de retorno \u00e9 o status final do processo ls ; None significa que terminou normalmente (sem erros). Por exemplo, a maior parte dos sistemas Unix oferece um comando chamado md5sum , que l\u00ea o conte\u00fado de um arquivo e calcula uma assinatura digital. Voc\u00ea pode ler sobre o MD5 em http://en.wikipedia.org/wiki/Md5. Este comando fornece uma forma eficiente de verificar se dois arquivos t\u00eam o mesmo conte\u00fado. A probabilidade de dois conte\u00fados diferentes produzirem a mesma assinatura digital \u00e9 muito pequena (isto \u00e9, muito pouco prov\u00e1vel que aconte\u00e7a antes do colapso do universo). Voc\u00ea pode usar um pipe para executar o md5sum do Python e receber o resultado: >>> filename = 'book.tex' >>> cmd = 'md5sum ' + filename >>> fp = os.popen(cmd) >>> res = fp.read() >>> stat = fp.close() >>> print(res) 1e0033f0ed0656636de0d75144ba32e0 book.tex >>> print(stat) None 14.9 - Escrevendo m\u00f3dulos Qualquer arquivo que contenha c\u00f3digo do Python pode ser importado como um m\u00f3dulo. Por exemplo, vamos supor que voc\u00ea tenha um arquivo chamado wc.py com o seguinte c\u00f3digo: def linecount(filename): count = 0 for line in open(filename): count += 1 return count print(linecount('wc.py')) Quando este programa \u00e9 executado, ele l\u00ea a si mesmo e exibe o n\u00famero de linhas no arquivo, que \u00e9 7. Voc\u00ea tamb\u00e9m pode import\u00e1-lo desta forma: >>> import wc 7 Agora voc\u00ea tem um objeto de m\u00f3dulo wc: >>> wc <module 'wc' from 'wc.py'> O objeto de m\u00f3dulo fornece o linecount: >>> wc.linecount('wc.py') 7 Ent\u00e3o \u00e9 assim que se escreve m\u00f3dulos no Python. O \u00fanico problema com este exemplo \u00e9 que quando voc\u00ea importa o m\u00f3dulo, ele executa o c\u00f3digo de teste no final. Normalmente, quando se importa um m\u00f3dulo, ele define novas fun\u00e7\u00f5es, mas n\u00e3o as executa. Os programas que ser\u00e3o importados como m\u00f3dulos muitas vezes usam a seguinte express\u00e3o: if __name__ == '__main__': print(linecount('wc.py')) __name__ \u00e9 uma vari\u00e1vel integrada, estabelecida quando o programa inicia. Se o programa estiver rodando como um script, __name__ tem o valor '__main__' ; neste caso, o c\u00f3digo de teste \u00e9 executado. Do contr\u00e1rio, se o m\u00f3dulo est\u00e1 sendo importado, o c\u00f3digo de teste \u00e9 ignorado. Como exerc\u00edcio, digite este exemplo em um arquivo chamado wc.py e execute-o como um script. Ent\u00e3o execute o interpretador do Python e import wc. Qual \u00e9 o valor de __name__ quando o m\u00f3dulo est\u00e1 sendo importado? Aten\u00e7\u00e3o: se voc\u00ea importar um m\u00f3dulo que j\u00e1 tenha sido importado, o Python n\u00e3o faz nada. Ele n\u00e3o rel\u00ea o arquivo, mesmo se tiver sido alterado. Se quiser recarregar um m\u00f3dulo, voc\u00ea pode usar a fun\u00e7\u00e3o integrada reload , mas isso pode causar problemas, ent\u00e3o o mais seguro \u00e9 reiniciar o interpretador e importar o m\u00f3dulo novamente. 14.10 - Depura\u00e7\u00e3o Quando estiver lendo e escrevendo arquivos, voc\u00ea pode ter problemas com whitespace. Esses erros podem ser dif\u00edceis para depurar, porque os espa\u00e7os, tabula\u00e7\u00f5es e quebras de linha normalmente s\u00e3o invis\u00edveis: >>> s = '1 2\\t 3\\n 4' >>> print(s) 1 2 3 4 A fun\u00e7\u00e3o integrada repr pode ajudar. Ela recebe qualquer objeto como argumento e retorna uma representa\u00e7\u00e3o em string do objeto. Para strings, representa caracteres de whitespace com sequ\u00eancias de barras invertidas: >>> print(repr(s)) '1 2\\t 3\\n 4' Isso pode ser \u00fatil para a depura\u00e7\u00e3o. Outro problema que voc\u00ea pode ter \u00e9 que sistemas diferentes usam caracteres diferentes para indicar o fim de uma linha. Alguns sistemas usam newline, representado por \\n . Outros usam um caractere de retorno, representado por \\r . Alguns usam ambos. Se mover arquivos entre sistemas diferentes, essas inconsist\u00eancias podem causar problemas. Para a maior parte dos sistemas h\u00e1 aplica\u00e7\u00f5es para converter de um formato a outro. Voc\u00ea pode encontr\u00e1-los (e ler mais sobre o assunto) em http://en.wikipedia.org/wiki/Newline. Ou, \u00e9 claro, voc\u00ea pode escrever um por conta pr\u00f3pria. 14.11 - Gloss\u00e1rio persistente Relativo a um programa que roda indefinidamente e mant\u00e9m pelo menos alguns dos seus dados em armazenamento permanente. operador de formata\u00e7\u00e3o Um operador, %, que recebe uma string de formata\u00e7\u00e3o e uma tupla e gera uma string que inclui os elementos da tupla formatada como especificado pela string de formata\u00e7\u00e3o. string de formata\u00e7\u00e3o String usada com o operador de formata\u00e7\u00e3o, que cont\u00e9m sequ\u00eancias de formata\u00e7\u00e3o. sequ\u00eancia de formata\u00e7\u00e3o Sequ\u00eancia de caracteres em uma string de formata\u00e7\u00e3o, como %d, que especifica como um valor deve ser formatado. arquivo de texto Sequ\u00eancia de caracteres guardados em armazenamento permanente, como uma unidade de disco r\u00edgido. diret\u00f3rio Uma cole\u00e7\u00e3o de arquivos nomeada, tamb\u00e9m chamada de pasta. caminho String que identifica um arquivo. caminho relativo Caminho que inicia no diret\u00f3rio atual. caminho absoluto Caminho que inicia no diret\u00f3rio de posi\u00e7\u00e3o mais alta (raiz) no sistema de arquivos. capturar Impedir uma exce\u00e7\u00e3o de encerrar um programa usando as instru\u00e7\u00f5es try e except. banco de dados Um arquivo cujo conte\u00fado \u00e9 organizado como um dicion\u00e1rio, com chaves que correspondem a valores. objeto bytes Objeto semelhante a uma string. shell Programa que permite aos usu\u00e1rios digitar comandos e execut\u00e1-los para iniciar outros programas. objeto pipe Objeto que representa um programa em execu\u00e7\u00e3o, permitindo que um programa do Python execute comandos e leia os resultados. 14.12 - Exerc\u00edcios Exerc\u00edcio 14.1 Escreva uma fun\u00e7\u00e3o chamada sed que receba como argumentos uma string-padr\u00e3o, uma string de substitui\u00e7\u00e3o e dois nomes de arquivo; ela deve ler o primeiro arquivo e escrever o conte\u00fado no segundo arquivo (criando-o, se necess\u00e1rio). Se a string-padr\u00e3o aparecer em algum lugar do arquivo, ela deve ser substitu\u00edda pela string de substitui\u00e7\u00e3o. Se ocorrer um erro durante a abertura, leitura, escrita ou fechamento dos arquivos, seu programa deve capturar a exce\u00e7\u00e3o, exibir uma mensagem de erro e encerrar. Solu\u00e7\u00e3o: http://thinkpython2.com/code/sed.py. Exerc\u00edcio 14.2 Se voc\u00ea baixar minha solu\u00e7\u00e3o do Exerc\u00edcio 12.2 em http://thinkpython2.com/code/anagram_sets.py, ver\u00e1 que ela cria um dicion\u00e1rio que mapeia uma string ordenada de letras \u00e0 lista de palavras que podem ser soletradas com aquelas letras. Por exemplo, 'opst' mapeia \u00e0 lista ['opts', 'post', 'pots', 'spot', 'stop', 'tops'] . Escreva um m\u00f3dulo que importe anagram_sets e forne\u00e7a duas novas fun\u00e7\u00f5es: store_anagrams deve guardar o dicion\u00e1rio de anagramas em uma \u201cprateleira\u201d (objeto criado pelo m\u00f3dulo sheve ); read_anagrams deve procurar uma palavra e devolver uma lista dos seus anagramas. Solu\u00e7\u00e3o: http://thinkpython2.com/code/anagram_db.py. Exerc\u00edcio 14.3 Em uma grande cole\u00e7\u00e3o de arquivos MP3 pode haver mais de uma c\u00f3pia da mesma m\u00fasica, guardada em diret\u00f3rios diferentes ou com nomes de arquivo diferentes. A meta deste exerc\u00edcio \u00e9 procurar duplicatas. Escreva um programa que procure um diret\u00f3rio e todos os seus subdiret\u00f3rios, recursivamente, e retorne uma lista de caminhos completos de todos os arquivos com um dado sufixo (como .mp3). Dica: os.path fornece v\u00e1rias fun\u00e7\u00f5es \u00fateis para manipular nomes de caminhos e de arquivos. Para reconhecer duplicatas, voc\u00ea pode usar md5sum para calcular uma \u201csoma de controle\u201d para cada arquivo. Se dois arquivos tiverem a mesma soma de controle, provavelmente t\u00eam o mesmo conte\u00fado. Para conferir o resultado, voc\u00ea pode usar o comando Unix diff . Solu\u00e7\u00e3o: http://thinkpython2.com/code/find_duplicates.py.","title":"Cap\u00edtulo 14: Arquivos"},{"location":"14-arquivos/#capitulo-14-arquivos","text":"Este cap\u00edtulo apresenta a ideia de programas \u201cpersistentes\u201d, que mant\u00eam dados em armazenamento permanente, e mostra como usar tipos diferentes de armazenamento permanente, como arquivos e bancos de dados.","title":"Cap\u00edtulo 14: Arquivos"},{"location":"14-arquivos/#141-persistencia","text":"A maioria dos programas que vimos at\u00e9 agora s\u00e3o transit\u00f3rios, porque s\u00e3o executados por algum tempo e produzem alguma sa\u00edda, mas, quando terminam, seus dados desaparecem. Se executar o programa novamente, ele come\u00e7a novamente do zero. Outros programas s\u00e3o persistentes: rodam por muito tempo (ou todo o tempo); mant\u00eam pelo menos alguns dos seus dados em armazenamento permanente (uma unidade de disco r\u00edgido, por exemplo); e se s\u00e3o desligados e reiniciados, continuam de onde pararam. Exemplos de programas persistentes s\u00e3o sistemas operacionais, que rodam praticamente durante todo o tempo em que um computador est\u00e1 ligado, e servidores web, que rodam todo o tempo, esperando pedidos de entrada na rede. Uma das formas mais simples para programas manterem seus dados \u00e9 lendo e escrevendo arquivos de texto. J\u00e1 vimos programas que leem arquivos de texto; neste cap\u00edtulo veremos programas que os escrevem. Uma alternativa \u00e9 armazenar o estado do programa em um banco de dados. Neste cap\u00edtulo apresentarei um banco de dados simples e um m\u00f3dulo, pickle, que facilita o armazenamento de dados de programas.","title":"14.1 - Persist\u00eancia"},{"location":"14-arquivos/#142-leitura-e-escrita","text":"Um arquivo de texto \u00e9 uma sequ\u00eancia de caracteres armazenados em um meio permanente como uma unidade de disco r\u00edgido, pendrive ou CD-ROM. Vimos como abrir e ler um arquivo em \u201cLeitura de listas de palavras\u201d na p\u00e1gina 133. Para escrever um arquivo texto, \u00e9 preciso abri-lo com o modo 'w' como segundo par\u00e2metro: >>> fout = open('output.txt', 'w') Se o arquivo j\u00e1 existe, abri-lo em modo de escrita elimina os dados antigos e come\u00e7a tudo de novo, ent\u00e3o tenha cuidado! Se o arquivo n\u00e3o existir, \u00e9 criado um arquivo novo. open retorna um objeto de arquivo que fornece m\u00e9todos para trabalhar com o arquivo. O m\u00e9todo write p\u00f5e dados no arquivo: >>> line1 = \"This here's the wattle,\\n\" >>> fout.write(line1) 24 O valor devolvido \u00e9 o n\u00famero de caracteres que foram escritos. O objeto de arquivo monitora a posi\u00e7\u00e3o em que est\u00e1, ent\u00e3o se voc\u00ea chamar write novamente, os novos dados s\u00e3o acrescentados ao fim do arquivo: >>> line2 = \"the emblem of our land.\\n\" >>> fout.write(line2) 24 Ao terminar de escrever, voc\u00ea deve fechar o arquivo: >>> fout.close() Se n\u00e3o fechar o arquivo, ele \u00e9 fechado para voc\u00ea quando o programa termina.","title":"14.2 - Leitura e escrita"},{"location":"14-arquivos/#143-operador-de-formatacao","text":"O argumento de write tem que ser uma string, ent\u00e3o, se quisermos inserir outros valores em um arquivo, precisamos convert\u00ea-los em strings. O modo mais f\u00e1cil de fazer isso \u00e9 com str : >>> x = 52 >>> fout.write(str(x)) Uma alternativa \u00e9 usar o operador de formata\u00e7\u00e3o, % . Quando aplicado a n\u00fameros inteiros, % \u00e9 o operador de m\u00f3dulo. No entanto, quando o primeiro operando \u00e9 uma string, % \u00e9 o operador de formata\u00e7\u00e3o. O primeiro operando \u00e9 a string de formata\u00e7\u00e3o, que cont\u00e9m uma ou v\u00e1rias sequ\u00eancias de formata\u00e7\u00e3o que especificam como o segundo operando deve ser formatado. O resultado \u00e9 uma string. Por exemplo, a sequ\u00eancia de formata\u00e7\u00e3o '%d' significa que o segundo operando deve ser formatado como um n\u00famero inteiro decimal: >>> camels = 42 >>> '%d' % camels '42' O resultado \u00e9 a string '42' , que n\u00e3o deve ser confundida com o valor inteiro 42 . Uma sequ\u00eancia de formata\u00e7\u00e3o pode aparecer em qualquer lugar na string, ent\u00e3o voc\u00ea pode embutir um valor em uma senten\u00e7a: >>> 'I have spotted %d camels.' % camels 'I have spotted 42 camels.' Se houver mais de uma sequ\u00eancia de formata\u00e7\u00e3o na string, o segundo argumento tem que ser uma tupla. Cada sequ\u00eancia de formata\u00e7\u00e3o \u00e9 combinada com um elemento da tupla, nesta ordem. O seguinte exemplo usa '%d' para formatar um n\u00famero inteiro, '%g' para formatar um n\u00famero de ponto flutuante e '%s' para formatar qualquer objeto como uma string: >>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels') 'In 3 years I have spotted 0.1 camels.' O n\u00famero de elementos na tupla tem de corresponder ao n\u00famero de sequ\u00eancias de formata\u00e7\u00e3o na string. Al\u00e9m disso, os tipos dos elementos t\u00eam de corresponder \u00e0s sequ\u00eancias de formata\u00e7\u00e3o: >>> '%d %d %d' % (1, 2) TypeError: not enough arguments for format string >>> '%d' % 'dollars' TypeError: %d format: a number is required, not str No primeiro exemplo n\u00e3o h\u00e1 elementos suficientes; no segundo, o elemento \u00e9 do tipo incorreto. Para obter mais informa\u00e7\u00f5es sobre o operador de formato, veja https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting. Voc\u00ea pode ler sobre uma alternativa mais eficiente, o m\u00e9todo de formata\u00e7\u00e3o de strings, em https://docs.python.org/3/library/stdtypes.html#str.format.","title":"14.3 - Operador de formata\u00e7\u00e3o"},{"location":"14-arquivos/#144-nomes-de-arquivo-e-caminhos","text":"Os arquivos s\u00e3o organizados em diret\u00f3rios (tamb\u00e9m chamados de \u201cpastas\u201d). Cada programa em execu\u00e7\u00e3o tem um \u201cdiret\u00f3rio atual\u201d, que \u00e9 o diret\u00f3rio-padr\u00e3o da maior parte das opera\u00e7\u00f5es. Por exemplo, quando voc\u00ea abre um arquivo de leitura, Python o procura no diret\u00f3rio atual. O m\u00f3dulo os fornece fun\u00e7\u00f5es para trabalhar com arquivos e diret\u00f3rios (\u201cos\u201d \u00e9 a abrevia\u00e7\u00e3o de \u201csistema operacional\u201d em ingl\u00eas). os.getcwd devolve o nome do diret\u00f3rio atual: >>> import os >>> cwd = os.getcwd() >>> cwd '/home/dinsdale' cwd \u00e9 a abrevia\u00e7\u00e3o de \u201cdiret\u00f3rio de trabalho atual\u201d em ingl\u00eas. O resultado neste exemplo \u00e9 /home/dinsdale , que \u00e9 o diret\u00f3rio-padr\u00e3o de um usu\u00e1rio chamado \u201cdinsdale\u201d. Uma string como '/home/dinsdale' , que identifica um arquivo ou diret\u00f3rio, \u00e9 chamada de caminho (path). Um nome de arquivo simples, como memo.txt , tamb\u00e9m \u00e9 considerado um caminho, mas \u00e9 um caminho relativo, porque se relaciona ao diret\u00f3rio atual. Se o diret\u00f3rio atual \u00e9 /home/dinsdale , o nome de arquivo memo.txt se referiria a /home/dinsdale/memo.txt . Um caminho que come\u00e7a com / n\u00e3o depende do diret\u00f3rio atual; isso \u00e9 chamado de caminho absoluto. Para encontrar o caminho absoluto para um arquivo, voc\u00ea pode usar os.path.abspath : >>> os.path.abspath('memo.txt') '/home/dinsdale/memo.txt' os.path fornece outras fun\u00e7\u00f5es para trabalhar com nomes de arquivo e caminhos. Por exemplo, os.path.exists que verifica se um arquivo ou diret\u00f3rio existe: >>> os.path.exists('memo.txt') True Se existir, os.path.isdir verifica se \u00e9 um diret\u00f3rio: >>> os.path.isdir('memo.txt') False >>> os.path.isdir('/home/dinsdale') True De forma similar, os.path.isfile verifica se \u00e9 um arquivo. os.listdir retorna uma lista dos arquivos (e outros diret\u00f3rios) no diret\u00f3rio dado: >>> os.listdir(cwd) ['music', 'photos', 'memo.txt'] Para demonstrar essas fun\u00e7\u00f5es, o exemplo seguinte \u201cpasseia\u201d por um diret\u00f3rio, exibe os nomes de todos os arquivos e chama a si mesmo recursivamente em todos os diret\u00f3rios: def walk(dirname): for name in os.listdir(dirname): path = os.path.join(dirname, name) if os.path.isfile(path): print(path) else: walk(path) os.path.join recebe um diret\u00f3rio e um nome de arquivo e os une em um caminho completo. O m\u00f3dulo os fornece uma fun\u00e7\u00e3o chamada walk , que \u00e9 semelhante, s\u00f3 que mais vers\u00e1til. Como exerc\u00edcio, leia a documenta\u00e7\u00e3o e use-a para exibir os nomes dos arquivos em um diret\u00f3rio dado e seus subdiret\u00f3rios. Voc\u00ea pode baixar minha solu\u00e7\u00e3o em http://thinkpython2.com/code/walk.py.","title":"14.4 - Nomes de arquivo e caminhos"},{"location":"14-arquivos/#145-captura-de-excecoes","text":"Muitas coisas podem dar errado quando voc\u00ea tenta ler e escrever arquivos. Se tentar abrir um arquivo que n\u00e3o existe, voc\u00ea recebe um IOError : >>> fin = open('bad_file') IOError: [Errno 2] No such file or directory: 'bad\\_file' Se n\u00e3o tiver permiss\u00e3o para acessar um arquivo: >>> fout = open('/etc/passwd', 'w') PermissionError: [Errno 13] Permission denied: '/etc/passwd' E se tentar abrir um diret\u00f3rio para leitura, recebe >>> fin = open('/home') IsADirectoryError: [Errno 21] Is a directory: '/home' Para evitar esses erros, voc\u00ea pode usar fun\u00e7\u00f5es como os.path.exists e os.path.isfile , mas levaria muito tempo e c\u00f3digo para verificar todas as possibilidades (se \"Errno 21\" significa algo, pode ser que pelo menos 21 coisas podem dar errado). \u00c9 melhor ir em frente e tentar, e lidar com problemas se eles surgirem, que \u00e9 exatamente o que a instru\u00e7\u00e3o try faz. A sintaxe \u00e9 semelhante \u00e0 da instru\u00e7\u00e3o if\u2026else : try: fin = open('bad_file') except: print('Something went wrong.') O Python come\u00e7a executando a cl\u00e1usula try . Se tudo for bem, ele ignora a cl\u00e1usula except e prossegue. Se ocorrer uma exce\u00e7\u00e3o, o programa sai da cl\u00e1usula try e executa a cl\u00e1usula except . Lidar com exce\u00e7\u00f5es usando uma instru\u00e7\u00e3o try chama-se capturar uma exce\u00e7\u00e3o. Neste exemplo, a cl\u00e1usula except exibe uma mensagem de erro que n\u00e3o \u00e9 muito \u00fatil. Em geral, a captura de uma exce\u00e7\u00e3o oferece a oportunidade de corrigir o problema ou tentar novamente, ou, ao menos, de terminar o programa adequadamente.","title":"14.5 - Captura de exce\u00e7\u00f5es"},{"location":"14-arquivos/#146-bancos-de-dados","text":"Um banco de dados \u00e9 um arquivo organizado para armazenar dados. Muitos bancos de dados s\u00e3o organizados como um dicion\u00e1rio, porque mapeiam chaves a valores. A maior diferen\u00e7a entre um banco de dados e um dicion\u00e1rio \u00e9 que o banco de dados est\u00e1 em um disco (ou outro armazenamento permanente), portanto persiste depois que o programa termina. O m\u00f3dulo dbm fornece uma interface para criar e atualizar arquivos de banco de dados. Como exemplo, criarei um banco de dados que cont\u00e9m legendas de arquivos de imagem. Abrir um banco de dados \u00e9 semelhante \u00e0 abertura de outros arquivos: >>> import dbm >>> db = dbm.open('captions', 'c') O modo 'c' significa que o banco de dados deve ser criado, se ainda n\u00e3o existir. O resultado \u00e9 um objeto de banco de dados que pode ser usado (para a maior parte das opera\u00e7\u00f5es) como um dicion\u00e1rio. Quando voc\u00ea cria um novo item, dbm atualiza o arquivo de banco de dados: >>> db['cleese.png'] = 'Photo of John Cleese.' Quando voc\u00ea acessa um dos itens, dbm l\u00ea o arquivo: >>> db['cleese.png'] b'Photo of John Cleese.' O resultado \u00e9 um objeto bytes , o que explica o prefixo b . Um objeto bytes \u00e9 semelhante a uma string, em muitos aspectos. Quando voc\u00ea avan\u00e7ar no Python, a diferen\u00e7a se tornar\u00e1 importante, mas, por enquanto, podemos ignor\u00e1-la. Se fizer outra atribui\u00e7\u00e3o a uma chave existente, o dbm substitui o valor antigo: >>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.' >>> db['cleese.png'] b'Photo of John Cleese doing a silly walk.' Alguns m\u00e9todos de dicion\u00e1rio, como keys e items, n\u00e3o funcionam com objetos de banco de dados. No entanto, a itera\u00e7\u00e3o com um loop for , sim: for key in db: print(key, db[key]) Como em outros arquivos, voc\u00ea deve fechar o banco de dados quando terminar: >>> db.close()","title":"14.6 - Bancos de dados"},{"location":"14-arquivos/#147-usando-o-pickle","text":"Uma limita\u00e7\u00e3o de dbm \u00e9 que as chaves e os valores t\u00eam que ser strings ou bytes. Se tentar usar algum outro tipo, vai receber um erro. O m\u00f3dulo pickle pode ajudar. Ele traduz quase qualquer tipo de objeto em uma string conveniente para o armazenamento em um banco de dados, e ent\u00e3o traduz strings de volta em objetos. pickle.dumps recebe um objeto como par\u00e2metro e retorna uma representa\u00e7\u00e3o de string: >>> import pickle >>> t = [1, 2, 3] >>> pickle.dumps(t) b'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.' O formato n\u00e3o \u00e9 \u00f3bvio para leitores humanos; o objetivo \u00e9 que seja f\u00e1cil para o pickle interpretar. pickle.loads reconstitui o objeto: >>> t1 = [1, 2, 3] >>> s = pickle.dumps(t1) >>> t2 = pickle.loads(s) >>> t2 [1, 2, 3] Embora o novo objeto tenha o mesmo valor que o antigo, n\u00e3o \u00e9 (em geral) o mesmo objeto: >>> t1 == t2 True >>> t1 is t2 False Em outras palavras, usar o pickle.dumps e pickle.loads tem o mesmo efeito que copiar o objeto. Voc\u00ea pode usar o pickle para guardar vari\u00e1veis que n\u00e3o s\u00e3o strings em um banco de dados. Na verdade, esta combina\u00e7\u00e3o \u00e9 t\u00e3o comum que foi encapsulada em um m\u00f3dulo chamado shelve .","title":"14.7 - Usando o Pickle"},{"location":"14-arquivos/#148-pipes","text":"A maior parte dos sistemas operacionais fornece uma interface de linha de comando, conhecida como shell. Shells normalmente fornecem comandos para navegar nos sistemas de arquivos e executar programas. Por exemplo, em Unix voc\u00ea pode alterar diret\u00f3rios com cd , exibir o conte\u00fado de um diret\u00f3rio com ls e abrir um navegador web digitando (por exemplo) firefox . Qualquer programa que possa ser aberto no shell tamb\u00e9m pode ser aberto no Python usando um objeto pipe, que representa um programa em execu\u00e7\u00e3o. Por exemplo, o comando Unix ls -l normalmente exibe o conte\u00fado do diret\u00f3rio atual no formato longo. Voc\u00ea pode abrir ls com os.popen[1] : >>> cmd = 'ls -l' >>> fp = os.popen(cmd) O argumento \u00e9 uma string que cont\u00e9m um comando shell. O valor de retorno \u00e9 um objeto que se comporta como um arquivo aberto. \u00c9 poss\u00edvel ler a sa\u00edda do processo ls uma linha por vez com readline ou receber tudo de uma vez com read: >>> res = fp.read() Ao terminar, feche o pipe como se fosse um arquivo: >>> stat = fp.close() >>> print(stat) None O valor de retorno \u00e9 o status final do processo ls ; None significa que terminou normalmente (sem erros). Por exemplo, a maior parte dos sistemas Unix oferece um comando chamado md5sum , que l\u00ea o conte\u00fado de um arquivo e calcula uma assinatura digital. Voc\u00ea pode ler sobre o MD5 em http://en.wikipedia.org/wiki/Md5. Este comando fornece uma forma eficiente de verificar se dois arquivos t\u00eam o mesmo conte\u00fado. A probabilidade de dois conte\u00fados diferentes produzirem a mesma assinatura digital \u00e9 muito pequena (isto \u00e9, muito pouco prov\u00e1vel que aconte\u00e7a antes do colapso do universo). Voc\u00ea pode usar um pipe para executar o md5sum do Python e receber o resultado: >>> filename = 'book.tex' >>> cmd = 'md5sum ' + filename >>> fp = os.popen(cmd) >>> res = fp.read() >>> stat = fp.close() >>> print(res) 1e0033f0ed0656636de0d75144ba32e0 book.tex >>> print(stat) None","title":"14.8 - Pipes"},{"location":"14-arquivos/#149-escrevendo-modulos","text":"Qualquer arquivo que contenha c\u00f3digo do Python pode ser importado como um m\u00f3dulo. Por exemplo, vamos supor que voc\u00ea tenha um arquivo chamado wc.py com o seguinte c\u00f3digo: def linecount(filename): count = 0 for line in open(filename): count += 1 return count print(linecount('wc.py')) Quando este programa \u00e9 executado, ele l\u00ea a si mesmo e exibe o n\u00famero de linhas no arquivo, que \u00e9 7. Voc\u00ea tamb\u00e9m pode import\u00e1-lo desta forma: >>> import wc 7 Agora voc\u00ea tem um objeto de m\u00f3dulo wc: >>> wc <module 'wc' from 'wc.py'> O objeto de m\u00f3dulo fornece o linecount: >>> wc.linecount('wc.py') 7 Ent\u00e3o \u00e9 assim que se escreve m\u00f3dulos no Python. O \u00fanico problema com este exemplo \u00e9 que quando voc\u00ea importa o m\u00f3dulo, ele executa o c\u00f3digo de teste no final. Normalmente, quando se importa um m\u00f3dulo, ele define novas fun\u00e7\u00f5es, mas n\u00e3o as executa. Os programas que ser\u00e3o importados como m\u00f3dulos muitas vezes usam a seguinte express\u00e3o: if __name__ == '__main__': print(linecount('wc.py')) __name__ \u00e9 uma vari\u00e1vel integrada, estabelecida quando o programa inicia. Se o programa estiver rodando como um script, __name__ tem o valor '__main__' ; neste caso, o c\u00f3digo de teste \u00e9 executado. Do contr\u00e1rio, se o m\u00f3dulo est\u00e1 sendo importado, o c\u00f3digo de teste \u00e9 ignorado. Como exerc\u00edcio, digite este exemplo em um arquivo chamado wc.py e execute-o como um script. Ent\u00e3o execute o interpretador do Python e import wc. Qual \u00e9 o valor de __name__ quando o m\u00f3dulo est\u00e1 sendo importado? Aten\u00e7\u00e3o: se voc\u00ea importar um m\u00f3dulo que j\u00e1 tenha sido importado, o Python n\u00e3o faz nada. Ele n\u00e3o rel\u00ea o arquivo, mesmo se tiver sido alterado. Se quiser recarregar um m\u00f3dulo, voc\u00ea pode usar a fun\u00e7\u00e3o integrada reload , mas isso pode causar problemas, ent\u00e3o o mais seguro \u00e9 reiniciar o interpretador e importar o m\u00f3dulo novamente.","title":"14.9 - Escrevendo m\u00f3dulos"},{"location":"14-arquivos/#1410-depuracao","text":"Quando estiver lendo e escrevendo arquivos, voc\u00ea pode ter problemas com whitespace. Esses erros podem ser dif\u00edceis para depurar, porque os espa\u00e7os, tabula\u00e7\u00f5es e quebras de linha normalmente s\u00e3o invis\u00edveis: >>> s = '1 2\\t 3\\n 4' >>> print(s) 1 2 3 4 A fun\u00e7\u00e3o integrada repr pode ajudar. Ela recebe qualquer objeto como argumento e retorna uma representa\u00e7\u00e3o em string do objeto. Para strings, representa caracteres de whitespace com sequ\u00eancias de barras invertidas: >>> print(repr(s)) '1 2\\t 3\\n 4' Isso pode ser \u00fatil para a depura\u00e7\u00e3o. Outro problema que voc\u00ea pode ter \u00e9 que sistemas diferentes usam caracteres diferentes para indicar o fim de uma linha. Alguns sistemas usam newline, representado por \\n . Outros usam um caractere de retorno, representado por \\r . Alguns usam ambos. Se mover arquivos entre sistemas diferentes, essas inconsist\u00eancias podem causar problemas. Para a maior parte dos sistemas h\u00e1 aplica\u00e7\u00f5es para converter de um formato a outro. Voc\u00ea pode encontr\u00e1-los (e ler mais sobre o assunto) em http://en.wikipedia.org/wiki/Newline. Ou, \u00e9 claro, voc\u00ea pode escrever um por conta pr\u00f3pria.","title":"14.10 - Depura\u00e7\u00e3o"},{"location":"14-arquivos/#1411-glossario","text":"persistente Relativo a um programa que roda indefinidamente e mant\u00e9m pelo menos alguns dos seus dados em armazenamento permanente. operador de formata\u00e7\u00e3o Um operador, %, que recebe uma string de formata\u00e7\u00e3o e uma tupla e gera uma string que inclui os elementos da tupla formatada como especificado pela string de formata\u00e7\u00e3o. string de formata\u00e7\u00e3o String usada com o operador de formata\u00e7\u00e3o, que cont\u00e9m sequ\u00eancias de formata\u00e7\u00e3o. sequ\u00eancia de formata\u00e7\u00e3o Sequ\u00eancia de caracteres em uma string de formata\u00e7\u00e3o, como %d, que especifica como um valor deve ser formatado. arquivo de texto Sequ\u00eancia de caracteres guardados em armazenamento permanente, como uma unidade de disco r\u00edgido. diret\u00f3rio Uma cole\u00e7\u00e3o de arquivos nomeada, tamb\u00e9m chamada de pasta. caminho String que identifica um arquivo. caminho relativo Caminho que inicia no diret\u00f3rio atual. caminho absoluto Caminho que inicia no diret\u00f3rio de posi\u00e7\u00e3o mais alta (raiz) no sistema de arquivos. capturar Impedir uma exce\u00e7\u00e3o de encerrar um programa usando as instru\u00e7\u00f5es try e except. banco de dados Um arquivo cujo conte\u00fado \u00e9 organizado como um dicion\u00e1rio, com chaves que correspondem a valores. objeto bytes Objeto semelhante a uma string. shell Programa que permite aos usu\u00e1rios digitar comandos e execut\u00e1-los para iniciar outros programas. objeto pipe Objeto que representa um programa em execu\u00e7\u00e3o, permitindo que um programa do Python execute comandos e leia os resultados.","title":"14.11 - Gloss\u00e1rio"},{"location":"14-arquivos/#1412-exercicios","text":"","title":"14.12 - Exerc\u00edcios"},{"location":"14-arquivos/#exercicio-141","text":"Escreva uma fun\u00e7\u00e3o chamada sed que receba como argumentos uma string-padr\u00e3o, uma string de substitui\u00e7\u00e3o e dois nomes de arquivo; ela deve ler o primeiro arquivo e escrever o conte\u00fado no segundo arquivo (criando-o, se necess\u00e1rio). Se a string-padr\u00e3o aparecer em algum lugar do arquivo, ela deve ser substitu\u00edda pela string de substitui\u00e7\u00e3o. Se ocorrer um erro durante a abertura, leitura, escrita ou fechamento dos arquivos, seu programa deve capturar a exce\u00e7\u00e3o, exibir uma mensagem de erro e encerrar. Solu\u00e7\u00e3o: http://thinkpython2.com/code/sed.py.","title":"Exerc\u00edcio 14.1"},{"location":"14-arquivos/#exercicio-142","text":"Se voc\u00ea baixar minha solu\u00e7\u00e3o do Exerc\u00edcio 12.2 em http://thinkpython2.com/code/anagram_sets.py, ver\u00e1 que ela cria um dicion\u00e1rio que mapeia uma string ordenada de letras \u00e0 lista de palavras que podem ser soletradas com aquelas letras. Por exemplo, 'opst' mapeia \u00e0 lista ['opts', 'post', 'pots', 'spot', 'stop', 'tops'] . Escreva um m\u00f3dulo que importe anagram_sets e forne\u00e7a duas novas fun\u00e7\u00f5es: store_anagrams deve guardar o dicion\u00e1rio de anagramas em uma \u201cprateleira\u201d (objeto criado pelo m\u00f3dulo sheve ); read_anagrams deve procurar uma palavra e devolver uma lista dos seus anagramas. Solu\u00e7\u00e3o: http://thinkpython2.com/code/anagram_db.py.","title":"Exerc\u00edcio 14.2"},{"location":"14-arquivos/#exercicio-143","text":"Em uma grande cole\u00e7\u00e3o de arquivos MP3 pode haver mais de uma c\u00f3pia da mesma m\u00fasica, guardada em diret\u00f3rios diferentes ou com nomes de arquivo diferentes. A meta deste exerc\u00edcio \u00e9 procurar duplicatas. Escreva um programa que procure um diret\u00f3rio e todos os seus subdiret\u00f3rios, recursivamente, e retorne uma lista de caminhos completos de todos os arquivos com um dado sufixo (como .mp3). Dica: os.path fornece v\u00e1rias fun\u00e7\u00f5es \u00fateis para manipular nomes de caminhos e de arquivos. Para reconhecer duplicatas, voc\u00ea pode usar md5sum para calcular uma \u201csoma de controle\u201d para cada arquivo. Se dois arquivos tiverem a mesma soma de controle, provavelmente t\u00eam o mesmo conte\u00fado. Para conferir o resultado, voc\u00ea pode usar o comando Unix diff . Solu\u00e7\u00e3o: http://thinkpython2.com/code/find_duplicates.py.","title":"Exerc\u00edcio 14.3"},{"location":"15-classes-objetos/","text":"Cap\u00edtulo 15: Classes e objetos A esta altura voc\u00ea j\u00e1 sabe como usar fun\u00e7\u00f5es para organizar c\u00f3digo e tipos integrados para organizar dados. O pr\u00f3ximo passo \u00e9 aprender \u201cprograma\u00e7\u00e3o orientada a objeto\u201d, que usa tipos definidos pelos programadores para organizar tanto o c\u00f3digo quanto os dados. A programa\u00e7\u00e3o orientada a objeto \u00e9 um t\u00f3pico abrangente; ser\u00e1 preciso passar por alguns cap\u00edtulos para abordar o tema. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Point1.py; as solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Point1_soln.py. 15.1 - Tipos definidos pelos programadores J\u00e1 usamos muitos tipos integrados do Python; agora vamos definir um tipo pr\u00f3prio. Como exemplo, criaremos um tipo chamado Point , que representa um ponto no espa\u00e7o bidimensional. Na nota\u00e7\u00e3o matem\u00e1tica, os pontos muitas vezes s\u00e3o escritos entre par\u00eanteses, com uma v\u00edrgula separando as coordenadas. Por exemplo, (0,0) representa a origem e (x, y) representa o ponto que est\u00e1 x unidades \u00e0 direita e y unidades acima da origem. H\u00e1 v\u00e1rias formas para representar pontos no Python: Podemos armazenar as coordenadas separadamente em duas vari\u00e1veis, x e y. Podemos armazenar as coordenadas como elementos em uma lista ou tupla. Podemos criar um tipo para representar pontos como objetos. Criar um tipo \u00e9 mais complicado que outras op\u00e7\u00f5es, mas tem vantagens que logo ficar\u00e3o evidentes. Um tipo definido pelo programador tamb\u00e9m \u00e9 chamado de classe. Uma defini\u00e7\u00e3o de classe pode ser assim: class Point: \"\"\"Represents a point in 2-D space.\"\"\" O cabe\u00e7alho indica que a nova classe se chama Point . O corpo \u00e9 uma docstring que explica para que a classe serve. Voc\u00ea pode definir vari\u00e1veis e m\u00e9todos dentro de uma defini\u00e7\u00e3o de classe, mas voltaremos a isso depois. Definir uma classe denominada Point cria um objeto de classe: >>> Point <class '__main__.Point'> Como Point \u00e9 definido no n\u00edvel superior, seu \u201cnome completo\u201d \u00e9 __main__.Point . O objeto de classe \u00e9 como uma f\u00e1brica para criar objetos. Para criar um Point , voc\u00ea chama Point como se fosse uma fun\u00e7\u00e3o: >>> blank = Point() >>> blank <__main__.Point object at 0xb7e9d3ac> O valor de retorno \u00e9 uma refer\u00eancia a um objeto Point , ao qual atribu\u00edmos blank. Criar um objeto chama-se instancia\u00e7\u00e3o, e o objeto \u00e9 uma inst\u00e2ncia da classe. Quando voc\u00ea exibe uma inst\u00e2ncia, o Python diz a que classe ela pertence e onde est\u00e1 armazenada na mem\u00f3ria (o prefixo o 0x significa que o n\u00famero seguinte est\u00e1 em formato hexadecimal). Cada objeto \u00e9 uma inst\u00e2ncia de alguma classe, ent\u00e3o \u201cobjeto\u201d e \u201cinst\u00e2ncia\u201d s\u00e3o intercambi\u00e1veis. Por\u00e9m, neste cap\u00edtulo uso \u201cinst\u00e2ncia\u201d para indicar que estou falando sobre um tipo definido pelo programador. 15.2 - Atributos Voc\u00ea pode atribuir valores a uma inst\u00e2ncia usando a nota\u00e7\u00e3o de ponto: >>> blank.x = 3.0 >>> blank.y = 4.0 Essa sintaxe \u00e9 semelhante \u00e0 usada para selecionar uma vari\u00e1vel de um m\u00f3dulo, como math.pi ou string.whitespace. Nesse caso, entretanto, estamos atribuindo valores a elementos nomeados de um objeto. Esses elementos chamam-se atributos. Em ingl\u00eas, quando \u00e9 um substantivo, a palavra \u201cAT-trib-ute\u201d \u00e9 pronunciada com \u00eanfase na primeira s\u00edlaba, ao contr\u00e1rio de \u201ca-TRIB-ute\u201d, que \u00e9 um verbo. O diagrama seguinte mostra o resultado dessas atribui\u00e7\u00f5es. Um diagrama de estado que mostra um objeto e seus atributos chama-se diagrama de objeto; veja a Figura 15.1. Figura 15.1 \u2013 Diagrama de um objeto Point . A vari\u00e1vel blank refere-se a um objeto Point , que cont\u00e9m dois atributos. Cada atributo refere-se a um n\u00famero de ponto flutuante. Voc\u00ea pode ler o valor de um atributo usando a mesma sintaxe: >>> blank.y 4.0 >>> x = blank.x >>> x 3.0 A express\u00e3o blank.x significa \u201cV\u00e1 ao objeto a que blank se refere e pegue o valor de x\u201d. No exemplo, atribu\u00edmos este valor a uma vari\u00e1vel x . N\u00e3o h\u00e1 nenhum conflito entre a vari\u00e1vel x e o atributo x . Voc\u00ea pode usar a nota\u00e7\u00e3o de ponto como parte de qualquer express\u00e3o. Por exemplo: >>> '(%g, %g)' % (blank.x, blank.y) '(3.0, 4.0)' >>> distance = math.sqrt(blank.x ** 2 + blank.y ** 2) >>> distance 5.0 Voc\u00ea pode passar uma inst\u00e2ncia como argumento da forma habitual. Por exemplo: def print_point(p): print('(%g, %g)' % (p.x, p.y)) print_point toma um ponto como argumento e o exibe em nota\u00e7\u00e3o matem\u00e1tica. Para invoc\u00e1-lo, voc\u00ea pode passar blank como argumento: >>> print_point(blank) (3.0, 4.0) Dentro da fun\u00e7\u00e3o, p \u00e9 um alias para blank , ent\u00e3o, se a fun\u00e7\u00e3o altera p , blank tamb\u00e9m muda. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada distance_between_points , que toma dois pontos como argumentos e retorna a dist\u00e2ncia entre eles. 15.3 - Ret\u00e2ngulos \u00c0s vezes, \u00e9 \u00f3bvio quais deveriam ser os atributos de um objeto, mas outras \u00e9 preciso decidir entre as possibilidades. Por exemplo, vamos supor que voc\u00ea esteja criando uma classe para representar ret\u00e2ngulos. Que atributos usaria para especificar a posi\u00e7\u00e3o e o tamanho de um ret\u00e2ngulo? Voc\u00ea pode ignorar \u00e2ngulo; para manter as coisas simples, suponha que o ret\u00e2ngulo seja vertical ou horizontal. H\u00e1 duas possibilidades, no m\u00ednimo: Voc\u00ea pode especificar um canto do ret\u00e2ngulo (ou o centro), a largura e a altura. Voc\u00ea pode especificar dois cantos opostos. Nesse ponto \u00e9 dif\u00edcil dizer qual op\u00e7\u00e3o \u00e9 melhor, ent\u00e3o implementaremos a primeira, como exemplo. Aqui est\u00e1 a defini\u00e7\u00e3o de classe: class Rectangle: \"\"\"Represents a rectangle. attributes: width, height, corner. \"\"\" A docstring lista os atributos: width e height s\u00e3o n\u00fameros; corner \u00e9 um objeto Point que especifica o canto inferior esquerdo. Para representar um ret\u00e2ngulo, voc\u00ea tem que instanciar um objeto Rectangle e atribuir valores aos atributos: box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 0.0 box.corner.y = 0.0 A express\u00e3o box.corner.x significa \u201cV\u00e1 ao objeto ao qual box se refere e pegue o atributo denominado corner ; ent\u00e3o v\u00e1 a este objeto e pegue o atributo denominado x \u201d. A Figura 15.2 mostra o estado deste objeto. Um objeto que \u00e9 um atributo de outro objeto \u00e9 integrado. A Figura 10.1 mostra o diagrama de estado para cheeses, numbers e empty. Figura 15.2 \u2013 Diagrama de um objeto Rectangle . 15.4 - Inst\u00e2ncias como valores de retorno As fun\u00e7\u00f5es podem retornar inst\u00e2ncias. Por exemplo, find_center recebe um Rectangle como argumento e devolve um Point , que cont\u00e9m as coordenadas do centro do ret\u00e2ngulo: def find_center(rect): p = Point() p.x = rect.corner.x + rect.width/2 p.y = rect.corner.y + rect.height/2 return p Aqui est\u00e1 um exemplo que passa box como um argumento para find_center e atribui o ponto resultante \u00e0 vari\u00e1vel center : >>> center = find_center(box) >>> print_point(center) (50, 100) 15.5 - Objetos s\u00e3o mut\u00e1veis Voc\u00ea pode alterar o estado de um objeto fazendo uma atribui\u00e7\u00e3o a um dos seus atributos. Por exemplo, para mudar o tamanho de um ret\u00e2ngulo sem mudar sua posi\u00e7\u00e3o, voc\u00ea pode alterar os valores de width e height: box.width = box.width + 50 box.height = box.height + 100 Voc\u00ea tamb\u00e9m pode escrever fun\u00e7\u00f5es que alteram objetos. Por exemplo, grow_rectangle recebe um objeto Rectangle e dois n\u00fameros, dwidth e dheight , e adiciona os n\u00fameros \u00e0 largura e altura do ret\u00e2ngulo: def grow_rectangle(rect, dwidth, dheight): rect.width += dwidth rect.height += dheight Eis um exemplo que demonstra o efeito: >>> box.width, box.height (150.0, 300.0) >>> grow_rectangle(box, 50, 100) >>> box.width, box.height (200.0, 400.0) Dentro da fun\u00e7\u00e3o, rect \u00e9 um alias de box , ent\u00e3o quando a fun\u00e7\u00e3o altera rect , box aponta para o objeto alterado. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada move_rectangle que toma um Rectangle e dois n\u00fameros chamados dx e dy. Ela deve alterar a posi\u00e7\u00e3o do ret\u00e2ngulo, adicionando dx \u00e0 coordenada x de corner e adicionando dy \u00e0 coordenada y de corner. 15.6 - C\u00f3pia Alias podem tornar um programa dif\u00edcil de ler porque as altera\u00e7\u00f5es em um lugar podem ter efeitos inesperados em outro lugar. \u00c9 dif\u00edcil monitorar todas as vari\u00e1veis que podem referir-se a um dado objeto. Em vez de usar alias, copiar o objeto pode ser uma alternativa. O m\u00f3dulo copy cont\u00e9m uma fun\u00e7\u00e3o chamada copy que pode duplicar qualquer objeto: >>> p1 = Point() >>> p1.x = 3.0 >>> p1.y = 4.0 >>> import copy >>> p2 = copy.copy(p1) p1 e p2 cont\u00eam os mesmos dados, mas n\u00e3o s\u00e3o o mesmo Point : >>> print_point(p1) (3, 4) >>> print_point(p2) (3, 4) >>> p1 is p2 False >>> p1 == p2 False O operador is indica que p1 e p2 n\u00e3o s\u00e3o o mesmo objeto, que \u00e9 o que esperamos. Por\u00e9m, voc\u00ea poderia ter esperado que == fosse apresentado como True , porque esses pontos cont\u00eam os mesmos dados. Nesse caso, pode ficar desapontado ao saber que, para inst\u00e2ncias, o comportamento padr\u00e3o do operador == \u00e9 o mesmo que o do operador is ; ele verifica a identidade dos objetos, n\u00e3o a sua equival\u00eancia. Isso acontece porque, para tipos definidos pelo programador, o Python n\u00e3o sabe o que deve ser considerado equivalente. Pelo menos, ainda n\u00e3o. Se voc\u00ea usar copy.copy para duplicar um ret\u00e2ngulo, descobrir\u00e1 que ele copia o objeto Rectangle , mas n\u00e3o o Point embutido nele: >>> box2 = copy.copy(box) >>> box2 is box False >>> box2.corner is box.corner True A Figura 15.3 mostra como fica o diagrama de objeto. Esta opera\u00e7\u00e3o chama-se c\u00f3pia superficial porque copia o objeto e qualquer refer\u00eancia que contenha, mas n\u00e3o os objetos integrados. Figura 15.3 \u2013 Diagrama: dois objetos Rectangle compartilhando o mesmo Point . Para a maior parte das aplica\u00e7\u00f5es, n\u00e3o \u00e9 isso que voc\u00ea quer. Nesse exemplo, invocar grow_rectangle em um dos Rectangles n\u00e3o afetaria o outro, mas invocar move_rectangle em qualquer um deles afetaria a ambos! Esse comportamento \u00e9 confuso e propenso a erros. Felizmente, o m\u00f3dulo copy oferece um m\u00e9todo chamado deepcopy que copia n\u00e3o s\u00f3 o objeto, mas tamb\u00e9m os objetos aos quais ele se refere, e os objetos aos quais estes se referem, e assim por diante. Voc\u00ea n\u00e3o se surpreender\u00e1 ao descobrir que esta opera\u00e7\u00e3o se chama c\u00f3pia profunda. >>> box3 = copy.deepcopy(box) >>> box3 is box False >>> box3.corner is box.corner False box3 e box s\u00e3o objetos completamente separados. Como exerc\u00edcio, escreva uma vers\u00e3o de move_rectangle que cria e retorne um novo ret\u00e2ngulo em vez de alterar o antigo. 15.7 - Depura\u00e7\u00e3o Ao come\u00e7ar a trabalhar com objetos, provavelmente voc\u00ea encontrar\u00e1 algumas novas exce\u00e7\u00f5es. Se tentar acessar um atributo que n\u00e3o existe, recebe um AttributeError : >>> p = Point() >>> p.x = 3 >>> p.y = 4 >>> p.z AttributeError: Point instance has no attribute 'z' Se n\u00e3o estiver certo sobre o tipo que um objeto \u00e9, pode perguntar: >>> type(p) <class '__main__.Point'> Voc\u00ea tamb\u00e9m pode usar isinstance para verificar se um objeto \u00e9 uma inst\u00e2ncia de uma classe: >>> isinstance(p, Point) True Caso n\u00e3o tenha certeza se um objeto tem determinado atributo, voc\u00ea pode usar a fun\u00e7\u00e3o integrada hasattr : >>> hasattr(p, 'x') True >>> hasattr(p, 'z') False O primeiro argumento pode ser qualquer objeto; o segundo argumento \u00e9 uma string com o nome do atributo. Voc\u00ea tamb\u00e9m pode usar uma instru\u00e7\u00e3o try para ver se o objeto tem os atributos de que precisa: try: x = p.x except AttributeError: x = 0 Essa abordagem pode facilitar a escrita de fun\u00e7\u00f5es que atuam com tipos diferentes; voc\u00ea ver\u00e1 mais informa\u00e7\u00f5es sobre isso em \u201cPolimorfismo\u201d, na p\u00e1gina 248. 15.8 - Gloss\u00e1rio classe Tipo definido pelo programador. Uma defini\u00e7\u00e3o de classe cria um objeto de classe. objeto de classe Objeto que cont\u00e9m a informa\u00e7\u00e3o sobre um tipo definido pelo programador. O objeto de classe pode ser usado para criar inst\u00e2ncias do tipo. inst\u00e2ncia Objeto que pertence a uma classe. instanciar Criar um objeto. atributo Um dos valores denominados associados a um objeto. objeto integrado Objeto que \u00e9 armazenado como um atributo de outro objeto. c\u00f3pia superficial Copiar o conte\u00fado de um objeto, inclusive qualquer refer\u00eancia a objetos integrados; implementada pela fun\u00e7\u00e3o copy no m\u00f3dulo copy. c\u00f3pia profunda Copiar o conte\u00fado de um objeto, bem como qualquer objeto integrado, e qualquer objeto integrado a estes, e assim por diante; implementado pela fun\u00e7\u00e3o deepcopy no m\u00f3dulo copy. diagrama de objeto Diagrama que mostra objetos, seus atributos e os valores dos atributos. 15.9 - Exerc\u00edcios Exerc\u00edcio 15.1 Escreva uma defini\u00e7\u00e3o para uma classe denominada Circle , com os atributos center e radius, onde center \u00e9 um objeto Point e radius \u00e9 um n\u00famero. Instancie um objeto Circle , que represente um c\u00edrculo com o centro em 150, 100 e raio 75. Escreva uma fun\u00e7\u00e3o denominada point_in_circle , que tome um Circle e um Point e retorne True , se o ponto estiver dentro ou no limite do c\u00edrculo. Escreva uma fun\u00e7\u00e3o chamada rect_in_circle , que tome um Circle e um Rectangle e retorne True , se o ret\u00e2ngulo estiver totalmente dentro ou no limite do c\u00edrculo. Escreva uma fun\u00e7\u00e3o denominada rect_circle_overlap , que tome um Circle e um Rectangle e retorne True , se algum dos cantos do ret\u00e2ngulo cair dentro do c\u00edrculo. Ou, em uma vers\u00e3o mais desafiadora, retorne True se alguma parte do ret\u00e2ngulo cair dentro do c\u00edrculo. Solu\u00e7\u00e3o: http://thinkpython2.com/code/Circle.py. Exerc\u00edcio 15.2 Escreva uma fun\u00e7\u00e3o chamada draw_rect que receba um objeto Turtle e um Rectangle e use o Turtle para desenhar o ret\u00e2ngulo. Veja no Cap\u00edtulo 4 os exemplos de uso de objetos Turtle . Escreva uma fun\u00e7\u00e3o chamada draw_circle , que tome um Turtle e um Circle e desenhe o c\u00edrculo.","title":"Cap\u00edtulo 15: Classes e objetos"},{"location":"15-classes-objetos/#capitulo-15-classes-e-objetos","text":"A esta altura voc\u00ea j\u00e1 sabe como usar fun\u00e7\u00f5es para organizar c\u00f3digo e tipos integrados para organizar dados. O pr\u00f3ximo passo \u00e9 aprender \u201cprograma\u00e7\u00e3o orientada a objeto\u201d, que usa tipos definidos pelos programadores para organizar tanto o c\u00f3digo quanto os dados. A programa\u00e7\u00e3o orientada a objeto \u00e9 um t\u00f3pico abrangente; ser\u00e1 preciso passar por alguns cap\u00edtulos para abordar o tema. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Point1.py; as solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Point1_soln.py.","title":"Cap\u00edtulo 15: Classes e objetos"},{"location":"15-classes-objetos/#151-tipos-definidos-pelos-programadores","text":"J\u00e1 usamos muitos tipos integrados do Python; agora vamos definir um tipo pr\u00f3prio. Como exemplo, criaremos um tipo chamado Point , que representa um ponto no espa\u00e7o bidimensional. Na nota\u00e7\u00e3o matem\u00e1tica, os pontos muitas vezes s\u00e3o escritos entre par\u00eanteses, com uma v\u00edrgula separando as coordenadas. Por exemplo, (0,0) representa a origem e (x, y) representa o ponto que est\u00e1 x unidades \u00e0 direita e y unidades acima da origem. H\u00e1 v\u00e1rias formas para representar pontos no Python: Podemos armazenar as coordenadas separadamente em duas vari\u00e1veis, x e y. Podemos armazenar as coordenadas como elementos em uma lista ou tupla. Podemos criar um tipo para representar pontos como objetos. Criar um tipo \u00e9 mais complicado que outras op\u00e7\u00f5es, mas tem vantagens que logo ficar\u00e3o evidentes. Um tipo definido pelo programador tamb\u00e9m \u00e9 chamado de classe. Uma defini\u00e7\u00e3o de classe pode ser assim: class Point: \"\"\"Represents a point in 2-D space.\"\"\" O cabe\u00e7alho indica que a nova classe se chama Point . O corpo \u00e9 uma docstring que explica para que a classe serve. Voc\u00ea pode definir vari\u00e1veis e m\u00e9todos dentro de uma defini\u00e7\u00e3o de classe, mas voltaremos a isso depois. Definir uma classe denominada Point cria um objeto de classe: >>> Point <class '__main__.Point'> Como Point \u00e9 definido no n\u00edvel superior, seu \u201cnome completo\u201d \u00e9 __main__.Point . O objeto de classe \u00e9 como uma f\u00e1brica para criar objetos. Para criar um Point , voc\u00ea chama Point como se fosse uma fun\u00e7\u00e3o: >>> blank = Point() >>> blank <__main__.Point object at 0xb7e9d3ac> O valor de retorno \u00e9 uma refer\u00eancia a um objeto Point , ao qual atribu\u00edmos blank. Criar um objeto chama-se instancia\u00e7\u00e3o, e o objeto \u00e9 uma inst\u00e2ncia da classe. Quando voc\u00ea exibe uma inst\u00e2ncia, o Python diz a que classe ela pertence e onde est\u00e1 armazenada na mem\u00f3ria (o prefixo o 0x significa que o n\u00famero seguinte est\u00e1 em formato hexadecimal). Cada objeto \u00e9 uma inst\u00e2ncia de alguma classe, ent\u00e3o \u201cobjeto\u201d e \u201cinst\u00e2ncia\u201d s\u00e3o intercambi\u00e1veis. Por\u00e9m, neste cap\u00edtulo uso \u201cinst\u00e2ncia\u201d para indicar que estou falando sobre um tipo definido pelo programador.","title":"15.1 - Tipos definidos pelos programadores"},{"location":"15-classes-objetos/#152-atributos","text":"Voc\u00ea pode atribuir valores a uma inst\u00e2ncia usando a nota\u00e7\u00e3o de ponto: >>> blank.x = 3.0 >>> blank.y = 4.0 Essa sintaxe \u00e9 semelhante \u00e0 usada para selecionar uma vari\u00e1vel de um m\u00f3dulo, como math.pi ou string.whitespace. Nesse caso, entretanto, estamos atribuindo valores a elementos nomeados de um objeto. Esses elementos chamam-se atributos. Em ingl\u00eas, quando \u00e9 um substantivo, a palavra \u201cAT-trib-ute\u201d \u00e9 pronunciada com \u00eanfase na primeira s\u00edlaba, ao contr\u00e1rio de \u201ca-TRIB-ute\u201d, que \u00e9 um verbo. O diagrama seguinte mostra o resultado dessas atribui\u00e7\u00f5es. Um diagrama de estado que mostra um objeto e seus atributos chama-se diagrama de objeto; veja a Figura 15.1. Figura 15.1 \u2013 Diagrama de um objeto Point . A vari\u00e1vel blank refere-se a um objeto Point , que cont\u00e9m dois atributos. Cada atributo refere-se a um n\u00famero de ponto flutuante. Voc\u00ea pode ler o valor de um atributo usando a mesma sintaxe: >>> blank.y 4.0 >>> x = blank.x >>> x 3.0 A express\u00e3o blank.x significa \u201cV\u00e1 ao objeto a que blank se refere e pegue o valor de x\u201d. No exemplo, atribu\u00edmos este valor a uma vari\u00e1vel x . N\u00e3o h\u00e1 nenhum conflito entre a vari\u00e1vel x e o atributo x . Voc\u00ea pode usar a nota\u00e7\u00e3o de ponto como parte de qualquer express\u00e3o. Por exemplo: >>> '(%g, %g)' % (blank.x, blank.y) '(3.0, 4.0)' >>> distance = math.sqrt(blank.x ** 2 + blank.y ** 2) >>> distance 5.0 Voc\u00ea pode passar uma inst\u00e2ncia como argumento da forma habitual. Por exemplo: def print_point(p): print('(%g, %g)' % (p.x, p.y)) print_point toma um ponto como argumento e o exibe em nota\u00e7\u00e3o matem\u00e1tica. Para invoc\u00e1-lo, voc\u00ea pode passar blank como argumento: >>> print_point(blank) (3.0, 4.0) Dentro da fun\u00e7\u00e3o, p \u00e9 um alias para blank , ent\u00e3o, se a fun\u00e7\u00e3o altera p , blank tamb\u00e9m muda. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada distance_between_points , que toma dois pontos como argumentos e retorna a dist\u00e2ncia entre eles.","title":"15.2 - Atributos"},{"location":"15-classes-objetos/#153-retangulos","text":"\u00c0s vezes, \u00e9 \u00f3bvio quais deveriam ser os atributos de um objeto, mas outras \u00e9 preciso decidir entre as possibilidades. Por exemplo, vamos supor que voc\u00ea esteja criando uma classe para representar ret\u00e2ngulos. Que atributos usaria para especificar a posi\u00e7\u00e3o e o tamanho de um ret\u00e2ngulo? Voc\u00ea pode ignorar \u00e2ngulo; para manter as coisas simples, suponha que o ret\u00e2ngulo seja vertical ou horizontal. H\u00e1 duas possibilidades, no m\u00ednimo: Voc\u00ea pode especificar um canto do ret\u00e2ngulo (ou o centro), a largura e a altura. Voc\u00ea pode especificar dois cantos opostos. Nesse ponto \u00e9 dif\u00edcil dizer qual op\u00e7\u00e3o \u00e9 melhor, ent\u00e3o implementaremos a primeira, como exemplo. Aqui est\u00e1 a defini\u00e7\u00e3o de classe: class Rectangle: \"\"\"Represents a rectangle. attributes: width, height, corner. \"\"\" A docstring lista os atributos: width e height s\u00e3o n\u00fameros; corner \u00e9 um objeto Point que especifica o canto inferior esquerdo. Para representar um ret\u00e2ngulo, voc\u00ea tem que instanciar um objeto Rectangle e atribuir valores aos atributos: box = Rectangle() box.width = 100.0 box.height = 200.0 box.corner = Point() box.corner.x = 0.0 box.corner.y = 0.0 A express\u00e3o box.corner.x significa \u201cV\u00e1 ao objeto ao qual box se refere e pegue o atributo denominado corner ; ent\u00e3o v\u00e1 a este objeto e pegue o atributo denominado x \u201d. A Figura 15.2 mostra o estado deste objeto. Um objeto que \u00e9 um atributo de outro objeto \u00e9 integrado. A Figura 10.1 mostra o diagrama de estado para cheeses, numbers e empty. Figura 15.2 \u2013 Diagrama de um objeto Rectangle .","title":"15.3 - Ret\u00e2ngulos"},{"location":"15-classes-objetos/#154-instancias-como-valores-de-retorno","text":"As fun\u00e7\u00f5es podem retornar inst\u00e2ncias. Por exemplo, find_center recebe um Rectangle como argumento e devolve um Point , que cont\u00e9m as coordenadas do centro do ret\u00e2ngulo: def find_center(rect): p = Point() p.x = rect.corner.x + rect.width/2 p.y = rect.corner.y + rect.height/2 return p Aqui est\u00e1 um exemplo que passa box como um argumento para find_center e atribui o ponto resultante \u00e0 vari\u00e1vel center : >>> center = find_center(box) >>> print_point(center) (50, 100)","title":"15.4 - Inst\u00e2ncias como valores de retorno"},{"location":"15-classes-objetos/#155-objetos-sao-mutaveis","text":"Voc\u00ea pode alterar o estado de um objeto fazendo uma atribui\u00e7\u00e3o a um dos seus atributos. Por exemplo, para mudar o tamanho de um ret\u00e2ngulo sem mudar sua posi\u00e7\u00e3o, voc\u00ea pode alterar os valores de width e height: box.width = box.width + 50 box.height = box.height + 100 Voc\u00ea tamb\u00e9m pode escrever fun\u00e7\u00f5es que alteram objetos. Por exemplo, grow_rectangle recebe um objeto Rectangle e dois n\u00fameros, dwidth e dheight , e adiciona os n\u00fameros \u00e0 largura e altura do ret\u00e2ngulo: def grow_rectangle(rect, dwidth, dheight): rect.width += dwidth rect.height += dheight Eis um exemplo que demonstra o efeito: >>> box.width, box.height (150.0, 300.0) >>> grow_rectangle(box, 50, 100) >>> box.width, box.height (200.0, 400.0) Dentro da fun\u00e7\u00e3o, rect \u00e9 um alias de box , ent\u00e3o quando a fun\u00e7\u00e3o altera rect , box aponta para o objeto alterado. Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada move_rectangle que toma um Rectangle e dois n\u00fameros chamados dx e dy. Ela deve alterar a posi\u00e7\u00e3o do ret\u00e2ngulo, adicionando dx \u00e0 coordenada x de corner e adicionando dy \u00e0 coordenada y de corner.","title":"15.5 - Objetos s\u00e3o mut\u00e1veis"},{"location":"15-classes-objetos/#156-copia","text":"Alias podem tornar um programa dif\u00edcil de ler porque as altera\u00e7\u00f5es em um lugar podem ter efeitos inesperados em outro lugar. \u00c9 dif\u00edcil monitorar todas as vari\u00e1veis que podem referir-se a um dado objeto. Em vez de usar alias, copiar o objeto pode ser uma alternativa. O m\u00f3dulo copy cont\u00e9m uma fun\u00e7\u00e3o chamada copy que pode duplicar qualquer objeto: >>> p1 = Point() >>> p1.x = 3.0 >>> p1.y = 4.0 >>> import copy >>> p2 = copy.copy(p1) p1 e p2 cont\u00eam os mesmos dados, mas n\u00e3o s\u00e3o o mesmo Point : >>> print_point(p1) (3, 4) >>> print_point(p2) (3, 4) >>> p1 is p2 False >>> p1 == p2 False O operador is indica que p1 e p2 n\u00e3o s\u00e3o o mesmo objeto, que \u00e9 o que esperamos. Por\u00e9m, voc\u00ea poderia ter esperado que == fosse apresentado como True , porque esses pontos cont\u00eam os mesmos dados. Nesse caso, pode ficar desapontado ao saber que, para inst\u00e2ncias, o comportamento padr\u00e3o do operador == \u00e9 o mesmo que o do operador is ; ele verifica a identidade dos objetos, n\u00e3o a sua equival\u00eancia. Isso acontece porque, para tipos definidos pelo programador, o Python n\u00e3o sabe o que deve ser considerado equivalente. Pelo menos, ainda n\u00e3o. Se voc\u00ea usar copy.copy para duplicar um ret\u00e2ngulo, descobrir\u00e1 que ele copia o objeto Rectangle , mas n\u00e3o o Point embutido nele: >>> box2 = copy.copy(box) >>> box2 is box False >>> box2.corner is box.corner True A Figura 15.3 mostra como fica o diagrama de objeto. Esta opera\u00e7\u00e3o chama-se c\u00f3pia superficial porque copia o objeto e qualquer refer\u00eancia que contenha, mas n\u00e3o os objetos integrados. Figura 15.3 \u2013 Diagrama: dois objetos Rectangle compartilhando o mesmo Point . Para a maior parte das aplica\u00e7\u00f5es, n\u00e3o \u00e9 isso que voc\u00ea quer. Nesse exemplo, invocar grow_rectangle em um dos Rectangles n\u00e3o afetaria o outro, mas invocar move_rectangle em qualquer um deles afetaria a ambos! Esse comportamento \u00e9 confuso e propenso a erros. Felizmente, o m\u00f3dulo copy oferece um m\u00e9todo chamado deepcopy que copia n\u00e3o s\u00f3 o objeto, mas tamb\u00e9m os objetos aos quais ele se refere, e os objetos aos quais estes se referem, e assim por diante. Voc\u00ea n\u00e3o se surpreender\u00e1 ao descobrir que esta opera\u00e7\u00e3o se chama c\u00f3pia profunda. >>> box3 = copy.deepcopy(box) >>> box3 is box False >>> box3.corner is box.corner False box3 e box s\u00e3o objetos completamente separados. Como exerc\u00edcio, escreva uma vers\u00e3o de move_rectangle que cria e retorne um novo ret\u00e2ngulo em vez de alterar o antigo.","title":"15.6 - C\u00f3pia"},{"location":"15-classes-objetos/#157-depuracao","text":"Ao come\u00e7ar a trabalhar com objetos, provavelmente voc\u00ea encontrar\u00e1 algumas novas exce\u00e7\u00f5es. Se tentar acessar um atributo que n\u00e3o existe, recebe um AttributeError : >>> p = Point() >>> p.x = 3 >>> p.y = 4 >>> p.z AttributeError: Point instance has no attribute 'z' Se n\u00e3o estiver certo sobre o tipo que um objeto \u00e9, pode perguntar: >>> type(p) <class '__main__.Point'> Voc\u00ea tamb\u00e9m pode usar isinstance para verificar se um objeto \u00e9 uma inst\u00e2ncia de uma classe: >>> isinstance(p, Point) True Caso n\u00e3o tenha certeza se um objeto tem determinado atributo, voc\u00ea pode usar a fun\u00e7\u00e3o integrada hasattr : >>> hasattr(p, 'x') True >>> hasattr(p, 'z') False O primeiro argumento pode ser qualquer objeto; o segundo argumento \u00e9 uma string com o nome do atributo. Voc\u00ea tamb\u00e9m pode usar uma instru\u00e7\u00e3o try para ver se o objeto tem os atributos de que precisa: try: x = p.x except AttributeError: x = 0 Essa abordagem pode facilitar a escrita de fun\u00e7\u00f5es que atuam com tipos diferentes; voc\u00ea ver\u00e1 mais informa\u00e7\u00f5es sobre isso em \u201cPolimorfismo\u201d, na p\u00e1gina 248.","title":"15.7 - Depura\u00e7\u00e3o"},{"location":"15-classes-objetos/#158-glossario","text":"classe Tipo definido pelo programador. Uma defini\u00e7\u00e3o de classe cria um objeto de classe. objeto de classe Objeto que cont\u00e9m a informa\u00e7\u00e3o sobre um tipo definido pelo programador. O objeto de classe pode ser usado para criar inst\u00e2ncias do tipo. inst\u00e2ncia Objeto que pertence a uma classe. instanciar Criar um objeto. atributo Um dos valores denominados associados a um objeto. objeto integrado Objeto que \u00e9 armazenado como um atributo de outro objeto. c\u00f3pia superficial Copiar o conte\u00fado de um objeto, inclusive qualquer refer\u00eancia a objetos integrados; implementada pela fun\u00e7\u00e3o copy no m\u00f3dulo copy. c\u00f3pia profunda Copiar o conte\u00fado de um objeto, bem como qualquer objeto integrado, e qualquer objeto integrado a estes, e assim por diante; implementado pela fun\u00e7\u00e3o deepcopy no m\u00f3dulo copy. diagrama de objeto Diagrama que mostra objetos, seus atributos e os valores dos atributos.","title":"15.8 - Gloss\u00e1rio"},{"location":"15-classes-objetos/#159-exercicios","text":"","title":"15.9 - Exerc\u00edcios"},{"location":"15-classes-objetos/#exercicio-151","text":"Escreva uma defini\u00e7\u00e3o para uma classe denominada Circle , com os atributos center e radius, onde center \u00e9 um objeto Point e radius \u00e9 um n\u00famero. Instancie um objeto Circle , que represente um c\u00edrculo com o centro em 150, 100 e raio 75. Escreva uma fun\u00e7\u00e3o denominada point_in_circle , que tome um Circle e um Point e retorne True , se o ponto estiver dentro ou no limite do c\u00edrculo. Escreva uma fun\u00e7\u00e3o chamada rect_in_circle , que tome um Circle e um Rectangle e retorne True , se o ret\u00e2ngulo estiver totalmente dentro ou no limite do c\u00edrculo. Escreva uma fun\u00e7\u00e3o denominada rect_circle_overlap , que tome um Circle e um Rectangle e retorne True , se algum dos cantos do ret\u00e2ngulo cair dentro do c\u00edrculo. Ou, em uma vers\u00e3o mais desafiadora, retorne True se alguma parte do ret\u00e2ngulo cair dentro do c\u00edrculo. Solu\u00e7\u00e3o: http://thinkpython2.com/code/Circle.py.","title":"Exerc\u00edcio 15.1"},{"location":"15-classes-objetos/#exercicio-152","text":"Escreva uma fun\u00e7\u00e3o chamada draw_rect que receba um objeto Turtle e um Rectangle e use o Turtle para desenhar o ret\u00e2ngulo. Veja no Cap\u00edtulo 4 os exemplos de uso de objetos Turtle . Escreva uma fun\u00e7\u00e3o chamada draw_circle , que tome um Turtle e um Circle e desenhe o c\u00edrculo.","title":"Exerc\u00edcio 15.2"},{"location":"16-classes-funcoes/","text":"Cap\u00edtulo 16: Classes e fun\u00e7\u00f5es Agora que sabemos como criar tipos, o pr\u00f3ximo passo deve ser escrever fun\u00e7\u00f5es que recebam objetos definidos pelo programador como par\u00e2metros e os retornem como resultados. Neste cap\u00edtulo tamb\u00e9m vou apresentar o \u201cestilo funcional de programa\u00e7\u00e3o\u201d e dois novos planos de desenvolvimento de programas. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time1.py. As solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o em http://thinkpython2.com/code/Time1_soln.py. 16.1 - Time Para ter mais um exemplo de tipo definido pelo programador, criaremos uma classe chamada Time (hora), que registra um hor\u00e1rio no dia. A defini\u00e7\u00e3o da classe \u00e9 assim: class Time: \"\"\"Represents the time of day. attributes: hour, minute, second \"\"\" Podemos criar um objeto Time e ter atributos para horas, minutos e segundos: time = Time() time.hour = 11 time.minute = 59 time.second = 30 O diagrama de estado do objeto Time est\u00e1 na Figura 16.1. Figura 16.1 \u2013 Diagrama de um objeto Time . Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada print_time , que receba um objeto Time e o exiba na forma hour:minute:second. Dica: a sequ\u00eancia de formata\u00e7\u00e3o '%.2d' exibe um n\u00famero inteiro com, pelo menos, dois d\u00edgitos, incluindo um zero \u00e0 esquerda, se for necess\u00e1rio. Escreva uma fun\u00e7\u00e3o booleana chamada is_after , que receba dois objetos Time, t1 e t2 , e devolva True se t1 for cronologicamente depois de t2 e False se n\u00e3o for. Desafio: n\u00e3o use uma instru\u00e7\u00e3o if . 16.2 - Fun\u00e7\u00f5es puras Nas pr\u00f3ximas se\u00e7\u00f5es, vamos escrever duas fun\u00e7\u00f5es que adicionam valores de tempo. Elas demonstram dois tipos de fun\u00e7\u00f5es: fun\u00e7\u00f5es puras e modificadores. Tamb\u00e9m demonstram um plano de desenvolvimento que chamarei de prot\u00f3tipo e corre\u00e7\u00e3o, que \u00e9 uma forma de atacar um problema complexo come\u00e7ando com um prot\u00f3tipo simples e lidando com as complica\u00e7\u00f5es de forma incremental. Aqui est\u00e1 um prot\u00f3tipo simples de add_time : def add_time(t1, t2): sum = Time() sum.hour = t1.hour + t2.hour sum.minute = t1.minute + t2.minute sum.second = t1.second + t2.second return sum A fun\u00e7\u00e3o cria um novo objeto Time , inicializa seus atributos e retorna uma refer\u00eancia ao novo objeto. A fun\u00e7\u00e3o pura \u00e9 chamada assim porque n\u00e3o altera nenhum dos objetos passados a ela como argumentos; al\u00e9m disso, ela n\u00e3o tem efeitos, como exibir um valor ou receber entradas de usu\u00e1rio, apenas retorna um valor. Para testar esta fun\u00e7\u00e3o, criarei objetos Time : start , que cont\u00e9m o tempo de in\u00edcio de um filme, como Monty Python e o c\u00e1lice sagrado , e duration , que cont\u00e9m o tempo de execu\u00e7\u00e3o do filme, que \u00e9 de 1 hora e 35 minutos. add_time calcula quando o filme acaba: >>> start = Time() >>> start.hour = 9 >>> start.minute = 45 >>> start.second = 0 >>> duration = Time() >>> duration.hour = 1 >>> duration.minute = 35 >>> duration.second = 0 >>> done = add_time(start, duration) >>> print_time(done) 10:80:00 O resultado, 10:80:00, pode n\u00e3o ser o que voc\u00ea esperava. O problema \u00e9 que esta fun\u00e7\u00e3o n\u00e3o trata casos onde o n\u00famero de segundos ou minutos \u00e9 maior que 60. Quando isso acontece, precisamos transportar os segundos extras \u00e0 coluna dos minutos ou os minutos extras \u00e0 coluna das horas. Aqui est\u00e1 uma vers\u00e3o melhorada: def add_time(t1, t2): sum = Time() sum.hour = t1.hour + t2.hour sum.minute = t1.minute + t2.minute sum.second = t1.second + t2.second if sum.second >= 60: sum.second -= 60 sum.minute += 1 if sum.minute >= 60: sum.minute -= 60 sum.hour += 1 return sum Embora esta fun\u00e7\u00e3o esteja correta, \u00e9 um pouco extensa. Veremos uma alternativa menor mais adiante. 16.3 - Modificadores \u00c0s vezes \u00e9 \u00fatil uma fun\u00e7\u00e3o alterar os objetos que recebe como par\u00e2metros. Nesse caso, as mudan\u00e7as s\u00e3o vis\u00edveis a quem chama a fun\u00e7\u00e3o. As fun\u00e7\u00f5es que fazem isso chamam-se modificadores. increment , que acrescenta um dado n\u00famero de segundos a um objeto Time , pode ser escrita naturalmente como um modificador. Aqui est\u00e1 um primeiro esbo\u00e7o: def increment(time, seconds): time.second += seconds if time.second >= 60: time.second -= 60 time.minute += 1 if time.minute >= 60: time.minute -= 60 time.hour += 1 A primeira linha executa a opera\u00e7\u00e3o b\u00e1sica; o resto lida com os casos especiais que vimos antes. Esta fun\u00e7\u00e3o est\u00e1 correta? O que acontece se second for muito mais que 60? Neste caso n\u00e3o basta transportar uma vez, temos que continuar fazendo isso at\u00e9 que time.second seja menos de 60. Uma solu\u00e7\u00e3o \u00e9 substituir a instru\u00e7\u00e3o if pela instru\u00e7\u00e3o while . Isso tornaria a fun\u00e7\u00e3o correta, mas n\u00e3o muito eficiente. Como exerc\u00edcio, escreva uma vers\u00e3o correta de increment que n\u00e3o contenha loops. O que se faz com modificadores tamb\u00e9m pode ser feito com fun\u00e7\u00f5es puras. Na verdade, algumas linguagens de programa\u00e7\u00e3o s\u00f3 permitem fun\u00e7\u00f5es puras. H\u00e1 evid\u00eancias de que os programas que usam fun\u00e7\u00f5es puras s\u00e3o mais r\u00e1pidos para serem desenvolvidos e menos propensos a erros que programas que usam modificadores. No entanto, modificadores s\u00e3o convenientes de vez em quando, e os programas funcionais tendem a ser menos eficientes. De forma geral, recomendo que voc\u00ea escreva fun\u00e7\u00f5es puras sempre que achar razo\u00e1vel e recorra a modificadores s\u00f3 se houver alguma vantagem clara. Esta abordagem pode ser chamada de programa\u00e7\u00e3o funcional . Como exerc\u00edcio, escreva uma vers\u00e3o \u201cpura\u201d de increment que cria e retorna um objeto Time em vez de alterar o par\u00e2metro. 16.4 - Prototipa\u00e7\u00e3o versus planejamento O plano de desenvolvimento que estou demonstrando chama-se \u201cprot\u00f3tipo e corre\u00e7\u00e3o\u201d. Para cada fun\u00e7\u00e3o, escrevi um prot\u00f3tipo que executa o c\u00e1lculo b\u00e1sico e ent\u00e3o testa a fun\u00e7\u00e3o, corrigindo erros no decorrer do caminho. Esta abordagem pode ser eficaz, especialmente se voc\u00ea ainda n\u00e3o tem uma compreens\u00e3o profunda do problema. Por\u00e9m, as corre\u00e7\u00f5es incrementais podem gerar c\u00f3digo que se complica desnecessariamente (pois trata de muitos casos especiais) e pouco confi\u00e1veis (j\u00e1 que \u00e9 dif\u00edcil saber se todos os erros foram encontrados). Uma alternativa \u00e9 o desenvolvimento planejado, no qual a compreens\u00e3o de alto n\u00edvel do problema pode facilitar muito a programa\u00e7\u00e3o. Neste caso, descobre-se que um objeto Time \u00e9, na verdade, um n\u00famero de tr\u00eas d\u00edgitos na base 60 (veja http://en.wikipedia.org/wiki/Sexagesimal)! O atributo second \u00e9 a \u201ccoluna de unidades\u201d, o atributo minute \u00e9 a \u201ccoluna dos 60\u201d, e o atributo hour \u00e9 a \u201ccoluna do 3.600\u201d. Quando escrevemos add_time e increment , est\u00e1vamos na verdade fazendo adi\u00e7\u00f5es na base 60, e por isso transport\u00e1vamos os resultados de uma coluna \u00e0 seguinte. Essa observa\u00e7\u00e3o sugere outra abordagem para o problema inteiro \u2013 podemos converter objetos Time em n\u00fameros inteiros e aproveitar o fato de que o computador sabe trabalhar com aritm\u00e9tica de n\u00fameros inteiros. Aqui est\u00e1 uma fun\u00e7\u00e3o que converte objetos Time em n\u00fameros inteiros: def time_to_int(time): minutes = time.hour * 60 + time.minute seconds = minutes * 60 + time.second return seconds E aqui est\u00e1 uma fun\u00e7\u00e3o que converte um n\u00famero inteiro em um Time (lembre-se de que divmod divide o primeiro argumento pelo segundo e devolve o quociente e o resto como uma tupla): def int_to_time(seconds): time = Time() minutes, time.second = divmod(seconds, 60) time.hour, time.minute = divmod(minutes, 60) return time Voc\u00ea pode ter que pensar um pouco e fazer alguns testes, para se convencer de que essas fun\u00e7\u00f5es est\u00e3o corretas. Um modo de test\u00e1-las \u00e9 ver se time_to_int(int_to_time(x)) == x para muitos valores de x . Este \u00e9 um exemplo de uma verifica\u00e7\u00e3o de consist\u00eancia. Uma vez que esteja convencido de que est\u00e3o corretas, voc\u00ea pode us\u00e1-las para reescrever add_time : def add_time(t1, t2): seconds = time_to_int(t1) + time_to_int(t2) return int_to_time(seconds) Esta vers\u00e3o \u00e9 mais curta que a original, e mais f\u00e1cil de verificar. Como exerc\u00edcio, reescreva increment usando time_to_int e int_to_time . Em algumas situa\u00e7\u00f5es, converter da base 60 para a base 10 e de volta \u00e9 mais dif\u00edcil que apenas lidar com as horas. A convers\u00e3o de base \u00e9 mais abstrata; nossa intui\u00e7\u00e3o para lidar com valores temporais \u00e9 melhor. No entanto, se tivermos discernimento para lidar com horas como n\u00fameros de base 60 e investirmos esfor\u00e7o em escrever as fun\u00e7\u00f5es de convers\u00e3o ( time_to_int e int_to_time ), chegamos a um programa que \u00e9 mais curto, mais f\u00e1cil de ler e depurar, e mais confi\u00e1vel. Tamb\u00e9m \u00e9 mais f\u00e1cil acrescentar recursos depois. Por exemplo, imagine subtrair dois objetos Time para encontrar a dura\u00e7\u00e3o entre eles. Uma abordagem ing\u00eanua seria implementar a subtra\u00e7\u00e3o com transporte. Por\u00e9m, usar fun\u00e7\u00f5es de convers\u00e3o seria mais f\u00e1cil e, provavelmente, mais correto. Ironicamente, tornar um problema mais dif\u00edcil (ou mais geral) facilita (porque h\u00e1 menos casos especiais e menos oportunidades de erro). 16.5 - Depura\u00e7\u00e3o Um objeto Time \u00e9 bem formado se os valores de minute e second estiverem entre 0 e 60 (incluindo 0, mas n\u00e3o 60) e se hour for positivo. hour e minute devem ser valores inteiros, mas podemos permitir que second tenha uma parte fracion\u00e1ria. Requisitos como esses chamam-se invari\u00e1veis porque sempre devem ser verdadeiros. Para dizer de outra forma, se n\u00e3o forem verdadeiros, algo deu errado. Escrever c\u00f3digo para verificar requisitos invari\u00e1veis pode ajudar a descobrir erros e encontrar suas causas. Por exemplo, voc\u00ea pode ter uma fun\u00e7\u00e3o como valid_time, que receba um objeto Time e retorne False se ele violar um requisito invari\u00e1vel: def valid_time(time): if time.hour < 0 or time.minute < 0 or time.second < 0: return False if time.minute >= 60 or time.second >= 60: return False return True No in\u00edcio de cada fun\u00e7\u00e3o voc\u00ea pode verificar os argumentos para ter certeza de que s\u00e3o v\u00e1lidos: def add_time(t1, t2): if not valid_time(t1) or not valid_time(t2): raise ValueError('invalid Time object in add_time') seconds = time_to_int(t1) + time_to_int(t2) return int_to_time(seconds) Ou voc\u00ea pode usar uma instru\u00e7\u00e3o assert , que verifica determinado requisito invari\u00e1vel e cria uma exce\u00e7\u00e3o se ela falhar: def add_time(t1, t2): assert valid_time(t1) and valid_time(t2) seconds = time_to_int(t1) + time_to_int(t2) return int_to_time(seconds) Instru\u00e7\u00f5es assert s\u00e3o \u00fateis porque distinguem o c\u00f3digo que lida com condi\u00e7\u00f5es normais do c\u00f3digo que verifica erros. 16.6 - Gloss\u00e1rio prot\u00f3tipo e corre\u00e7\u00e3o Plano de desenvolvimento no qual a escrita do programa parte de um esbo\u00e7o inicial, e depois segue ao teste e corre\u00e7\u00e3o de erros, conforme sejam encontrados. desenvolvimento planejado Plano de desenvolvimento que implica uma compreens\u00e3o de alto n\u00edvel do problema e mais planejamento que desenvolvimento incremental ou desenvolvimento prototipado. fun\u00e7\u00e3o pura Fun\u00e7\u00e3o que n\u00e3o altera nenhum dos objetos que recebe como argumento. A maior parte das fun\u00e7\u00f5es puras gera resultado. modificador Fun\u00e7\u00e3o que modifica um ou v\u00e1rios dos objetos que recebe como argumento. A maior parte dos modificadores s\u00e3o nulos; isto \u00e9, retornam None. programa\u00e7\u00e3o funcional Estilo de projeto de programa no qual a maioria das fun\u00e7\u00f5es s\u00e3o puras. invari\u00e1vel Condi\u00e7\u00e3o que sempre deve ser verdadeira durante a execu\u00e7\u00e3o de um programa. instru\u00e7\u00e3o assert Instru\u00e7\u00e3o que verifica uma condi\u00e7\u00e3o e levanta uma exce\u00e7\u00e3o se esta falhar. 16.7 - Exerc\u00edcios Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time1.py; as solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time1_soln.py. Exerc\u00edcio 16.1 Escreva uma fun\u00e7\u00e3o chamada mul_time que receba um objeto Time e um n\u00famero e retorne um novo objeto Time que contenha o produto do Time original e do n\u00famero. Ent\u00e3o use mul_time para escrever uma fun\u00e7\u00e3o que receba um objeto Time representando o tempo at\u00e9 o fim de uma corrida e um n\u00famero que represente a dist\u00e2ncia, e retorne um objeto Time com o passo m\u00e9dio (tempo por milha). Exerc\u00edcio 16.2 O m\u00f3dulo datetime fornece objetos time que s\u00e3o semelhantes aos objetos Time deste cap\u00edtulo, mas ele oferece um grande conjunto de m\u00e9todos e operadores. Leia a documenta\u00e7\u00e3o em http://docs.python.org/3/library/datetime.html. Use o m\u00f3dulo datetime para escrever um programa que receba a data atual e exiba o dia da semana. Escreva um programa que receba um anivers\u00e1rio como entrada e exiba a idade do usu\u00e1rio e o n\u00famero de dias, horas, minutos e segundos at\u00e9 o seu pr\u00f3ximo anivers\u00e1rio. Para duas pessoas nascidas em dias diferentes, h\u00e1 um dia em que a idade de uma equivale a duas vezes a da outra. Este \u00e9 o Dia Duplo delas. Escreva um programa que receba dois anivers\u00e1rios e calcule o Dia Duplo dos aniversariantes. Para um desafio um pouco maior, escreva a vers\u00e3o mais geral que calcule o dia em que uma pessoa \u00e9 N vezes mais velha que a outra.","title":"Cap\u00edtulo 16: Classes e fun\u00e7\u00f5es"},{"location":"16-classes-funcoes/#capitulo-16-classes-e-funcoes","text":"Agora que sabemos como criar tipos, o pr\u00f3ximo passo deve ser escrever fun\u00e7\u00f5es que recebam objetos definidos pelo programador como par\u00e2metros e os retornem como resultados. Neste cap\u00edtulo tamb\u00e9m vou apresentar o \u201cestilo funcional de programa\u00e7\u00e3o\u201d e dois novos planos de desenvolvimento de programas. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time1.py. As solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o em http://thinkpython2.com/code/Time1_soln.py.","title":"Cap\u00edtulo 16: Classes e fun\u00e7\u00f5es"},{"location":"16-classes-funcoes/#161-time","text":"Para ter mais um exemplo de tipo definido pelo programador, criaremos uma classe chamada Time (hora), que registra um hor\u00e1rio no dia. A defini\u00e7\u00e3o da classe \u00e9 assim: class Time: \"\"\"Represents the time of day. attributes: hour, minute, second \"\"\" Podemos criar um objeto Time e ter atributos para horas, minutos e segundos: time = Time() time.hour = 11 time.minute = 59 time.second = 30 O diagrama de estado do objeto Time est\u00e1 na Figura 16.1. Figura 16.1 \u2013 Diagrama de um objeto Time . Como exerc\u00edcio, escreva uma fun\u00e7\u00e3o chamada print_time , que receba um objeto Time e o exiba na forma hour:minute:second. Dica: a sequ\u00eancia de formata\u00e7\u00e3o '%.2d' exibe um n\u00famero inteiro com, pelo menos, dois d\u00edgitos, incluindo um zero \u00e0 esquerda, se for necess\u00e1rio. Escreva uma fun\u00e7\u00e3o booleana chamada is_after , que receba dois objetos Time, t1 e t2 , e devolva True se t1 for cronologicamente depois de t2 e False se n\u00e3o for. Desafio: n\u00e3o use uma instru\u00e7\u00e3o if .","title":"16.1 - Time"},{"location":"16-classes-funcoes/#162-funcoes-puras","text":"Nas pr\u00f3ximas se\u00e7\u00f5es, vamos escrever duas fun\u00e7\u00f5es que adicionam valores de tempo. Elas demonstram dois tipos de fun\u00e7\u00f5es: fun\u00e7\u00f5es puras e modificadores. Tamb\u00e9m demonstram um plano de desenvolvimento que chamarei de prot\u00f3tipo e corre\u00e7\u00e3o, que \u00e9 uma forma de atacar um problema complexo come\u00e7ando com um prot\u00f3tipo simples e lidando com as complica\u00e7\u00f5es de forma incremental. Aqui est\u00e1 um prot\u00f3tipo simples de add_time : def add_time(t1, t2): sum = Time() sum.hour = t1.hour + t2.hour sum.minute = t1.minute + t2.minute sum.second = t1.second + t2.second return sum A fun\u00e7\u00e3o cria um novo objeto Time , inicializa seus atributos e retorna uma refer\u00eancia ao novo objeto. A fun\u00e7\u00e3o pura \u00e9 chamada assim porque n\u00e3o altera nenhum dos objetos passados a ela como argumentos; al\u00e9m disso, ela n\u00e3o tem efeitos, como exibir um valor ou receber entradas de usu\u00e1rio, apenas retorna um valor. Para testar esta fun\u00e7\u00e3o, criarei objetos Time : start , que cont\u00e9m o tempo de in\u00edcio de um filme, como Monty Python e o c\u00e1lice sagrado , e duration , que cont\u00e9m o tempo de execu\u00e7\u00e3o do filme, que \u00e9 de 1 hora e 35 minutos. add_time calcula quando o filme acaba: >>> start = Time() >>> start.hour = 9 >>> start.minute = 45 >>> start.second = 0 >>> duration = Time() >>> duration.hour = 1 >>> duration.minute = 35 >>> duration.second = 0 >>> done = add_time(start, duration) >>> print_time(done) 10:80:00 O resultado, 10:80:00, pode n\u00e3o ser o que voc\u00ea esperava. O problema \u00e9 que esta fun\u00e7\u00e3o n\u00e3o trata casos onde o n\u00famero de segundos ou minutos \u00e9 maior que 60. Quando isso acontece, precisamos transportar os segundos extras \u00e0 coluna dos minutos ou os minutos extras \u00e0 coluna das horas. Aqui est\u00e1 uma vers\u00e3o melhorada: def add_time(t1, t2): sum = Time() sum.hour = t1.hour + t2.hour sum.minute = t1.minute + t2.minute sum.second = t1.second + t2.second if sum.second >= 60: sum.second -= 60 sum.minute += 1 if sum.minute >= 60: sum.minute -= 60 sum.hour += 1 return sum Embora esta fun\u00e7\u00e3o esteja correta, \u00e9 um pouco extensa. Veremos uma alternativa menor mais adiante.","title":"16.2 - Fun\u00e7\u00f5es puras"},{"location":"16-classes-funcoes/#163-modificadores","text":"\u00c0s vezes \u00e9 \u00fatil uma fun\u00e7\u00e3o alterar os objetos que recebe como par\u00e2metros. Nesse caso, as mudan\u00e7as s\u00e3o vis\u00edveis a quem chama a fun\u00e7\u00e3o. As fun\u00e7\u00f5es que fazem isso chamam-se modificadores. increment , que acrescenta um dado n\u00famero de segundos a um objeto Time , pode ser escrita naturalmente como um modificador. Aqui est\u00e1 um primeiro esbo\u00e7o: def increment(time, seconds): time.second += seconds if time.second >= 60: time.second -= 60 time.minute += 1 if time.minute >= 60: time.minute -= 60 time.hour += 1 A primeira linha executa a opera\u00e7\u00e3o b\u00e1sica; o resto lida com os casos especiais que vimos antes. Esta fun\u00e7\u00e3o est\u00e1 correta? O que acontece se second for muito mais que 60? Neste caso n\u00e3o basta transportar uma vez, temos que continuar fazendo isso at\u00e9 que time.second seja menos de 60. Uma solu\u00e7\u00e3o \u00e9 substituir a instru\u00e7\u00e3o if pela instru\u00e7\u00e3o while . Isso tornaria a fun\u00e7\u00e3o correta, mas n\u00e3o muito eficiente. Como exerc\u00edcio, escreva uma vers\u00e3o correta de increment que n\u00e3o contenha loops. O que se faz com modificadores tamb\u00e9m pode ser feito com fun\u00e7\u00f5es puras. Na verdade, algumas linguagens de programa\u00e7\u00e3o s\u00f3 permitem fun\u00e7\u00f5es puras. H\u00e1 evid\u00eancias de que os programas que usam fun\u00e7\u00f5es puras s\u00e3o mais r\u00e1pidos para serem desenvolvidos e menos propensos a erros que programas que usam modificadores. No entanto, modificadores s\u00e3o convenientes de vez em quando, e os programas funcionais tendem a ser menos eficientes. De forma geral, recomendo que voc\u00ea escreva fun\u00e7\u00f5es puras sempre que achar razo\u00e1vel e recorra a modificadores s\u00f3 se houver alguma vantagem clara. Esta abordagem pode ser chamada de programa\u00e7\u00e3o funcional . Como exerc\u00edcio, escreva uma vers\u00e3o \u201cpura\u201d de increment que cria e retorna um objeto Time em vez de alterar o par\u00e2metro.","title":"16.3 - Modificadores"},{"location":"16-classes-funcoes/#164-prototipacao-versus-planejamento","text":"O plano de desenvolvimento que estou demonstrando chama-se \u201cprot\u00f3tipo e corre\u00e7\u00e3o\u201d. Para cada fun\u00e7\u00e3o, escrevi um prot\u00f3tipo que executa o c\u00e1lculo b\u00e1sico e ent\u00e3o testa a fun\u00e7\u00e3o, corrigindo erros no decorrer do caminho. Esta abordagem pode ser eficaz, especialmente se voc\u00ea ainda n\u00e3o tem uma compreens\u00e3o profunda do problema. Por\u00e9m, as corre\u00e7\u00f5es incrementais podem gerar c\u00f3digo que se complica desnecessariamente (pois trata de muitos casos especiais) e pouco confi\u00e1veis (j\u00e1 que \u00e9 dif\u00edcil saber se todos os erros foram encontrados). Uma alternativa \u00e9 o desenvolvimento planejado, no qual a compreens\u00e3o de alto n\u00edvel do problema pode facilitar muito a programa\u00e7\u00e3o. Neste caso, descobre-se que um objeto Time \u00e9, na verdade, um n\u00famero de tr\u00eas d\u00edgitos na base 60 (veja http://en.wikipedia.org/wiki/Sexagesimal)! O atributo second \u00e9 a \u201ccoluna de unidades\u201d, o atributo minute \u00e9 a \u201ccoluna dos 60\u201d, e o atributo hour \u00e9 a \u201ccoluna do 3.600\u201d. Quando escrevemos add_time e increment , est\u00e1vamos na verdade fazendo adi\u00e7\u00f5es na base 60, e por isso transport\u00e1vamos os resultados de uma coluna \u00e0 seguinte. Essa observa\u00e7\u00e3o sugere outra abordagem para o problema inteiro \u2013 podemos converter objetos Time em n\u00fameros inteiros e aproveitar o fato de que o computador sabe trabalhar com aritm\u00e9tica de n\u00fameros inteiros. Aqui est\u00e1 uma fun\u00e7\u00e3o que converte objetos Time em n\u00fameros inteiros: def time_to_int(time): minutes = time.hour * 60 + time.minute seconds = minutes * 60 + time.second return seconds E aqui est\u00e1 uma fun\u00e7\u00e3o que converte um n\u00famero inteiro em um Time (lembre-se de que divmod divide o primeiro argumento pelo segundo e devolve o quociente e o resto como uma tupla): def int_to_time(seconds): time = Time() minutes, time.second = divmod(seconds, 60) time.hour, time.minute = divmod(minutes, 60) return time Voc\u00ea pode ter que pensar um pouco e fazer alguns testes, para se convencer de que essas fun\u00e7\u00f5es est\u00e3o corretas. Um modo de test\u00e1-las \u00e9 ver se time_to_int(int_to_time(x)) == x para muitos valores de x . Este \u00e9 um exemplo de uma verifica\u00e7\u00e3o de consist\u00eancia. Uma vez que esteja convencido de que est\u00e3o corretas, voc\u00ea pode us\u00e1-las para reescrever add_time : def add_time(t1, t2): seconds = time_to_int(t1) + time_to_int(t2) return int_to_time(seconds) Esta vers\u00e3o \u00e9 mais curta que a original, e mais f\u00e1cil de verificar. Como exerc\u00edcio, reescreva increment usando time_to_int e int_to_time . Em algumas situa\u00e7\u00f5es, converter da base 60 para a base 10 e de volta \u00e9 mais dif\u00edcil que apenas lidar com as horas. A convers\u00e3o de base \u00e9 mais abstrata; nossa intui\u00e7\u00e3o para lidar com valores temporais \u00e9 melhor. No entanto, se tivermos discernimento para lidar com horas como n\u00fameros de base 60 e investirmos esfor\u00e7o em escrever as fun\u00e7\u00f5es de convers\u00e3o ( time_to_int e int_to_time ), chegamos a um programa que \u00e9 mais curto, mais f\u00e1cil de ler e depurar, e mais confi\u00e1vel. Tamb\u00e9m \u00e9 mais f\u00e1cil acrescentar recursos depois. Por exemplo, imagine subtrair dois objetos Time para encontrar a dura\u00e7\u00e3o entre eles. Uma abordagem ing\u00eanua seria implementar a subtra\u00e7\u00e3o com transporte. Por\u00e9m, usar fun\u00e7\u00f5es de convers\u00e3o seria mais f\u00e1cil e, provavelmente, mais correto. Ironicamente, tornar um problema mais dif\u00edcil (ou mais geral) facilita (porque h\u00e1 menos casos especiais e menos oportunidades de erro).","title":"16.4 - Prototipa\u00e7\u00e3o versus planejamento"},{"location":"16-classes-funcoes/#165-depuracao","text":"Um objeto Time \u00e9 bem formado se os valores de minute e second estiverem entre 0 e 60 (incluindo 0, mas n\u00e3o 60) e se hour for positivo. hour e minute devem ser valores inteiros, mas podemos permitir que second tenha uma parte fracion\u00e1ria. Requisitos como esses chamam-se invari\u00e1veis porque sempre devem ser verdadeiros. Para dizer de outra forma, se n\u00e3o forem verdadeiros, algo deu errado. Escrever c\u00f3digo para verificar requisitos invari\u00e1veis pode ajudar a descobrir erros e encontrar suas causas. Por exemplo, voc\u00ea pode ter uma fun\u00e7\u00e3o como valid_time, que receba um objeto Time e retorne False se ele violar um requisito invari\u00e1vel: def valid_time(time): if time.hour < 0 or time.minute < 0 or time.second < 0: return False if time.minute >= 60 or time.second >= 60: return False return True No in\u00edcio de cada fun\u00e7\u00e3o voc\u00ea pode verificar os argumentos para ter certeza de que s\u00e3o v\u00e1lidos: def add_time(t1, t2): if not valid_time(t1) or not valid_time(t2): raise ValueError('invalid Time object in add_time') seconds = time_to_int(t1) + time_to_int(t2) return int_to_time(seconds) Ou voc\u00ea pode usar uma instru\u00e7\u00e3o assert , que verifica determinado requisito invari\u00e1vel e cria uma exce\u00e7\u00e3o se ela falhar: def add_time(t1, t2): assert valid_time(t1) and valid_time(t2) seconds = time_to_int(t1) + time_to_int(t2) return int_to_time(seconds) Instru\u00e7\u00f5es assert s\u00e3o \u00fateis porque distinguem o c\u00f3digo que lida com condi\u00e7\u00f5es normais do c\u00f3digo que verifica erros.","title":"16.5 - Depura\u00e7\u00e3o"},{"location":"16-classes-funcoes/#166-glossario","text":"prot\u00f3tipo e corre\u00e7\u00e3o Plano de desenvolvimento no qual a escrita do programa parte de um esbo\u00e7o inicial, e depois segue ao teste e corre\u00e7\u00e3o de erros, conforme sejam encontrados. desenvolvimento planejado Plano de desenvolvimento que implica uma compreens\u00e3o de alto n\u00edvel do problema e mais planejamento que desenvolvimento incremental ou desenvolvimento prototipado. fun\u00e7\u00e3o pura Fun\u00e7\u00e3o que n\u00e3o altera nenhum dos objetos que recebe como argumento. A maior parte das fun\u00e7\u00f5es puras gera resultado. modificador Fun\u00e7\u00e3o que modifica um ou v\u00e1rios dos objetos que recebe como argumento. A maior parte dos modificadores s\u00e3o nulos; isto \u00e9, retornam None. programa\u00e7\u00e3o funcional Estilo de projeto de programa no qual a maioria das fun\u00e7\u00f5es s\u00e3o puras. invari\u00e1vel Condi\u00e7\u00e3o que sempre deve ser verdadeira durante a execu\u00e7\u00e3o de um programa. instru\u00e7\u00e3o assert Instru\u00e7\u00e3o que verifica uma condi\u00e7\u00e3o e levanta uma exce\u00e7\u00e3o se esta falhar.","title":"16.6 - Gloss\u00e1rio"},{"location":"16-classes-funcoes/#167-exercicios","text":"Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time1.py; as solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time1_soln.py.","title":"16.7 - Exerc\u00edcios"},{"location":"16-classes-funcoes/#exercicio-161","text":"Escreva uma fun\u00e7\u00e3o chamada mul_time que receba um objeto Time e um n\u00famero e retorne um novo objeto Time que contenha o produto do Time original e do n\u00famero. Ent\u00e3o use mul_time para escrever uma fun\u00e7\u00e3o que receba um objeto Time representando o tempo at\u00e9 o fim de uma corrida e um n\u00famero que represente a dist\u00e2ncia, e retorne um objeto Time com o passo m\u00e9dio (tempo por milha).","title":"Exerc\u00edcio 16.1"},{"location":"16-classes-funcoes/#exercicio-162","text":"O m\u00f3dulo datetime fornece objetos time que s\u00e3o semelhantes aos objetos Time deste cap\u00edtulo, mas ele oferece um grande conjunto de m\u00e9todos e operadores. Leia a documenta\u00e7\u00e3o em http://docs.python.org/3/library/datetime.html. Use o m\u00f3dulo datetime para escrever um programa que receba a data atual e exiba o dia da semana. Escreva um programa que receba um anivers\u00e1rio como entrada e exiba a idade do usu\u00e1rio e o n\u00famero de dias, horas, minutos e segundos at\u00e9 o seu pr\u00f3ximo anivers\u00e1rio. Para duas pessoas nascidas em dias diferentes, h\u00e1 um dia em que a idade de uma equivale a duas vezes a da outra. Este \u00e9 o Dia Duplo delas. Escreva um programa que receba dois anivers\u00e1rios e calcule o Dia Duplo dos aniversariantes. Para um desafio um pouco maior, escreva a vers\u00e3o mais geral que calcule o dia em que uma pessoa \u00e9 N vezes mais velha que a outra.","title":"Exerc\u00edcio 16.2"},{"location":"17-classes-metodos/","text":"Cap\u00edtulo 17: Classes e m\u00e9todos Embora estejamos usando alguns recursos de orienta\u00e7\u00e3o a objeto do Python, os programas dos dois \u00faltimos cap\u00edtulos n\u00e3o s\u00e3o realmente orientados a objeto, porque n\u00e3o representam as rela\u00e7\u00f5es entre os tipos definidos pelo programador e as fun\u00e7\u00f5es que os produzem. O pr\u00f3ximo passo \u00e9 transformar essas fun\u00e7\u00f5es em m\u00e9todos que tornem as rela\u00e7\u00f5es claras. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time2.py e as solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o em http://thinkpython2.com/code/Point2_soln.py. 17.1 - Recursos de orienta\u00e7\u00e3o a objeto Python \u00e9 uma linguagem de programa\u00e7\u00e3o orientada a objeto, ou seja, ela oferece recursos de programa\u00e7\u00e3o orientada a objeto que tem a seguintes caracter\u00edsticas: Os programas incluem defini\u00e7\u00f5es de classes e m\u00e9todos. A maior parte dos c\u00e1lculos \u00e9 expressa em termos de opera\u00e7\u00f5es em objetos. Os objetos muitas vezes representam coisas no mundo real, e os m\u00e9todos muitas vezes correspondem \u00e0s formas em que as coisas no mundo real interagem. Por exemplo, a classe Time definida no Cap\u00edtulo 16 corresponde \u00e0 forma como as pessoas registram a hora do dia, e as fun\u00e7\u00f5es que definimos correspondem aos tipos de coisas que as pessoas fazem com os hor\u00e1rios. De forma similar, as classes Point e Rectangle no Cap\u00edtulo 15 correspondem aos conceitos matem\u00e1ticos de ponto e ret\u00e2ngulo. Por enquanto, n\u00e3o aproveitamos os recursos que o Python oferece para programa\u00e7\u00e3o orientada a objeto. Esses recursos n\u00e3o s\u00e3o estritamente necess\u00e1rios; a maioria deles oferece uma sintaxe alternativa para coisas que j\u00e1 fizemos. No entanto, em muitos casos, a alternativa \u00e9 mais concisa e representa de forma mais exata a estrutura do programa. Por exemplo, em Time1.py n\u00e3o h\u00e1 nenhuma conex\u00e3o \u00f3bvia entre a defini\u00e7\u00e3o de classe e as defini\u00e7\u00f5es de fun\u00e7\u00e3o que seguem. Com um pouco de aten\u00e7\u00e3o, \u00e9 evidente que cada fun\u00e7\u00e3o recebe pelo menos um objeto Time como argumento. Essa observa\u00e7\u00e3o \u00e9 a motiva\u00e7\u00e3o para usar m\u00e9todos; um m\u00e9todo \u00e9 uma fun\u00e7\u00e3o associada a determinada classe. Vimos m\u00e9todos de string, listas, dicion\u00e1rios e tuplas. Neste cap\u00edtulo definiremos m\u00e9todos para tipos definidos pelo programador. M\u00e9todos s\u00e3o semanticamente o mesmo que fun\u00e7\u00f5es, mas h\u00e1 duas diferen\u00e7as sint\u00e1ticas: Os m\u00e9todos s\u00e3o definidos dentro de uma defini\u00e7\u00e3o de classe para tornar clara a rela\u00e7\u00e3o entre a classe e o m\u00e9todo. A sintaxe para invocar um m\u00e9todo \u00e9 diferente da sintaxe para chamar uma fun\u00e7\u00e3o. Nas pr\u00f3ximas se\u00e7\u00f5es tomaremos as fun\u00e7\u00f5es dos dois cap\u00edtulos anteriores e as transformaremos em m\u00e9todos. Essa transforma\u00e7\u00e3o \u00e9 puramente mec\u00e2nica; voc\u00ea pode faz\u00ea-la seguindo uma s\u00e9rie de passos. Se estiver \u00e0 vontade para fazer a convers\u00e3o entre uma forma e outra, sempre poder\u00e1 escolher a melhor forma para contemplar os seus objetivos. 17.2 - Exibi\u00e7\u00e3o de objetos No Cap\u00edtulo 16 definimos uma classe chamada Time em \u201cTime\u201d, na p\u00e1gina 231, e voc\u00ea escreveu uma fun\u00e7\u00e3o denominada print_time : class Time: \"\"\"Represents the time of day.\"\"\" def print_time(time): print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)) Para chamar esta fun\u00e7\u00e3o, voc\u00ea precisa passar um objeto Time como argumento: >>> start = Time() >>> start.hour = 9 >>> start.minute = 45 >>> start.second = 00 >>> print_time(start) 09:45:00 Para fazer de print_time um m\u00e9todo, tudo o que precisamos fazer \u00e9 mover a defini\u00e7\u00e3o da fun\u00e7\u00e3o para dentro da defini\u00e7\u00e3o da classe. Note a altera\u00e7\u00e3o na endenta\u00e7\u00e3o: class Time: def print_time(time): print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)) Agora h\u00e1 duas formas de chamar print_time . A primeira forma (e menos comum) \u00e9 usar a sintaxe de fun\u00e7\u00e3o: >>> Time.print_time(start) 09:45:00 Nesse uso da nota\u00e7\u00e3o de ponto, Time \u00e9 o nome da classe, e print_time \u00e9 o nome do m\u00e9todo. start \u00e9 passado como um par\u00e2metro. A segunda forma (e mais concisa) \u00e9 usar a sintaxe de m\u00e9todo: >>> start.print_time() 09:45:00 Nesse uso da nota\u00e7\u00e3o de ponto, print_time \u00e9 o nome do m\u00e9todo (novamente), e start \u00e9 o objeto no qual o m\u00e9todo \u00e9 invocado, que se chama de sujeito. Assim como em uma senten\u00e7a, onde o sujeito \u00e9 o foco da escrita, o sujeito de uma invoca\u00e7\u00e3o de m\u00e9todo \u00e9 o foco do m\u00e9todo. Dentro do m\u00e9todo, o sujeito \u00e9 atribu\u00eddo ao primeiro par\u00e2metro, portanto, neste caso, start \u00e9 atribu\u00eddo a time . Por conven\u00e7\u00e3o, o primeiro par\u00e2metro de um m\u00e9todo chama-se self , ent\u00e3o seria mais comum escrever print_time desta forma: class Time: def print_time(self): print('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)) A raz\u00e3o dessa conven\u00e7\u00e3o \u00e9 uma met\u00e1fora impl\u00edcita: A sintaxe de uma chamada de fun\u00e7\u00e3o, print_time(start) , sugere que a fun\u00e7\u00e3o \u00e9 o agente ativo. Ela diz algo como: \u201cEi, print_time ! Aqui est\u00e1 um objeto para voc\u00ea exibir\u201d. Na programa\u00e7\u00e3o orientada a objeto, os objetos s\u00e3o os agentes ativos. Uma invoca\u00e7\u00e3o de m\u00e9todo como start.print_time() diz: \u201cEi, start ! Por favor, exiba-se\u201d. Essa mudan\u00e7a de perspectiva pode ser mais polida, mas n\u00e3o \u00e9 \u00f3bvio que seja \u00fatil. Nos exemplos que vimos at\u00e9 agora, pode n\u00e3o ser. Por\u00e9m, \u00e0s vezes, deslocar a responsabilidade das fun\u00e7\u00f5es para os objetos permite escrever fun\u00e7\u00f5es (ou m\u00e9todos) mais vers\u00e1teis e facilita a manuten\u00e7\u00e3o e reutiliza\u00e7\u00e3o do c\u00f3digo. Como exerc\u00edcio, reescreva time_to_int (de \u201cPrototipa\u00e7\u00e3o versus planejamento\u201d, na p\u00e1gina 234) como um m\u00e9todo. Voc\u00ea pode ficar tentado a reescrever int_to_time como um m\u00e9todo tamb\u00e9m, mas isso n\u00e3o faz muito sentido porque n\u00e3o haveria nenhum objeto sobre o qual invoc\u00e1-lo. 17.3 - Outro exemplo Aqui est\u00e1 uma vers\u00e3o de increment (de \u201cModificadores\u201d, na p\u00e1gina 233) reescrita como m\u00e9todo: # dentro da classe Time: def increment(self, seconds): seconds += self.time_to_int() return int_to_time(seconds) Essa vers\u00e3o assume que time_to_int seja escrita como m\u00e9todo. Al\u00e9m disso, observe que \u00e9 uma fun\u00e7\u00e3o pura, n\u00e3o um modificador. \u00c9 assim que eu invocaria increment: >>> start.print_time() 09:45:00 >>> end = start.increment(1337) >>> end.print_time() 10:07:17 O sujeito, start, \u00e9 atribu\u00eddo ao primeiro par\u00e2metro, self. O argumento, 1337, \u00e9 atribu\u00eddo ao segundo par\u00e2metro, seconds. Esse mecanismo pode ser confuso, especialmente se voc\u00ea fizer um erro. Por exemplo, se invocar increment com dois argumentos, recebe: >>> end = start.increment(1337, 460) TypeError: increment() takes 2 positional arguments but 3 were given A mensagem de erro \u00e9 inicialmente confusa, porque h\u00e1 s\u00f3 dois argumentos entre par\u00eanteses. No entanto, o sujeito tamb\u00e9m \u00e9 considerado um argumento, ent\u00e3o, somando tudo, s\u00e3o tr\u00eas. A prop\u00f3sito, um argumento posicional \u00e9 o que n\u00e3o tem um nome de par\u00e2metro; isto \u00e9, n\u00e3o \u00e9 um argumento de palavra-chave. Nesta chamada da fun\u00e7\u00e3o: sketch(parrot, cage, dead=True) parrot e cage s\u00e3o posicionais, e dead \u00e9 um argumento de palavra-chave. 17.4 - Um exemplo mais complicado Reescrever is_after (de \u201cTime\u201d, na p\u00e1gina 231) \u00e9 ligeiramente mais complicado, porque ela recebe dois objetos Time como par\u00e2metros. Nesse caso, a conven\u00e7\u00e3o \u00e9 denominar o primeiro par\u00e2metro self e o segundo par\u00e2metro other: # dentro da classe Time: def is_after(self, other): return self.time_to_int() > other.time_to_int() Para usar este m\u00e9todo, voc\u00ea deve invoc\u00e1-lo para um objeto e passar outro como argumento: >>> end.is_after(start) True Uma vantagem desta sintaxe \u00e9 que \u00e9 quase literal em ingl\u00eas: \u201co fim \u00e9 depois da partida?\u201d. 17.5 - M\u00e9todo init O m\u00e9todo __init__ (abrevia\u00e7\u00e3o da palavra em ingl\u00eas para \u201cinicializa\u00e7\u00e3o\u201d) \u00e9 um m\u00e9todo especial, invocado quando um objeto \u00e9 instanciado. Seu nome completo \u00e9 __init__ (dois caracteres de sublinhado, seguidos de init, e mais dois sublinhados). Um m\u00e9todo __init__ da classe Time pode ser algo assim: # dentro da classe Time: def __init__(self, hour=0, minute=0, second=0): self.hour = hour self.minute = minute self.second = second \u00c9 comum que os par\u00e2metros de __init__ tenham os mesmos nomes que os atributos. A instru\u00e7\u00e3o self.hour = hour guarda o valor do par\u00e2metro hour como um atributo de self . Os par\u00e2metros s\u00e3o opcionais, ent\u00e3o, se voc\u00ea chamar Time sem argumentos, recebe os valores padr\u00e3o: >>> time = Time() >>> time.print_time() 00:00:00 Se incluir um argumento, ele define hour. >>> time = Time (9) >>> time.print_time() 09:00:00 Se fornecer dois argumentos, hour e minute ser\u00e3o definidos: >>> time = Time(9, 45) >>> time.print_time() 09:45:00 E se voc\u00ea fornecer tr\u00eas argumentos, os tr\u00eas valores ser\u00e3o definidos. Como exerc\u00edcio, escreva um m\u00e9todo init da classe Point que receba x e y como par\u00e2metros opcionais e os relacione aos atributos correspondentes. 17.6 - M\u00e9todo __str__ __str__ \u00e9 um m\u00e9todo especial, como __init__ , usado para retornar uma representa\u00e7\u00e3o de string de um objeto. Por exemplo, aqui est\u00e1 um m\u00e9todo str para objetos Time: # dentro da classe Time: def __str__(self): return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second) Ao exibir um objeto com print, o Python invoca o m\u00e9todo str: >>> time = Time(9, 45) >>> print(time) 09:45:00 Quando escrevo uma nova classe, quase sempre come\u00e7o escrevendo __init__ , o que facilita a instancia\u00e7\u00e3o de objetos, e __str__ , que \u00e9 \u00fatil para a depura\u00e7\u00e3o. Como exerc\u00edcio, escreva um m\u00e9todo str da classe Point. Crie um objeto Point e exiba-o. 17.7 - Sobrecarga de operadores Ao definir outros m\u00e9todos especiais, voc\u00ea pode especificar o comportamento de operadores nos tipos definidos pelo programador. Por exemplo, se voc\u00ea definir um m\u00e9todo chamado __add__ para a classe Time de Time, pode usar o operador + em objetos Time. A defini\u00e7\u00e3o pode ser assim: # dentro da classe Time: def __add__(self, other): seconds = self.time_to_int() + other.time_to_int() return int_to_time(seconds) Voc\u00ea pode us\u00e1-lo assim: >>> start = Time(9, 45) >>> duration = Time(1, 35) >>> print(start + duration) 11:20:00 Ao aplicar o operador + a objetos Time, o Python invoca __add__ . Ao exibir o resultado, o Python invoca __str__ . Ou seja, h\u00e1 muita coisa acontecendo nos bastidores! Alterar o comportamento de um operador para que funcione com tipos definidos pelo programador chama-se sobrecarga de operadores. Para cada operador no Python h\u00e1 um m\u00e9todo especial correspondente, como __add__ . Para obter mais informa\u00e7\u00f5es, veja http://docs.python.org/3/reference/datamodel.html#specialnames. Como exerc\u00edcio, escreva um m\u00e9todo add para a classe Point. 17.8 - Despacho por tipo Na se\u00e7\u00e3o anterior, acrescentamos dois objetos Time, mas voc\u00ea tamb\u00e9m pode querer acrescentar um n\u00famero inteiro a um objeto Time. A seguir, veja uma vers\u00e3o de __add__ , que verifica o tipo de other e invoca add_time ou increment: # dentro da classe Time: def __add__(self, other): if isinstance(other, Time): return self.add_time(other) else: return self.increment(other) def add_time(self, other): seconds = self.time_to_int() + other.time_to_int() return int_to_time(seconds) def increment(self, seconds): seconds += self.time_to_int() return int_to_time(seconds) A fun\u00e7\u00e3o constru\u00edda isinstance recebe um valor e um objeto de classe e retorna True se o valor for uma inst\u00e2ncia da classe. Se other for um objeto Time, __add__ invoca add_time . Do contr\u00e1rio, assume que o par\u00e2metro seja um n\u00famero e invoca increment. Essa opera\u00e7\u00e3o chama-se despacho por tipo porque despacha a opera\u00e7\u00e3o a m\u00e9todos diferentes, baseados no tipo dos argumentos. Veja exemplos que usam o operador + com tipos diferentes: >>> start = Time(9, 45) >>> duration = Time(1, 35) >>> print(start + duration) 11:20:00 >>> print(start + 1337) 10:07:17 Infelizmente, esta implementa\u00e7\u00e3o da adi\u00e7\u00e3o n\u00e3o \u00e9 comutativa. Se o n\u00famero inteiro for o primeiro operando, voc\u00ea recebe >>> print(1337 + start) TypeError: unsupported operand type(s) for +: 'int' and 'instance' O problema \u00e9 que, em vez de pedir ao objeto Time que adicione um n\u00famero inteiro, o Python est\u00e1 pedindo que um n\u00famero inteiro adicione um objeto Time, e ele n\u00e3o sabe como fazer isso. Entretanto, h\u00e1 uma solu\u00e7\u00e3o inteligente para este problema: o m\u00e9todo especial __radd__ , que significa \u201cadi\u00e7\u00e3o \u00e0 direita\u201d. Esse m\u00e9todo \u00e9 invocado quando um objeto Time aparece no lado direito do operador +. Aqui est\u00e1 a defini\u00e7\u00e3o: # dentro da classe Time: def __radd__(self, other): return self.__add__(other) E \u00e9 assim que ele \u00e9 usado: >>> print(1337 + start) 10:07:17 Como exerc\u00edcio, escreva um m\u00e9todo add para Points que funcione com um objeto Point ou com uma tupla: Se o segundo operando for um Point, o m\u00e9todo deve retornar um novo Point cuja coordenada x \u00e9 a soma das coordenadas x dos operandos, e o mesmo se aplica \u00e0s coordenadas de y. Se o segundo operando for uma tupla, o m\u00e9todo deve adicionar o primeiro elemento da tupla \u00e0 coordenada de x e o segundo elemento \u00e0 coordenada de y, retornando um novo Point com o resultado. 17.9 - Polimorfismo O despacho por tipo \u00e9 \u00fatil, mas (felizmente) nem sempre \u00e9 necess\u00e1rio. Muitas vezes, voc\u00ea pode evit\u00e1-lo escrevendo fun\u00e7\u00f5es que funcionem corretamente para argumentos de tipos diferentes. Muitas das fun\u00e7\u00f5es que escrevemos para strings tamb\u00e9m funcionam para outros tipos de sequ\u00eancia. Por exemplo, em \u201cUm dicion\u00e1rio como uma cole\u00e7\u00e3o de contadores\u201d, na p\u00e1gina 163, usamos histogram para contar o n\u00famero de vezes que cada letra aparece numa palavra: def histogram(s): d = dict() for c in s: if c not in d: d[c] = 1 else: d[c] = d[c] + 1 return d Essa fun\u00e7\u00e3o tamb\u00e9m funciona com listas, tuplas e at\u00e9 dicion\u00e1rios, desde que os elementos de s sejam hashable, ent\u00e3o eles podem ser usados como chaves em d: >>> t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam'] >>> histogram(t) {'bacon': 1, 'egg': 1, 'spam': 4} As fun\u00e7\u00f5es que funcionam com v\u00e1rios tipos chamam-se polim\u00f3rficas. O polimorfismo pode facilitar a reutiliza\u00e7\u00e3o do c\u00f3digo. Por exemplo, a fun\u00e7\u00e3o integrada sum, que adiciona os elementos de uma sequ\u00eancia, funciona s\u00f3 se os elementos da sequ\u00eancia forem compat\u00edveis com adi\u00e7\u00e3o. Como os objetos Time oferecem o m\u00e9todo add, eles funcionam com sum: >>> t1 = Time(7, 43) >>> t2 = Time(7, 41) >>> t3 = Time(7, 37) >>> total = sum([t1, t2, t3]) >>> print(total) 23:01:00 Em geral, se todas as opera\u00e7\u00f5es dentro de uma fun\u00e7\u00e3o forem compat\u00edveis com um dado tipo, n\u00e3o haver\u00e1 problemas. O melhor tipo de polimorfismo \u00e9 o n\u00e3o intencional, quando voc\u00ea descobre que uma fun\u00e7\u00e3o que j\u00e1 escreveu pode ser aplicada a um tipo para o qual ela n\u00e3o tinha planejada. 17.10 - Interface e implementa\u00e7\u00e3o Uma das metas do projeto orientado a objeto \u00e9 facilitar a manuten\u00e7\u00e3o do programa, para que voc\u00ea possa mant\u00ea-lo funcionando quando outras partes do sistema forem alteradas, e tamb\u00e9m poder alterar o programa para satisfazer novas condi\u00e7\u00f5es. Um princ\u00edpio de projeto que ajuda a atingir essa meta \u00e9 manter as interfaces separadas das implementa\u00e7\u00f5es. Para objetos, isso quer dizer que os m\u00e9todos que uma classe oferece n\u00e3o devem depender de como os atributos s\u00e3o representados. Por exemplo, neste cap\u00edtulo desenvolvemos uma classe que representa uma hora do dia. Os m\u00e9todos fornecidos por esta classe incluem time_to_int, is_after e add_time. Podemos implementar esses m\u00e9todos de v\u00e1rias formas. Os detalhes da implementa\u00e7\u00e3o dependem de como representamos as horas. Neste cap\u00edtulo, os atributos de um objeto Time s\u00e3o hour, minute e second. Como alternativa, podemos substituir esses atributos por um n\u00famero inteiro \u00fanico que represente o n\u00famero de segundos desde a meia-noite. Essa implementa\u00e7\u00e3o faria com que alguns m\u00e9todos, como is_after, fossem mais f\u00e1ceis de escrever, mas dificultaria o uso de outros m\u00e9todos. Pode acontecer que, depois de implementar uma nova classe, voc\u00ea descubra uma implementa\u00e7\u00e3o melhor. Se outras partes do programa estiverem usando a sua classe, mudar a interface pode ser trabalhoso e induzir a erros. No entanto, se projetou a interface cuidadosamente, pode alterar a implementa\u00e7\u00e3o sem mudar a interface, e n\u00e3o ser\u00e1 preciso mudar outras partes do programa. 17.11 - Depura\u00e7\u00e3o \u00c9 legal acrescentar atributos a objetos em qualquer ponto da execu\u00e7\u00e3o de um programa, mas se voc\u00ea tiver objetos do mesmo tipo que n\u00e3o t\u00eam os mesmos atributos, \u00e9 f\u00e1cil cometer erros. \u00c9 uma boa ideia inicializar todos os atributos de um objeto no m\u00e9todo init. Caso n\u00e3o tenha certeza se um objeto tem um determinado atributo, voc\u00ea pode usar a fun\u00e7\u00e3o integrada hasattr (ver \u201cDepura\u00e7\u00e3o\u201d, na p\u00e1gina 236). Outra forma de acessar atributos \u00e9 com a fun\u00e7\u00e3o integrada vars, que recebe um objeto e retorna um dicion\u00e1rio que mapeia os nomes dos atributos (como strings) aos seus valores: >>> p = Point(3, 4) >>> vars(p) {'y': 4, 'x': 3} Para facilitar a depura\u00e7\u00e3o, pode ser \u00fatil usar esta fun\u00e7\u00e3o: def print_attributes(obj): for attr in vars(obj): print(attr, getattr(obj, attr)) print_attributes atravessa o dicion\u00e1rio e imprime cada nome de atributo e o seu valor correspondente. A fun\u00e7\u00e3o integrada getattr recebe um objeto e um nome de atributo (como uma string) e devolve o valor do atributo. 17.12 - Gloss\u00e1rio linguagem orientada a objeto Linguagem que fornece recursos, como tipos definidos pelo programador e m\u00e9todos, que facilitam a programa\u00e7\u00e3o orientada a objeto. programa\u00e7\u00e3o orientada a objeto Estilo de programa\u00e7\u00e3o na qual os dados e as opera\u00e7\u00f5es que os manipulam s\u00e3o organizadas em classes e m\u00e9todos. m\u00e9todo Fun\u00e7\u00e3o criada dentro de uma defini\u00e7\u00e3o de classe e invocada em inst\u00e2ncias desta classe. sujeito Objeto sobre o qual um m\u00e9todo \u00e9 invocado. argumento posicional Argumento que n\u00e3o inclui um nome de par\u00e2metro, portanto n\u00e3o \u00e9 um argumento de palavra-chave. sobrecarga de operador Altera\u00e7\u00e3o do comportamento de um operador como + para que funcione com um tipo definido pelo programador. despacho por tipo Modelo de programa\u00e7\u00e3o que invoca fun\u00e7\u00f5es diferentes dependendo do tipo do operando. polim\u00f3rfico Pertinente a uma fun\u00e7\u00e3o que pode funcionar com mais de um tipo. ocultamento de informa\u00e7\u00e3o Princ\u00edpio segundo o qual a interface fornecida por um objeto n\u00e3o deve depender da sua implementa\u00e7\u00e3o, especialmente em rela\u00e7\u00e3o \u00e0 representa\u00e7\u00e3o dos seus atributos. 17.13 - Exerc\u00edcios Exerc\u00edcio 17.1 Baixe o c\u00f3digo deste cap\u00edtulo em http://thinkpython2.com/code/Time2.py. Altere os atributos de Time para que um n\u00famero inteiro \u00fanico represente os segundos decorridos desde a meia-noite. Ent\u00e3o altere os m\u00e9todos (e a fun\u00e7\u00e3o int_to_time) para funcionar com a nova implementa\u00e7\u00e3o. Voc\u00ea n\u00e3o deve modificar o c\u00f3digo de teste em main. Ao terminar, a sa\u00edda deve ser a mesma que antes. Solu\u00e7\u00e3o: http://thinkpython2.com/code/Time2_soln.py. Exerc\u00edcio 17.2 Este exerc\u00edcio \u00e9 uma hist\u00f3ria com moral sobre um dos erros mais comuns e dif\u00edceis de encontrar no Python. Escreva uma defini\u00e7\u00e3o de classe chamada Kangaroo com os seguintes m\u00e9todos: Um m\u00e9todo __init__ que inicialize um atributo chamado pouch_contents em uma lista vazia. Um m\u00e9todo chamado put_in_pouch que receba um objeto de qualquer tipo e o acrescente a pouch_contents . Um m\u00e9todo __str__ que retorne uma representa\u00e7\u00e3o de string do objeto Kangaroo e os conte\u00fados de pouch (bolsa). Teste o seu c\u00f3digo criando dois objetos Kangaroo, atribuindo-os a vari\u00e1veis chamadas kanga e roo, e ent\u00e3o acrescentando roo ao conte\u00fado da bolsa de kanga. Baixe http://thinkpython2.com/code/BadKangaroo.py. Ele cont\u00e9m uma solu\u00e7\u00e3o para o problema anterior com um defeito bem grande e bem feio. Encontre e corrija o defeito. Se n\u00e3o conseguir achar a solu\u00e7\u00e3o, voc\u00ea pode baixar http://thinkpython2.com/code/GoodKangaroo.py, que explica o problema e demonstra uma solu\u00e7\u00e3o.","title":"Cap\u00edtulo 17: Classes e m\u00e9todos"},{"location":"17-classes-metodos/#capitulo-17-classes-e-metodos","text":"Embora estejamos usando alguns recursos de orienta\u00e7\u00e3o a objeto do Python, os programas dos dois \u00faltimos cap\u00edtulos n\u00e3o s\u00e3o realmente orientados a objeto, porque n\u00e3o representam as rela\u00e7\u00f5es entre os tipos definidos pelo programador e as fun\u00e7\u00f5es que os produzem. O pr\u00f3ximo passo \u00e9 transformar essas fun\u00e7\u00f5es em m\u00e9todos que tornem as rela\u00e7\u00f5es claras. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Time2.py e as solu\u00e7\u00f5es para os exerc\u00edcios est\u00e3o em http://thinkpython2.com/code/Point2_soln.py.","title":"Cap\u00edtulo 17: Classes e m\u00e9todos"},{"location":"17-classes-metodos/#171-recursos-de-orientacao-a-objeto","text":"Python \u00e9 uma linguagem de programa\u00e7\u00e3o orientada a objeto, ou seja, ela oferece recursos de programa\u00e7\u00e3o orientada a objeto que tem a seguintes caracter\u00edsticas: Os programas incluem defini\u00e7\u00f5es de classes e m\u00e9todos. A maior parte dos c\u00e1lculos \u00e9 expressa em termos de opera\u00e7\u00f5es em objetos. Os objetos muitas vezes representam coisas no mundo real, e os m\u00e9todos muitas vezes correspondem \u00e0s formas em que as coisas no mundo real interagem. Por exemplo, a classe Time definida no Cap\u00edtulo 16 corresponde \u00e0 forma como as pessoas registram a hora do dia, e as fun\u00e7\u00f5es que definimos correspondem aos tipos de coisas que as pessoas fazem com os hor\u00e1rios. De forma similar, as classes Point e Rectangle no Cap\u00edtulo 15 correspondem aos conceitos matem\u00e1ticos de ponto e ret\u00e2ngulo. Por enquanto, n\u00e3o aproveitamos os recursos que o Python oferece para programa\u00e7\u00e3o orientada a objeto. Esses recursos n\u00e3o s\u00e3o estritamente necess\u00e1rios; a maioria deles oferece uma sintaxe alternativa para coisas que j\u00e1 fizemos. No entanto, em muitos casos, a alternativa \u00e9 mais concisa e representa de forma mais exata a estrutura do programa. Por exemplo, em Time1.py n\u00e3o h\u00e1 nenhuma conex\u00e3o \u00f3bvia entre a defini\u00e7\u00e3o de classe e as defini\u00e7\u00f5es de fun\u00e7\u00e3o que seguem. Com um pouco de aten\u00e7\u00e3o, \u00e9 evidente que cada fun\u00e7\u00e3o recebe pelo menos um objeto Time como argumento. Essa observa\u00e7\u00e3o \u00e9 a motiva\u00e7\u00e3o para usar m\u00e9todos; um m\u00e9todo \u00e9 uma fun\u00e7\u00e3o associada a determinada classe. Vimos m\u00e9todos de string, listas, dicion\u00e1rios e tuplas. Neste cap\u00edtulo definiremos m\u00e9todos para tipos definidos pelo programador. M\u00e9todos s\u00e3o semanticamente o mesmo que fun\u00e7\u00f5es, mas h\u00e1 duas diferen\u00e7as sint\u00e1ticas: Os m\u00e9todos s\u00e3o definidos dentro de uma defini\u00e7\u00e3o de classe para tornar clara a rela\u00e7\u00e3o entre a classe e o m\u00e9todo. A sintaxe para invocar um m\u00e9todo \u00e9 diferente da sintaxe para chamar uma fun\u00e7\u00e3o. Nas pr\u00f3ximas se\u00e7\u00f5es tomaremos as fun\u00e7\u00f5es dos dois cap\u00edtulos anteriores e as transformaremos em m\u00e9todos. Essa transforma\u00e7\u00e3o \u00e9 puramente mec\u00e2nica; voc\u00ea pode faz\u00ea-la seguindo uma s\u00e9rie de passos. Se estiver \u00e0 vontade para fazer a convers\u00e3o entre uma forma e outra, sempre poder\u00e1 escolher a melhor forma para contemplar os seus objetivos.","title":"17.1 - Recursos de orienta\u00e7\u00e3o a objeto"},{"location":"17-classes-metodos/#172-exibicao-de-objetos","text":"No Cap\u00edtulo 16 definimos uma classe chamada Time em \u201cTime\u201d, na p\u00e1gina 231, e voc\u00ea escreveu uma fun\u00e7\u00e3o denominada print_time : class Time: \"\"\"Represents the time of day.\"\"\" def print_time(time): print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)) Para chamar esta fun\u00e7\u00e3o, voc\u00ea precisa passar um objeto Time como argumento: >>> start = Time() >>> start.hour = 9 >>> start.minute = 45 >>> start.second = 00 >>> print_time(start) 09:45:00 Para fazer de print_time um m\u00e9todo, tudo o que precisamos fazer \u00e9 mover a defini\u00e7\u00e3o da fun\u00e7\u00e3o para dentro da defini\u00e7\u00e3o da classe. Note a altera\u00e7\u00e3o na endenta\u00e7\u00e3o: class Time: def print_time(time): print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second)) Agora h\u00e1 duas formas de chamar print_time . A primeira forma (e menos comum) \u00e9 usar a sintaxe de fun\u00e7\u00e3o: >>> Time.print_time(start) 09:45:00 Nesse uso da nota\u00e7\u00e3o de ponto, Time \u00e9 o nome da classe, e print_time \u00e9 o nome do m\u00e9todo. start \u00e9 passado como um par\u00e2metro. A segunda forma (e mais concisa) \u00e9 usar a sintaxe de m\u00e9todo: >>> start.print_time() 09:45:00 Nesse uso da nota\u00e7\u00e3o de ponto, print_time \u00e9 o nome do m\u00e9todo (novamente), e start \u00e9 o objeto no qual o m\u00e9todo \u00e9 invocado, que se chama de sujeito. Assim como em uma senten\u00e7a, onde o sujeito \u00e9 o foco da escrita, o sujeito de uma invoca\u00e7\u00e3o de m\u00e9todo \u00e9 o foco do m\u00e9todo. Dentro do m\u00e9todo, o sujeito \u00e9 atribu\u00eddo ao primeiro par\u00e2metro, portanto, neste caso, start \u00e9 atribu\u00eddo a time . Por conven\u00e7\u00e3o, o primeiro par\u00e2metro de um m\u00e9todo chama-se self , ent\u00e3o seria mais comum escrever print_time desta forma: class Time: def print_time(self): print('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)) A raz\u00e3o dessa conven\u00e7\u00e3o \u00e9 uma met\u00e1fora impl\u00edcita: A sintaxe de uma chamada de fun\u00e7\u00e3o, print_time(start) , sugere que a fun\u00e7\u00e3o \u00e9 o agente ativo. Ela diz algo como: \u201cEi, print_time ! Aqui est\u00e1 um objeto para voc\u00ea exibir\u201d. Na programa\u00e7\u00e3o orientada a objeto, os objetos s\u00e3o os agentes ativos. Uma invoca\u00e7\u00e3o de m\u00e9todo como start.print_time() diz: \u201cEi, start ! Por favor, exiba-se\u201d. Essa mudan\u00e7a de perspectiva pode ser mais polida, mas n\u00e3o \u00e9 \u00f3bvio que seja \u00fatil. Nos exemplos que vimos at\u00e9 agora, pode n\u00e3o ser. Por\u00e9m, \u00e0s vezes, deslocar a responsabilidade das fun\u00e7\u00f5es para os objetos permite escrever fun\u00e7\u00f5es (ou m\u00e9todos) mais vers\u00e1teis e facilita a manuten\u00e7\u00e3o e reutiliza\u00e7\u00e3o do c\u00f3digo. Como exerc\u00edcio, reescreva time_to_int (de \u201cPrototipa\u00e7\u00e3o versus planejamento\u201d, na p\u00e1gina 234) como um m\u00e9todo. Voc\u00ea pode ficar tentado a reescrever int_to_time como um m\u00e9todo tamb\u00e9m, mas isso n\u00e3o faz muito sentido porque n\u00e3o haveria nenhum objeto sobre o qual invoc\u00e1-lo.","title":"17.2 - Exibi\u00e7\u00e3o de objetos"},{"location":"17-classes-metodos/#173-outro-exemplo","text":"Aqui est\u00e1 uma vers\u00e3o de increment (de \u201cModificadores\u201d, na p\u00e1gina 233) reescrita como m\u00e9todo: # dentro da classe Time: def increment(self, seconds): seconds += self.time_to_int() return int_to_time(seconds) Essa vers\u00e3o assume que time_to_int seja escrita como m\u00e9todo. Al\u00e9m disso, observe que \u00e9 uma fun\u00e7\u00e3o pura, n\u00e3o um modificador. \u00c9 assim que eu invocaria increment: >>> start.print_time() 09:45:00 >>> end = start.increment(1337) >>> end.print_time() 10:07:17 O sujeito, start, \u00e9 atribu\u00eddo ao primeiro par\u00e2metro, self. O argumento, 1337, \u00e9 atribu\u00eddo ao segundo par\u00e2metro, seconds. Esse mecanismo pode ser confuso, especialmente se voc\u00ea fizer um erro. Por exemplo, se invocar increment com dois argumentos, recebe: >>> end = start.increment(1337, 460) TypeError: increment() takes 2 positional arguments but 3 were given A mensagem de erro \u00e9 inicialmente confusa, porque h\u00e1 s\u00f3 dois argumentos entre par\u00eanteses. No entanto, o sujeito tamb\u00e9m \u00e9 considerado um argumento, ent\u00e3o, somando tudo, s\u00e3o tr\u00eas. A prop\u00f3sito, um argumento posicional \u00e9 o que n\u00e3o tem um nome de par\u00e2metro; isto \u00e9, n\u00e3o \u00e9 um argumento de palavra-chave. Nesta chamada da fun\u00e7\u00e3o: sketch(parrot, cage, dead=True) parrot e cage s\u00e3o posicionais, e dead \u00e9 um argumento de palavra-chave.","title":"17.3 - Outro exemplo"},{"location":"17-classes-metodos/#174-um-exemplo-mais-complicado","text":"Reescrever is_after (de \u201cTime\u201d, na p\u00e1gina 231) \u00e9 ligeiramente mais complicado, porque ela recebe dois objetos Time como par\u00e2metros. Nesse caso, a conven\u00e7\u00e3o \u00e9 denominar o primeiro par\u00e2metro self e o segundo par\u00e2metro other: # dentro da classe Time: def is_after(self, other): return self.time_to_int() > other.time_to_int() Para usar este m\u00e9todo, voc\u00ea deve invoc\u00e1-lo para um objeto e passar outro como argumento: >>> end.is_after(start) True Uma vantagem desta sintaxe \u00e9 que \u00e9 quase literal em ingl\u00eas: \u201co fim \u00e9 depois da partida?\u201d.","title":"17.4 - Um exemplo mais complicado"},{"location":"17-classes-metodos/#175-metodo-init","text":"O m\u00e9todo __init__ (abrevia\u00e7\u00e3o da palavra em ingl\u00eas para \u201cinicializa\u00e7\u00e3o\u201d) \u00e9 um m\u00e9todo especial, invocado quando um objeto \u00e9 instanciado. Seu nome completo \u00e9 __init__ (dois caracteres de sublinhado, seguidos de init, e mais dois sublinhados). Um m\u00e9todo __init__ da classe Time pode ser algo assim: # dentro da classe Time: def __init__(self, hour=0, minute=0, second=0): self.hour = hour self.minute = minute self.second = second \u00c9 comum que os par\u00e2metros de __init__ tenham os mesmos nomes que os atributos. A instru\u00e7\u00e3o self.hour = hour guarda o valor do par\u00e2metro hour como um atributo de self . Os par\u00e2metros s\u00e3o opcionais, ent\u00e3o, se voc\u00ea chamar Time sem argumentos, recebe os valores padr\u00e3o: >>> time = Time() >>> time.print_time() 00:00:00 Se incluir um argumento, ele define hour. >>> time = Time (9) >>> time.print_time() 09:00:00 Se fornecer dois argumentos, hour e minute ser\u00e3o definidos: >>> time = Time(9, 45) >>> time.print_time() 09:45:00 E se voc\u00ea fornecer tr\u00eas argumentos, os tr\u00eas valores ser\u00e3o definidos. Como exerc\u00edcio, escreva um m\u00e9todo init da classe Point que receba x e y como par\u00e2metros opcionais e os relacione aos atributos correspondentes.","title":"17.5 - M\u00e9todo init"},{"location":"17-classes-metodos/#176-metodo-__str__","text":"__str__ \u00e9 um m\u00e9todo especial, como __init__ , usado para retornar uma representa\u00e7\u00e3o de string de um objeto. Por exemplo, aqui est\u00e1 um m\u00e9todo str para objetos Time: # dentro da classe Time: def __str__(self): return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second) Ao exibir um objeto com print, o Python invoca o m\u00e9todo str: >>> time = Time(9, 45) >>> print(time) 09:45:00 Quando escrevo uma nova classe, quase sempre come\u00e7o escrevendo __init__ , o que facilita a instancia\u00e7\u00e3o de objetos, e __str__ , que \u00e9 \u00fatil para a depura\u00e7\u00e3o. Como exerc\u00edcio, escreva um m\u00e9todo str da classe Point. Crie um objeto Point e exiba-o.","title":"17.6 - M\u00e9todo __str__"},{"location":"17-classes-metodos/#177-sobrecarga-de-operadores","text":"Ao definir outros m\u00e9todos especiais, voc\u00ea pode especificar o comportamento de operadores nos tipos definidos pelo programador. Por exemplo, se voc\u00ea definir um m\u00e9todo chamado __add__ para a classe Time de Time, pode usar o operador + em objetos Time. A defini\u00e7\u00e3o pode ser assim: # dentro da classe Time: def __add__(self, other): seconds = self.time_to_int() + other.time_to_int() return int_to_time(seconds) Voc\u00ea pode us\u00e1-lo assim: >>> start = Time(9, 45) >>> duration = Time(1, 35) >>> print(start + duration) 11:20:00 Ao aplicar o operador + a objetos Time, o Python invoca __add__ . Ao exibir o resultado, o Python invoca __str__ . Ou seja, h\u00e1 muita coisa acontecendo nos bastidores! Alterar o comportamento de um operador para que funcione com tipos definidos pelo programador chama-se sobrecarga de operadores. Para cada operador no Python h\u00e1 um m\u00e9todo especial correspondente, como __add__ . Para obter mais informa\u00e7\u00f5es, veja http://docs.python.org/3/reference/datamodel.html#specialnames. Como exerc\u00edcio, escreva um m\u00e9todo add para a classe Point.","title":"17.7 - Sobrecarga de operadores"},{"location":"17-classes-metodos/#178-despacho-por-tipo","text":"Na se\u00e7\u00e3o anterior, acrescentamos dois objetos Time, mas voc\u00ea tamb\u00e9m pode querer acrescentar um n\u00famero inteiro a um objeto Time. A seguir, veja uma vers\u00e3o de __add__ , que verifica o tipo de other e invoca add_time ou increment: # dentro da classe Time: def __add__(self, other): if isinstance(other, Time): return self.add_time(other) else: return self.increment(other) def add_time(self, other): seconds = self.time_to_int() + other.time_to_int() return int_to_time(seconds) def increment(self, seconds): seconds += self.time_to_int() return int_to_time(seconds) A fun\u00e7\u00e3o constru\u00edda isinstance recebe um valor e um objeto de classe e retorna True se o valor for uma inst\u00e2ncia da classe. Se other for um objeto Time, __add__ invoca add_time . Do contr\u00e1rio, assume que o par\u00e2metro seja um n\u00famero e invoca increment. Essa opera\u00e7\u00e3o chama-se despacho por tipo porque despacha a opera\u00e7\u00e3o a m\u00e9todos diferentes, baseados no tipo dos argumentos. Veja exemplos que usam o operador + com tipos diferentes: >>> start = Time(9, 45) >>> duration = Time(1, 35) >>> print(start + duration) 11:20:00 >>> print(start + 1337) 10:07:17 Infelizmente, esta implementa\u00e7\u00e3o da adi\u00e7\u00e3o n\u00e3o \u00e9 comutativa. Se o n\u00famero inteiro for o primeiro operando, voc\u00ea recebe >>> print(1337 + start) TypeError: unsupported operand type(s) for +: 'int' and 'instance' O problema \u00e9 que, em vez de pedir ao objeto Time que adicione um n\u00famero inteiro, o Python est\u00e1 pedindo que um n\u00famero inteiro adicione um objeto Time, e ele n\u00e3o sabe como fazer isso. Entretanto, h\u00e1 uma solu\u00e7\u00e3o inteligente para este problema: o m\u00e9todo especial __radd__ , que significa \u201cadi\u00e7\u00e3o \u00e0 direita\u201d. Esse m\u00e9todo \u00e9 invocado quando um objeto Time aparece no lado direito do operador +. Aqui est\u00e1 a defini\u00e7\u00e3o: # dentro da classe Time: def __radd__(self, other): return self.__add__(other) E \u00e9 assim que ele \u00e9 usado: >>> print(1337 + start) 10:07:17 Como exerc\u00edcio, escreva um m\u00e9todo add para Points que funcione com um objeto Point ou com uma tupla: Se o segundo operando for um Point, o m\u00e9todo deve retornar um novo Point cuja coordenada x \u00e9 a soma das coordenadas x dos operandos, e o mesmo se aplica \u00e0s coordenadas de y. Se o segundo operando for uma tupla, o m\u00e9todo deve adicionar o primeiro elemento da tupla \u00e0 coordenada de x e o segundo elemento \u00e0 coordenada de y, retornando um novo Point com o resultado.","title":"17.8 - Despacho por tipo"},{"location":"17-classes-metodos/#179-polimorfismo","text":"O despacho por tipo \u00e9 \u00fatil, mas (felizmente) nem sempre \u00e9 necess\u00e1rio. Muitas vezes, voc\u00ea pode evit\u00e1-lo escrevendo fun\u00e7\u00f5es que funcionem corretamente para argumentos de tipos diferentes. Muitas das fun\u00e7\u00f5es que escrevemos para strings tamb\u00e9m funcionam para outros tipos de sequ\u00eancia. Por exemplo, em \u201cUm dicion\u00e1rio como uma cole\u00e7\u00e3o de contadores\u201d, na p\u00e1gina 163, usamos histogram para contar o n\u00famero de vezes que cada letra aparece numa palavra: def histogram(s): d = dict() for c in s: if c not in d: d[c] = 1 else: d[c] = d[c] + 1 return d Essa fun\u00e7\u00e3o tamb\u00e9m funciona com listas, tuplas e at\u00e9 dicion\u00e1rios, desde que os elementos de s sejam hashable, ent\u00e3o eles podem ser usados como chaves em d: >>> t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam'] >>> histogram(t) {'bacon': 1, 'egg': 1, 'spam': 4} As fun\u00e7\u00f5es que funcionam com v\u00e1rios tipos chamam-se polim\u00f3rficas. O polimorfismo pode facilitar a reutiliza\u00e7\u00e3o do c\u00f3digo. Por exemplo, a fun\u00e7\u00e3o integrada sum, que adiciona os elementos de uma sequ\u00eancia, funciona s\u00f3 se os elementos da sequ\u00eancia forem compat\u00edveis com adi\u00e7\u00e3o. Como os objetos Time oferecem o m\u00e9todo add, eles funcionam com sum: >>> t1 = Time(7, 43) >>> t2 = Time(7, 41) >>> t3 = Time(7, 37) >>> total = sum([t1, t2, t3]) >>> print(total) 23:01:00 Em geral, se todas as opera\u00e7\u00f5es dentro de uma fun\u00e7\u00e3o forem compat\u00edveis com um dado tipo, n\u00e3o haver\u00e1 problemas. O melhor tipo de polimorfismo \u00e9 o n\u00e3o intencional, quando voc\u00ea descobre que uma fun\u00e7\u00e3o que j\u00e1 escreveu pode ser aplicada a um tipo para o qual ela n\u00e3o tinha planejada.","title":"17.9 - Polimorfismo"},{"location":"17-classes-metodos/#1710-interface-e-implementacao","text":"Uma das metas do projeto orientado a objeto \u00e9 facilitar a manuten\u00e7\u00e3o do programa, para que voc\u00ea possa mant\u00ea-lo funcionando quando outras partes do sistema forem alteradas, e tamb\u00e9m poder alterar o programa para satisfazer novas condi\u00e7\u00f5es. Um princ\u00edpio de projeto que ajuda a atingir essa meta \u00e9 manter as interfaces separadas das implementa\u00e7\u00f5es. Para objetos, isso quer dizer que os m\u00e9todos que uma classe oferece n\u00e3o devem depender de como os atributos s\u00e3o representados. Por exemplo, neste cap\u00edtulo desenvolvemos uma classe que representa uma hora do dia. Os m\u00e9todos fornecidos por esta classe incluem time_to_int, is_after e add_time. Podemos implementar esses m\u00e9todos de v\u00e1rias formas. Os detalhes da implementa\u00e7\u00e3o dependem de como representamos as horas. Neste cap\u00edtulo, os atributos de um objeto Time s\u00e3o hour, minute e second. Como alternativa, podemos substituir esses atributos por um n\u00famero inteiro \u00fanico que represente o n\u00famero de segundos desde a meia-noite. Essa implementa\u00e7\u00e3o faria com que alguns m\u00e9todos, como is_after, fossem mais f\u00e1ceis de escrever, mas dificultaria o uso de outros m\u00e9todos. Pode acontecer que, depois de implementar uma nova classe, voc\u00ea descubra uma implementa\u00e7\u00e3o melhor. Se outras partes do programa estiverem usando a sua classe, mudar a interface pode ser trabalhoso e induzir a erros. No entanto, se projetou a interface cuidadosamente, pode alterar a implementa\u00e7\u00e3o sem mudar a interface, e n\u00e3o ser\u00e1 preciso mudar outras partes do programa.","title":"17.10 - Interface e implementa\u00e7\u00e3o"},{"location":"17-classes-metodos/#1711-depuracao","text":"\u00c9 legal acrescentar atributos a objetos em qualquer ponto da execu\u00e7\u00e3o de um programa, mas se voc\u00ea tiver objetos do mesmo tipo que n\u00e3o t\u00eam os mesmos atributos, \u00e9 f\u00e1cil cometer erros. \u00c9 uma boa ideia inicializar todos os atributos de um objeto no m\u00e9todo init. Caso n\u00e3o tenha certeza se um objeto tem um determinado atributo, voc\u00ea pode usar a fun\u00e7\u00e3o integrada hasattr (ver \u201cDepura\u00e7\u00e3o\u201d, na p\u00e1gina 236). Outra forma de acessar atributos \u00e9 com a fun\u00e7\u00e3o integrada vars, que recebe um objeto e retorna um dicion\u00e1rio que mapeia os nomes dos atributos (como strings) aos seus valores: >>> p = Point(3, 4) >>> vars(p) {'y': 4, 'x': 3} Para facilitar a depura\u00e7\u00e3o, pode ser \u00fatil usar esta fun\u00e7\u00e3o: def print_attributes(obj): for attr in vars(obj): print(attr, getattr(obj, attr)) print_attributes atravessa o dicion\u00e1rio e imprime cada nome de atributo e o seu valor correspondente. A fun\u00e7\u00e3o integrada getattr recebe um objeto e um nome de atributo (como uma string) e devolve o valor do atributo.","title":"17.11 - Depura\u00e7\u00e3o"},{"location":"17-classes-metodos/#1712-glossario","text":"linguagem orientada a objeto Linguagem que fornece recursos, como tipos definidos pelo programador e m\u00e9todos, que facilitam a programa\u00e7\u00e3o orientada a objeto. programa\u00e7\u00e3o orientada a objeto Estilo de programa\u00e7\u00e3o na qual os dados e as opera\u00e7\u00f5es que os manipulam s\u00e3o organizadas em classes e m\u00e9todos. m\u00e9todo Fun\u00e7\u00e3o criada dentro de uma defini\u00e7\u00e3o de classe e invocada em inst\u00e2ncias desta classe. sujeito Objeto sobre o qual um m\u00e9todo \u00e9 invocado. argumento posicional Argumento que n\u00e3o inclui um nome de par\u00e2metro, portanto n\u00e3o \u00e9 um argumento de palavra-chave. sobrecarga de operador Altera\u00e7\u00e3o do comportamento de um operador como + para que funcione com um tipo definido pelo programador. despacho por tipo Modelo de programa\u00e7\u00e3o que invoca fun\u00e7\u00f5es diferentes dependendo do tipo do operando. polim\u00f3rfico Pertinente a uma fun\u00e7\u00e3o que pode funcionar com mais de um tipo. ocultamento de informa\u00e7\u00e3o Princ\u00edpio segundo o qual a interface fornecida por um objeto n\u00e3o deve depender da sua implementa\u00e7\u00e3o, especialmente em rela\u00e7\u00e3o \u00e0 representa\u00e7\u00e3o dos seus atributos.","title":"17.12 - Gloss\u00e1rio"},{"location":"17-classes-metodos/#1713-exercicios","text":"","title":"17.13 - Exerc\u00edcios"},{"location":"17-classes-metodos/#exercicio-171","text":"Baixe o c\u00f3digo deste cap\u00edtulo em http://thinkpython2.com/code/Time2.py. Altere os atributos de Time para que um n\u00famero inteiro \u00fanico represente os segundos decorridos desde a meia-noite. Ent\u00e3o altere os m\u00e9todos (e a fun\u00e7\u00e3o int_to_time) para funcionar com a nova implementa\u00e7\u00e3o. Voc\u00ea n\u00e3o deve modificar o c\u00f3digo de teste em main. Ao terminar, a sa\u00edda deve ser a mesma que antes. Solu\u00e7\u00e3o: http://thinkpython2.com/code/Time2_soln.py.","title":"Exerc\u00edcio 17.1"},{"location":"17-classes-metodos/#exercicio-172","text":"Este exerc\u00edcio \u00e9 uma hist\u00f3ria com moral sobre um dos erros mais comuns e dif\u00edceis de encontrar no Python. Escreva uma defini\u00e7\u00e3o de classe chamada Kangaroo com os seguintes m\u00e9todos: Um m\u00e9todo __init__ que inicialize um atributo chamado pouch_contents em uma lista vazia. Um m\u00e9todo chamado put_in_pouch que receba um objeto de qualquer tipo e o acrescente a pouch_contents . Um m\u00e9todo __str__ que retorne uma representa\u00e7\u00e3o de string do objeto Kangaroo e os conte\u00fados de pouch (bolsa). Teste o seu c\u00f3digo criando dois objetos Kangaroo, atribuindo-os a vari\u00e1veis chamadas kanga e roo, e ent\u00e3o acrescentando roo ao conte\u00fado da bolsa de kanga. Baixe http://thinkpython2.com/code/BadKangaroo.py. Ele cont\u00e9m uma solu\u00e7\u00e3o para o problema anterior com um defeito bem grande e bem feio. Encontre e corrija o defeito. Se n\u00e3o conseguir achar a solu\u00e7\u00e3o, voc\u00ea pode baixar http://thinkpython2.com/code/GoodKangaroo.py, que explica o problema e demonstra uma solu\u00e7\u00e3o.","title":"Exerc\u00edcio 17.2"},{"location":"18-heranca/","text":"Cap\u00edtulo 18: Heran\u00e7a O termo mais associado com a programa\u00e7\u00e3o orientada a objeto \u00e9 heran\u00e7a. A heran\u00e7a \u00e9 a capacidade de definir uma nova classe que seja uma vers\u00e3o modificada de uma classe existente. Neste cap\u00edtulo demonstrarei a heran\u00e7a usando classes que representam jogos de cartas, baralhos e m\u00e3os de p\u00f4quer. Se voc\u00ea n\u00e3o joga p\u00f4quer, pode ler sobre ele em http://en.wikipedia.org/wiki/Poker, mas n\u00e3o \u00e9 necess\u00e1rio; vou dizer tudo o que precisa saber para os exerc\u00edcios. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Card.py. 18.1 - Objetos Card H\u00e1 52 cartas em um baralho, e cada uma pertence a 1 dos 4 naipes e a 1 dos 13 valores. Os naipes s\u00e3o espadas, copas, ouros e paus (no bridge, em ordem descendente). A ordem dos valores \u00e9 \u00e1s, 2, 3, 4, 5, 6, 7, 8, 9, 10, valete, dama e rei. Dependendo do jogo que estiver jogando, um \u00e1s pode ser mais alto que o rei ou mais baixo que 2. Se quis\u00e9ssemos definir um novo objeto para representar uma carta de jogo, os atributos \u00f3bvios seriam rank (valor) e suit (naipe). Mas n\u00e3o \u00e9 t\u00e3o \u00f3bvio qual tipo de atributo deveriam ser. Uma possibilidade \u00e9 usar strings com palavras como 'Spade' (Espadas) para naipes e 'Queen' (Dama) para valores. Um problema com esta implementa\u00e7\u00e3o \u00e9 que n\u00e3o seria f\u00e1cil comparar cartas para ver qual valor ou naipe tem classifica\u00e7\u00e3o mais alta em rela\u00e7\u00e3o aos outros. Uma alternativa \u00e9 usar n\u00fameros inteiros para codificar os valores e os naipes. Neste contexto, \u201ccodificar\u201d significa que vamos definir um mapeamento entre n\u00fameros e naipes, ou entre n\u00fameros e valores. Este tipo de codifica\u00e7\u00e3o n\u00e3o tem nada a ver com criptografia. Por exemplo, esta tabela mostra os naipes e os c\u00f3digos de n\u00famero inteiro correspondentes: Spades (Espadas) \u21a6 3 Hearts (Copas) \u21a6 2 Diamonds (Ouros) \u21a6 1 Clubs (Paus) \u21a6 0 Este c\u00f3digo facilita a compara\u00e7\u00e3o entre as cartas; como naipes mais altos mapeiam a n\u00fameros mais altos, podemos comparar naipes aos seus c\u00f3digos. O mapeamento de valores \u00e9 at\u00e9 \u00f3bvio; cada um dos valores num\u00e9ricos \u00e9 mapeado ao n\u00famero inteiro correspondente, e para cartas com figuras: Jack (Valete) \u21a6 11 Queen (Dama) \u21a6 12 King (Rei) \u21a6 13 Estou usando o s\u00edmbolo \u21a6 para deixar claro que esses mapeamentos n\u00e3o s\u00e3o parte do programa em Python. Eles s\u00e3o parte do projeto do programa, mas n\u00e3o aparecem explicitamente no c\u00f3digo. A defini\u00e7\u00e3o de classe para Card (carta) \u00e9 assim: class Card: \"\"\"Represents a standard playing card.\"\"\" def __init__(self, suit=0, rank=2): self.suit = suit self.rank = rank Como sempre, o m\u00e9todo __init__ recebe um par\u00e2metro opcional de cada atributo. A carta padr\u00e3o \u00e9 2 de paus. Para criar um Card, voc\u00ea chama Card com o naipe e valor desejados: queen_of_diamonds = Card(1, 12) 18.2 - Atributos de classe Para exibir objetos Card de uma forma que as pessoas possam ler com facilidade, precisamos de um mapeamento dos c\u00f3digos de n\u00famero inteiro aos naipes e valores correspondentes. Uma forma natural de fazer isso \u00e9 com listas de strings. Atribu\u00edmos essas listas a atributos de classe: # dentro da classe Card: suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'] def __str__(self): return '%s of %s' % (Card.rank_names[self.rank], Card.suit_names[self.suit]) Vari\u00e1veis como suit_names e rank_names , que s\u00e3o definidas dentro de uma classe, mas fora de qualquer m\u00e9todo, chamam-se atributos de classe porque s\u00e3o associadas com o objeto de classe Card. Este termo as distingue de vari\u00e1veis como suit e rank , chamadas de atributos de inst\u00e2ncia porque s\u00e3o associados com determinada inst\u00e2ncia. Ambos os tipos de atributo s\u00e3o acessados usando a nota\u00e7\u00e3o de ponto. Por exemplo, em __str__ , self \u00e9 um objeto Card , e self.rank \u00e9 o seu valor. De forma semelhante, Card \u00e9 um objeto de classe, e Card.rank_names \u00e9 uma lista de strings associadas \u00e0 essa classe. Cada carta tem seu pr\u00f3prio suit e rank, mas h\u00e1 s\u00f3 uma c\u00f3pia de suit_names e rank_names. Juntando tudo, a express\u00e3o Card.rank_names[self.rank] significa \u201cuse o rank (valor) do atributo do objeto self como um \u00edndice na lista rank_names da classe Card e selecione a string adequada\u201d. O primeiro elemento de rank_names \u00e9 None, porque n\u00e3o h\u00e1 nenhuma carta com valor zero. Incluindo None para ocupar uma vari\u00e1vel, conseguimos fazer um belo mapeamento onde o \u00edndice 2 \u00e9 associado \u00e0 string '2', e assim por diante. Para evitar ter que usar esse truque, poder\u00edamos usar um dicion\u00e1rio em vez de uma lista. Com os m\u00e9todos que temos por enquanto, podemos criar e exibir cartas: >>> card1 = Card(2, 11) >>> print(card1) Jack of Hearts A Figura 18.1 \u00e9 um diagrama do objeto de classe Card e uma inst\u00e2ncia de Card. Card \u00e9 um objeto de classe; seu tipo \u00e9 type. card1 \u00e9 uma inst\u00e2ncia de Card, ent\u00e3o seu tipo \u00e9 Card. Para economizar espa\u00e7o, n\u00e3o inclu\u00ed o conte\u00fado de suit_names e rank_names. Figura 18.1 \u2013 Diagrama de objetos: classe Card e card1 , uma inst\u00e2ncia de Card . 18.3 - Compara\u00e7\u00e3o de cartas Para tipos integrados, h\u00e1 operadores relacionais ( < , > , == etc.) que comparam valores e determinam quando um \u00e9 maior, menor ou igual a outro. Para tipos definidos pelo programador, podemos ignorar o comportamento dos operadores integrados fornecendo um m\u00e9todo denominado __lt__ , que representa \u201cmenos que\u201d. __lt__ recebe dois par\u00e2metros, self e other , e True se self for estritamente menor que other . A ordem correta das cartas n\u00e3o \u00e9 \u00f3bvia. Por exemplo, qual \u00e9 melhor, o 3 de paus ou o 2 de ouros? Uma tem o valor mais alto, mas a outra tem um naipe mais alto. Para comparar cartas, \u00e9 preciso decidir o que \u00e9 mais importante, o valor ou o naipe. A resposta pode depender de que jogo voc\u00ea est\u00e1 jogando, mas, para manter a simplicidade, vamos fazer a escolha arbitr\u00e1ria de que o naipe \u00e9 mais importante, ent\u00e3o todas as cartas de espadas s\u00e3o mais importantes que as de ouros, e assim por diante. Com isto decidido, podemos escrever __lt__ : # dentro da classe Card: def __lt__(self, other): # conferir os naipes if self.suit < other.suit: return True if self.suit > other.suit: return False # os naipes s\u00e3o os mesmos... conferir valores return self.rank < other.rank Voc\u00ea pode escrever isso de forma mais concisa usando uma compara\u00e7\u00e3o de tuplas: # dentro da classe Card: def __lt__(self, other): t1 = self.suit, self.rank t2 = other.suit, other.rank return t1 < t2 Como exerc\u00edcio, escreva um m\u00e9todo __lt__ para objetos Time. Voc\u00ea pode usar uma compara\u00e7\u00e3o de tuplas, mas tamb\u00e9m pode usar a compara\u00e7\u00e3o de n\u00fameros inteiros. 18.4 - Baralhos Agora que temos Card, o pr\u00f3ximo passo \u00e9 definir Deck (baralho). Como um baralho \u00e9 composto de cartas, \u00e9 natural que um baralho contenha uma lista de cartas como atributo. Veja a seguir uma defini\u00e7\u00e3o de classe para Deck . O m\u00e9todo init cria o atributo cards e gera o conjunto padr\u00e3o de 52 cartas: class Deck: def __init__(self): self.cards = [] for suit in range(4): for rank in range(1, 14): card = Card(suit, rank) self.cards.append(card) A forma mais f\u00e1cil de preencher o baralho \u00e9 com um loop aninhado. O loop exterior enumera os naipes de 0 a 3. O loop interior enumera os valores de 1 a 13. Cada itera\u00e7\u00e3o cria um novo Card com o naipe e valor atual, e a acrescenta a self.cards. 18.5 - Exibi\u00e7\u00e3o do baralho Aqui est\u00e1 um m\u00e9todo str para Deck: # dentro da classe Deck: def __str__(self): res = [] for card in self.cards: res.append(str(card)) return '\\n'.join(res) Este m\u00e9todo demonstra uma forma eficiente de acumular uma string grande: a cria\u00e7\u00e3o de uma lista de strings e a utiliza\u00e7\u00e3o do m\u00e9todo de string join. A fun\u00e7\u00e3o integrada str invoca o m\u00e9todo __str__ em cada carta e retorna a representa\u00e7\u00e3o da string. Como invocamos join em um caractere newline, as cartas s\u00e3o separadas por quebras de linha. O resultado \u00e9 esse: >>> deck = Deck() >>> print(deck) Ace of Clubs 2 of Clubs 3 of Clubs ... 10 of Spades Jack of Spades Queen of Spades King of Spades Embora o resultado apare\u00e7a em 52 linhas, na verdade ele \u00e9 uma string longa com quebras de linha. 18.6 - Adi\u00e7\u00e3o, remo\u00e7\u00e3o, embaralhamento e classifica\u00e7\u00e3o Para lidar com as cartas, gostar\u00edamos de ter um m\u00e9todo que removesse uma carta do baralho e a devolvesse. O m\u00e9todo de lista pop oferece uma forma conveniente de fazer isso: # dentro da classe Deck: def pop_card(self): return self.cards.pop() Como pop retira a \u00faltima carta na lista, estamos lidando com o fundo do baralho. Para adicionar uma carta, podemos usar o m\u00e9todo de lista append: # dentro da classe Deck: def add_card(self, card): self.cards.append(card) Um m\u00e9todo como esse, que usa outro m\u00e9todo sem dar muito trabalho, \u00e0s vezes \u00e9 chamado de folheado. A met\u00e1fora vem do trabalho em madeira, onde o folheado \u00e9 uma camada fina de madeira de boa qualidade colada \u00e0 superf\u00edcie de uma madeira mais barata para melhorar a apar\u00eancia. Nesse caso, add_card \u00e9 um m\u00e9todo \u201cfino\u201d que expressa uma opera\u00e7\u00e3o de lista em termos adequados a baralhos. Ele melhora a apar\u00eancia ou interface da implementa\u00e7\u00e3o. Em outro exemplo, podemos escrever um m\u00e9todo Deck denominado shuffle, usando a fun\u00e7\u00e3o shuffle do m\u00f3dulo random: # dentro da classe Deck: def shuffle(self): random.shuffle(self.cards) N\u00e3o se esque\u00e7a de importar random. Como exerc\u00edcio, escreva um m\u00e9todo de Deck chamado sort, que use o m\u00e9todo de lista sort para classificar as cartas em um Deck. sort usa o m\u00e9todo __lt__ que definimos para determinar a ordem. 18.7 - Heran\u00e7a A heran\u00e7a \u00e9 a capacidade de definir uma nova classe que seja uma vers\u00e3o modificada de uma classe existente. Como exemplo, digamos que queremos que uma classe represente uma \u201cm\u00e3o\u201d, isto \u00e9, as cartas mantidas por um jogador. Uma m\u00e3o \u00e9 semelhante a um baralho: ambos s\u00e3o compostos por uma cole\u00e7\u00e3o de cartas, e ambos exigem opera\u00e7\u00f5es como adicionar e remover cartas. Uma m\u00e3o tamb\u00e9m \u00e9 diferente de um baralho; h\u00e1 opera\u00e7\u00f5es que queremos para m\u00e3os que n\u00e3o fazem sentido para um baralho. Por exemplo, no p\u00f4quer poder\u00edamos comparar duas m\u00e3os para ver qual ganha. No bridge, poder\u00edamos calcular a pontua\u00e7\u00e3o de uma m\u00e3o para fazer uma aposta. Essa rela\u00e7\u00e3o entre classes \u2013 semelhante, mas diferente \u2013 adequa-se \u00e0 heran\u00e7a. Para definir uma nova classe que herda algo de uma classe existente, basta colocar o nome da classe existente entre par\u00eanteses: class Hand(Deck): \"\"\"Represents a hand of playing cards.\"\"\" Esta defini\u00e7\u00e3o indica que Hand herda de Deck; isso significa que podemos usar m\u00e9todos como pop_card e add_card para Hand bem como para Deck. Quando uma nova classe herda de uma existente, a existente chama-se pai e a nova classe chama-se filho. Neste exemplo, Hand herda __init__ de Deck, mas na verdade n\u00e3o faz o que queremos: em vez de preencher a m\u00e3o com 52 cartas novas, o m\u00e9todo init de Hand deve inicializar card com uma lista vazia. Se fornecermos um m\u00e9todo init na classe Hand, ele ignora o da classe Deck: # dentro da classe Hand: def __init__(self, label=''): self.cards = [] self.label = label Ao criar Hand, o Python invoca este m\u00e9todo init, n\u00e3o o de Deck. >>> hand = Hand('new hand') >>> hand.cards [] >>> hand.label 'new hand' Outros m\u00e9todos s\u00e3o herdados de Deck, portanto podemos usar pop_card e add_card para lidar com uma carta: >>> deck = Deck() >>> card = deck.pop_card() >>> hand.add_card(card) >>> print(hand) King of Spades Um pr\u00f3ximo passo natural seria encapsular este c\u00f3digo em um m\u00e9todo chamado move_cards : # dentro da classe Deck: def move_cards(self, hand, num): for i in range(num): hand.add_card(self.pop_card()) move_cards recebe dois argumentos, um objeto Hand e o n\u00famero de cartas com que vai lidar. Ele altera tanto self como hand e retorna None. Em alguns jogos, as cartas s\u00e3o movidas de uma m\u00e3o a outra, ou de uma m\u00e3o de volta ao baralho. \u00c9 poss\u00edvel usar move_cards para algumas dessas opera\u00e7\u00f5es: self pode ser um Deck ou Hand, e hand, apesar do nome, tamb\u00e9m pode ser um Deck. A heran\u00e7a \u00e9 um recurso \u00fatil. Alguns programas que poderiam ser repetitivos sem heran\u00e7a podem ser escritos de forma mais elegante com ela. A heran\u00e7a pode facilitar a reutiliza\u00e7\u00e3o de c\u00f3digo, j\u00e1 que voc\u00ea pode personalizar o comportamento de classes pais sem ter que alter\u00e1-las. Em alguns casos, a estrutura de heran\u00e7a reflete a estrutura natural do problema, o que torna o projeto mais f\u00e1cil de entender. De outro lado, a heran\u00e7a pode tornar os programas dif\u00edceis de ler. Quando um m\u00e9todo \u00e9 invocado, \u00e0s vezes n\u00e3o est\u00e1 claro onde encontrar sua defini\u00e7\u00e3o. O c\u00f3digo relevante pode ser espalhado por v\u00e1rios m\u00f3dulos. Al\u00e9m disso, muitas das coisas que podem ser feitas usando a heran\u00e7a podem ser feitas sem elas, \u00e0s vezes, at\u00e9 de forma melhor. 18.8 - Diagramas de classe Por enquanto vimos diagramas de pilha, que mostram o estado de um programa e diagramas de objeto, que mostram os atributos de um objeto e seus valores. Esses diagramas representam um retrato da execu\u00e7\u00e3o de um programa, ent\u00e3o eles mudam no decorrer da execu\u00e7\u00e3o do programa. Eles tamb\u00e9m s\u00e3o altamente detalhados; para alguns objetivos, detalhados demais. Um diagrama de classe \u00e9 uma representa\u00e7\u00e3o mais abstrata da estrutura de um programa. Em vez de mostrar objetos individuais, ele mostra classes e as rela\u00e7\u00f5es entre elas. H\u00e1 v\u00e1rios tipos de rela\u00e7\u00f5es entre as classes: Os objetos de uma classe podem conter refer\u00eancias a objetos em outra classe. Por exemplo, cada Rectangle cont\u00e9m uma refer\u00eancia a um Point, e cada Deck cont\u00e9m refer\u00eancias a muitos Cards. Esse tipo de rela\u00e7\u00e3o chama-se composi\u00e7\u00e3o. \u00c9 uma rela\u00e7\u00e3o do tipo HAS-A (tem um), com a ideia de \u201cum Rectangle tem um Point\u201d. Uma classe pode herdar de outra. Esta rela\u00e7\u00e3o chama-se IS-A (\u00e9 um), com a ideia de \u201cum Hand \u00e9 um tipo de Deck\u201d. Uma classe pode depender de outra no sentido de que os objetos em uma classe possam receber objetos na segunda classe como par\u00e2metros ou usar esses objetos como parte de um c\u00e1lculo. Este tipo de rela\u00e7\u00e3o chama-se depend\u00eancia. Um diagrama de classe \u00e9 uma representa\u00e7\u00e3o gr\u00e1fica dessas rela\u00e7\u00f5es. Por exemplo, a Figura 18.2 mostra as rela\u00e7\u00f5es entre Card, Deck e Hand. Figura 18.2 \u2013 Diagrama de classes. A flecha com um tri\u00e2ngulo oco representa uma rela\u00e7\u00e3o IS-A; nesse caso, indica que Hand herda de Deck. A ponta de flecha padr\u00e3o representa uma rela\u00e7\u00e3o HAS-A; nesse caso, um Deck tem refer\u00eancias a objetos Card. A estrela * perto da ponta de flecha indica a multiplicidade; ela indica quantos Cards um Deck tem. Uma multiplicidade pode ser um n\u00famero simples como 52, um intervalo como 5..7 ou uma estrela, que indica que um Deck pode ter qualquer n\u00famero de Cards. N\u00e3o h\u00e1 nenhuma depend\u00eancia neste diagrama. Elas normalmente apareceriam com uma flecha tracejada. Ou, se houver muitas depend\u00eancias, \u00e0s vezes elas s\u00e3o omitidas. Um diagrama mais detalhado poderia mostrar que um Deck na verdade cont\u00e9m uma lista de Cards, mas os tipos integrados como lista e dict n\u00e3o s\u00e3o normalmente inclu\u00eddos em diagramas de classe. 18.9 - Encapsulamento de dados Os cap\u00edtulos anteriores demonstram um plano de desenvolvimento que poder\u00edamos chamar de \u201cprojeto orientado a objeto\u201d. Identificamos os objetos de que precisamos \u2013 como Point, Rectangle e Time \u2013 e definimos classes para represent\u00e1-los. Em cada caso h\u00e1 uma correspond\u00eancia \u00f3bvia entre o objeto e alguma entidade no mundo real (ou, pelo menos, no mundo matem\u00e1tico). Mas, \u00e0s vezes, \u00e9 menos \u00f3bvio quais objetos voc\u00ea precisa e como eles devem interagir. Nesse caso \u00e9 necess\u00e1rio um plano de desenvolvimento diferente. Da mesma forma em que descobrimos interfaces de fun\u00e7\u00e3o por encapsulamento e generaliza\u00e7\u00e3o, podemos descobrir interfaces de classe por encapsulamento de dados. A an\u00e1lise de Markov, de \u201cAn\u00e1lise de Markov\u201d, na p\u00e1gina 200, apresenta um bom exemplo. Se baixar o meu c\u00f3digo em http://thinkpython2.com/code/markov.py, voc\u00ea vai ver que ele usa duas vari\u00e1veis globais \u2013 suffix_map e prefix \u2013 que s\u00e3o lidas e escritas a partir de v\u00e1rias fun\u00e7\u00f5es. suffix_map = {} prefix = () Como essas vari\u00e1veis s\u00e3o globais, s\u00f3 podemos executar uma an\u00e1lise de cada vez. Se lermos dois textos, seus prefixos e sufixos seriam acrescentados \u00e0s mesmas estruturas de dados (o que geraria textos interessantes). Para executar an\u00e1lises m\u00faltiplas e guard\u00e1-las separadamente, podemos encapsular o estado de cada an\u00e1lise em um objeto. \u00c9 assim que fica: class Markov: def __init__(self): self.suffix_map = {} self.prefix = () Em seguida, transformamos as fun\u00e7\u00f5es em m\u00e9todos. Por exemplo, aqui est\u00e1 process_word: def process_word(self, word, order=2): if len(self.prefix) < order: self.prefix += (word,) return try: self.suffix_map[self.prefix].append(word) except KeyError: # se n\u00e3o houver entradas deste prefixo, crie uma. self.suffix_map[self.prefix] = [word] self.prefix = shift(self.prefix, word) Transformar um programa como esse \u2013 alterando o projeto sem mudar o comportamento \u2013 \u00e9 outro exemplo de refatora\u00e7\u00e3o (veja \u201cRefatora\u00e7\u00e3o\u201d, na p\u00e1gina 70). Este exemplo sugere um plano de desenvolvimento para projetar objetos e m\u00e9todos: Comece escrevendo fun\u00e7\u00f5es que leiam e criem vari\u00e1veis globais (quando necess\u00e1rio). Uma vez que o programa esteja funcionando, procure associa\u00e7\u00f5es entre vari\u00e1veis globais e fun\u00e7\u00f5es que as usem. Encapsule vari\u00e1veis relacionadas como atributos de objeto. Transforme as fun\u00e7\u00f5es associadas em m\u00e9todos da nova classe. Como exerc\u00edcio, baixe o meu c\u00f3digo de Markov de http://thinkpython2.com/code/markov.py e siga os passos descritos acima para encapsular as vari\u00e1veis globais como atributos de uma nova classe chamada Markov. Solu\u00e7\u00e3o: http://thinkpython2.com/code/Markov.py (observe o M mai\u00fasculo). 18.10 - Depura\u00e7\u00e3o A heran\u00e7a pode dificultar a depura\u00e7\u00e3o porque quando voc\u00ea invoca um m\u00e9todo em um objeto, pode ser dif\u00edcil compreender qual m\u00e9todo ser\u00e1 invocado. Suponha que esteja escrevendo uma fun\u00e7\u00e3o que funcione com objetos Hand. Voc\u00ea gostaria que ela funcionasse com todos os tipos de Hand, como PokerHands, BridgeHands etc. Se invocar um m\u00e9todo como shuffle, poder\u00e1 receber o que foi definido em Deck, mas se alguma das subclasses ignorar este m\u00e9todo, voc\u00ea receber\u00e1 outra vers\u00e3o. Este comportamento pode ser bom, mas tamb\u00e9m confuso. A qualquer momento em que n\u00e3o esteja seguro a respeito do fluxo de execu\u00e7\u00e3o do seu programa, a solu\u00e7\u00e3o mais simples \u00e9 acrescentar instru\u00e7\u00f5es de exibi\u00e7\u00e3o no in\u00edcio dos m\u00e9todos em quest\u00e3o. Se Deck.shuffle exibir uma mensagem que diz algo como Running Deck.shuffle, ent\u00e3o no decorrer da execu\u00e7\u00e3o do programa ele monitora seu fluxo. Uma alternativa \u00e9 usar esta fun\u00e7\u00e3o, que recebe um objeto e um nome de m\u00e9todo (como uma string) e retorna a classe que fornece a defini\u00e7\u00e3o do m\u00e9todo: def find_defining_class(obj, meth_name): for ty in type(obj).mro(): if meth_name in ty.__dict__: return ty Aqui est\u00e1 um exemplo: >>> hand = Hand() >>> find_defining_class(hand, 'shuffle') <class 'Card.Deck'> Ent\u00e3o o m\u00e9todo shuffle deste Hand \u00e9 o de Deck. find_defining_class usa o m\u00e9todo mro para obter a lista de objetos de classe (tipos) onde os m\u00e9todos ser\u00e3o procurados. \u201cMRO\u201d significa \u201cordem de resolu\u00e7\u00e3o do m\u00e9todo\u201d, que \u00e9 a sequ\u00eancia de classes que o Python pesquisa para \u201cdescobrir\u201d um nome de m\u00e9todo. Aqui est\u00e1 uma sugest\u00e3o de projeto: quando voc\u00ea ignora um m\u00e9todo, a interface do novo m\u00e9todo deve ser a mesma que a do antigo. Ela deve receber os mesmos par\u00e2metros, retornar o mesmo tipo e obedecer \u00e0s mesmas precondi\u00e7\u00f5es e p\u00f3s-condi\u00e7\u00f5es. Se seguir esta regra, voc\u00ea descobrir\u00e1 que qualquer fun\u00e7\u00e3o projetada para funcionar com uma inst\u00e2ncia de uma classe pai, como Deck, tamb\u00e9m funcionar\u00e1 com inst\u00e2ncias de classes filho como Hand e PokerHand. Se violar esta regra, o que se chama de \u201cprinc\u00edpio de substitui\u00e7\u00e3o de Liskov\u201d, seu c\u00f3digo cair\u00e1 como (desculpe) um castelo de cartas. 18.11 - Gloss\u00e1rio codificar Representar um conjunto de valores usando outro conjunto de valores construindo um mapeamento entre eles. atributo de classe Atributo associado a um objeto de classe. Os atributos de classe s\u00e3o definidos dentro de uma defini\u00e7\u00e3o de classe, mas fora de qualquer m\u00e9todo. atributo de inst\u00e2ncia Atributo associado a uma inst\u00e2ncia de uma classe. folheado M\u00e9todo ou fun\u00e7\u00e3o que apresenta uma interface diferente para outra fun\u00e7\u00e3o sem fazer muitos c\u00e1lculos. heran\u00e7a Capacidade de definir uma nova classe que seja uma vers\u00e3o modificada de uma classe definida anteriormente. classe-pai Classe da qual uma classe-filho herda. classe-filho Nova classe criada por heran\u00e7a de uma classe existente; tamb\u00e9m chamada de \u201csubclasse\u201d. rela\u00e7\u00e3o IS-A Rela\u00e7\u00e3o entre uma classe-filho e sua classe-pai. Tamb\u00e9m chamada de heran\u00e7a. rela\u00e7\u00e3o HAS-A Rela\u00e7\u00e3o entre duas classes onde as inst\u00e2ncias de uma classe cont\u00eam refer\u00eancias a inst\u00e2ncias da outra. Tamb\u00e9m chamada de composi\u00e7\u00e3o. depend\u00eancia Rela\u00e7\u00e3o entre duas classes onde as inst\u00e2ncias de uma classe usam inst\u00e2ncias de outra classe, mas n\u00e3o as guardam como atributos. diagrama de classe Diagrama que mostra as classes em um programa e as rela\u00e7\u00f5es entre elas. multiplicidade Nota\u00e7\u00e3o em um diagrama de classe que mostra, para uma rela\u00e7\u00e3o HAS-A, quantas refer\u00eancias a inst\u00e2ncias da outra classe podem existir. encapsulamento de dados Plano de desenvolvimento de programa que envolve um prot\u00f3tipo usando vari\u00e1veis globais e uma vers\u00e3o final que transforma as vari\u00e1veis globais em atributos de inst\u00e2ncia. 18.12 - Exerc\u00edcios Exerc\u00edcio 18.1 Para o seguinte programa, desenhe um diagrama de classe UML que mostre estas classes e as rela\u00e7\u00f5es entre elas. class PingPongParent: pass class Ping(PingPongParent): def __init__(self, pong): self.pong = pong class Pong(PingPongParent): def __init__(self, pings=None): if pings is None: self.pings = [] else: self.pings = pings def add_ping(self, ping): self.pings.append(ping) pong = Pong() ping = Ping(pong) pong.add_ping(ping) Exerc\u00edcio 18.2 Escreva um m\u00e9todo Deck chamado deal_hands que receba dois par\u00e2metros: o n\u00famero de m\u00e3os e o n\u00famero de cartas por m\u00e3o. Ele deve criar o n\u00famero adequado de objetos Hand, lidar com o n\u00famero adequado de cartas por m\u00e3o e retornar uma lista de Hands. Exerc\u00edcio 18.3 A seguir, as m\u00e3os poss\u00edveis no p\u00f4quer, em ordem crescente de valor e ordem decrescente de probabilidade: par Duas cartas com o mesmo valor. dois pares Dois pares de cartas com o mesmo valor. trinca Tr\u00eas cartas com o mesmo valor. sequ\u00eancia Cinco cartas com valores em sequ\u00eancia (os ases podem ser altos ou baixos, ent\u00e3o Ace-2-3-4-5 \u00e9 uma sequ\u00eancia, assim como 10-Jack-Queen-King-Ace, mas Queen-King-Ace-2-3 n\u00e3o \u00e9.) flush Cinco cartas com o mesmo naipe. full house Tr\u00eas cartas com um valor, duas cartas com outro. quadra Quatro cartas com o mesmo valor. straight flush Cinco cartas em sequ\u00eancia (como definido acima) e com o mesmo naipe. A meta desses exerc\u00edcios \u00e9 estimar a probabilidade de ter estas v\u00e1rias m\u00e3os. Baixe os seguintes arquivos de http://thinkpython2.com/code: Card.py : Vers\u00e3o completa das classes Card, Deck e Hand deste cap\u00edtulo. PokerHand.py : Uma implementa\u00e7\u00e3o incompleta de uma classe que representa uma m\u00e3o de p\u00f4quer e c\u00f3digo para test\u00e1-la. Se executar PokerHand.py, voc\u00ea ver\u00e1 que o programa cria m\u00e3os de p\u00f4quer com 7 cartas e verifica se alguma delas cont\u00e9m um flush. Leia este c\u00f3digo com aten\u00e7\u00e3o antes de continuar. Acrescente m\u00e9todos a PokerHand.py chamados has_pair , has_twopair , etc. que retornem True ou False conforme a m\u00e3o cumpra os crit\u00e9rios em quest\u00e3o. Seu c\u00f3digo deve funcionar corretamente para \u201cm\u00e3os\u201d que contenham qualquer n\u00famero de cartas (embora 5 e 7 sejam as quantidades mais comuns). Escreva um m\u00e9todo chamado classify que descubra a classifica\u00e7\u00e3o do valor mais alto para uma m\u00e3o e estabele\u00e7a o atributo label em quest\u00e3o. Por exemplo, uma m\u00e3o de 7 cartas poderia conter um flush e um par; ela deve ser marcada como \u201cflush\u201d. Quando se convencer de que os seus m\u00e9todos de classifica\u00e7\u00e3o est\u00e3o funcionando, o pr\u00f3ximo passo deve ser estimar as probabilidades de v\u00e1rias m\u00e3os. Escreva uma fun\u00e7\u00e3o em PokerHand.py que embaralhe cartas, divida-as em m\u00e3os, classifique as m\u00e3os e conte o n\u00famero de vezes em que v\u00e1rias classifica\u00e7\u00f5es aparecem. Exiba uma tabela das classifica\u00e7\u00f5es e suas probabilidades. Execute seu programa com n\u00fameros cada vez maiores de m\u00e3os at\u00e9 que os valores de sa\u00edda convirjam a um grau razo\u00e1vel de exatid\u00e3o. Compare seus resultados com os valores em http://en.wikipedia.org/wiki/Hand_rankings. Solu\u00e7\u00e3o: http://thinkpython2.com/code/PokerHandSoln.py.","title":"Cap\u00edtulo 18: Heran\u00e7a"},{"location":"18-heranca/#capitulo-18-heranca","text":"O termo mais associado com a programa\u00e7\u00e3o orientada a objeto \u00e9 heran\u00e7a. A heran\u00e7a \u00e9 a capacidade de definir uma nova classe que seja uma vers\u00e3o modificada de uma classe existente. Neste cap\u00edtulo demonstrarei a heran\u00e7a usando classes que representam jogos de cartas, baralhos e m\u00e3os de p\u00f4quer. Se voc\u00ea n\u00e3o joga p\u00f4quer, pode ler sobre ele em http://en.wikipedia.org/wiki/Poker, mas n\u00e3o \u00e9 necess\u00e1rio; vou dizer tudo o que precisa saber para os exerc\u00edcios. Os exemplos de c\u00f3digo deste cap\u00edtulo est\u00e3o dispon\u00edveis em http://thinkpython2.com/code/Card.py.","title":"Cap\u00edtulo 18: Heran\u00e7a"},{"location":"18-heranca/#181-objetos-card","text":"H\u00e1 52 cartas em um baralho, e cada uma pertence a 1 dos 4 naipes e a 1 dos 13 valores. Os naipes s\u00e3o espadas, copas, ouros e paus (no bridge, em ordem descendente). A ordem dos valores \u00e9 \u00e1s, 2, 3, 4, 5, 6, 7, 8, 9, 10, valete, dama e rei. Dependendo do jogo que estiver jogando, um \u00e1s pode ser mais alto que o rei ou mais baixo que 2. Se quis\u00e9ssemos definir um novo objeto para representar uma carta de jogo, os atributos \u00f3bvios seriam rank (valor) e suit (naipe). Mas n\u00e3o \u00e9 t\u00e3o \u00f3bvio qual tipo de atributo deveriam ser. Uma possibilidade \u00e9 usar strings com palavras como 'Spade' (Espadas) para naipes e 'Queen' (Dama) para valores. Um problema com esta implementa\u00e7\u00e3o \u00e9 que n\u00e3o seria f\u00e1cil comparar cartas para ver qual valor ou naipe tem classifica\u00e7\u00e3o mais alta em rela\u00e7\u00e3o aos outros. Uma alternativa \u00e9 usar n\u00fameros inteiros para codificar os valores e os naipes. Neste contexto, \u201ccodificar\u201d significa que vamos definir um mapeamento entre n\u00fameros e naipes, ou entre n\u00fameros e valores. Este tipo de codifica\u00e7\u00e3o n\u00e3o tem nada a ver com criptografia. Por exemplo, esta tabela mostra os naipes e os c\u00f3digos de n\u00famero inteiro correspondentes: Spades (Espadas) \u21a6 3 Hearts (Copas) \u21a6 2 Diamonds (Ouros) \u21a6 1 Clubs (Paus) \u21a6 0 Este c\u00f3digo facilita a compara\u00e7\u00e3o entre as cartas; como naipes mais altos mapeiam a n\u00fameros mais altos, podemos comparar naipes aos seus c\u00f3digos. O mapeamento de valores \u00e9 at\u00e9 \u00f3bvio; cada um dos valores num\u00e9ricos \u00e9 mapeado ao n\u00famero inteiro correspondente, e para cartas com figuras: Jack (Valete) \u21a6 11 Queen (Dama) \u21a6 12 King (Rei) \u21a6 13 Estou usando o s\u00edmbolo \u21a6 para deixar claro que esses mapeamentos n\u00e3o s\u00e3o parte do programa em Python. Eles s\u00e3o parte do projeto do programa, mas n\u00e3o aparecem explicitamente no c\u00f3digo. A defini\u00e7\u00e3o de classe para Card (carta) \u00e9 assim: class Card: \"\"\"Represents a standard playing card.\"\"\" def __init__(self, suit=0, rank=2): self.suit = suit self.rank = rank Como sempre, o m\u00e9todo __init__ recebe um par\u00e2metro opcional de cada atributo. A carta padr\u00e3o \u00e9 2 de paus. Para criar um Card, voc\u00ea chama Card com o naipe e valor desejados: queen_of_diamonds = Card(1, 12)","title":"18.1 - Objetos Card"},{"location":"18-heranca/#182-atributos-de-classe","text":"Para exibir objetos Card de uma forma que as pessoas possam ler com facilidade, precisamos de um mapeamento dos c\u00f3digos de n\u00famero inteiro aos naipes e valores correspondentes. Uma forma natural de fazer isso \u00e9 com listas de strings. Atribu\u00edmos essas listas a atributos de classe: # dentro da classe Card: suit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades'] rank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'] def __str__(self): return '%s of %s' % (Card.rank_names[self.rank], Card.suit_names[self.suit]) Vari\u00e1veis como suit_names e rank_names , que s\u00e3o definidas dentro de uma classe, mas fora de qualquer m\u00e9todo, chamam-se atributos de classe porque s\u00e3o associadas com o objeto de classe Card. Este termo as distingue de vari\u00e1veis como suit e rank , chamadas de atributos de inst\u00e2ncia porque s\u00e3o associados com determinada inst\u00e2ncia. Ambos os tipos de atributo s\u00e3o acessados usando a nota\u00e7\u00e3o de ponto. Por exemplo, em __str__ , self \u00e9 um objeto Card , e self.rank \u00e9 o seu valor. De forma semelhante, Card \u00e9 um objeto de classe, e Card.rank_names \u00e9 uma lista de strings associadas \u00e0 essa classe. Cada carta tem seu pr\u00f3prio suit e rank, mas h\u00e1 s\u00f3 uma c\u00f3pia de suit_names e rank_names. Juntando tudo, a express\u00e3o Card.rank_names[self.rank] significa \u201cuse o rank (valor) do atributo do objeto self como um \u00edndice na lista rank_names da classe Card e selecione a string adequada\u201d. O primeiro elemento de rank_names \u00e9 None, porque n\u00e3o h\u00e1 nenhuma carta com valor zero. Incluindo None para ocupar uma vari\u00e1vel, conseguimos fazer um belo mapeamento onde o \u00edndice 2 \u00e9 associado \u00e0 string '2', e assim por diante. Para evitar ter que usar esse truque, poder\u00edamos usar um dicion\u00e1rio em vez de uma lista. Com os m\u00e9todos que temos por enquanto, podemos criar e exibir cartas: >>> card1 = Card(2, 11) >>> print(card1) Jack of Hearts A Figura 18.1 \u00e9 um diagrama do objeto de classe Card e uma inst\u00e2ncia de Card. Card \u00e9 um objeto de classe; seu tipo \u00e9 type. card1 \u00e9 uma inst\u00e2ncia de Card, ent\u00e3o seu tipo \u00e9 Card. Para economizar espa\u00e7o, n\u00e3o inclu\u00ed o conte\u00fado de suit_names e rank_names. Figura 18.1 \u2013 Diagrama de objetos: classe Card e card1 , uma inst\u00e2ncia de Card .","title":"18.2 - Atributos de classe"},{"location":"18-heranca/#183-comparacao-de-cartas","text":"Para tipos integrados, h\u00e1 operadores relacionais ( < , > , == etc.) que comparam valores e determinam quando um \u00e9 maior, menor ou igual a outro. Para tipos definidos pelo programador, podemos ignorar o comportamento dos operadores integrados fornecendo um m\u00e9todo denominado __lt__ , que representa \u201cmenos que\u201d. __lt__ recebe dois par\u00e2metros, self e other , e True se self for estritamente menor que other . A ordem correta das cartas n\u00e3o \u00e9 \u00f3bvia. Por exemplo, qual \u00e9 melhor, o 3 de paus ou o 2 de ouros? Uma tem o valor mais alto, mas a outra tem um naipe mais alto. Para comparar cartas, \u00e9 preciso decidir o que \u00e9 mais importante, o valor ou o naipe. A resposta pode depender de que jogo voc\u00ea est\u00e1 jogando, mas, para manter a simplicidade, vamos fazer a escolha arbitr\u00e1ria de que o naipe \u00e9 mais importante, ent\u00e3o todas as cartas de espadas s\u00e3o mais importantes que as de ouros, e assim por diante. Com isto decidido, podemos escrever __lt__ : # dentro da classe Card: def __lt__(self, other): # conferir os naipes if self.suit < other.suit: return True if self.suit > other.suit: return False # os naipes s\u00e3o os mesmos... conferir valores return self.rank < other.rank Voc\u00ea pode escrever isso de forma mais concisa usando uma compara\u00e7\u00e3o de tuplas: # dentro da classe Card: def __lt__(self, other): t1 = self.suit, self.rank t2 = other.suit, other.rank return t1 < t2 Como exerc\u00edcio, escreva um m\u00e9todo __lt__ para objetos Time. Voc\u00ea pode usar uma compara\u00e7\u00e3o de tuplas, mas tamb\u00e9m pode usar a compara\u00e7\u00e3o de n\u00fameros inteiros.","title":"18.3 - Compara\u00e7\u00e3o de cartas"},{"location":"18-heranca/#184-baralhos","text":"Agora que temos Card, o pr\u00f3ximo passo \u00e9 definir Deck (baralho). Como um baralho \u00e9 composto de cartas, \u00e9 natural que um baralho contenha uma lista de cartas como atributo. Veja a seguir uma defini\u00e7\u00e3o de classe para Deck . O m\u00e9todo init cria o atributo cards e gera o conjunto padr\u00e3o de 52 cartas: class Deck: def __init__(self): self.cards = [] for suit in range(4): for rank in range(1, 14): card = Card(suit, rank) self.cards.append(card) A forma mais f\u00e1cil de preencher o baralho \u00e9 com um loop aninhado. O loop exterior enumera os naipes de 0 a 3. O loop interior enumera os valores de 1 a 13. Cada itera\u00e7\u00e3o cria um novo Card com o naipe e valor atual, e a acrescenta a self.cards.","title":"18.4 - Baralhos"},{"location":"18-heranca/#185-exibicao-do-baralho","text":"Aqui est\u00e1 um m\u00e9todo str para Deck: # dentro da classe Deck: def __str__(self): res = [] for card in self.cards: res.append(str(card)) return '\\n'.join(res) Este m\u00e9todo demonstra uma forma eficiente de acumular uma string grande: a cria\u00e7\u00e3o de uma lista de strings e a utiliza\u00e7\u00e3o do m\u00e9todo de string join. A fun\u00e7\u00e3o integrada str invoca o m\u00e9todo __str__ em cada carta e retorna a representa\u00e7\u00e3o da string. Como invocamos join em um caractere newline, as cartas s\u00e3o separadas por quebras de linha. O resultado \u00e9 esse: >>> deck = Deck() >>> print(deck) Ace of Clubs 2 of Clubs 3 of Clubs ... 10 of Spades Jack of Spades Queen of Spades King of Spades Embora o resultado apare\u00e7a em 52 linhas, na verdade ele \u00e9 uma string longa com quebras de linha.","title":"18.5 - Exibi\u00e7\u00e3o do baralho"},{"location":"18-heranca/#186-adicao-remocao-embaralhamento-e-classificacao","text":"Para lidar com as cartas, gostar\u00edamos de ter um m\u00e9todo que removesse uma carta do baralho e a devolvesse. O m\u00e9todo de lista pop oferece uma forma conveniente de fazer isso: # dentro da classe Deck: def pop_card(self): return self.cards.pop() Como pop retira a \u00faltima carta na lista, estamos lidando com o fundo do baralho. Para adicionar uma carta, podemos usar o m\u00e9todo de lista append: # dentro da classe Deck: def add_card(self, card): self.cards.append(card) Um m\u00e9todo como esse, que usa outro m\u00e9todo sem dar muito trabalho, \u00e0s vezes \u00e9 chamado de folheado. A met\u00e1fora vem do trabalho em madeira, onde o folheado \u00e9 uma camada fina de madeira de boa qualidade colada \u00e0 superf\u00edcie de uma madeira mais barata para melhorar a apar\u00eancia. Nesse caso, add_card \u00e9 um m\u00e9todo \u201cfino\u201d que expressa uma opera\u00e7\u00e3o de lista em termos adequados a baralhos. Ele melhora a apar\u00eancia ou interface da implementa\u00e7\u00e3o. Em outro exemplo, podemos escrever um m\u00e9todo Deck denominado shuffle, usando a fun\u00e7\u00e3o shuffle do m\u00f3dulo random: # dentro da classe Deck: def shuffle(self): random.shuffle(self.cards) N\u00e3o se esque\u00e7a de importar random. Como exerc\u00edcio, escreva um m\u00e9todo de Deck chamado sort, que use o m\u00e9todo de lista sort para classificar as cartas em um Deck. sort usa o m\u00e9todo __lt__ que definimos para determinar a ordem.","title":"18.6 - Adi\u00e7\u00e3o, remo\u00e7\u00e3o, embaralhamento e classifica\u00e7\u00e3o"},{"location":"18-heranca/#187-heranca","text":"A heran\u00e7a \u00e9 a capacidade de definir uma nova classe que seja uma vers\u00e3o modificada de uma classe existente. Como exemplo, digamos que queremos que uma classe represente uma \u201cm\u00e3o\u201d, isto \u00e9, as cartas mantidas por um jogador. Uma m\u00e3o \u00e9 semelhante a um baralho: ambos s\u00e3o compostos por uma cole\u00e7\u00e3o de cartas, e ambos exigem opera\u00e7\u00f5es como adicionar e remover cartas. Uma m\u00e3o tamb\u00e9m \u00e9 diferente de um baralho; h\u00e1 opera\u00e7\u00f5es que queremos para m\u00e3os que n\u00e3o fazem sentido para um baralho. Por exemplo, no p\u00f4quer poder\u00edamos comparar duas m\u00e3os para ver qual ganha. No bridge, poder\u00edamos calcular a pontua\u00e7\u00e3o de uma m\u00e3o para fazer uma aposta. Essa rela\u00e7\u00e3o entre classes \u2013 semelhante, mas diferente \u2013 adequa-se \u00e0 heran\u00e7a. Para definir uma nova classe que herda algo de uma classe existente, basta colocar o nome da classe existente entre par\u00eanteses: class Hand(Deck): \"\"\"Represents a hand of playing cards.\"\"\" Esta defini\u00e7\u00e3o indica que Hand herda de Deck; isso significa que podemos usar m\u00e9todos como pop_card e add_card para Hand bem como para Deck. Quando uma nova classe herda de uma existente, a existente chama-se pai e a nova classe chama-se filho. Neste exemplo, Hand herda __init__ de Deck, mas na verdade n\u00e3o faz o que queremos: em vez de preencher a m\u00e3o com 52 cartas novas, o m\u00e9todo init de Hand deve inicializar card com uma lista vazia. Se fornecermos um m\u00e9todo init na classe Hand, ele ignora o da classe Deck: # dentro da classe Hand: def __init__(self, label=''): self.cards = [] self.label = label Ao criar Hand, o Python invoca este m\u00e9todo init, n\u00e3o o de Deck. >>> hand = Hand('new hand') >>> hand.cards [] >>> hand.label 'new hand' Outros m\u00e9todos s\u00e3o herdados de Deck, portanto podemos usar pop_card e add_card para lidar com uma carta: >>> deck = Deck() >>> card = deck.pop_card() >>> hand.add_card(card) >>> print(hand) King of Spades Um pr\u00f3ximo passo natural seria encapsular este c\u00f3digo em um m\u00e9todo chamado move_cards : # dentro da classe Deck: def move_cards(self, hand, num): for i in range(num): hand.add_card(self.pop_card()) move_cards recebe dois argumentos, um objeto Hand e o n\u00famero de cartas com que vai lidar. Ele altera tanto self como hand e retorna None. Em alguns jogos, as cartas s\u00e3o movidas de uma m\u00e3o a outra, ou de uma m\u00e3o de volta ao baralho. \u00c9 poss\u00edvel usar move_cards para algumas dessas opera\u00e7\u00f5es: self pode ser um Deck ou Hand, e hand, apesar do nome, tamb\u00e9m pode ser um Deck. A heran\u00e7a \u00e9 um recurso \u00fatil. Alguns programas que poderiam ser repetitivos sem heran\u00e7a podem ser escritos de forma mais elegante com ela. A heran\u00e7a pode facilitar a reutiliza\u00e7\u00e3o de c\u00f3digo, j\u00e1 que voc\u00ea pode personalizar o comportamento de classes pais sem ter que alter\u00e1-las. Em alguns casos, a estrutura de heran\u00e7a reflete a estrutura natural do problema, o que torna o projeto mais f\u00e1cil de entender. De outro lado, a heran\u00e7a pode tornar os programas dif\u00edceis de ler. Quando um m\u00e9todo \u00e9 invocado, \u00e0s vezes n\u00e3o est\u00e1 claro onde encontrar sua defini\u00e7\u00e3o. O c\u00f3digo relevante pode ser espalhado por v\u00e1rios m\u00f3dulos. Al\u00e9m disso, muitas das coisas que podem ser feitas usando a heran\u00e7a podem ser feitas sem elas, \u00e0s vezes, at\u00e9 de forma melhor.","title":"18.7 - Heran\u00e7a"},{"location":"18-heranca/#188-diagramas-de-classe","text":"Por enquanto vimos diagramas de pilha, que mostram o estado de um programa e diagramas de objeto, que mostram os atributos de um objeto e seus valores. Esses diagramas representam um retrato da execu\u00e7\u00e3o de um programa, ent\u00e3o eles mudam no decorrer da execu\u00e7\u00e3o do programa. Eles tamb\u00e9m s\u00e3o altamente detalhados; para alguns objetivos, detalhados demais. Um diagrama de classe \u00e9 uma representa\u00e7\u00e3o mais abstrata da estrutura de um programa. Em vez de mostrar objetos individuais, ele mostra classes e as rela\u00e7\u00f5es entre elas. H\u00e1 v\u00e1rios tipos de rela\u00e7\u00f5es entre as classes: Os objetos de uma classe podem conter refer\u00eancias a objetos em outra classe. Por exemplo, cada Rectangle cont\u00e9m uma refer\u00eancia a um Point, e cada Deck cont\u00e9m refer\u00eancias a muitos Cards. Esse tipo de rela\u00e7\u00e3o chama-se composi\u00e7\u00e3o. \u00c9 uma rela\u00e7\u00e3o do tipo HAS-A (tem um), com a ideia de \u201cum Rectangle tem um Point\u201d. Uma classe pode herdar de outra. Esta rela\u00e7\u00e3o chama-se IS-A (\u00e9 um), com a ideia de \u201cum Hand \u00e9 um tipo de Deck\u201d. Uma classe pode depender de outra no sentido de que os objetos em uma classe possam receber objetos na segunda classe como par\u00e2metros ou usar esses objetos como parte de um c\u00e1lculo. Este tipo de rela\u00e7\u00e3o chama-se depend\u00eancia. Um diagrama de classe \u00e9 uma representa\u00e7\u00e3o gr\u00e1fica dessas rela\u00e7\u00f5es. Por exemplo, a Figura 18.2 mostra as rela\u00e7\u00f5es entre Card, Deck e Hand. Figura 18.2 \u2013 Diagrama de classes. A flecha com um tri\u00e2ngulo oco representa uma rela\u00e7\u00e3o IS-A; nesse caso, indica que Hand herda de Deck. A ponta de flecha padr\u00e3o representa uma rela\u00e7\u00e3o HAS-A; nesse caso, um Deck tem refer\u00eancias a objetos Card. A estrela * perto da ponta de flecha indica a multiplicidade; ela indica quantos Cards um Deck tem. Uma multiplicidade pode ser um n\u00famero simples como 52, um intervalo como 5..7 ou uma estrela, que indica que um Deck pode ter qualquer n\u00famero de Cards. N\u00e3o h\u00e1 nenhuma depend\u00eancia neste diagrama. Elas normalmente apareceriam com uma flecha tracejada. Ou, se houver muitas depend\u00eancias, \u00e0s vezes elas s\u00e3o omitidas. Um diagrama mais detalhado poderia mostrar que um Deck na verdade cont\u00e9m uma lista de Cards, mas os tipos integrados como lista e dict n\u00e3o s\u00e3o normalmente inclu\u00eddos em diagramas de classe.","title":"18.8 - Diagramas de classe"},{"location":"18-heranca/#189-encapsulamento-de-dados","text":"Os cap\u00edtulos anteriores demonstram um plano de desenvolvimento que poder\u00edamos chamar de \u201cprojeto orientado a objeto\u201d. Identificamos os objetos de que precisamos \u2013 como Point, Rectangle e Time \u2013 e definimos classes para represent\u00e1-los. Em cada caso h\u00e1 uma correspond\u00eancia \u00f3bvia entre o objeto e alguma entidade no mundo real (ou, pelo menos, no mundo matem\u00e1tico). Mas, \u00e0s vezes, \u00e9 menos \u00f3bvio quais objetos voc\u00ea precisa e como eles devem interagir. Nesse caso \u00e9 necess\u00e1rio um plano de desenvolvimento diferente. Da mesma forma em que descobrimos interfaces de fun\u00e7\u00e3o por encapsulamento e generaliza\u00e7\u00e3o, podemos descobrir interfaces de classe por encapsulamento de dados. A an\u00e1lise de Markov, de \u201cAn\u00e1lise de Markov\u201d, na p\u00e1gina 200, apresenta um bom exemplo. Se baixar o meu c\u00f3digo em http://thinkpython2.com/code/markov.py, voc\u00ea vai ver que ele usa duas vari\u00e1veis globais \u2013 suffix_map e prefix \u2013 que s\u00e3o lidas e escritas a partir de v\u00e1rias fun\u00e7\u00f5es. suffix_map = {} prefix = () Como essas vari\u00e1veis s\u00e3o globais, s\u00f3 podemos executar uma an\u00e1lise de cada vez. Se lermos dois textos, seus prefixos e sufixos seriam acrescentados \u00e0s mesmas estruturas de dados (o que geraria textos interessantes). Para executar an\u00e1lises m\u00faltiplas e guard\u00e1-las separadamente, podemos encapsular o estado de cada an\u00e1lise em um objeto. \u00c9 assim que fica: class Markov: def __init__(self): self.suffix_map = {} self.prefix = () Em seguida, transformamos as fun\u00e7\u00f5es em m\u00e9todos. Por exemplo, aqui est\u00e1 process_word: def process_word(self, word, order=2): if len(self.prefix) < order: self.prefix += (word,) return try: self.suffix_map[self.prefix].append(word) except KeyError: # se n\u00e3o houver entradas deste prefixo, crie uma. self.suffix_map[self.prefix] = [word] self.prefix = shift(self.prefix, word) Transformar um programa como esse \u2013 alterando o projeto sem mudar o comportamento \u2013 \u00e9 outro exemplo de refatora\u00e7\u00e3o (veja \u201cRefatora\u00e7\u00e3o\u201d, na p\u00e1gina 70). Este exemplo sugere um plano de desenvolvimento para projetar objetos e m\u00e9todos: Comece escrevendo fun\u00e7\u00f5es que leiam e criem vari\u00e1veis globais (quando necess\u00e1rio). Uma vez que o programa esteja funcionando, procure associa\u00e7\u00f5es entre vari\u00e1veis globais e fun\u00e7\u00f5es que as usem. Encapsule vari\u00e1veis relacionadas como atributos de objeto. Transforme as fun\u00e7\u00f5es associadas em m\u00e9todos da nova classe. Como exerc\u00edcio, baixe o meu c\u00f3digo de Markov de http://thinkpython2.com/code/markov.py e siga os passos descritos acima para encapsular as vari\u00e1veis globais como atributos de uma nova classe chamada Markov. Solu\u00e7\u00e3o: http://thinkpython2.com/code/Markov.py (observe o M mai\u00fasculo).","title":"18.9 - Encapsulamento de dados"},{"location":"18-heranca/#1810-depuracao","text":"A heran\u00e7a pode dificultar a depura\u00e7\u00e3o porque quando voc\u00ea invoca um m\u00e9todo em um objeto, pode ser dif\u00edcil compreender qual m\u00e9todo ser\u00e1 invocado. Suponha que esteja escrevendo uma fun\u00e7\u00e3o que funcione com objetos Hand. Voc\u00ea gostaria que ela funcionasse com todos os tipos de Hand, como PokerHands, BridgeHands etc. Se invocar um m\u00e9todo como shuffle, poder\u00e1 receber o que foi definido em Deck, mas se alguma das subclasses ignorar este m\u00e9todo, voc\u00ea receber\u00e1 outra vers\u00e3o. Este comportamento pode ser bom, mas tamb\u00e9m confuso. A qualquer momento em que n\u00e3o esteja seguro a respeito do fluxo de execu\u00e7\u00e3o do seu programa, a solu\u00e7\u00e3o mais simples \u00e9 acrescentar instru\u00e7\u00f5es de exibi\u00e7\u00e3o no in\u00edcio dos m\u00e9todos em quest\u00e3o. Se Deck.shuffle exibir uma mensagem que diz algo como Running Deck.shuffle, ent\u00e3o no decorrer da execu\u00e7\u00e3o do programa ele monitora seu fluxo. Uma alternativa \u00e9 usar esta fun\u00e7\u00e3o, que recebe um objeto e um nome de m\u00e9todo (como uma string) e retorna a classe que fornece a defini\u00e7\u00e3o do m\u00e9todo: def find_defining_class(obj, meth_name): for ty in type(obj).mro(): if meth_name in ty.__dict__: return ty Aqui est\u00e1 um exemplo: >>> hand = Hand() >>> find_defining_class(hand, 'shuffle') <class 'Card.Deck'> Ent\u00e3o o m\u00e9todo shuffle deste Hand \u00e9 o de Deck. find_defining_class usa o m\u00e9todo mro para obter a lista de objetos de classe (tipos) onde os m\u00e9todos ser\u00e3o procurados. \u201cMRO\u201d significa \u201cordem de resolu\u00e7\u00e3o do m\u00e9todo\u201d, que \u00e9 a sequ\u00eancia de classes que o Python pesquisa para \u201cdescobrir\u201d um nome de m\u00e9todo. Aqui est\u00e1 uma sugest\u00e3o de projeto: quando voc\u00ea ignora um m\u00e9todo, a interface do novo m\u00e9todo deve ser a mesma que a do antigo. Ela deve receber os mesmos par\u00e2metros, retornar o mesmo tipo e obedecer \u00e0s mesmas precondi\u00e7\u00f5es e p\u00f3s-condi\u00e7\u00f5es. Se seguir esta regra, voc\u00ea descobrir\u00e1 que qualquer fun\u00e7\u00e3o projetada para funcionar com uma inst\u00e2ncia de uma classe pai, como Deck, tamb\u00e9m funcionar\u00e1 com inst\u00e2ncias de classes filho como Hand e PokerHand. Se violar esta regra, o que se chama de \u201cprinc\u00edpio de substitui\u00e7\u00e3o de Liskov\u201d, seu c\u00f3digo cair\u00e1 como (desculpe) um castelo de cartas.","title":"18.10 - Depura\u00e7\u00e3o"},{"location":"18-heranca/#1811-glossario","text":"codificar Representar um conjunto de valores usando outro conjunto de valores construindo um mapeamento entre eles. atributo de classe Atributo associado a um objeto de classe. Os atributos de classe s\u00e3o definidos dentro de uma defini\u00e7\u00e3o de classe, mas fora de qualquer m\u00e9todo. atributo de inst\u00e2ncia Atributo associado a uma inst\u00e2ncia de uma classe. folheado M\u00e9todo ou fun\u00e7\u00e3o que apresenta uma interface diferente para outra fun\u00e7\u00e3o sem fazer muitos c\u00e1lculos. heran\u00e7a Capacidade de definir uma nova classe que seja uma vers\u00e3o modificada de uma classe definida anteriormente. classe-pai Classe da qual uma classe-filho herda. classe-filho Nova classe criada por heran\u00e7a de uma classe existente; tamb\u00e9m chamada de \u201csubclasse\u201d. rela\u00e7\u00e3o IS-A Rela\u00e7\u00e3o entre uma classe-filho e sua classe-pai. Tamb\u00e9m chamada de heran\u00e7a. rela\u00e7\u00e3o HAS-A Rela\u00e7\u00e3o entre duas classes onde as inst\u00e2ncias de uma classe cont\u00eam refer\u00eancias a inst\u00e2ncias da outra. Tamb\u00e9m chamada de composi\u00e7\u00e3o. depend\u00eancia Rela\u00e7\u00e3o entre duas classes onde as inst\u00e2ncias de uma classe usam inst\u00e2ncias de outra classe, mas n\u00e3o as guardam como atributos. diagrama de classe Diagrama que mostra as classes em um programa e as rela\u00e7\u00f5es entre elas. multiplicidade Nota\u00e7\u00e3o em um diagrama de classe que mostra, para uma rela\u00e7\u00e3o HAS-A, quantas refer\u00eancias a inst\u00e2ncias da outra classe podem existir. encapsulamento de dados Plano de desenvolvimento de programa que envolve um prot\u00f3tipo usando vari\u00e1veis globais e uma vers\u00e3o final que transforma as vari\u00e1veis globais em atributos de inst\u00e2ncia.","title":"18.11 - Gloss\u00e1rio"},{"location":"18-heranca/#1812-exercicios","text":"","title":"18.12 - Exerc\u00edcios"},{"location":"18-heranca/#exercicio-181","text":"Para o seguinte programa, desenhe um diagrama de classe UML que mostre estas classes e as rela\u00e7\u00f5es entre elas. class PingPongParent: pass class Ping(PingPongParent): def __init__(self, pong): self.pong = pong class Pong(PingPongParent): def __init__(self, pings=None): if pings is None: self.pings = [] else: self.pings = pings def add_ping(self, ping): self.pings.append(ping) pong = Pong() ping = Ping(pong) pong.add_ping(ping)","title":"Exerc\u00edcio 18.1"},{"location":"18-heranca/#exercicio-182","text":"Escreva um m\u00e9todo Deck chamado deal_hands que receba dois par\u00e2metros: o n\u00famero de m\u00e3os e o n\u00famero de cartas por m\u00e3o. Ele deve criar o n\u00famero adequado de objetos Hand, lidar com o n\u00famero adequado de cartas por m\u00e3o e retornar uma lista de Hands.","title":"Exerc\u00edcio 18.2"},{"location":"18-heranca/#exercicio-183","text":"A seguir, as m\u00e3os poss\u00edveis no p\u00f4quer, em ordem crescente de valor e ordem decrescente de probabilidade: par Duas cartas com o mesmo valor. dois pares Dois pares de cartas com o mesmo valor. trinca Tr\u00eas cartas com o mesmo valor. sequ\u00eancia Cinco cartas com valores em sequ\u00eancia (os ases podem ser altos ou baixos, ent\u00e3o Ace-2-3-4-5 \u00e9 uma sequ\u00eancia, assim como 10-Jack-Queen-King-Ace, mas Queen-King-Ace-2-3 n\u00e3o \u00e9.) flush Cinco cartas com o mesmo naipe. full house Tr\u00eas cartas com um valor, duas cartas com outro. quadra Quatro cartas com o mesmo valor. straight flush Cinco cartas em sequ\u00eancia (como definido acima) e com o mesmo naipe. A meta desses exerc\u00edcios \u00e9 estimar a probabilidade de ter estas v\u00e1rias m\u00e3os. Baixe os seguintes arquivos de http://thinkpython2.com/code: Card.py : Vers\u00e3o completa das classes Card, Deck e Hand deste cap\u00edtulo. PokerHand.py : Uma implementa\u00e7\u00e3o incompleta de uma classe que representa uma m\u00e3o de p\u00f4quer e c\u00f3digo para test\u00e1-la. Se executar PokerHand.py, voc\u00ea ver\u00e1 que o programa cria m\u00e3os de p\u00f4quer com 7 cartas e verifica se alguma delas cont\u00e9m um flush. Leia este c\u00f3digo com aten\u00e7\u00e3o antes de continuar. Acrescente m\u00e9todos a PokerHand.py chamados has_pair , has_twopair , etc. que retornem True ou False conforme a m\u00e3o cumpra os crit\u00e9rios em quest\u00e3o. Seu c\u00f3digo deve funcionar corretamente para \u201cm\u00e3os\u201d que contenham qualquer n\u00famero de cartas (embora 5 e 7 sejam as quantidades mais comuns). Escreva um m\u00e9todo chamado classify que descubra a classifica\u00e7\u00e3o do valor mais alto para uma m\u00e3o e estabele\u00e7a o atributo label em quest\u00e3o. Por exemplo, uma m\u00e3o de 7 cartas poderia conter um flush e um par; ela deve ser marcada como \u201cflush\u201d. Quando se convencer de que os seus m\u00e9todos de classifica\u00e7\u00e3o est\u00e3o funcionando, o pr\u00f3ximo passo deve ser estimar as probabilidades de v\u00e1rias m\u00e3os. Escreva uma fun\u00e7\u00e3o em PokerHand.py que embaralhe cartas, divida-as em m\u00e3os, classifique as m\u00e3os e conte o n\u00famero de vezes em que v\u00e1rias classifica\u00e7\u00f5es aparecem. Exiba uma tabela das classifica\u00e7\u00f5es e suas probabilidades. Execute seu programa com n\u00fameros cada vez maiores de m\u00e3os at\u00e9 que os valores de sa\u00edda convirjam a um grau razo\u00e1vel de exatid\u00e3o. Compare seus resultados com os valores em http://en.wikipedia.org/wiki/Hand_rankings. Solu\u00e7\u00e3o: http://thinkpython2.com/code/PokerHandSoln.py.","title":"Exerc\u00edcio 18.3"},{"location":"19-extra/","text":"Cap\u00edtulo 19: Extra Uma das minhas metas com este livro \u00e9 ensinar o m\u00ednimo poss\u00edvel de Python. Quando havia duas formas de fazer algo, escolhia uma e evitava mencionar a outra. Ou, \u00e0s vezes, usava a segunda como exerc\u00edcio. Agora quero voltar a algumas coisas boas que ficaram para tr\u00e1s. O Python oferece v\u00e1rios recursos que n\u00e3o s\u00e3o realmente necess\u00e1rios \u2013 voc\u00ea pode escrever um bom c\u00f3digo sem eles \u2013 mas com eles \u00e9 poss\u00edvel escrever um c\u00f3digo mais conciso, leg\u00edvel ou eficiente e, \u00e0s vezes, todos os tr\u00eas. 19.1 - Express\u00f5es condicionais Vimos instru\u00e7\u00f5es condicionais em \u201cExecu\u00e7\u00e3o condicional\u201d, na p\u00e1gina 78. As instru\u00e7\u00f5es condicionais muitas vezes s\u00e3o usadas para escolher um entre dois valores; por exemplo: if x > 0: y = math.log(x) else: y = float('nan') Esta instru\u00e7\u00e3o verifica se x \u00e9 positivo. Nesse caso, ela calcula math.log. Do contr\u00e1rio, math.log causaria um ValueError. Para evitar interromper o programa, geramos um \u201cNaN\u201d, que \u00e9 um valor de ponto flutuante especial que representa um \u201cN\u00e3o n\u00famero\u201d. Podemos escrever essa instru\u00e7\u00e3o de forma mais concisa usando uma express\u00e3o condicional: y = math.log(x) if x > 0 else float('nan') Voc\u00ea quase pode ler esta linha como se tivesse sido escrita em ingl\u00eas: \u201cy recebe log-x se x for maior que 0; do contr\u00e1rio, ele recebe NaN\u201d. As fun\u00e7\u00f5es recursivas por vezes podem ser reescritas usando express\u00f5es condicionais. Por exemplo, aqui est\u00e1 uma vers\u00e3o recursiva de factorial: def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) Podemos reescrev\u00ea-la assim: def factorial(n): return 1 if n == 0 else n * factorial(n-1) Outro uso de express\u00f5es condicionais \u00e9 lidar com argumentos opcionais. Por exemplo, aqui est\u00e1 o m\u00e9todo init de GoodKangaroo (veja o Exerc\u00edcio 17.2): def __init__(self, name, contents=None): self.name = name if contents == None: contents = [] self.pouch_contents = contents Podemos reescrev\u00ea-lo assim: def __init__(self, name, contents=None): self.name = name self.pouch_contents = [] if contents == None else contents Em geral, \u00e9 poss\u00edvel substituir uma instru\u00e7\u00e3o condicional por uma express\u00e3o condicional se ambos os ramos contiverem express\u00f5es simples que sejam retornadas ou atribu\u00eddas \u00e0 mesma vari\u00e1vel. 19.2 - Abrang\u00eancia de listas Em \u201cMapeamento, filtragem e redu\u00e7\u00e3o\u201d, na p\u00e1gina 147, vimos os padr\u00f5es de filtragem e mapeamento. Por exemplo, esta fun\u00e7\u00e3o toma uma lista de strings, mapeia o m\u00e9todo de string capitalize aos elementos, e retorna uma nova lista de strings: def capitalize_all(t): res = [] for s in t: res.append(s.capitalize()) return res Podemos escrever isso de forma mais concisa usando abrang\u00eancia de listas (list comprehension): def capitalize_all(t): return [s.capitalize() for s in t] Os operadores de colchete indicam que estamos construindo uma nova lista. A express\u00e3o dentro dos colchetes especifica os elementos da lista, e a cl\u00e1usula for indica qual sequ\u00eancia estamos atravessando. A sintaxe da abrang\u00eancia de listas \u00e9 um pouco esquisita porque a vari\u00e1vel de loop, s nesse exemplo, aparece na express\u00e3o antes de chegarmos \u00e0 defini\u00e7\u00e3o. Abrang\u00eancias de listas tamb\u00e9m podem ser usadas para filtragem. Por exemplo, esta fun\u00e7\u00e3o s\u00f3 seleciona os elementos de t que s\u00e3o mai\u00fasculos, e retorna uma nova lista: def only_upper(t): res = [] for s in t: if s.isupper(): res.append(s) return res Podemos reescrev\u00ea-la usando abrang\u00eancia de listas: def only_upper(t): return [s for s in t if s.isupper()] Abrang\u00eancias de listas s\u00e3o concisas e f\u00e1ceis de ler, pelo menos para express\u00f5es simples. E s\u00e3o normalmente mais r\u00e1pidas que os loops for equivalentes, \u00e0s vezes muito mais r\u00e1pidas. Ent\u00e3o, se voc\u00ea ficar irritado comigo por n\u00e3o ter mencionado isso antes, eu entendo. Por\u00e9m, em minha defesa, as abrang\u00eancias de listas s\u00e3o mais dif\u00edceis de depurar porque n\u00e3o \u00e9 poss\u00edvel ter instru\u00e7\u00f5es de exibi\u00e7\u00e3o dentro do loop. Sugiro que voc\u00ea as use s\u00f3 se o c\u00e1lculo for simples o suficiente para que acerte j\u00e1 de primeira. E para principiantes isso significa nunca. 19.3 - Express\u00f5es geradoras Express\u00f5es geradoras s\u00e3o semelhantes \u00e0s abrang\u00eancias de listas, mas com par\u00eanteses em vez de colchetes: >>> g = (x**2 for x in range(5)) >>> g <generator object <genexpr> at 0x7f4c45a786c0> O resultado \u00e9 um objeto gerador que sabe como fazer itera\u00e7\u00f5es por uma sequ\u00eancia de valores. No entanto, ao contr\u00e1rio de uma abrang\u00eancia de listas, ele n\u00e3o calcula todos os valores de uma vez; espera pelo pedido. A fun\u00e7\u00e3o integrada next recebe o pr\u00f3ximo valor do gerador: >>> next(g) 0 >>> next(g) 1 Quando voc\u00ea chega no fim da sequ\u00eancia, next cria uma exce\u00e7\u00e3o StopIteration. Tamb\u00e9m \u00e9 poss\u00edvel usar um loop for para fazer a itera\u00e7\u00e3o pelos valores: >>> for val in g: ... print(val) 4 9 16 O objeto gerador monitora a posi\u00e7\u00e3o em que est\u00e1 na sequ\u00eancia, portanto o loop for continua de onde next parou. Uma vez que o gerador se esgotar, ele continua criando StopException: >>> next(g) StopIteration As express\u00f5es geradoras muitas vezes s\u00e3o usadas com fun\u00e7\u00f5es como sum, max e min: >>> sum(x**2 for x in range(5)) 30 19.4 - any e all O Python tem uma fun\u00e7\u00e3o integrada, any, que recebe uma sequ\u00eancia de valores booleanos e retorna True se algum dos valores for True. Ela funciona em listas: >>> any([False, False, True]) True Entretanto, muitas vezes \u00e9 usada com express\u00f5es geradoras: >>> any(letter == 't' for letter in 'monty') True Esse exemplo n\u00e3o \u00e9 muito \u00fatil porque faz a mesma coisa que o operador in. Por\u00e9m, podemos usar any para reescrever algumas das fun\u00e7\u00f5es de pesquisa que escrevemos em \u201cBusca\u201d, na p\u00e1gina 136. Por exemplo, poder\u00edamos escrever avoids dessa forma: def avoids(word, forbidden): return not any(letter in forbidden for letter in word) A fun\u00e7\u00e3o quase pode ser lida como uma frase em ingl\u00eas: \u201cword evita forbidden se n\u00e3o houver nenhuma letra proibida em word\u201d. Usar any com uma express\u00e3o geradora \u00e9 eficiente porque ela retorna imediatamente se encontrar um valor True, ent\u00e3o n\u00e3o \u00e9 preciso avaliar a sequ\u00eancia inteira. O Python oferece outra fun\u00e7\u00e3o integrada, all , que retorna True se todos os elementos da sequ\u00eancia forem True. Como exerc\u00edcio, use all para reescrever uses_all de \u201cBusca\u201d, na p\u00e1gina 136. 19.5 - Conjuntos Na se\u00e7\u00e3o \u201cSubtra\u00e7\u00e3o de dicion\u00e1rio\u201d, da p\u00e1gina 198, uso dicion\u00e1rios para encontrar as palavras que aparecem em um documento, mas n\u00e3o numa lista de palavras. A fun\u00e7\u00e3o que escrevi recebe d1, que cont\u00e9m as palavras do documento como chaves e d2, que cont\u00e9m a lista de palavras. Ela retorna um dicion\u00e1rio que cont\u00e9m as chaves de d1 que n\u00e3o est\u00e3o em d2: def subtract(d1, d2): res = dict() for key in d1: if key not in d2: res[key] = None return res Em todos esses dicion\u00e1rios, os valores n\u00e3o s\u00e3o None porque nunca os usamos. O resultado \u00e9 que desperdi\u00e7amos espa\u00e7o de armazenamento. O Python fornece outro tipo integrado, chamado set (conjunto), que se comporta como uma cole\u00e7\u00e3o de chaves de dicion\u00e1rio sem valores. Acrescentar elementos a um conjunto \u00e9 r\u00e1pido; assim como verificar a ades\u00e3o. E os conjuntos fornecem m\u00e9todos e operadores para calcular opera\u00e7\u00f5es de conjuntos. Por exemplo, a subtra\u00e7\u00e3o de conjuntos est\u00e1 dispon\u00edvel como um m\u00e9todo chamado difference ou como um operador, -. Portanto, podemos reescrever subtract desta forma: def subtract(d1, d2): return set(d1) - set(d2) O resultado \u00e9 um conjunto em vez de um dicion\u00e1rio, mas, para opera\u00e7\u00f5es como itera\u00e7\u00e3o, o comportamento \u00e9 o mesmo. Alguns exerc\u00edcios neste livro podem ser feitos de forma concisa e eficiente com conjuntos. Por exemplo, aqui est\u00e1 uma solu\u00e7\u00e3o para has_duplicates, do Exerc\u00edcio 10.7, que usa um dicion\u00e1rio: def has_duplicates(t): d = {} for x in t: if x in d: return True d[x] = True return False Quando um elemento aparece pela primeira vez, ele \u00e9 acrescentado ao dicion\u00e1rio. Se o mesmo elemento aparece novamente, a fun\u00e7\u00e3o retorna True. Usando conjuntos, podemos escrever a mesma fun\u00e7\u00e3o dessa forma: def has_duplicates(t): return len(set(t)) < len(t) Um elemento s\u00f3 pode aparecer em um conjunto uma vez, portanto, se um elemento em t aparecer mais de uma vez, o conjunto ser\u00e1 menor que t. Se n\u00e3o houver duplicatas, o conjunto ter\u00e1 o mesmo tamanho que t. Tamb\u00e9m podemos usar conjuntos para fazer alguns exerc\u00edcios no Cap\u00edtulo 9. Por exemplo, aqui est\u00e1 uma vers\u00e3o de uses_only com um loop: def uses_only(word, available): for letter in word: if letter not in available: return False return True uses_only verifica se todas as cartas em word est\u00e3o em available. Podemos reescrev\u00ea-la assim: def uses_only(word, available): return set(word) <= set(available) O operador <= verifica se um conjunto \u00e9 um subconjunto ou outro, incluindo a possibilidade de que sejam iguais, o que \u00e9 verdade se todas as letras de word aparecerem em available. Como exerc\u00edcio, reescreva avoids usando conjuntos. 19.6 - Contadores Um contador \u00e9 como um conjunto, exceto que se um elemento aparecer mais de uma vez, o contador registra quantas vezes ele aparece. Se tiver familiaridade com a ideia matem\u00e1tica de um multiconjunto (multiset), um contador \u00e9 uma forma natural de representar um multiconjunto. Contadores s\u00e3o definidos em um m\u00f3dulo padr\u00e3o chamado collections , portanto \u00e9 preciso import\u00e1-lo. Voc\u00ea pode inicializar um contador com uma string, lista ou alguma outra coisa que seja compat\u00edvel com itera\u00e7\u00e3o: >>> from collections import Counter >>> count = Counter('parrot') >>> count Counter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1}) Os contadores comportam-se como dicion\u00e1rios de muitas formas; eles mapeiam cada chave ao n\u00famero de vezes que aparece. Como em dicion\u00e1rios, as chaves t\u00eam de ser hashable. Ao contr\u00e1rio de dicion\u00e1rios, os contadores n\u00e3o causam uma exce\u00e7\u00e3o se voc\u00ea acessar um elemento que n\u00e3o aparece. Em vez disso, retornam 0: >>> count['d'] 0 Podemos usar contadores para reescrever is_anagram do Exerc\u00edcio 10.6: def is_anagram(word1, word2): return Counter(word1) == Counter(word2) Se duas palavras forem anagramas, elas cont\u00eam as mesmas letras com as mesmas contagens, ent\u00e3o seus contadores s\u00e3o equivalentes. Os contadores oferecem m\u00e9todos e operadores para executar opera\u00e7\u00f5es similares \u00e0s dos conjuntos, incluindo adi\u00e7\u00e3o, subtra\u00e7\u00e3o, uni\u00e3o e intersec\u00e7\u00e3o. E eles fornecem um m\u00e9todo muitas vezes \u00fatil, most_common, que retorna uma lista de pares frequ\u00eancia-valor, organizados do mais ao menos comum: >>> count = Counter('parrot') >>> for val, freq in count.most_common(3): ... print(val, freq) r 2 p 1 a 1 19.7 - defaultdict O m\u00f3dulo collections tamb\u00e9m tem defaultdict , que se parece com um dicion\u00e1rio, exceto pelo fato de que se voc\u00ea acessar uma chave que n\u00e3o existe, um novo valor pode ser gerado automaticamente. Quando voc\u00ea cria um defaultdict, fornece uma fun\u00e7\u00e3o usada para criar valores. Uma fun\u00e7\u00e3o usada para criar objetos \u00e0s vezes \u00e9 chamada de factory (f\u00e1brica). As fun\u00e7\u00f5es integradas que criam listas, conjuntos e outros tipos podem ser usadas como f\u00e1bricas: >>> from collections import defaultdict >>> d = defaultdict(list) Note que o argumento \u00e9 list, que \u00e9 um objeto de classe, n\u00e3o list(), que \u00e9 uma nova lista. A fun\u00e7\u00e3o que voc\u00ea fornece n\u00e3o \u00e9 chamada a menos que voc\u00ea acesse uma chave que n\u00e3o existe: >>> t = d['new key'] >>> t [] A nova lista, que estamos chamando de t, tamb\u00e9m \u00e9 adicionada ao dicion\u00e1rio. Ent\u00e3o, se alterarmos t, a mudan\u00e7a aparece em d: >>> t.append('new value') >>> d defaultdict(<class 'list'>, {'new key': ['new value']}) Se estiver fazendo um dicion\u00e1rio de listas, voc\u00ea pode escrever um c\u00f3digo mais simples usando defaultdict. Na minha solu\u00e7\u00e3o para o Exerc\u00edcio 12.2, que voc\u00ea pode ver em http://thinkpython2.com/code/anagram_sets.py, fa\u00e7o um dicion\u00e1rio que mapeia uma string organizada de letras a uma lista de palavras que pode ser soletrada com essas letras. Por exemplo, 'opst' mapeia para a lista ['opts', 'post', 'pots', 'spot', 'stop', 'tops'] . Aqui est\u00e1 o c\u00f3digo original: def all_anagrams(filename): d = {} for line in open(filename): word = line.strip().lower() t = signature(word) if t not in d: d[t] = [word] else: d[t].append(word) return d Isso pode ser simplificado usando setdefault, que voc\u00ea poderia ter usado no Exerc\u00edcio 11.2: def all_anagrams(filename): d = {} for line in open(filename): word = line.strip().lower() t = signature(word) d.setdefault(t, []).append(word) return d O problema dessa solu\u00e7\u00e3o \u00e9 que ela faz uma lista nova a cada vez, mesmo que n\u00e3o seja necess\u00e1rio. Para listas, isso n\u00e3o \u00e9 grande coisa, mas se a fun\u00e7\u00e3o f\u00e1brica for complicada, poderia ser. Podemos evitar este problema e simplificar o c\u00f3digo usando um defaultdict: def all_anagrams(filename): d = defaultdict(list) for line in open(filename): word = line.strip().lower() t = signature(word) d[t].append(word) return d A minha solu\u00e7\u00e3o para o Exerc\u00edcio 18.3, que voc\u00ea pode baixar em http://thinkpython2.com/code/PokerHandSoln.py, usa setdefault na fun\u00e7\u00e3o has_straightflush . O problema dessa solu\u00e7\u00e3o \u00e9 criar um objeto Hand cada vez que passa pelo loop, seja ele necess\u00e1rio ou n\u00e3o. Como exerc\u00edcio, reescreva-a usando um defaultdict. 19.8 - Tuplas nomeadas Muitos objetos simples s\u00e3o basicamente cole\u00e7\u00f5es de valores relacionados. Por exemplo, o objeto Point, definido no Cap\u00edtulo 15, cont\u00e9m dois n\u00fameros, x e y. Ao definir uma classe como essa, normalmente voc\u00ea come\u00e7a com um m\u00e9todo init e um m\u00e9todo str: class Point: def __init__(self, x=0, y=0): self.x = x self.y = y def __str__(self): return '(%g, %g)' % (self.x, self.y) \u00c9 muito c\u00f3digo para transmitir pouca informa\u00e7\u00e3o. O Python tem uma forma mais concisa de dizer a mesma coisa: from collections import namedtuple Point = namedtuple('Point', ['x', 'y']) O primeiro argumento \u00e9 o nome da classe que voc\u00ea quer criar. O segundo \u00e9 uma lista dos atributos que o objeto Point deve ter, como strings. O valor de retorno de namedtuple \u00e9 um objeto de classe: >>> Point <class '__main__.Point'> Point fornece automaticamente m\u00e9todos como __init__ e __str__ ent\u00e3o n\u00e3o \u00e9 preciso escrev\u00ea-los. Para criar um objeto Point, voc\u00ea usa a classe Point como uma fun\u00e7\u00e3o: >>> p = Point(1, 2) >>> p Point(x=1, y=2) O m\u00e9todo __init__ atribui os argumentos a atributos usando os nomes que voc\u00ea forneceu. O m\u00e9todo __str__ exibe uma representa\u00e7\u00e3o do objeto Point e seus atributos. Voc\u00ea pode acessar os elementos da tupla nomeada pelo nome: >>> p.x, p.y (1, 2) Mas tamb\u00e9m pode tratar uma tupla nomeada como uma tupla: >>> p[0], p[1] (1, 2) >>> x, y = p >>> x, y (1, 2) Tuplas nomeadas fornecem uma forma r\u00e1pida de definir classes simples. O problema \u00e9 que classes simples n\u00e3o ficam sempre simples. Mais adiante voc\u00ea poder\u00e1 decidir que quer acrescentar m\u00e9todos a uma tupla nomeada. Nesse caso, voc\u00ea poder\u00e1 definir uma nova classe que herde da tupla nomeada: class Pointier(Point): # adicionar mais m\u00e9todos aqui Ou poder\u00e1 mudar para uma defini\u00e7\u00e3o de classe convencional. 19.9 - Reunindo argumentos de palavra-chave Em \u201cTuplas com argumentos de comprimento vari\u00e1vel\u201d, na p\u00e1gina 181, vimos como escrever uma fun\u00e7\u00e3o que re\u00fane seus argumentos em uma tupla: def printall(*args): print(args) Voc\u00ea pode chamar esta fun\u00e7\u00e3o com qualquer n\u00famero de argumentos posicionais (isto \u00e9, argumentos que n\u00e3o t\u00eam palavras-chave): >>> printall(1, 2.0, '3') (1, 2.0, '3') Por\u00e9m, o operador * n\u00e3o re\u00fane argumentos de palavra-chave: >>> printall(1, 2.0, third='3') TypeError: printall() got an unexpected keyword argument 'third' Para reunir argumentos de palavra-chave, voc\u00ea pode usar o operador ** : def printall(*args, **kwargs): print(args, kwargs) Voc\u00ea pode chamar o par\u00e2metro de coleta de palavra-chave, como quiser, mas kwargs \u00e9 uma escolha comum. O resultado \u00e9 um dicion\u00e1rio que mapeia palavras-chave a valores: >>> printall(1, 2.0, third='3') (1, 2.0) {'third': '3'} Se tiver um dicion\u00e1rio de palavras-chave e valores, pode usar o operador de dispers\u00e3o, ** , para chamar uma fun\u00e7\u00e3o: >>> d = dict(x=1, y=2) >>> Point(**d) Point(x=1, y=2) Sem o operador de dispers\u00e3o, a fun\u00e7\u00e3o trataria d como um \u00fanico argumento posicional, e ent\u00e3o atribuiria d a x e se queixaria porque n\u00e3o h\u00e1 nada para atribuir a y: >>> d = dict(x=1, y=2) >>> Point(d) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: __new__() missing 1 required positional argument: 'y' Quando estiver trabalhando com fun\u00e7\u00f5es com um grande n\u00famero de par\u00e2metros, muitas vezes \u00e9 \u00fatil criar dicion\u00e1rios e pass\u00e1-los como argumentos para especificar as op\u00e7\u00f5es usadas com maior frequ\u00eancia. 19.10 - Gloss\u00e1rio express\u00e3o condicional Express\u00e3o que cont\u00e9m um de dois valores, dependendo de uma condi\u00e7\u00e3o. abrang\u00eancia de lista (list comprehension) Express\u00e3o com um loop for entre colchetes que produz uma nova lista. express\u00e3o geradora Uma express\u00e3o com um loop for entre par\u00eanteses que produz um objeto gerador. multiconjunto Entidade matem\u00e1tica que representa um mapeamento entre os elementos de um conjunto e o n\u00famero de vezes que aparecem. f\u00e1brica (factory) Fun\u00e7\u00e3o normalmente passada como par\u00e2metro, usada para criar objetos. 19.11 - Exerc\u00edcios Exerc\u00edcio 19.1 Esta \u00e9 uma fun\u00e7\u00e3o que calcula o coeficiente binominal recursivamente: def binomial_coeff(n, k): \"\"\"Compute the binomial coefficient \"n choose k\". n: number of trials k: number of successes returns: int \"\"\" if k == 0: return 1 if n == 0: return 0 res = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1) return res Reescreva o corpo da fun\u00e7\u00e3o usando express\u00f5es condicionais aninhadas. Uma observa\u00e7\u00e3o: esta fun\u00e7\u00e3o n\u00e3o \u00e9 muito eficiente porque acaba calculando os mesmos valores v\u00e1rias vezes. Voc\u00ea pode torn\u00e1-lo mais eficiente com memos (veja \u201cMemos\u201d, na p\u00e1gina 169). No entanto, vai ver que \u00e9 mais dif\u00edcil usar memos se escrev\u00ea-la usando express\u00f5es condicionais.","title":"Cap\u00edtulo 19: Extra"},{"location":"19-extra/#capitulo-19-extra","text":"Uma das minhas metas com este livro \u00e9 ensinar o m\u00ednimo poss\u00edvel de Python. Quando havia duas formas de fazer algo, escolhia uma e evitava mencionar a outra. Ou, \u00e0s vezes, usava a segunda como exerc\u00edcio. Agora quero voltar a algumas coisas boas que ficaram para tr\u00e1s. O Python oferece v\u00e1rios recursos que n\u00e3o s\u00e3o realmente necess\u00e1rios \u2013 voc\u00ea pode escrever um bom c\u00f3digo sem eles \u2013 mas com eles \u00e9 poss\u00edvel escrever um c\u00f3digo mais conciso, leg\u00edvel ou eficiente e, \u00e0s vezes, todos os tr\u00eas.","title":"Cap\u00edtulo 19: Extra"},{"location":"19-extra/#191-expressoes-condicionais","text":"Vimos instru\u00e7\u00f5es condicionais em \u201cExecu\u00e7\u00e3o condicional\u201d, na p\u00e1gina 78. As instru\u00e7\u00f5es condicionais muitas vezes s\u00e3o usadas para escolher um entre dois valores; por exemplo: if x > 0: y = math.log(x) else: y = float('nan') Esta instru\u00e7\u00e3o verifica se x \u00e9 positivo. Nesse caso, ela calcula math.log. Do contr\u00e1rio, math.log causaria um ValueError. Para evitar interromper o programa, geramos um \u201cNaN\u201d, que \u00e9 um valor de ponto flutuante especial que representa um \u201cN\u00e3o n\u00famero\u201d. Podemos escrever essa instru\u00e7\u00e3o de forma mais concisa usando uma express\u00e3o condicional: y = math.log(x) if x > 0 else float('nan') Voc\u00ea quase pode ler esta linha como se tivesse sido escrita em ingl\u00eas: \u201cy recebe log-x se x for maior que 0; do contr\u00e1rio, ele recebe NaN\u201d. As fun\u00e7\u00f5es recursivas por vezes podem ser reescritas usando express\u00f5es condicionais. Por exemplo, aqui est\u00e1 uma vers\u00e3o recursiva de factorial: def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) Podemos reescrev\u00ea-la assim: def factorial(n): return 1 if n == 0 else n * factorial(n-1) Outro uso de express\u00f5es condicionais \u00e9 lidar com argumentos opcionais. Por exemplo, aqui est\u00e1 o m\u00e9todo init de GoodKangaroo (veja o Exerc\u00edcio 17.2): def __init__(self, name, contents=None): self.name = name if contents == None: contents = [] self.pouch_contents = contents Podemos reescrev\u00ea-lo assim: def __init__(self, name, contents=None): self.name = name self.pouch_contents = [] if contents == None else contents Em geral, \u00e9 poss\u00edvel substituir uma instru\u00e7\u00e3o condicional por uma express\u00e3o condicional se ambos os ramos contiverem express\u00f5es simples que sejam retornadas ou atribu\u00eddas \u00e0 mesma vari\u00e1vel.","title":"19.1 - Express\u00f5es condicionais"},{"location":"19-extra/#192-abrangencia-de-listas","text":"Em \u201cMapeamento, filtragem e redu\u00e7\u00e3o\u201d, na p\u00e1gina 147, vimos os padr\u00f5es de filtragem e mapeamento. Por exemplo, esta fun\u00e7\u00e3o toma uma lista de strings, mapeia o m\u00e9todo de string capitalize aos elementos, e retorna uma nova lista de strings: def capitalize_all(t): res = [] for s in t: res.append(s.capitalize()) return res Podemos escrever isso de forma mais concisa usando abrang\u00eancia de listas (list comprehension): def capitalize_all(t): return [s.capitalize() for s in t] Os operadores de colchete indicam que estamos construindo uma nova lista. A express\u00e3o dentro dos colchetes especifica os elementos da lista, e a cl\u00e1usula for indica qual sequ\u00eancia estamos atravessando. A sintaxe da abrang\u00eancia de listas \u00e9 um pouco esquisita porque a vari\u00e1vel de loop, s nesse exemplo, aparece na express\u00e3o antes de chegarmos \u00e0 defini\u00e7\u00e3o. Abrang\u00eancias de listas tamb\u00e9m podem ser usadas para filtragem. Por exemplo, esta fun\u00e7\u00e3o s\u00f3 seleciona os elementos de t que s\u00e3o mai\u00fasculos, e retorna uma nova lista: def only_upper(t): res = [] for s in t: if s.isupper(): res.append(s) return res Podemos reescrev\u00ea-la usando abrang\u00eancia de listas: def only_upper(t): return [s for s in t if s.isupper()] Abrang\u00eancias de listas s\u00e3o concisas e f\u00e1ceis de ler, pelo menos para express\u00f5es simples. E s\u00e3o normalmente mais r\u00e1pidas que os loops for equivalentes, \u00e0s vezes muito mais r\u00e1pidas. Ent\u00e3o, se voc\u00ea ficar irritado comigo por n\u00e3o ter mencionado isso antes, eu entendo. Por\u00e9m, em minha defesa, as abrang\u00eancias de listas s\u00e3o mais dif\u00edceis de depurar porque n\u00e3o \u00e9 poss\u00edvel ter instru\u00e7\u00f5es de exibi\u00e7\u00e3o dentro do loop. Sugiro que voc\u00ea as use s\u00f3 se o c\u00e1lculo for simples o suficiente para que acerte j\u00e1 de primeira. E para principiantes isso significa nunca.","title":"19.2 - Abrang\u00eancia de listas"},{"location":"19-extra/#193-expressoes-geradoras","text":"Express\u00f5es geradoras s\u00e3o semelhantes \u00e0s abrang\u00eancias de listas, mas com par\u00eanteses em vez de colchetes: >>> g = (x**2 for x in range(5)) >>> g <generator object <genexpr> at 0x7f4c45a786c0> O resultado \u00e9 um objeto gerador que sabe como fazer itera\u00e7\u00f5es por uma sequ\u00eancia de valores. No entanto, ao contr\u00e1rio de uma abrang\u00eancia de listas, ele n\u00e3o calcula todos os valores de uma vez; espera pelo pedido. A fun\u00e7\u00e3o integrada next recebe o pr\u00f3ximo valor do gerador: >>> next(g) 0 >>> next(g) 1 Quando voc\u00ea chega no fim da sequ\u00eancia, next cria uma exce\u00e7\u00e3o StopIteration. Tamb\u00e9m \u00e9 poss\u00edvel usar um loop for para fazer a itera\u00e7\u00e3o pelos valores: >>> for val in g: ... print(val) 4 9 16 O objeto gerador monitora a posi\u00e7\u00e3o em que est\u00e1 na sequ\u00eancia, portanto o loop for continua de onde next parou. Uma vez que o gerador se esgotar, ele continua criando StopException: >>> next(g) StopIteration As express\u00f5es geradoras muitas vezes s\u00e3o usadas com fun\u00e7\u00f5es como sum, max e min: >>> sum(x**2 for x in range(5)) 30","title":"19.3 - Express\u00f5es geradoras"},{"location":"19-extra/#194-any-e-all","text":"O Python tem uma fun\u00e7\u00e3o integrada, any, que recebe uma sequ\u00eancia de valores booleanos e retorna True se algum dos valores for True. Ela funciona em listas: >>> any([False, False, True]) True Entretanto, muitas vezes \u00e9 usada com express\u00f5es geradoras: >>> any(letter == 't' for letter in 'monty') True Esse exemplo n\u00e3o \u00e9 muito \u00fatil porque faz a mesma coisa que o operador in. Por\u00e9m, podemos usar any para reescrever algumas das fun\u00e7\u00f5es de pesquisa que escrevemos em \u201cBusca\u201d, na p\u00e1gina 136. Por exemplo, poder\u00edamos escrever avoids dessa forma: def avoids(word, forbidden): return not any(letter in forbidden for letter in word) A fun\u00e7\u00e3o quase pode ser lida como uma frase em ingl\u00eas: \u201cword evita forbidden se n\u00e3o houver nenhuma letra proibida em word\u201d. Usar any com uma express\u00e3o geradora \u00e9 eficiente porque ela retorna imediatamente se encontrar um valor True, ent\u00e3o n\u00e3o \u00e9 preciso avaliar a sequ\u00eancia inteira. O Python oferece outra fun\u00e7\u00e3o integrada, all , que retorna True se todos os elementos da sequ\u00eancia forem True. Como exerc\u00edcio, use all para reescrever uses_all de \u201cBusca\u201d, na p\u00e1gina 136.","title":"19.4 - any e all"},{"location":"19-extra/#195-conjuntos","text":"Na se\u00e7\u00e3o \u201cSubtra\u00e7\u00e3o de dicion\u00e1rio\u201d, da p\u00e1gina 198, uso dicion\u00e1rios para encontrar as palavras que aparecem em um documento, mas n\u00e3o numa lista de palavras. A fun\u00e7\u00e3o que escrevi recebe d1, que cont\u00e9m as palavras do documento como chaves e d2, que cont\u00e9m a lista de palavras. Ela retorna um dicion\u00e1rio que cont\u00e9m as chaves de d1 que n\u00e3o est\u00e3o em d2: def subtract(d1, d2): res = dict() for key in d1: if key not in d2: res[key] = None return res Em todos esses dicion\u00e1rios, os valores n\u00e3o s\u00e3o None porque nunca os usamos. O resultado \u00e9 que desperdi\u00e7amos espa\u00e7o de armazenamento. O Python fornece outro tipo integrado, chamado set (conjunto), que se comporta como uma cole\u00e7\u00e3o de chaves de dicion\u00e1rio sem valores. Acrescentar elementos a um conjunto \u00e9 r\u00e1pido; assim como verificar a ades\u00e3o. E os conjuntos fornecem m\u00e9todos e operadores para calcular opera\u00e7\u00f5es de conjuntos. Por exemplo, a subtra\u00e7\u00e3o de conjuntos est\u00e1 dispon\u00edvel como um m\u00e9todo chamado difference ou como um operador, -. Portanto, podemos reescrever subtract desta forma: def subtract(d1, d2): return set(d1) - set(d2) O resultado \u00e9 um conjunto em vez de um dicion\u00e1rio, mas, para opera\u00e7\u00f5es como itera\u00e7\u00e3o, o comportamento \u00e9 o mesmo. Alguns exerc\u00edcios neste livro podem ser feitos de forma concisa e eficiente com conjuntos. Por exemplo, aqui est\u00e1 uma solu\u00e7\u00e3o para has_duplicates, do Exerc\u00edcio 10.7, que usa um dicion\u00e1rio: def has_duplicates(t): d = {} for x in t: if x in d: return True d[x] = True return False Quando um elemento aparece pela primeira vez, ele \u00e9 acrescentado ao dicion\u00e1rio. Se o mesmo elemento aparece novamente, a fun\u00e7\u00e3o retorna True. Usando conjuntos, podemos escrever a mesma fun\u00e7\u00e3o dessa forma: def has_duplicates(t): return len(set(t)) < len(t) Um elemento s\u00f3 pode aparecer em um conjunto uma vez, portanto, se um elemento em t aparecer mais de uma vez, o conjunto ser\u00e1 menor que t. Se n\u00e3o houver duplicatas, o conjunto ter\u00e1 o mesmo tamanho que t. Tamb\u00e9m podemos usar conjuntos para fazer alguns exerc\u00edcios no Cap\u00edtulo 9. Por exemplo, aqui est\u00e1 uma vers\u00e3o de uses_only com um loop: def uses_only(word, available): for letter in word: if letter not in available: return False return True uses_only verifica se todas as cartas em word est\u00e3o em available. Podemos reescrev\u00ea-la assim: def uses_only(word, available): return set(word) <= set(available) O operador <= verifica se um conjunto \u00e9 um subconjunto ou outro, incluindo a possibilidade de que sejam iguais, o que \u00e9 verdade se todas as letras de word aparecerem em available. Como exerc\u00edcio, reescreva avoids usando conjuntos.","title":"19.5 - Conjuntos"},{"location":"19-extra/#196-contadores","text":"Um contador \u00e9 como um conjunto, exceto que se um elemento aparecer mais de uma vez, o contador registra quantas vezes ele aparece. Se tiver familiaridade com a ideia matem\u00e1tica de um multiconjunto (multiset), um contador \u00e9 uma forma natural de representar um multiconjunto. Contadores s\u00e3o definidos em um m\u00f3dulo padr\u00e3o chamado collections , portanto \u00e9 preciso import\u00e1-lo. Voc\u00ea pode inicializar um contador com uma string, lista ou alguma outra coisa que seja compat\u00edvel com itera\u00e7\u00e3o: >>> from collections import Counter >>> count = Counter('parrot') >>> count Counter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1}) Os contadores comportam-se como dicion\u00e1rios de muitas formas; eles mapeiam cada chave ao n\u00famero de vezes que aparece. Como em dicion\u00e1rios, as chaves t\u00eam de ser hashable. Ao contr\u00e1rio de dicion\u00e1rios, os contadores n\u00e3o causam uma exce\u00e7\u00e3o se voc\u00ea acessar um elemento que n\u00e3o aparece. Em vez disso, retornam 0: >>> count['d'] 0 Podemos usar contadores para reescrever is_anagram do Exerc\u00edcio 10.6: def is_anagram(word1, word2): return Counter(word1) == Counter(word2) Se duas palavras forem anagramas, elas cont\u00eam as mesmas letras com as mesmas contagens, ent\u00e3o seus contadores s\u00e3o equivalentes. Os contadores oferecem m\u00e9todos e operadores para executar opera\u00e7\u00f5es similares \u00e0s dos conjuntos, incluindo adi\u00e7\u00e3o, subtra\u00e7\u00e3o, uni\u00e3o e intersec\u00e7\u00e3o. E eles fornecem um m\u00e9todo muitas vezes \u00fatil, most_common, que retorna uma lista de pares frequ\u00eancia-valor, organizados do mais ao menos comum: >>> count = Counter('parrot') >>> for val, freq in count.most_common(3): ... print(val, freq) r 2 p 1 a 1","title":"19.6 - Contadores"},{"location":"19-extra/#197-defaultdict","text":"O m\u00f3dulo collections tamb\u00e9m tem defaultdict , que se parece com um dicion\u00e1rio, exceto pelo fato de que se voc\u00ea acessar uma chave que n\u00e3o existe, um novo valor pode ser gerado automaticamente. Quando voc\u00ea cria um defaultdict, fornece uma fun\u00e7\u00e3o usada para criar valores. Uma fun\u00e7\u00e3o usada para criar objetos \u00e0s vezes \u00e9 chamada de factory (f\u00e1brica). As fun\u00e7\u00f5es integradas que criam listas, conjuntos e outros tipos podem ser usadas como f\u00e1bricas: >>> from collections import defaultdict >>> d = defaultdict(list) Note que o argumento \u00e9 list, que \u00e9 um objeto de classe, n\u00e3o list(), que \u00e9 uma nova lista. A fun\u00e7\u00e3o que voc\u00ea fornece n\u00e3o \u00e9 chamada a menos que voc\u00ea acesse uma chave que n\u00e3o existe: >>> t = d['new key'] >>> t [] A nova lista, que estamos chamando de t, tamb\u00e9m \u00e9 adicionada ao dicion\u00e1rio. Ent\u00e3o, se alterarmos t, a mudan\u00e7a aparece em d: >>> t.append('new value') >>> d defaultdict(<class 'list'>, {'new key': ['new value']}) Se estiver fazendo um dicion\u00e1rio de listas, voc\u00ea pode escrever um c\u00f3digo mais simples usando defaultdict. Na minha solu\u00e7\u00e3o para o Exerc\u00edcio 12.2, que voc\u00ea pode ver em http://thinkpython2.com/code/anagram_sets.py, fa\u00e7o um dicion\u00e1rio que mapeia uma string organizada de letras a uma lista de palavras que pode ser soletrada com essas letras. Por exemplo, 'opst' mapeia para a lista ['opts', 'post', 'pots', 'spot', 'stop', 'tops'] . Aqui est\u00e1 o c\u00f3digo original: def all_anagrams(filename): d = {} for line in open(filename): word = line.strip().lower() t = signature(word) if t not in d: d[t] = [word] else: d[t].append(word) return d Isso pode ser simplificado usando setdefault, que voc\u00ea poderia ter usado no Exerc\u00edcio 11.2: def all_anagrams(filename): d = {} for line in open(filename): word = line.strip().lower() t = signature(word) d.setdefault(t, []).append(word) return d O problema dessa solu\u00e7\u00e3o \u00e9 que ela faz uma lista nova a cada vez, mesmo que n\u00e3o seja necess\u00e1rio. Para listas, isso n\u00e3o \u00e9 grande coisa, mas se a fun\u00e7\u00e3o f\u00e1brica for complicada, poderia ser. Podemos evitar este problema e simplificar o c\u00f3digo usando um defaultdict: def all_anagrams(filename): d = defaultdict(list) for line in open(filename): word = line.strip().lower() t = signature(word) d[t].append(word) return d A minha solu\u00e7\u00e3o para o Exerc\u00edcio 18.3, que voc\u00ea pode baixar em http://thinkpython2.com/code/PokerHandSoln.py, usa setdefault na fun\u00e7\u00e3o has_straightflush . O problema dessa solu\u00e7\u00e3o \u00e9 criar um objeto Hand cada vez que passa pelo loop, seja ele necess\u00e1rio ou n\u00e3o. Como exerc\u00edcio, reescreva-a usando um defaultdict.","title":"19.7 - defaultdict"},{"location":"19-extra/#198-tuplas-nomeadas","text":"Muitos objetos simples s\u00e3o basicamente cole\u00e7\u00f5es de valores relacionados. Por exemplo, o objeto Point, definido no Cap\u00edtulo 15, cont\u00e9m dois n\u00fameros, x e y. Ao definir uma classe como essa, normalmente voc\u00ea come\u00e7a com um m\u00e9todo init e um m\u00e9todo str: class Point: def __init__(self, x=0, y=0): self.x = x self.y = y def __str__(self): return '(%g, %g)' % (self.x, self.y) \u00c9 muito c\u00f3digo para transmitir pouca informa\u00e7\u00e3o. O Python tem uma forma mais concisa de dizer a mesma coisa: from collections import namedtuple Point = namedtuple('Point', ['x', 'y']) O primeiro argumento \u00e9 o nome da classe que voc\u00ea quer criar. O segundo \u00e9 uma lista dos atributos que o objeto Point deve ter, como strings. O valor de retorno de namedtuple \u00e9 um objeto de classe: >>> Point <class '__main__.Point'> Point fornece automaticamente m\u00e9todos como __init__ e __str__ ent\u00e3o n\u00e3o \u00e9 preciso escrev\u00ea-los. Para criar um objeto Point, voc\u00ea usa a classe Point como uma fun\u00e7\u00e3o: >>> p = Point(1, 2) >>> p Point(x=1, y=2) O m\u00e9todo __init__ atribui os argumentos a atributos usando os nomes que voc\u00ea forneceu. O m\u00e9todo __str__ exibe uma representa\u00e7\u00e3o do objeto Point e seus atributos. Voc\u00ea pode acessar os elementos da tupla nomeada pelo nome: >>> p.x, p.y (1, 2) Mas tamb\u00e9m pode tratar uma tupla nomeada como uma tupla: >>> p[0], p[1] (1, 2) >>> x, y = p >>> x, y (1, 2) Tuplas nomeadas fornecem uma forma r\u00e1pida de definir classes simples. O problema \u00e9 que classes simples n\u00e3o ficam sempre simples. Mais adiante voc\u00ea poder\u00e1 decidir que quer acrescentar m\u00e9todos a uma tupla nomeada. Nesse caso, voc\u00ea poder\u00e1 definir uma nova classe que herde da tupla nomeada: class Pointier(Point): # adicionar mais m\u00e9todos aqui Ou poder\u00e1 mudar para uma defini\u00e7\u00e3o de classe convencional.","title":"19.8 - Tuplas nomeadas"},{"location":"19-extra/#199-reunindo-argumentos-de-palavra-chave","text":"Em \u201cTuplas com argumentos de comprimento vari\u00e1vel\u201d, na p\u00e1gina 181, vimos como escrever uma fun\u00e7\u00e3o que re\u00fane seus argumentos em uma tupla: def printall(*args): print(args) Voc\u00ea pode chamar esta fun\u00e7\u00e3o com qualquer n\u00famero de argumentos posicionais (isto \u00e9, argumentos que n\u00e3o t\u00eam palavras-chave): >>> printall(1, 2.0, '3') (1, 2.0, '3') Por\u00e9m, o operador * n\u00e3o re\u00fane argumentos de palavra-chave: >>> printall(1, 2.0, third='3') TypeError: printall() got an unexpected keyword argument 'third' Para reunir argumentos de palavra-chave, voc\u00ea pode usar o operador ** : def printall(*args, **kwargs): print(args, kwargs) Voc\u00ea pode chamar o par\u00e2metro de coleta de palavra-chave, como quiser, mas kwargs \u00e9 uma escolha comum. O resultado \u00e9 um dicion\u00e1rio que mapeia palavras-chave a valores: >>> printall(1, 2.0, third='3') (1, 2.0) {'third': '3'} Se tiver um dicion\u00e1rio de palavras-chave e valores, pode usar o operador de dispers\u00e3o, ** , para chamar uma fun\u00e7\u00e3o: >>> d = dict(x=1, y=2) >>> Point(**d) Point(x=1, y=2) Sem o operador de dispers\u00e3o, a fun\u00e7\u00e3o trataria d como um \u00fanico argumento posicional, e ent\u00e3o atribuiria d a x e se queixaria porque n\u00e3o h\u00e1 nada para atribuir a y: >>> d = dict(x=1, y=2) >>> Point(d) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: __new__() missing 1 required positional argument: 'y' Quando estiver trabalhando com fun\u00e7\u00f5es com um grande n\u00famero de par\u00e2metros, muitas vezes \u00e9 \u00fatil criar dicion\u00e1rios e pass\u00e1-los como argumentos para especificar as op\u00e7\u00f5es usadas com maior frequ\u00eancia.","title":"19.9 - Reunindo argumentos de palavra-chave"},{"location":"19-extra/#1910-glossario","text":"express\u00e3o condicional Express\u00e3o que cont\u00e9m um de dois valores, dependendo de uma condi\u00e7\u00e3o. abrang\u00eancia de lista (list comprehension) Express\u00e3o com um loop for entre colchetes que produz uma nova lista. express\u00e3o geradora Uma express\u00e3o com um loop for entre par\u00eanteses que produz um objeto gerador. multiconjunto Entidade matem\u00e1tica que representa um mapeamento entre os elementos de um conjunto e o n\u00famero de vezes que aparecem. f\u00e1brica (factory) Fun\u00e7\u00e3o normalmente passada como par\u00e2metro, usada para criar objetos.","title":"19.10 - Gloss\u00e1rio"},{"location":"19-extra/#1911-exercicios","text":"","title":"19.11 - Exerc\u00edcios"},{"location":"19-extra/#exercicio-191","text":"Esta \u00e9 uma fun\u00e7\u00e3o que calcula o coeficiente binominal recursivamente: def binomial_coeff(n, k): \"\"\"Compute the binomial coefficient \"n choose k\". n: number of trials k: number of successes returns: int \"\"\" if k == 0: return 1 if n == 0: return 0 res = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1) return res Reescreva o corpo da fun\u00e7\u00e3o usando express\u00f5es condicionais aninhadas. Uma observa\u00e7\u00e3o: esta fun\u00e7\u00e3o n\u00e3o \u00e9 muito eficiente porque acaba calculando os mesmos valores v\u00e1rias vezes. Voc\u00ea pode torn\u00e1-lo mais eficiente com memos (veja \u201cMemos\u201d, na p\u00e1gina 169). No entanto, vai ver que \u00e9 mais dif\u00edcil usar memos se escrev\u00ea-la usando express\u00f5es condicionais.","title":"Exerc\u00edcio 19.1"},{"location":"A-depuracao/","text":"Ap\u00eandice A: Depura\u00e7\u00e3o Durante a depura\u00e7\u00e3o, voc\u00ea deve distinguir entre tipos diferentes de erros para rastre\u00e1-los mais rapidamente: Erros de sintaxe s\u00e3o descobertos pelo interpretador quando ele est\u00e1 traduzindo o c\u00f3digo-fonte para c\u00f3digo de bytes. Eles indicam que h\u00e1 algo errado com a estrutura do programa. Exemplo: a omiss\u00e3o dos dois pontos no fim de uma instru\u00e7\u00e3o def gera a mensagem um tanto redundante SyntaxError: invalid syntax. Erros de tempo de execu\u00e7\u00e3o s\u00e3o produzidos pelo interpretador se algo der errado durante a execu\u00e7\u00e3o do programa. A maior parte das mensagens de erro de tempo de execu\u00e7\u00e3o inclui informa\u00e7\u00f5es sobre onde o erro ocorreu e o que as fun\u00e7\u00f5es estavam fazendo. Exemplo: a recursividade infinita eventualmente leva ao erro de tempo de execu\u00e7\u00e3o maximum recursion depth exceeded. Erros sem\u00e2nticos s\u00e3o problemas com um programa que \u00e9 executado sem produzir mensagens de erro, mas que n\u00e3o faz a coisa certa. Exemplo: uma express\u00e3o que n\u00e3o pode ser avaliada na ordem esperada, produzindo um resultado incorreto. O primeiro passo da depura\u00e7\u00e3o \u00e9 compreender com que tipo de erro voc\u00ea est\u00e1 lidando. Embora as pr\u00f3ximas se\u00e7\u00f5es sejam organizadas pelo tipo de erro, algumas t\u00e9cnicas s\u00e3o aplic\u00e1veis em mais de uma situa\u00e7\u00e3o. A.1 - Erros de sintaxe Os erros de sintaxe normalmente s\u00e3o f\u00e1ceis de corrigir, uma vez que voc\u00ea descubra quais s\u00e3o. Infelizmente, as mensagens de erro muitas vezes n\u00e3o s\u00e3o \u00fateis. As mensagens mais comuns s\u00e3o SyntaxError: invalid syntax e SyntaxError: invalid token, e nenhuma das duas \u00e9 muito informativa. Por outro lado, a mensagem diz onde no programa o problema ocorreu. E, na verdade, diz a voc\u00ea onde o Python notou um problema, que \u00e9 n\u00e3o necessariamente onde o erro est\u00e1. \u00c0s vezes, o erro est\u00e1 antes da posi\u00e7\u00e3o da mensagem de erro, muitas vezes na linha precedente. Se estiver construindo o programa incrementalmente, voc\u00ea ter\u00e1 uma boa ideia sobre onde encontrar o erro. Estar\u00e1 na \u00faltima linha que acrescentou. Se estiver copiando o c\u00f3digo de um livro, comece comparando com aten\u00e7\u00e3o o seu c\u00f3digo e o do livro. Verifique cada caractere. Ao mesmo tempo, lembre-se de que o livro pode estar errado, ent\u00e3o, se vir algo que parece um erro de sintaxe, pode ser mesmo. Aqui est\u00e3o algumas formas de evitar os erros de sintaxe mais comuns: Confira se n\u00e3o est\u00e1 usando uma palavra-chave do Python para um nome de vari\u00e1vel. Verifique se h\u00e1 dois pontos no fim do cabe\u00e7alho de cada instru\u00e7\u00e3o composta, incluindo instru\u00e7\u00f5es for, while, if e def. Confira se as strings no c\u00f3digo t\u00eam as aspas correspondentes. Verifique se todas as aspas s\u00e3o retas, em vez de curvas. Se tiver strings com v\u00e1rias linhas com aspas triplas (simples ou duplas), confira se fechou a string adequadamente. Uma string n\u00e3o fechada pode causar um erro de invalid token no fim do seu programa, ou pode tratar a parte seguinte do programa como uma string at\u00e9 chegar \u00e0 string seguinte. No segundo caso, o programa pode nem produzir uma mensagem de erro! Um operador inicial aberto \u2013 ( , { ou [ \u2013 faz o Python continuar at\u00e9 a linha seguinte, como se esta fosse parte da instru\u00e7\u00e3o atual. Geralmente, um erro ocorre quase imediatamente na linha seguinte. Confira se h\u00e1 o cl\u00e1ssico = em vez do == dentro de uma condicional. Verifique a endenta\u00e7\u00e3o para ter certeza de que est\u00e1 alinhada como deveria. O Python pode lidar com espa\u00e7os e tabula\u00e7\u00f5es, mas, se mistur\u00e1-los, isso pode causar problemas. A melhor forma de evitar esse problema \u00e9 usar um editor de texto que identifique o Python e gere endenta\u00e7\u00e3o consistente. Se h\u00e1 caracteres n\u00e3o ASCII no c\u00f3digo (incluindo strings e coment\u00e1rios), isso pode causar problemas, embora o Python 3 normalmente lide com caracteres n\u00e3o ASCII. Tenha cuidado se colar texto de uma p\u00e1gina web ou outra fonte. Se nada funcionar, v\u00e1 para a pr\u00f3xima se\u00e7\u00e3o... A.1.1 - Continuo fazendo altera\u00e7\u00f5es e n\u00e3o faz nenhuma diferen\u00e7a Se o interpretador disser que h\u00e1 um erro e voc\u00ea n\u00e3o o encontra, pode ser que voc\u00ea e o interpretador n\u00e3o estejam olhando para o mesmo c\u00f3digo. Verifique o seu ambiente de programa\u00e7\u00e3o para ter certeza de que o programa que est\u00e1 editando \u00e9 o mesmo que o Python est\u00e1 tentando executar. Se n\u00e3o estiver certo, tente p\u00f4r um erro de sintaxe \u00f3bvio e deliberado no in\u00edcio do programa. Agora execute-o novamente. Se o interpretador n\u00e3o encontrar o novo erro, voc\u00ea n\u00e3o est\u00e1 executando o novo c\u00f3digo. H\u00e1 alguns culpados prov\u00e1veis: Voc\u00ea editou o arquivo e esqueceu de salvar as altera\u00e7\u00f5es antes de execut\u00e1-lo novamente. Alguns ambientes de programa\u00e7\u00e3o fazem isso para voc\u00ea, mas alguns n\u00e3o fazem. Voc\u00ea mudou o nome do arquivo, mas ainda est\u00e1 executando o nome antigo. Algo no seu ambiente de desenvolvimento est\u00e1 configurado incorretamente. Se estiver escrevendo um m\u00f3dulo e usando import, confira se n\u00e3o usou o mesmo nome no seu m\u00f3dulo que os dos m\u00f3dulos padr\u00e3o do Python. Se voc\u00ea estiver usando import para ler um m\u00f3dulo, lembre-se de que \u00e9 preciso reiniciar o interpretador ou usar reload para ler um arquivo alterado. Se importar o m\u00f3dulo novamente, ele n\u00e3o faz nada. Se j\u00e1 esgotou as possibilidades e n\u00e3o conseguiu descobrir o que est\u00e1 acontecendo, uma abordagem \u00e9 come\u00e7ar novamente com um programa como \u201cHello, World!\u201d, para ter certeza de que consegue executar um programa conhecido. Ent\u00e3o, gradualmente acrescente as partes do programa original ao novo. A.2 - Erros de tempo de execu\u00e7\u00e3o Uma vez que o seu programa esteja sintaticamente correto, o Python pode l\u00ea-lo e, pelo menos, come\u00e7ar a execut\u00e1-lo. O que poderia dar errado? A.2.1 - Meu programa n\u00e3o faz nada Este problema \u00e9 mais comum quando o seu arquivo \u00e9 composto de fun\u00e7\u00f5es e classes, mas na verdade n\u00e3o invoca uma fun\u00e7\u00e3o para come\u00e7ar a execu\u00e7\u00e3o. Isso pode ser intencional se voc\u00ea s\u00f3 planeja importar este m\u00f3dulo para fornecer classes e fun\u00e7\u00f5es. Se n\u00e3o for intencional, tenha certeza de que h\u00e1 uma chamada de fun\u00e7\u00e3o no programa, e que o fluxo de execu\u00e7\u00e3o o alcan\u00e7a (veja \u201cFluxo da execu\u00e7\u00e3o\u201d a seguir). A.2.2 - Meu programa trava Se um programa parar e parecer que n\u00e3o est\u00e1 fazendo nada, ele est\u00e1 \u201ctravado\u201d. Muitas vezes isso significa que est\u00e1 preso em um loop ou recurs\u00e3o infinita. Se houver determinado loop que voc\u00ea suspeita ser o problema, acrescente uma instru\u00e7\u00e3o print imediatamente antes do loop que diga \u201centrando no loop\u201d, e outra imediatamente depois que diga \u201csaindo do loop\u201d. Execute o programa. Se receber a primeira mensagem e a segunda n\u00e3o, voc\u00ea tem um loop infinito. V\u00e1 \u00e0 se\u00e7\u00e3o \u201cLoop infinito\u201d mais adiante. Na maior parte do tempo, a recursividade infinita far\u00e1 com que o programa seja executado durante algum tempo e ent\u00e3o gere um erro \u201cRuntimeError: Maximum recursion depth exceeded\u201d. Se isso acontecer, v\u00e1 \u00e0 se\u00e7\u00e3o \u201cRecursividade infinita\u201d mais adiante. Se n\u00e3o estiver recebendo este erro, mas suspeita que h\u00e1 um problema com um m\u00e9todo ou fun\u00e7\u00e3o recursiva, voc\u00ea ainda pode usar as t\u00e9cnicas da se\u00e7\u00e3o \u201cRecursividade infinita\u201d. Se nenhum desses passos funcionar, comece a testar outros loops e outras fun\u00e7\u00f5es e m\u00e9todos recursivos. Se isso n\u00e3o funcionar, ent\u00e3o \u00e9 poss\u00edvel que voc\u00ea n\u00e3o entenda o fluxo de execu\u00e7\u00e3o do seu programa. V\u00e1 \u00e0 se\u00e7\u00e3o \u201cFluxo de execu\u00e7\u00e3o\u201d mais adiante. Loop infinito Se voc\u00ea acha que h\u00e1 um loop infinito e talvez saiba qual loop est\u00e1 causando o problema, acrescente uma instru\u00e7\u00e3o print no fim do loop que exiba os valores das vari\u00e1veis na condi\u00e7\u00e3o e o valor da condi\u00e7\u00e3o. Por exemplo: while x > 0 and y < 0 : # faz algo com x # faz algo com y print('x: ', x) print('y: ', y) print(\"condition: \", (x > 0 and y < 0)) Agora, quando executar o programa, voc\u00ea ver\u00e1 tr\u00eas linhas de sa\u00edda para cada vez que o programa passar pelo loop. Na \u00faltima vez que passar pelo loop, a condi\u00e7\u00e3o deve ser False. Se o loop continuar, voc\u00ea poder\u00e1 ver os valores de x e y, e compreender porque n\u00e3o est\u00e3o sendo atualizados corretamente. Recursividade infinita Na maioria das vezes, a recursividade infinita faz o programa rodar durante algum tempo e ent\u00e3o produzir um erro de \"Maximum recursion depth exceeded\". Se suspeitar que uma fun\u00e7\u00e3o est\u00e1 causando recursividade infinita, confira se h\u00e1 um caso-base. Deve haver alguma condi\u00e7\u00e3o que faz a fun\u00e7\u00e3o retornar sem fazer uma invoca\u00e7\u00e3o recursiva. Do contr\u00e1rio, voc\u00ea ter\u00e1 que repensar o algoritmo e identificar um caso-base. Se houver um caso-base, mas o programa n\u00e3o parece alcan\u00e7\u00e1-lo, acrescente uma instru\u00e7\u00e3o print no in\u00edcio da fun\u00e7\u00e3o para exibir os par\u00e2metros. Agora, quando executar o programa, voc\u00ea ver\u00e1 algumas linhas de sa\u00edda cada vez que a fun\u00e7\u00e3o for invocada, e ver\u00e1 os valores dos par\u00e2metros. Se os par\u00e2metros n\u00e3o estiverem se movendo em dire\u00e7\u00e3o ao caso-base, voc\u00ea ter\u00e1 algumas ideias sobre a raz\u00e3o disso. Fluxo de execu\u00e7\u00e3o Se n\u00e3o tiver certeza de como o fluxo de execu\u00e7\u00e3o est\u00e1 se movendo pelo seu programa, acrescente instru\u00e7\u00f5es print ao come\u00e7o de cada fun\u00e7\u00e3o com uma mensagem como \u201centrada na fun\u00e7\u00e3o foo\u201d, onde foo \u00e9 o nome da fun\u00e7\u00e3o. Agora, quando executar o programa, ele exibir\u00e1 cada fun\u00e7\u00e3o que for invocada. A.2.3 - Quando executo o programa recebo uma exce\u00e7\u00e3o Se algo der errado durante o tempo de execu\u00e7\u00e3o, o Python exibe uma mensagem que inclui o nome da exce\u00e7\u00e3o, a linha do programa onde o problema ocorreu, e um traceback. O traceback identifica a fun\u00e7\u00e3o que est\u00e1 rodando atualmente, e a fun\u00e7\u00e3o que a chamou, assim como a fun\u00e7\u00e3o que chamou esta, e assim por diante. Em outras palavras, ele tra\u00e7a a sequ\u00eancia de chamadas de fun\u00e7\u00e3o que fez com que voc\u00ea chegasse onde est\u00e1, incluindo o n\u00famero da linha no seu arquivo onde cada chamada ocorreu. O primeiro passo \u00e9 examinar o lugar no programa onde o erro ocorreu e ver se consegue compreender o que aconteceu. Esses s\u00e3o alguns dos erros de tempo de execu\u00e7\u00e3o mais comuns: NameError Voc\u00ea est\u00e1 tentando usar uma vari\u00e1vel que n\u00e3o existe no ambiente atual. Confira se o nome est\u00e1 escrito corretamente e de forma consistente. E lembre-se de que as vari\u00e1veis locais s\u00e3o locais; voc\u00ea n\u00e3o pode se referir a elas a partir do exterior da fun\u00e7\u00e3o onde s\u00e3o definidas. TypeError H\u00e1 v\u00e1rias causas poss\u00edveis: Voc\u00ea est\u00e1 tentando usar um valor de forma inadequada. Exemplo: indexar uma string, lista ou tupla com algo diferente de um n\u00famero inteiro. N\u00e3o h\u00e1 correspond\u00eancia entre os itens em uma string de formata\u00e7\u00e3o e os itens passados para convers\u00e3o. Isso pode acontecer se o n\u00famero de itens n\u00e3o tiver correspond\u00eancia ou uma convers\u00e3o inv\u00e1lida for chamada. Voc\u00ea est\u00e1 passando o n\u00famero incorreto de argumentos a uma fun\u00e7\u00e3o. Para m\u00e9todos, olhe para a defini\u00e7\u00e3o do m\u00e9todo e verifique se o primeiro par\u00e2metro \u00e9 self. Ent\u00e3o olhe para a invoca\u00e7\u00e3o do m\u00e9todo; confira se est\u00e1 invocando o m\u00e9todo a um objeto com o tipo correto e fornecendo os outros argumentos corretamente. KeyError Voc\u00ea est\u00e1 tentando acessar um elemento de um dicion\u00e1rio usando uma chave que o dicion\u00e1rio n\u00e3o cont\u00e9m. Se as chaves forem strings, lembre-se de que letras mai\u00fasculas s\u00e3o diferentes de min\u00fasculas. AttributeError Voc\u00ea est\u00e1 tentando acessar um atributo ou m\u00e9todo que n\u00e3o existe. Verifique a ortografia! Voc\u00ea pode usar a fun\u00e7\u00e3o integrada vars para listar os atributos que existem mesmo. Se um AttributeError indicar que um objeto \u00e9 do tipo NoneType, fica subentendido que \u00e9 None. Ent\u00e3o o problema n\u00e3o \u00e9 o nome do atributo, mas o objeto. Pode ser que o objeto seja none porque voc\u00ea se esqueceu de retornar um valor de uma fun\u00e7\u00e3o; se chegar ao fim de uma fun\u00e7\u00e3o sem chegar a uma instru\u00e7\u00e3o return, ela retorna None. Outra causa comum \u00e9 usar o resultado de um m\u00e9todo de lista, como sort, que retorne None. IndexError O \u00edndice que voc\u00ea est\u00e1 usando para acessar uma lista, string ou tupla \u00e9 maior que o seu comprimento menos um. Imediatamente antes do local do erro, acrescente uma instru\u00e7\u00e3o print para exibir o valor do \u00edndice e o comprimento do array. O array \u00e9 do tamanho certo? O \u00edndice tem o valor certo? O depurador do Python (pdb) \u00e9 \u00fatil para rastrear exce\u00e7\u00f5es porque permite examinar o estado do programa imediatamente antes do erro. Voc\u00ea pode ler sobre o pdb em https://docs.python.org/3/library/pdb.html. A.2.4 - Acrescentei tantas instru\u00e7\u00f5es print que fui inundado pelos resultados Um dos problemas com a utiliza\u00e7\u00e3o de instru\u00e7\u00f5es print para a depura\u00e7\u00e3o \u00e9 que voc\u00ea pode terminar enterrado pelos resultados. H\u00e1 duas formas de prosseguir: simplifique a sa\u00edda ou simplifique o programa. Para simplificar a sa\u00edda, voc\u00ea pode retirar ou transformar as instru\u00e7\u00f5es print que n\u00e3o est\u00e3o ajudando em coment\u00e1rios, ou combin\u00e1-las, ou formatar a sa\u00edda para que seja mais f\u00e1cil de entender. Para simplificar o programa, h\u00e1 v\u00e1rias coisas que voc\u00ea pode fazer. Em primeiro lugar, reduza o problema no qual o programa est\u00e1 trabalhando. Por exemplo, se est\u00e1 fazendo uma busca em uma lista, procure em uma lista pequena. Se o programa receber entradas do usu\u00e1rio, d\u00ea a entrada mais simples poss\u00edvel que cause o problema. Em segundo lugar, limpe o programa. Retire o c\u00f3digo morto e reorganize o programa para torn\u00e1-lo o mais f\u00e1cil poss\u00edvel de ler. Por exemplo, se voc\u00ea suspeitar que o problema est\u00e1 em uma parte profundamente aninhada do programa, tente reescrever aquela parte com uma estrutura mais simples. Se suspeitar de uma fun\u00e7\u00e3o grande, tente quebr\u00e1-la em fun\u00e7\u00f5es menores para test\u00e1-las separadamente. Muitas vezes, o pr\u00f3prio processo de encontrar o caso de teste m\u00ednimo leva voc\u00ea ao problema. Se descobrir que um programa funciona em uma situa\u00e7\u00e3o, mas n\u00e3o em outra, isso d\u00e1 uma pista sobre o que est\u00e1 acontecendo. De forma similar, reescrever uma parte do c\u00f3digo pode ajudar a encontrar erros sutis. Se fizer uma altera\u00e7\u00e3o que voc\u00ea ache que n\u00e3o vai afetar o programa, mas que acabe afetando, isso pode ajud\u00e1-lo. A.3 - Erros sem\u00e2nticos De algumas formas, os erros sem\u00e2nticos s\u00e3o os mais dif\u00edceis de depurar, porque o interpretador n\u00e3o fornece nenhuma informa\u00e7\u00e3o sobre qual \u00e9 o problema. S\u00f3 voc\u00ea sabe o que o programa deve fazer. O primeiro passo \u00e9 fazer uma conex\u00e3o entre o texto do programa e o comportamento que est\u00e1 vendo. Voc\u00ea precisa de uma hip\u00f3tese sobre o que o programa est\u00e1 fazendo de fato. Uma das coisas que torna isso dif\u00edcil \u00e9 que os computadores s\u00e3o r\u00e1pidos. Pode ser que voc\u00ea queira diminuir a velocidade do programa para ser equivalente \u00e0 humana; com alguns depuradores \u00e9 poss\u00edvel fazer isso. No entanto, o tempo que leva para inserir instru\u00e7\u00f5es print bem colocadas muitas vezes \u00e9 curto em compara\u00e7\u00e3o ao da configura\u00e7\u00e3o do depurador, inser\u00e7\u00e3o e remo\u00e7\u00e3o de marca\u00e7\u00f5es e coloca\u00e7\u00e3o do \u201ccompasso\u201d do programa onde o erro est\u00e1 ocorrendo. A.3.1 - Meu programa n\u00e3o funciona Voc\u00ea deve se perguntar o seguinte: H\u00e1 algo que o programa deveria fazer, mas que n\u00e3o parece acontecer? Encontre a se\u00e7\u00e3o do c\u00f3digo que executa a fun\u00e7\u00e3o em quest\u00e3o e confira se est\u00e1 sendo executada quando voc\u00ea acha que deveria. Algo est\u00e1 acontecendo, mas n\u00e3o o que deveria? Encontre o c\u00f3digo no seu programa que executa a fun\u00e7\u00e3o em quest\u00e3o e veja se est\u00e1 sendo executada na hora errada. Uma se\u00e7\u00e3o do c\u00f3digo est\u00e1 produzindo um efeito que n\u00e3o \u00e9 o esperado? Tenha certeza de que entende o c\u00f3digo em quest\u00e3o, especialmente se envolver fun\u00e7\u00f5es ou m\u00e9todos de outros m\u00f3dulos do Python. Leia a documenta\u00e7\u00e3o das fun\u00e7\u00f5es que chama. Teste-as escrevendo casos de teste simples e verificando os resultados. Para programar, \u00e9 preciso ter um modelo mental de como os programas funcionam. Se escrever um programa que n\u00e3o faz o que espera, muitas vezes o problema n\u00e3o est\u00e1 no programa, est\u00e1 no seu modelo mental. A melhor forma de corrigir o seu modelo mental \u00e9 quebrar o programa nos seus componentes (normalmente as fun\u00e7\u00f5es e m\u00e9todos) e testar cada componente em separado. Uma vez que encontre a discrep\u00e2ncia entre o seu modelo e a realidade, poder\u00e1 resolver o problema. Naturalmente, voc\u00ea deveria construir e testar componentes conforme desenvolva o programa. Assim, se encontrar um problema, deve haver s\u00f3 uma pequena quantidade de c\u00f3digo novo que n\u00e3o sabe se est\u00e1 correto. A.3.2 - Tenho uma baita express\u00e3o cabeluda e ela n\u00e3o faz o que espero Escrever express\u00f5es complexas \u00e9 \u00f3timo enquanto s\u00e3o leg\u00edveis, mas elas podem ser dif\u00edceis de depurar. Muitas vezes \u00e9 uma boa ideia quebrar uma express\u00e3o complexa em uma s\u00e9rie de atribui\u00e7\u00f5es a vari\u00e1veis tempor\u00e1rias. Por exemplo: self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard()) A express\u00e3o pode ser reescrita assim: neighbor = self.findNeighbor(i) pickedCard = self.hands[neighbor].popCard() self.hands[i].addCard(pickedCard) A vers\u00e3o expl\u00edcita \u00e9 mais f\u00e1cil de ler porque os nomes das vari\u00e1veis oferecem documenta\u00e7\u00e3o adicional, e \u00e9 mais f\u00e1cil de depurar porque voc\u00ea pode verificar os tipos das vari\u00e1veis intermedi\u00e1rias e exibir seus valores. Outro problema que pode ocorrer com grandes express\u00f5es \u00e9 que a ordem da avalia\u00e7\u00e3o pode n\u00e3o ser o que voc\u00ea espera. Por exemplo, se estiver traduzindo a express\u00e3o para o Python, poderia escrever: y = x / 2 * math.pi Isso n\u00e3o est\u00e1 correto porque a multiplica\u00e7\u00e3o e a divis\u00e3o t\u00eam a mesma preced\u00eancia e s\u00e3o avaliadas da esquerda para a direita. Ent\u00e3o, \u00e9 assim que essa express\u00e3o \u00e9 calculada: x\u03c0/2. Uma boa forma de depurar express\u00f5es \u00e9 acrescentar par\u00eanteses para tornar a ordem da avalia\u00e7\u00e3o expl\u00edcita: y = x / (2 * math.pi) Sempre que n\u00e3o tiver certeza sobre a ordem da avalia\u00e7\u00e3o, use par\u00eanteses. Al\u00e9m de o programa ficar correto (quanto \u00e0 execu\u00e7\u00e3o do que era pretendido), ele tamb\u00e9m ser\u00e1 mais leg\u00edvel para outras pessoas que n\u00e3o memorizaram a ordem de opera\u00e7\u00f5es. A.3.3 - Tenho uma fun\u00e7\u00e3o que n\u00e3o retorna o que espero Se tiver uma instru\u00e7\u00e3o return com uma express\u00e3o complexa, n\u00e3o h\u00e1 possibilidade de exibir o resultado antes do retorno. Novamente, voc\u00ea pode usar uma vari\u00e1vel tempor\u00e1ria. Por exemplo, em vez de: return self.hands[i].removeMatches() voc\u00ea poderia escrever: count = self.hands[i].removeMatches() return count Agora voc\u00ea tem a oportunidade de exibir o valor de count antes do retorno. A.3.4 - Estou perdido e preciso de ajuda Em primeiro lugar, afaste-se do computador por alguns minutos. Computadores emitem ondas que afetam o c\u00e9rebro, causando estes sintomas: frustra\u00e7\u00e3o e raiva; cren\u00e7as supersticiosas (\u201co computador me odeia\u201d) e pensamento m\u00e1gico (\u201co programa s\u00f3 funciona quando uso o meu chap\u00e9u virado para tr\u00e1s\u201d); programa\u00e7\u00e3o aleat\u00f3ria (a tentativa de programar escrevendo todos os programas poss\u00edveis e escolhendo aquele que faz a coisa certa). Se estiver sofrendo algum desses sintomas, levante-se e d\u00ea uma volta. Quando se acalmar, pense no programa. O que ele est\u00e1 fazendo? Quais s\u00e3o algumas causas poss\u00edveis para esse comportamento? Quando foi a \u00faltima vez que tinha um programa funcionando, e o que fez depois disso? \u00c0s vezes leva tempo para encontrar um erro. Com frequ\u00eancia encontro erros quando estou longe do computador e deixo a minha mente vagar. Os melhores lugares para encontrar erros s\u00e3o os trens, o chuveiro e a cama, logo antes de adormecer. A.3.5 - S\u00e9rio, preciso mesmo de ajuda Acontece. Mesmo os melhores programadores ocasionalmente empacam. Pode ocorrer de voc\u00ea trabalhar tanto em um programa que n\u00e3o consegue enxergar o erro. Precisa de outro par de olhos. Antes de trazer mais algu\u00e9m, n\u00e3o se esque\u00e7a de se preparar. Seu programa deve ser o mais simples poss\u00edvel, e deve estar funcionando com a menor entrada poss\u00edvel que cause o erro. Deve ter instru\u00e7\u00f5es print nos lugares adequados (e a sa\u00edda que produzem deve ser compreens\u00edvel). Voc\u00ea deve entender o problema o suficiente para descrev\u00ea-lo de forma concisa. Ao trazer algu\u00e9m para ajudar, lembre-se de dar as informa\u00e7\u00f5es de que a pessoa possa precisar: Se houver uma mensagem de erro, qual \u00e9 e que parte do programa indica? Qual foi a \u00faltima coisa que fez antes de este erro ocorrer? Quais foram as \u00faltimas linhas de c\u00f3digo que escreveu, ou qual \u00e9 o novo caso de teste que falhou? O que tentou at\u00e9 agora e o que aprendeu? Quando encontrar o erro, pense por um segundo no que poderia ter feito para encontr\u00e1-lo mais r\u00e1pido. Na pr\u00f3xima vez em que vir algo similar, poder\u00e1 encontrar o erro mais rapidamente. Lembre-se, a meta n\u00e3o \u00e9 s\u00f3 fazer o programa funcionar. A meta \u00e9 aprender como fazer o programa funcionar.","title":"Ap\u00eandice A: Depura\u00e7\u00e3o"},{"location":"A-depuracao/#apendice-a-depuracao","text":"Durante a depura\u00e7\u00e3o, voc\u00ea deve distinguir entre tipos diferentes de erros para rastre\u00e1-los mais rapidamente: Erros de sintaxe s\u00e3o descobertos pelo interpretador quando ele est\u00e1 traduzindo o c\u00f3digo-fonte para c\u00f3digo de bytes. Eles indicam que h\u00e1 algo errado com a estrutura do programa. Exemplo: a omiss\u00e3o dos dois pontos no fim de uma instru\u00e7\u00e3o def gera a mensagem um tanto redundante SyntaxError: invalid syntax. Erros de tempo de execu\u00e7\u00e3o s\u00e3o produzidos pelo interpretador se algo der errado durante a execu\u00e7\u00e3o do programa. A maior parte das mensagens de erro de tempo de execu\u00e7\u00e3o inclui informa\u00e7\u00f5es sobre onde o erro ocorreu e o que as fun\u00e7\u00f5es estavam fazendo. Exemplo: a recursividade infinita eventualmente leva ao erro de tempo de execu\u00e7\u00e3o maximum recursion depth exceeded. Erros sem\u00e2nticos s\u00e3o problemas com um programa que \u00e9 executado sem produzir mensagens de erro, mas que n\u00e3o faz a coisa certa. Exemplo: uma express\u00e3o que n\u00e3o pode ser avaliada na ordem esperada, produzindo um resultado incorreto. O primeiro passo da depura\u00e7\u00e3o \u00e9 compreender com que tipo de erro voc\u00ea est\u00e1 lidando. Embora as pr\u00f3ximas se\u00e7\u00f5es sejam organizadas pelo tipo de erro, algumas t\u00e9cnicas s\u00e3o aplic\u00e1veis em mais de uma situa\u00e7\u00e3o.","title":"Ap\u00eandice A: Depura\u00e7\u00e3o"},{"location":"A-depuracao/#a1-erros-de-sintaxe","text":"Os erros de sintaxe normalmente s\u00e3o f\u00e1ceis de corrigir, uma vez que voc\u00ea descubra quais s\u00e3o. Infelizmente, as mensagens de erro muitas vezes n\u00e3o s\u00e3o \u00fateis. As mensagens mais comuns s\u00e3o SyntaxError: invalid syntax e SyntaxError: invalid token, e nenhuma das duas \u00e9 muito informativa. Por outro lado, a mensagem diz onde no programa o problema ocorreu. E, na verdade, diz a voc\u00ea onde o Python notou um problema, que \u00e9 n\u00e3o necessariamente onde o erro est\u00e1. \u00c0s vezes, o erro est\u00e1 antes da posi\u00e7\u00e3o da mensagem de erro, muitas vezes na linha precedente. Se estiver construindo o programa incrementalmente, voc\u00ea ter\u00e1 uma boa ideia sobre onde encontrar o erro. Estar\u00e1 na \u00faltima linha que acrescentou. Se estiver copiando o c\u00f3digo de um livro, comece comparando com aten\u00e7\u00e3o o seu c\u00f3digo e o do livro. Verifique cada caractere. Ao mesmo tempo, lembre-se de que o livro pode estar errado, ent\u00e3o, se vir algo que parece um erro de sintaxe, pode ser mesmo. Aqui est\u00e3o algumas formas de evitar os erros de sintaxe mais comuns: Confira se n\u00e3o est\u00e1 usando uma palavra-chave do Python para um nome de vari\u00e1vel. Verifique se h\u00e1 dois pontos no fim do cabe\u00e7alho de cada instru\u00e7\u00e3o composta, incluindo instru\u00e7\u00f5es for, while, if e def. Confira se as strings no c\u00f3digo t\u00eam as aspas correspondentes. Verifique se todas as aspas s\u00e3o retas, em vez de curvas. Se tiver strings com v\u00e1rias linhas com aspas triplas (simples ou duplas), confira se fechou a string adequadamente. Uma string n\u00e3o fechada pode causar um erro de invalid token no fim do seu programa, ou pode tratar a parte seguinte do programa como uma string at\u00e9 chegar \u00e0 string seguinte. No segundo caso, o programa pode nem produzir uma mensagem de erro! Um operador inicial aberto \u2013 ( , { ou [ \u2013 faz o Python continuar at\u00e9 a linha seguinte, como se esta fosse parte da instru\u00e7\u00e3o atual. Geralmente, um erro ocorre quase imediatamente na linha seguinte. Confira se h\u00e1 o cl\u00e1ssico = em vez do == dentro de uma condicional. Verifique a endenta\u00e7\u00e3o para ter certeza de que est\u00e1 alinhada como deveria. O Python pode lidar com espa\u00e7os e tabula\u00e7\u00f5es, mas, se mistur\u00e1-los, isso pode causar problemas. A melhor forma de evitar esse problema \u00e9 usar um editor de texto que identifique o Python e gere endenta\u00e7\u00e3o consistente. Se h\u00e1 caracteres n\u00e3o ASCII no c\u00f3digo (incluindo strings e coment\u00e1rios), isso pode causar problemas, embora o Python 3 normalmente lide com caracteres n\u00e3o ASCII. Tenha cuidado se colar texto de uma p\u00e1gina web ou outra fonte. Se nada funcionar, v\u00e1 para a pr\u00f3xima se\u00e7\u00e3o...","title":"A.1 - Erros de sintaxe"},{"location":"A-depuracao/#a11-continuo-fazendo-alteracoes-e-nao-faz-nenhuma-diferenca","text":"Se o interpretador disser que h\u00e1 um erro e voc\u00ea n\u00e3o o encontra, pode ser que voc\u00ea e o interpretador n\u00e3o estejam olhando para o mesmo c\u00f3digo. Verifique o seu ambiente de programa\u00e7\u00e3o para ter certeza de que o programa que est\u00e1 editando \u00e9 o mesmo que o Python est\u00e1 tentando executar. Se n\u00e3o estiver certo, tente p\u00f4r um erro de sintaxe \u00f3bvio e deliberado no in\u00edcio do programa. Agora execute-o novamente. Se o interpretador n\u00e3o encontrar o novo erro, voc\u00ea n\u00e3o est\u00e1 executando o novo c\u00f3digo. H\u00e1 alguns culpados prov\u00e1veis: Voc\u00ea editou o arquivo e esqueceu de salvar as altera\u00e7\u00f5es antes de execut\u00e1-lo novamente. Alguns ambientes de programa\u00e7\u00e3o fazem isso para voc\u00ea, mas alguns n\u00e3o fazem. Voc\u00ea mudou o nome do arquivo, mas ainda est\u00e1 executando o nome antigo. Algo no seu ambiente de desenvolvimento est\u00e1 configurado incorretamente. Se estiver escrevendo um m\u00f3dulo e usando import, confira se n\u00e3o usou o mesmo nome no seu m\u00f3dulo que os dos m\u00f3dulos padr\u00e3o do Python. Se voc\u00ea estiver usando import para ler um m\u00f3dulo, lembre-se de que \u00e9 preciso reiniciar o interpretador ou usar reload para ler um arquivo alterado. Se importar o m\u00f3dulo novamente, ele n\u00e3o faz nada. Se j\u00e1 esgotou as possibilidades e n\u00e3o conseguiu descobrir o que est\u00e1 acontecendo, uma abordagem \u00e9 come\u00e7ar novamente com um programa como \u201cHello, World!\u201d, para ter certeza de que consegue executar um programa conhecido. Ent\u00e3o, gradualmente acrescente as partes do programa original ao novo.","title":"A.1.1 - Continuo fazendo altera\u00e7\u00f5es e n\u00e3o faz nenhuma diferen\u00e7a"},{"location":"A-depuracao/#a2-erros-de-tempo-de-execucao","text":"Uma vez que o seu programa esteja sintaticamente correto, o Python pode l\u00ea-lo e, pelo menos, come\u00e7ar a execut\u00e1-lo. O que poderia dar errado?","title":"A.2 - Erros de tempo de execu\u00e7\u00e3o"},{"location":"A-depuracao/#a21-meu-programa-nao-faz-nada","text":"Este problema \u00e9 mais comum quando o seu arquivo \u00e9 composto de fun\u00e7\u00f5es e classes, mas na verdade n\u00e3o invoca uma fun\u00e7\u00e3o para come\u00e7ar a execu\u00e7\u00e3o. Isso pode ser intencional se voc\u00ea s\u00f3 planeja importar este m\u00f3dulo para fornecer classes e fun\u00e7\u00f5es. Se n\u00e3o for intencional, tenha certeza de que h\u00e1 uma chamada de fun\u00e7\u00e3o no programa, e que o fluxo de execu\u00e7\u00e3o o alcan\u00e7a (veja \u201cFluxo da execu\u00e7\u00e3o\u201d a seguir).","title":"A.2.1 - Meu programa n\u00e3o faz nada"},{"location":"A-depuracao/#a22-meu-programa-trava","text":"Se um programa parar e parecer que n\u00e3o est\u00e1 fazendo nada, ele est\u00e1 \u201ctravado\u201d. Muitas vezes isso significa que est\u00e1 preso em um loop ou recurs\u00e3o infinita. Se houver determinado loop que voc\u00ea suspeita ser o problema, acrescente uma instru\u00e7\u00e3o print imediatamente antes do loop que diga \u201centrando no loop\u201d, e outra imediatamente depois que diga \u201csaindo do loop\u201d. Execute o programa. Se receber a primeira mensagem e a segunda n\u00e3o, voc\u00ea tem um loop infinito. V\u00e1 \u00e0 se\u00e7\u00e3o \u201cLoop infinito\u201d mais adiante. Na maior parte do tempo, a recursividade infinita far\u00e1 com que o programa seja executado durante algum tempo e ent\u00e3o gere um erro \u201cRuntimeError: Maximum recursion depth exceeded\u201d. Se isso acontecer, v\u00e1 \u00e0 se\u00e7\u00e3o \u201cRecursividade infinita\u201d mais adiante. Se n\u00e3o estiver recebendo este erro, mas suspeita que h\u00e1 um problema com um m\u00e9todo ou fun\u00e7\u00e3o recursiva, voc\u00ea ainda pode usar as t\u00e9cnicas da se\u00e7\u00e3o \u201cRecursividade infinita\u201d. Se nenhum desses passos funcionar, comece a testar outros loops e outras fun\u00e7\u00f5es e m\u00e9todos recursivos. Se isso n\u00e3o funcionar, ent\u00e3o \u00e9 poss\u00edvel que voc\u00ea n\u00e3o entenda o fluxo de execu\u00e7\u00e3o do seu programa. V\u00e1 \u00e0 se\u00e7\u00e3o \u201cFluxo de execu\u00e7\u00e3o\u201d mais adiante.","title":"A.2.2 - Meu programa trava"},{"location":"A-depuracao/#loop-infinito","text":"Se voc\u00ea acha que h\u00e1 um loop infinito e talvez saiba qual loop est\u00e1 causando o problema, acrescente uma instru\u00e7\u00e3o print no fim do loop que exiba os valores das vari\u00e1veis na condi\u00e7\u00e3o e o valor da condi\u00e7\u00e3o. Por exemplo: while x > 0 and y < 0 : # faz algo com x # faz algo com y print('x: ', x) print('y: ', y) print(\"condition: \", (x > 0 and y < 0)) Agora, quando executar o programa, voc\u00ea ver\u00e1 tr\u00eas linhas de sa\u00edda para cada vez que o programa passar pelo loop. Na \u00faltima vez que passar pelo loop, a condi\u00e7\u00e3o deve ser False. Se o loop continuar, voc\u00ea poder\u00e1 ver os valores de x e y, e compreender porque n\u00e3o est\u00e3o sendo atualizados corretamente.","title":"Loop infinito"},{"location":"A-depuracao/#recursividade-infinita","text":"Na maioria das vezes, a recursividade infinita faz o programa rodar durante algum tempo e ent\u00e3o produzir um erro de \"Maximum recursion depth exceeded\". Se suspeitar que uma fun\u00e7\u00e3o est\u00e1 causando recursividade infinita, confira se h\u00e1 um caso-base. Deve haver alguma condi\u00e7\u00e3o que faz a fun\u00e7\u00e3o retornar sem fazer uma invoca\u00e7\u00e3o recursiva. Do contr\u00e1rio, voc\u00ea ter\u00e1 que repensar o algoritmo e identificar um caso-base. Se houver um caso-base, mas o programa n\u00e3o parece alcan\u00e7\u00e1-lo, acrescente uma instru\u00e7\u00e3o print no in\u00edcio da fun\u00e7\u00e3o para exibir os par\u00e2metros. Agora, quando executar o programa, voc\u00ea ver\u00e1 algumas linhas de sa\u00edda cada vez que a fun\u00e7\u00e3o for invocada, e ver\u00e1 os valores dos par\u00e2metros. Se os par\u00e2metros n\u00e3o estiverem se movendo em dire\u00e7\u00e3o ao caso-base, voc\u00ea ter\u00e1 algumas ideias sobre a raz\u00e3o disso.","title":"Recursividade infinita"},{"location":"A-depuracao/#fluxo-de-execucao","text":"Se n\u00e3o tiver certeza de como o fluxo de execu\u00e7\u00e3o est\u00e1 se movendo pelo seu programa, acrescente instru\u00e7\u00f5es print ao come\u00e7o de cada fun\u00e7\u00e3o com uma mensagem como \u201centrada na fun\u00e7\u00e3o foo\u201d, onde foo \u00e9 o nome da fun\u00e7\u00e3o. Agora, quando executar o programa, ele exibir\u00e1 cada fun\u00e7\u00e3o que for invocada.","title":"Fluxo de execu\u00e7\u00e3o"},{"location":"A-depuracao/#a23-quando-executo-o-programa-recebo-uma-excecao","text":"Se algo der errado durante o tempo de execu\u00e7\u00e3o, o Python exibe uma mensagem que inclui o nome da exce\u00e7\u00e3o, a linha do programa onde o problema ocorreu, e um traceback. O traceback identifica a fun\u00e7\u00e3o que est\u00e1 rodando atualmente, e a fun\u00e7\u00e3o que a chamou, assim como a fun\u00e7\u00e3o que chamou esta, e assim por diante. Em outras palavras, ele tra\u00e7a a sequ\u00eancia de chamadas de fun\u00e7\u00e3o que fez com que voc\u00ea chegasse onde est\u00e1, incluindo o n\u00famero da linha no seu arquivo onde cada chamada ocorreu. O primeiro passo \u00e9 examinar o lugar no programa onde o erro ocorreu e ver se consegue compreender o que aconteceu. Esses s\u00e3o alguns dos erros de tempo de execu\u00e7\u00e3o mais comuns:","title":"A.2.3 - Quando executo o programa recebo uma exce\u00e7\u00e3o"},{"location":"A-depuracao/#nameerror","text":"Voc\u00ea est\u00e1 tentando usar uma vari\u00e1vel que n\u00e3o existe no ambiente atual. Confira se o nome est\u00e1 escrito corretamente e de forma consistente. E lembre-se de que as vari\u00e1veis locais s\u00e3o locais; voc\u00ea n\u00e3o pode se referir a elas a partir do exterior da fun\u00e7\u00e3o onde s\u00e3o definidas.","title":"NameError"},{"location":"A-depuracao/#typeerror","text":"H\u00e1 v\u00e1rias causas poss\u00edveis: Voc\u00ea est\u00e1 tentando usar um valor de forma inadequada. Exemplo: indexar uma string, lista ou tupla com algo diferente de um n\u00famero inteiro. N\u00e3o h\u00e1 correspond\u00eancia entre os itens em uma string de formata\u00e7\u00e3o e os itens passados para convers\u00e3o. Isso pode acontecer se o n\u00famero de itens n\u00e3o tiver correspond\u00eancia ou uma convers\u00e3o inv\u00e1lida for chamada. Voc\u00ea est\u00e1 passando o n\u00famero incorreto de argumentos a uma fun\u00e7\u00e3o. Para m\u00e9todos, olhe para a defini\u00e7\u00e3o do m\u00e9todo e verifique se o primeiro par\u00e2metro \u00e9 self. Ent\u00e3o olhe para a invoca\u00e7\u00e3o do m\u00e9todo; confira se est\u00e1 invocando o m\u00e9todo a um objeto com o tipo correto e fornecendo os outros argumentos corretamente.","title":"TypeError"},{"location":"A-depuracao/#keyerror","text":"Voc\u00ea est\u00e1 tentando acessar um elemento de um dicion\u00e1rio usando uma chave que o dicion\u00e1rio n\u00e3o cont\u00e9m. Se as chaves forem strings, lembre-se de que letras mai\u00fasculas s\u00e3o diferentes de min\u00fasculas.","title":"KeyError"},{"location":"A-depuracao/#attributeerror","text":"Voc\u00ea est\u00e1 tentando acessar um atributo ou m\u00e9todo que n\u00e3o existe. Verifique a ortografia! Voc\u00ea pode usar a fun\u00e7\u00e3o integrada vars para listar os atributos que existem mesmo. Se um AttributeError indicar que um objeto \u00e9 do tipo NoneType, fica subentendido que \u00e9 None. Ent\u00e3o o problema n\u00e3o \u00e9 o nome do atributo, mas o objeto. Pode ser que o objeto seja none porque voc\u00ea se esqueceu de retornar um valor de uma fun\u00e7\u00e3o; se chegar ao fim de uma fun\u00e7\u00e3o sem chegar a uma instru\u00e7\u00e3o return, ela retorna None. Outra causa comum \u00e9 usar o resultado de um m\u00e9todo de lista, como sort, que retorne None.","title":"AttributeError"},{"location":"A-depuracao/#indexerror","text":"O \u00edndice que voc\u00ea est\u00e1 usando para acessar uma lista, string ou tupla \u00e9 maior que o seu comprimento menos um. Imediatamente antes do local do erro, acrescente uma instru\u00e7\u00e3o print para exibir o valor do \u00edndice e o comprimento do array. O array \u00e9 do tamanho certo? O \u00edndice tem o valor certo? O depurador do Python (pdb) \u00e9 \u00fatil para rastrear exce\u00e7\u00f5es porque permite examinar o estado do programa imediatamente antes do erro. Voc\u00ea pode ler sobre o pdb em https://docs.python.org/3/library/pdb.html.","title":"IndexError"},{"location":"A-depuracao/#a24-acrescentei-tantas-instrucoes-print-que-fui-inundado-pelos-resultados","text":"Um dos problemas com a utiliza\u00e7\u00e3o de instru\u00e7\u00f5es print para a depura\u00e7\u00e3o \u00e9 que voc\u00ea pode terminar enterrado pelos resultados. H\u00e1 duas formas de prosseguir: simplifique a sa\u00edda ou simplifique o programa. Para simplificar a sa\u00edda, voc\u00ea pode retirar ou transformar as instru\u00e7\u00f5es print que n\u00e3o est\u00e3o ajudando em coment\u00e1rios, ou combin\u00e1-las, ou formatar a sa\u00edda para que seja mais f\u00e1cil de entender. Para simplificar o programa, h\u00e1 v\u00e1rias coisas que voc\u00ea pode fazer. Em primeiro lugar, reduza o problema no qual o programa est\u00e1 trabalhando. Por exemplo, se est\u00e1 fazendo uma busca em uma lista, procure em uma lista pequena. Se o programa receber entradas do usu\u00e1rio, d\u00ea a entrada mais simples poss\u00edvel que cause o problema. Em segundo lugar, limpe o programa. Retire o c\u00f3digo morto e reorganize o programa para torn\u00e1-lo o mais f\u00e1cil poss\u00edvel de ler. Por exemplo, se voc\u00ea suspeitar que o problema est\u00e1 em uma parte profundamente aninhada do programa, tente reescrever aquela parte com uma estrutura mais simples. Se suspeitar de uma fun\u00e7\u00e3o grande, tente quebr\u00e1-la em fun\u00e7\u00f5es menores para test\u00e1-las separadamente. Muitas vezes, o pr\u00f3prio processo de encontrar o caso de teste m\u00ednimo leva voc\u00ea ao problema. Se descobrir que um programa funciona em uma situa\u00e7\u00e3o, mas n\u00e3o em outra, isso d\u00e1 uma pista sobre o que est\u00e1 acontecendo. De forma similar, reescrever uma parte do c\u00f3digo pode ajudar a encontrar erros sutis. Se fizer uma altera\u00e7\u00e3o que voc\u00ea ache que n\u00e3o vai afetar o programa, mas que acabe afetando, isso pode ajud\u00e1-lo.","title":"A.2.4 - Acrescentei tantas instru\u00e7\u00f5es print que fui inundado pelos resultados"},{"location":"A-depuracao/#a3-erros-semanticos","text":"De algumas formas, os erros sem\u00e2nticos s\u00e3o os mais dif\u00edceis de depurar, porque o interpretador n\u00e3o fornece nenhuma informa\u00e7\u00e3o sobre qual \u00e9 o problema. S\u00f3 voc\u00ea sabe o que o programa deve fazer. O primeiro passo \u00e9 fazer uma conex\u00e3o entre o texto do programa e o comportamento que est\u00e1 vendo. Voc\u00ea precisa de uma hip\u00f3tese sobre o que o programa est\u00e1 fazendo de fato. Uma das coisas que torna isso dif\u00edcil \u00e9 que os computadores s\u00e3o r\u00e1pidos. Pode ser que voc\u00ea queira diminuir a velocidade do programa para ser equivalente \u00e0 humana; com alguns depuradores \u00e9 poss\u00edvel fazer isso. No entanto, o tempo que leva para inserir instru\u00e7\u00f5es print bem colocadas muitas vezes \u00e9 curto em compara\u00e7\u00e3o ao da configura\u00e7\u00e3o do depurador, inser\u00e7\u00e3o e remo\u00e7\u00e3o de marca\u00e7\u00f5es e coloca\u00e7\u00e3o do \u201ccompasso\u201d do programa onde o erro est\u00e1 ocorrendo.","title":"A.3 - Erros sem\u00e2nticos"},{"location":"A-depuracao/#a31-meu-programa-nao-funciona","text":"Voc\u00ea deve se perguntar o seguinte: H\u00e1 algo que o programa deveria fazer, mas que n\u00e3o parece acontecer? Encontre a se\u00e7\u00e3o do c\u00f3digo que executa a fun\u00e7\u00e3o em quest\u00e3o e confira se est\u00e1 sendo executada quando voc\u00ea acha que deveria. Algo est\u00e1 acontecendo, mas n\u00e3o o que deveria? Encontre o c\u00f3digo no seu programa que executa a fun\u00e7\u00e3o em quest\u00e3o e veja se est\u00e1 sendo executada na hora errada. Uma se\u00e7\u00e3o do c\u00f3digo est\u00e1 produzindo um efeito que n\u00e3o \u00e9 o esperado? Tenha certeza de que entende o c\u00f3digo em quest\u00e3o, especialmente se envolver fun\u00e7\u00f5es ou m\u00e9todos de outros m\u00f3dulos do Python. Leia a documenta\u00e7\u00e3o das fun\u00e7\u00f5es que chama. Teste-as escrevendo casos de teste simples e verificando os resultados. Para programar, \u00e9 preciso ter um modelo mental de como os programas funcionam. Se escrever um programa que n\u00e3o faz o que espera, muitas vezes o problema n\u00e3o est\u00e1 no programa, est\u00e1 no seu modelo mental. A melhor forma de corrigir o seu modelo mental \u00e9 quebrar o programa nos seus componentes (normalmente as fun\u00e7\u00f5es e m\u00e9todos) e testar cada componente em separado. Uma vez que encontre a discrep\u00e2ncia entre o seu modelo e a realidade, poder\u00e1 resolver o problema. Naturalmente, voc\u00ea deveria construir e testar componentes conforme desenvolva o programa. Assim, se encontrar um problema, deve haver s\u00f3 uma pequena quantidade de c\u00f3digo novo que n\u00e3o sabe se est\u00e1 correto.","title":"A.3.1 - Meu programa n\u00e3o funciona"},{"location":"A-depuracao/#a32-tenho-uma-baita-expressao-cabeluda-e-ela-nao-faz-o-que-espero","text":"Escrever express\u00f5es complexas \u00e9 \u00f3timo enquanto s\u00e3o leg\u00edveis, mas elas podem ser dif\u00edceis de depurar. Muitas vezes \u00e9 uma boa ideia quebrar uma express\u00e3o complexa em uma s\u00e9rie de atribui\u00e7\u00f5es a vari\u00e1veis tempor\u00e1rias. Por exemplo: self.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard()) A express\u00e3o pode ser reescrita assim: neighbor = self.findNeighbor(i) pickedCard = self.hands[neighbor].popCard() self.hands[i].addCard(pickedCard) A vers\u00e3o expl\u00edcita \u00e9 mais f\u00e1cil de ler porque os nomes das vari\u00e1veis oferecem documenta\u00e7\u00e3o adicional, e \u00e9 mais f\u00e1cil de depurar porque voc\u00ea pode verificar os tipos das vari\u00e1veis intermedi\u00e1rias e exibir seus valores. Outro problema que pode ocorrer com grandes express\u00f5es \u00e9 que a ordem da avalia\u00e7\u00e3o pode n\u00e3o ser o que voc\u00ea espera. Por exemplo, se estiver traduzindo a express\u00e3o para o Python, poderia escrever: y = x / 2 * math.pi Isso n\u00e3o est\u00e1 correto porque a multiplica\u00e7\u00e3o e a divis\u00e3o t\u00eam a mesma preced\u00eancia e s\u00e3o avaliadas da esquerda para a direita. Ent\u00e3o, \u00e9 assim que essa express\u00e3o \u00e9 calculada: x\u03c0/2. Uma boa forma de depurar express\u00f5es \u00e9 acrescentar par\u00eanteses para tornar a ordem da avalia\u00e7\u00e3o expl\u00edcita: y = x / (2 * math.pi) Sempre que n\u00e3o tiver certeza sobre a ordem da avalia\u00e7\u00e3o, use par\u00eanteses. Al\u00e9m de o programa ficar correto (quanto \u00e0 execu\u00e7\u00e3o do que era pretendido), ele tamb\u00e9m ser\u00e1 mais leg\u00edvel para outras pessoas que n\u00e3o memorizaram a ordem de opera\u00e7\u00f5es.","title":"A.3.2 - Tenho uma baita express\u00e3o cabeluda e ela n\u00e3o faz o que espero"},{"location":"A-depuracao/#a33-tenho-uma-funcao-que-nao-retorna-o-que-espero","text":"Se tiver uma instru\u00e7\u00e3o return com uma express\u00e3o complexa, n\u00e3o h\u00e1 possibilidade de exibir o resultado antes do retorno. Novamente, voc\u00ea pode usar uma vari\u00e1vel tempor\u00e1ria. Por exemplo, em vez de: return self.hands[i].removeMatches() voc\u00ea poderia escrever: count = self.hands[i].removeMatches() return count Agora voc\u00ea tem a oportunidade de exibir o valor de count antes do retorno.","title":"A.3.3 - Tenho uma fun\u00e7\u00e3o que n\u00e3o retorna o que espero"},{"location":"A-depuracao/#a34-estou-perdido-e-preciso-de-ajuda","text":"Em primeiro lugar, afaste-se do computador por alguns minutos. Computadores emitem ondas que afetam o c\u00e9rebro, causando estes sintomas: frustra\u00e7\u00e3o e raiva; cren\u00e7as supersticiosas (\u201co computador me odeia\u201d) e pensamento m\u00e1gico (\u201co programa s\u00f3 funciona quando uso o meu chap\u00e9u virado para tr\u00e1s\u201d); programa\u00e7\u00e3o aleat\u00f3ria (a tentativa de programar escrevendo todos os programas poss\u00edveis e escolhendo aquele que faz a coisa certa). Se estiver sofrendo algum desses sintomas, levante-se e d\u00ea uma volta. Quando se acalmar, pense no programa. O que ele est\u00e1 fazendo? Quais s\u00e3o algumas causas poss\u00edveis para esse comportamento? Quando foi a \u00faltima vez que tinha um programa funcionando, e o que fez depois disso? \u00c0s vezes leva tempo para encontrar um erro. Com frequ\u00eancia encontro erros quando estou longe do computador e deixo a minha mente vagar. Os melhores lugares para encontrar erros s\u00e3o os trens, o chuveiro e a cama, logo antes de adormecer.","title":"A.3.4 - Estou perdido e preciso de ajuda"},{"location":"A-depuracao/#a35-serio-preciso-mesmo-de-ajuda","text":"Acontece. Mesmo os melhores programadores ocasionalmente empacam. Pode ocorrer de voc\u00ea trabalhar tanto em um programa que n\u00e3o consegue enxergar o erro. Precisa de outro par de olhos. Antes de trazer mais algu\u00e9m, n\u00e3o se esque\u00e7a de se preparar. Seu programa deve ser o mais simples poss\u00edvel, e deve estar funcionando com a menor entrada poss\u00edvel que cause o erro. Deve ter instru\u00e7\u00f5es print nos lugares adequados (e a sa\u00edda que produzem deve ser compreens\u00edvel). Voc\u00ea deve entender o problema o suficiente para descrev\u00ea-lo de forma concisa. Ao trazer algu\u00e9m para ajudar, lembre-se de dar as informa\u00e7\u00f5es de que a pessoa possa precisar: Se houver uma mensagem de erro, qual \u00e9 e que parte do programa indica? Qual foi a \u00faltima coisa que fez antes de este erro ocorrer? Quais foram as \u00faltimas linhas de c\u00f3digo que escreveu, ou qual \u00e9 o novo caso de teste que falhou? O que tentou at\u00e9 agora e o que aprendeu? Quando encontrar o erro, pense por um segundo no que poderia ter feito para encontr\u00e1-lo mais r\u00e1pido. Na pr\u00f3xima vez em que vir algo similar, poder\u00e1 encontrar o erro mais rapidamente. Lembre-se, a meta n\u00e3o \u00e9 s\u00f3 fazer o programa funcionar. A meta \u00e9 aprender como fazer o programa funcionar.","title":"A.3.5 - S\u00e9rio, preciso mesmo de ajuda"},{"location":"B-analise-algorit/","text":"Ap\u00eandice B: An\u00e1lise de algoritmos Este ap\u00eandice \u00e9 um excerto editado de Think Complexity, por Allen B. Downey, tamb\u00e9m publicado pela O\u2019Reilly Media (2012). Depois de ler este livro aqui, pode ser uma boa ideia l\u00ea-lo tamb\u00e9m. An\u00e1lise de algoritmos \u00e9 um ramo da Ci\u00eancia da Computa\u00e7\u00e3o que estuda o desempenho de algoritmos, especialmente suas exig\u00eancias de tempo de execu\u00e7\u00e3o e requisitos de espa\u00e7o. Veja http://en.wikipedia.org/wiki/Analysis_of_algorithms. A meta pr\u00e1tica da an\u00e1lise de algoritmos \u00e9 prever o desempenho de algoritmos diferentes para guiar decis\u00f5es de projeto. Durante a campanha presidencial dos Estados Unidos de 2008, pediram ao candidato Barack Obama para fazer uma entrevista de emprego improvisada quando visitou a Google. O diretor executivo, Eric Schmidt, brincou, pedindo a ele \u201ca forma mais eficiente de classificar um milh\u00e3o de n\u00fameros inteiros de 32 bits\u201d. Aparentemente, Obama tinha sido alertado porque respondeu na hora: \u201cCreio que a ordena\u00e7\u00e3o por bolha (bubble sort) n\u00e3o seria a escolha certa\u201d. Veja http://bit.ly/1MpIwTf. Isso \u00e9 verdade: a ordena\u00e7\u00e3o por bolha \u00e9 conceitualmente simples, mas lenta para grandes conjuntos de dados. A resposta que Schmidt procurava provavelmente \u00e9 \u201cordena\u00e7\u00e3o radix\u201d (radix sort) (http://en.wikipedia.org/wiki/Radix_sort)[2]. A meta da an\u00e1lise de algoritmos \u00e9 fazer compara\u00e7\u00f5es significativas entre algoritmos, mas h\u00e1 alguns problemas: O desempenho relativo dos algoritmos pode depender de caracter\u00edsticas do hardware; ent\u00e3o um algoritmo pode ser mais r\u00e1pido na M\u00e1quina A, e outro na M\u00e1quina B. A solu\u00e7\u00e3o geral para este problema \u00e9 especificar um modelo de m\u00e1quina e analisar o n\u00famero de passos ou opera\u00e7\u00f5es que um algoritmo exige sob um modelo dado. O desempenho relativo pode depender dos detalhes do conjunto de dados. Por exemplo, alguns algoritmos de ordena\u00e7\u00e3o rodam mais r\u00e1pido se os dados j\u00e1 foram parcialmente ordenados; outros algoritmos rodam mais devagar neste caso. Uma forma comum de evitar este problema \u00e9 analisar o pior caso. \u00c0s vezes \u00e9 \u00fatil analisar o desempenho de casos m\u00e9dios, mas isso \u00e9 normalmente mais dif\u00edcil, e pode n\u00e3o ser \u00f3bvio qual conjunto de casos deve ser usado para a m\u00e9dia. O desempenho relativo tamb\u00e9m depende do tamanho do problema. Um algoritmo de ordena\u00e7\u00e3o que \u00e9 r\u00e1pido para pequenas listas pode ser lento para longas listas. A solu\u00e7\u00e3o habitual para este problema \u00e9 expressar o tempo de execu\u00e7\u00e3o (ou o n\u00famero de opera\u00e7\u00f5es) como uma fun\u00e7\u00e3o do tamanho de problema e fun\u00e7\u00f5es de grupo em categorias que dependem de sua velocidade de crescimento quando o tamanho de problema aumenta. Uma coisa boa sobre este tipo de compara\u00e7\u00e3o \u00e9 que ela \u00e9 pr\u00f3pria para a classifica\u00e7\u00e3o simples de algoritmos. Por exemplo, se souber que o tempo de execu\u00e7\u00e3o do algoritmo A tende a ser proporcional ao tamanho da entrada n, e o algoritmo B tende a ser proporcional a n2, ent\u00e3o espero que A seja mais r\u00e1pido que B, pelo menos para valores grandes de n. Esse tipo de an\u00e1lise tem algumas desvantagens, mas falaremos disso mais adiante. B.1 - Ordem de crescimento Vamos supor que voc\u00ea analisou dois algoritmos e expressou seus tempos de execu\u00e7\u00e3o em rela\u00e7\u00e3o ao tamanho da entrada: o algoritmo A leva 100n+1 passos para resolver um problema com o tamanho n; o algoritmo B leva n2 + n + 1 passos. A tabela seguinte mostra o tempo de execu\u00e7\u00e3o desses algoritmos para tamanhos de problema diferentes: Tamanho da entrada Tempo de execu\u00e7\u00e3o do algoritmo A Tempo de execu\u00e7\u00e3o do algoritmo B 10 1 001 111 100 10 001 10 101 1 000 100 001 1 001 001 10 000 1 000 001 > 1010 Ao chegar em n=10, o algoritmo A parece bem ruim; ele \u00e9 quase dez vezes mais longo que o algoritmo B. No entanto, para n=100 eles s\u00e3o bem parecidos, e, para valores maiores, A \u00e9 muito melhor. A raz\u00e3o fundamental \u00e9 que para grandes valores de n, qualquer fun\u00e7\u00e3o que contenha um termo n2 ser\u00e1 mais r\u00e1pida que uma fun\u00e7\u00e3o cujo termo principal seja n. O termo principal \u00e9 o que tem o expoente mais alto. Para o algoritmo A, o termo principal tem um grande coeficiente, 100, que \u00e9 a raz\u00e3o de B ser melhor que A para um valor pequeno de n. Entretanto, apesar dos coeficientes, sempre haver\u00e1 algum valor de n em que an2 > bn, para valores de a e b. O mesmo argumento se aplica aos termos que n\u00e3o s\u00e3o principais. Mesmo se o tempo de execu\u00e7\u00e3o do algoritmo A fosse n+1000000, ainda seria melhor que o algoritmo B para um valor suficientemente grande de n. Em geral, esperamos que um algoritmo com um termo principal menor seja um algoritmo melhor para grandes problemas, mas, para problemas menores, pode haver um ponto de desvio onde outro algoritmo seja melhor. A posi\u00e7\u00e3o do ponto de desvio depende dos detalhes dos algoritmos, das entradas e do hardware; ent\u00e3o, ele \u00e9 normalmente ignorado para os prop\u00f3sitos da an\u00e1lise algor\u00edtmica. Por\u00e9m, isso n\u00e3o significa que voc\u00ea pode se esquecer dele. Se dois algoritmos tiverem o mesmo termo principal de ordem, \u00e9 dif\u00edcil dizer qual \u00e9 melhor; mais uma vez, a resposta depende dos detalhes. Assim, para a an\u00e1lise algor\u00edtmica, fun\u00e7\u00f5es com o mesmo termo principal s\u00e3o consideradas equivalentes, mesmo se tiverem coeficientes diferentes. Uma ordem de crescimento \u00e9 um conjunto de fun\u00e7\u00f5es cujo comportamento de crescimento \u00e9 considerado equivalente. Por exemplo, 2n, 100n e n+1 pertencem \u00e0 mesma ordem de crescimento, que se escreve O(n) em nota\u00e7\u00e3o Grande-O e muitas vezes \u00e9 chamada de linear, porque cada fun\u00e7\u00e3o no conjunto cresce linearmente em rela\u00e7\u00e3o a n. Todas as fun\u00e7\u00f5es com o termo principal n2 pertencem a O(n2); elas s\u00e3o chamadas de quadr\u00e1ticas. A tabela seguinte mostra algumas ordens de crescimento mais comuns na an\u00e1lise algor\u00edtmica, em ordem crescente de complexidade. Ordem de crescimento Nome O(1) constante O(logb n) logar\u00edtmica (para qualquer b) O(n) linear O(n logb n) log-linear O(n2) quadr\u00e1tica O(n3) c\u00fabica O(cn) exponencial (para qualquer c) Para os termos logar\u00edtmicos, a base do logaritmo n\u00e3o importa; a altera\u00e7\u00e3o de bases \u00e9 o equivalente da multiplica\u00e7\u00e3o por uma constante, o que n\u00e3o altera a ordem de crescimento. De forma similar, todas as fun\u00e7\u00f5es exponenciais pertencem \u00e0 mesma ordem de crescimento, apesar da base do expoente. As fun\u00e7\u00f5es exponenciais crescem muito rapidamente, ent\u00e3o os algoritmos exponenciais s\u00f3 s\u00e3o \u00fateis para pequenos problemas. Exerc\u00edcio B.1 Leia a p\u00e1gina da Wikip\u00e9dia sobre a nota\u00e7\u00e3o Grande-O (Big-Oh notation) em http://en.wikipedia.org/wiki/Big_O_notation e responda \u00e0s seguintes perguntas: 1. Qual \u00e9 a ordem de crescimento de n3 + n2? E de 1000000n3 + n2? Ou de n3 + 1000000n2? 2. Qual \u00e9 a ordem de crescimento de (n2 + n) . (n + 1)? Antes de come\u00e7ar a multiplicar, lembre-se de que voc\u00ea s\u00f3 precisa do termo principal. 3. Se f est\u00e1 em O(g), para alguma fun\u00e7\u00e3o n\u00e3o especificada g, o que podemos dizer de af+b? 4. Se f1 e f2 est\u00e3o em O(g), o que podemos dizer a respeito de f1 + f2? 5. Se f1 est\u00e1 em O(g) e f2 est\u00e1 em O(h), o que podemos dizer a respeito de f1 + f2? 6. Se f1 est\u00e1 em O(g) e f2 \u00e9 O(h), o que podemos dizer a respeito de f1 . f2? Programadores que se preocupam com o desempenho muitas vezes consideram esse tipo de an\u00e1lise dif\u00edcil de engolir. A raz\u00e3o para isso \u00e9: \u00e0s vezes os coeficientes e os termos n\u00e3o principais fazem muita diferen\u00e7a. Os detalhes do hardware, a linguagem de programa\u00e7\u00e3o e as caracter\u00edsticas da entrada fazem grande diferen\u00e7a. E para pequenos problemas, o comportamento assint\u00f3tico \u00e9 irrelevante. Por\u00e9m, se mantiver essas quest\u00f5es em mente, a an\u00e1lise algor\u00edtmica pode ser uma ferramenta \u00fatil. Pelo menos para grandes problemas, os \u201cmelhores\u201d algoritmos s\u00e3o normalmente melhores, e, \u00e0s vezes, muito melhores. A diferen\u00e7a entre dois algoritmos com a mesma ordem de crescimento \u00e9 normalmente um fator constante, mas a diferen\u00e7a entre um bom algoritmo e um algoritmo ruim \u00e9 ilimitada! B.2 - An\u00e1lise de opera\u00e7\u00f5es b\u00e1sicas do Python No Python, a maior parte das opera\u00e7\u00f5es aritm\u00e9ticas tem um tempo constante; a multiplica\u00e7\u00e3o normalmente leva mais tempo que a adi\u00e7\u00e3o e a subtra\u00e7\u00e3o, e a divis\u00e3o leva at\u00e9 mais tempo, mas esses tempos de execu\u00e7\u00e3o n\u00e3o dependem da magnitude dos operandos. Os n\u00fameros inteiros muito grandes s\u00e3o uma exce\u00e7\u00e3o; nesse caso, o tempo de execu\u00e7\u00e3o aumenta com o n\u00famero de d\u00edgitos. Opera\u00e7\u00f5es de indexa\u00e7\u00e3o \u2013 ler ou escrever elementos em uma sequ\u00eancia ou dicion\u00e1rio \u2013 tamb\u00e9m t\u00eam tempo constante, n\u00e3o importa o tamanho da estrutura de dados. Um loop for que atravesse uma sequ\u00eancia ou dicion\u00e1rio \u00e9 normalmente linear, desde que todas as opera\u00e7\u00f5es no corpo do loop sejam de tempo constante. Por exemplo, somar os elementos de uma lista \u00e9 linear: total = 0 for x in t: total += x A fun\u00e7\u00e3o integrada sum tamb\u00e9m \u00e9 linear porque faz a mesma coisa, mas tende a ser mais r\u00e1pida porque \u00e9 uma implementa\u00e7\u00e3o mais eficiente; na linguagem da an\u00e1lise algor\u00edtmica, tem um coeficiente principal menor. Via de regra, se o corpo de um loop est\u00e1 em O(na), ent\u00e3o o loop inteiro est\u00e1 em O(na + 1). A exce\u00e7\u00e3o \u00e9 se voc\u00ea puder mostrar que o loop encerra depois de um n\u00famero constante de itera\u00e7\u00f5es. Se um loop \u00e9 executado k vezes, n\u00e3o importa o valor de n, ent\u00e3o o loop est\u00e1 em O(na), mesmo para valores grandes de k. A multiplica\u00e7\u00e3o por k n\u00e3o altera a ordem de crescimento, nem a divis\u00e3o. Ent\u00e3o, se o corpo de um loop est\u00e1 em O(na) e \u00e9 executado n/k vezes, o loop est\u00e1 em O(na + 1), mesmo para valores grandes de k. A maior parte das opera\u00e7\u00f5es de strings e tuplas s\u00e3o lineares, exceto a indexa\u00e7\u00e3o e len, que s\u00e3o de tempo constante. As fun\u00e7\u00f5es integradas min e max s\u00e3o lineares. O tempo de execu\u00e7\u00e3o de uma opera\u00e7\u00e3o de fatia \u00e9 proporcional ao comprimento da sa\u00edda, mas n\u00e3o depende do tamanho da entrada. A concatena\u00e7\u00e3o de strings \u00e9 linear; o tempo de execu\u00e7\u00e3o depende da soma dos comprimentos dos operandos. Todos os m\u00e9todos de string s\u00e3o lineares, mas se os comprimentos das strings forem limitados por uma constante \u2013 por exemplo, opera\u00e7\u00f5es em caracteres \u00fanicos \u2013 s\u00e3o consideradas de tempo constante. O m\u00e9todo de string join \u00e9 linear; o tempo de execu\u00e7\u00e3o depende do comprimento total das strings. A maior parte dos m\u00e9todos de lista s\u00e3o lineares, mas h\u00e1 algumas exce\u00e7\u00f5es: A soma de um elemento ao fim de uma lista \u00e9 de tempo constante em m\u00e9dia; quando o espa\u00e7o acaba, ela ocasionalmente \u00e9 copiada a uma posi\u00e7\u00e3o maior, mas o tempo total de opera\u00e7\u00f5es n \u00e9 O(n), portanto o tempo m\u00e9dio de cada opera\u00e7\u00e3o \u00e9 O(1). A remo\u00e7\u00e3o de um elemento do fim de uma lista \u00e9 de tempo constante. A ordena\u00e7\u00e3o \u00e9 O(n log n). A maior parte das opera\u00e7\u00f5es e m\u00e9todos de dicion\u00e1rio s\u00e3o de tempo constante, mas h\u00e1 algumas exce\u00e7\u00f5es: O tempo de execu\u00e7\u00e3o de update \u00e9 proporcional ao tamanho do dicion\u00e1rio passado como par\u00e2metro, n\u00e3o o dicion\u00e1rio que est\u00e1 sendo atualizado. keys, values e items s\u00e3o de tempo constante porque retornam iteradores. Por\u00e9m, se fizer um loop pelos iteradores, o loop ser\u00e1 linear. O desempenho de dicion\u00e1rios \u00e9 um dos milagres menores da ci\u00eancia da computa\u00e7\u00e3o. Vemos como funcionam em \u201cHashtables\u201d, na p\u00e1gina 302. Exerc\u00edcio B.2 Leia a p\u00e1gina da Wikip\u00e9dia sobre algoritmos de ordena\u00e7\u00e3o em http://en.wikipedia.org/wiki/Sorting_algorithm e responda \u00e0s seguintes perguntas: 1. O que \u00e9 um \u201ctipo de compara\u00e7\u00e3o\u201d? Qual \u00e9 a melhor op\u00e7\u00e3o nos casos de pior cen\u00e1rio de ordem de crescimento para um tipo de compara\u00e7\u00e3o? Qual \u00e9 a melhor op\u00e7\u00e3o nos casos de pior cen\u00e1rio de ordem de crescimento para qualquer algoritmo de ordena\u00e7\u00e3o? 2. Qual \u00e9 a ordem de crescimento do tipo bolha, e por que Barack Obama acha que \u201cn\u00e3o \u00e9 a escolha certa\u201d? 3. Qual \u00e9 a ordem de crescimento do tipo radix? Quais s\u00e3o as precondi\u00e7\u00f5es necess\u00e1rias para us\u00e1-la? 4. O que \u00e9 um tipo est\u00e1vel e qual \u00e9 sua import\u00e2ncia na pr\u00e1tica? 5. Qual \u00e9 o pior algoritmo de ordena\u00e7\u00e3o (que tenha um nome)? 6. Que algoritmo de ordena\u00e7\u00e3o a biblioteca C usa? Que algoritmo de ordena\u00e7\u00e3o o Python usa? Esses algoritmos s\u00e3o est\u00e1veis? Voc\u00ea pode ter que pesquisar no Google para encontrar essas respostas. Muitos dos tipos de n\u00e3o compara\u00e7\u00e3o s\u00e3o lineares, ent\u00e3o, por que o Python usa um tipo de compara\u00e7\u00e3o O(n log n)? B.3 - An\u00e1lise de algoritmos de busca Uma busca \u00e9 um algoritmo que recebe uma cole\u00e7\u00e3o e um item de objetivo e determina se o objetivo est\u00e1 na cole\u00e7\u00e3o, muitas vezes retornando o \u00edndice do objetivo. O algoritmo de busca mais simples \u00e9 uma \u201cbusca linear\u201d, que atravessa os itens da cole\u00e7\u00e3o em ordem, parando se encontrar o objetivo. No pior caso, ele tem que atravessar a cole\u00e7\u00e3o inteira, ent\u00e3o o tempo de execu\u00e7\u00e3o \u00e9 linear. O operador in para sequ\u00eancias usa uma busca linear; assim como m\u00e9todos de string como find e count. Se os elementos da sequ\u00eancia estiverem em ordem, voc\u00ea pode usar uma busca por bisse\u00e7\u00e3o, que \u00e9 O(log n). A busca por bisse\u00e7\u00e3o \u00e9 semelhante ao algoritmo que voc\u00ea poderia usar para procurar uma palavra em um dicion\u00e1rio (um dicion\u00e1rio de papel, n\u00e3o a estrutura de dados). Em vez de come\u00e7ar no in\u00edcio e verificar cada item em ordem, voc\u00ea come\u00e7a com o item do meio e verifica se a palavra que est\u00e1 procurando vem antes ou depois. Se vier antes, ent\u00e3o procura na primeira metade da sequ\u00eancia. Se n\u00e3o, procura na segunda metade. Seja como for, voc\u00ea corta o n\u00famero de itens restantes pela metade. Se a sequ\u00eancia tiver um milh\u00e3o de itens, ser\u00e3o necess\u00e1rios cerca de 20 passos para encontrar a palavra ou concluir que n\u00e3o est\u00e1 l\u00e1. Ent\u00e3o \u00e9 aproximadamente 50 mil vezes mais r\u00e1pido que uma busca linear. A busca por bisse\u00e7\u00e3o pode ser muito mais r\u00e1pida que a busca linear, mas \u00e9 preciso que a sequ\u00eancia esteja em ordem, o que pode exigir trabalho extra. H\u00e1 outra estrutura de dados chamada hashtable, que \u00e9 at\u00e9 mais r\u00e1pida \u2013 voc\u00ea pode fazer uma busca em tempo constante \u2013 e ela n\u00e3o exige que os itens estejam ordenados. Os dicion\u00e1rios do Python s\u00e3o implementados usando hashtables e \u00e9 por isso a maior parte das opera\u00e7\u00f5es de dicion\u00e1rio, incluindo o operador in, s\u00e3o de tempo constante. B.4 - Hashtables Para explicar como hashtables funcionam e por que o seu desempenho \u00e9 t\u00e3o bom, come\u00e7o com uma implementa\u00e7\u00e3o simples de um mapa e vou melhor\u00e1-lo gradualmente at\u00e9 que seja uma hashtable. Uso o Python para demonstrar essas implementa\u00e7\u00f5es, mas, na vida real, eu n\u00e3o escreveria um c\u00f3digo como esse no Python; bastaria usar um dicion\u00e1rio! Assim, para o resto deste cap\u00edtulo, voc\u00ea tem que supor que os dicion\u00e1rios n\u00e3o existem e que quer implementar uma estrutura de dados que fa\u00e7a o mapa de chaves a valores. As opera\u00e7\u00f5es que precisa implementar s\u00e3o: add(k, v) Insere um novo item que mapeia a chave k ao valor v. Com um dicion\u00e1rio de Python, `d`, essa opera\u00e7\u00e3o \u00e9 escrita `d[k] = v`. get(k) Procura e devolve o valor que corresponde \u00e0 chave k. Com um dicion\u00e1rio de Python, `d`, esta opera\u00e7\u00e3o \u00e9 escrita `d[k]` ou `d.get(k)`. Por enquanto, vou supor que cada chave s\u00f3 apare\u00e7a uma vez. A implementa\u00e7\u00e3o mais simples desta interface usa uma lista de tuplas, onde cada tupla \u00e9 um par chave-valor: class LinearMap: def __init__(self): self.items = [] def add(self, k, v): self.items.append((k, v)) def get(self, k): for key, val in self.items: if key == k: return val raise KeyError add acrescenta uma tupla chave-valor \u00e0 lista de itens, o que tem tempo constante. get usa um loop for para buscar na lista: se encontrar a chave-alvo, retorna o valor correspondente; do contr\u00e1rio, exibe um KeyError. Ent\u00e3o get \u00e9 linear. Uma alternativa \u00e9 manter uma lista ordenada por chaves. Assim, get poderia usar uma busca por bisse\u00e7\u00e3o, que \u00e9 O(log n). Por\u00e9m, inserir um novo item no meio de uma lista \u00e9 linear, ent\u00e3o isso pode n\u00e3o ser a melhor op\u00e7\u00e3o. H\u00e1 outras estruturas de dados que podem implementar add e get em tempo logar\u00edtmico, mas isso n\u00e3o \u00e9 t\u00e3o bom como tempo constante, ent\u00e3o vamos continuar. Uma forma de melhorar LinearMap \u00e9 quebrar a lista de pares chave-valor em listas menores. Aqui est\u00e1 uma implementa\u00e7\u00e3o chamada BetterMap , que \u00e9 uma lista de cem LinearMaps. Como veremos em um segundo, a ordem de crescimento para get ainda \u00e9 linear, mas BetterMap \u00e9 um passo no caminho em dire\u00e7\u00e3o a hashtables: class BetterMap: def __init__(self, n=100): self.maps = [] for i in range(n): self.maps.append(LinearMap()) def find_map(self, k): index = hash(k) % len(self.maps) return self.maps[index] def add(self, k, v): m = self.find_map(k) m.add(k, v) def get(self, k): m = self.find_map(k) return m.get(k) __init__ cria uma lista de n LinearMaps. find_map \u00e9 usada por add e get para saber em qual mapa o novo item deve ir ou em qual mapa fazer a busca. find_map usa a fun\u00e7\u00e3o integrada hash, que recebe quase qualquer objeto do Python e retorna um n\u00famero inteiro. Uma limita\u00e7\u00e3o desta implementa\u00e7\u00e3o \u00e9 que ela s\u00f3 funciona com chaves hashable. Tipos mut\u00e1veis como listas e dicion\u00e1rios n\u00e3o s\u00e3o hashable. Objetos hashable considerados equivalentes retornam o mesmo valor hash, mas o oposto n\u00e3o \u00e9 necessariamente verdade: dois objetos com valores diferentes podem retornar o mesmo valor hash. find_map usa o operador m\u00f3dulo para manter os valores hash no intervalo de 0 a len(self.maps), ent\u00e3o o resultado \u00e9 um \u00edndice legal na lista. Naturalmente, isso significa que muitos valores hash diferentes ser\u00e3o reunidos no mesmo \u00edndice. Entretanto, se a fun\u00e7\u00e3o hash dispersar as coisas de forma consistente (que \u00e9 o que as fun\u00e7\u00f5es hash foram projetadas para fazer), ent\u00e3o esperamos ter n/100 itens por LinearMap . Como o tempo de execu\u00e7\u00e3o de LinearMap.get \u00e9 proporcional ao n\u00famero de itens, esperamos que BetterMap seja aproximadamente cem vezes mais r\u00e1pido que LinearMap . A ordem de crescimento ainda \u00e9 linear, mas o coeficiente principal \u00e9 menor. Isto \u00e9 bom, mas n\u00e3o t\u00e3o bom quanto uma hashtable. Aqui (finalmente) est\u00e1 a ideia crucial que faz hashtables serem r\u00e1pidas: se puder limitar o comprimento m\u00e1ximo de LinearMaps, LinearMap.get \u00e9 de tempo constante. Tudo o que voc\u00ea precisa fazer \u00e9 rastrear o n\u00famero de itens e quando o n\u00famero de itens por LinearMap exceder o limite, alterar o tamanho da hashtable acrescentando LinearMaps. Aqui est\u00e1 uma implementa\u00e7\u00e3o de uma hashtable: class HashMap: def __init__(self): self.maps = BetterMap(2) self.num = 0 def get(self, k): return self.maps.get(k) def add(self, k, v): if self.num == len(self.maps.maps): self.resize() self.maps.add(k, v) self.num += 1 def resize(self): new_maps = BetterMap(self.num * 2) for m in self.maps.maps: for k, v in m.items: new_maps.add(k, v) self.maps = new_maps Cada HashMap cont\u00e9m um BetterMap ; __init__ inicia com apenas dois LinearMaps e inicializa num, que monitora o n\u00famero de itens. get apenas despacha para BetterMap . O verdadeiro trabalho acontece em add, que verifica o n\u00famero de itens e o tamanho de BetterMap : se forem iguais, o n\u00famero m\u00e9dio de itens por LinearMap \u00e9 um, ent\u00e3o resize \u00e9 chamada. resize faz um novo BetterMap duas vezes maior que o anterior, e ent\u00e3o \u201credispersa\u201d os itens do mapa antigo no novo. A redispers\u00e3o \u00e9 necess\u00e1ria porque alterar o n\u00famero de LinearMaps muda o denominador do operador m\u00f3dulo em find_map . Isso significa que alguns objetos que costumavam ser dispersos no mesmo LinearMap ser\u00e3o separados (que \u00e9 o que quer\u00edamos, certo?). A redispers\u00e3o \u00e9 linear, ent\u00e3o resize \u00e9 linear, o que pode parecer ruim, j\u00e1 que prometi que add seria de tempo constante. Entretanto, lembre-se de que n\u00e3o temos que alterar o tamanho a cada vez, ent\u00e3o add normalmente \u00e9 de tempo constante e s\u00f3 ocasionalmente linear. O volume total de trabalho para executar add n vezes \u00e9 proporcional a n, ent\u00e3o o tempo m\u00e9dio de cada add \u00e9 de tempo constante! Para ver como isso funciona, pense como seria come\u00e7ar com uma HashTable vazia e inserir uma s\u00e9rie de itens. Come\u00e7amos com dois LinearMaps, ent\u00e3o as duas primeiras inser\u00e7\u00f5es s\u00e3o r\u00e1pidas (n\u00e3o \u00e9 necess\u00e1rio alterar o tamanho). Digamos que elas tomem uma unidade do trabalho cada uma. A pr\u00f3xima inser\u00e7\u00e3o exige uma altera\u00e7\u00e3o de tamanho, ent\u00e3o temos de redispersar os dois primeiros itens (vamos chamar isso de mais duas unidades de trabalho) e ent\u00e3o acrescentar o terceiro item (mais uma unidade). Acrescentar o pr\u00f3ximo item custa uma unidade, ent\u00e3o o total, por enquanto, \u00e9 de seis unidades de trabalho para quatro itens. O pr\u00f3ximo add custa cinco unidades, mas os tr\u00eas seguintes s\u00e3o s\u00f3 uma unidade cada um, ent\u00e3o o total \u00e9 de 14 unidades para as primeiras oito inser\u00e7\u00f5es. O pr\u00f3ximo add custa nove unidades, mas ent\u00e3o podemos inserir mais sete antes da pr\u00f3xima altera\u00e7\u00e3o de tamanho, ent\u00e3o o total \u00e9 de 30 unidades para as primeiras 16 inser\u00e7\u00f5es. Depois de 32 inser\u00e7\u00f5es, o custo total \u00e9 de 62 unidades, e espero que voc\u00ea esteja come\u00e7ando a ver um padr\u00e3o. Depois de n inser\u00e7\u00f5es, nas quais n \u00e9 uma pot\u00eancia de dois, o custo total \u00e9 de 2n-2 unidades, ent\u00e3o o trabalho m\u00e9dio por inser\u00e7\u00e3o \u00e9 um pouco menos de duas unidades. Quando n \u00e9 uma pot\u00eancia de dois, esse \u00e9 o melhor caso; para outros valores de n, o trabalho m\u00e9dio \u00e9 um pouco maior, mas isso n\u00e3o \u00e9 importante. O importante \u00e9 que seja O(1). A Figura 21.1 mostra graficamente como isso funciona. Cada bloco representa uma unidade de trabalho. As colunas mostram o trabalho total para cada inser\u00e7\u00e3o na ordem da esquerda para a direita: os primeiros dois adds custam uma unidade, o terceiro custa tr\u00eas unidades etc. Figura B.1 \u2013 O custo de inser\u00e7\u00f5es em uma hashtable. O trabalho extra de redispers\u00e3o aparece como uma sequ\u00eancia de torres cada vez mais altas com um aumento de espa\u00e7o entre elas. Agora, se derrubar as torres, espalhando o custo de alterar o tamanho por todas as inser\u00e7\u00f5es, poder\u00e1 ver graficamente que o custo total depois de n inser\u00e7\u00f5es \u00e9 de 2n \u2212 2. Uma caracter\u00edstica importante deste algoritmo \u00e9 que quando alteramos o tamanho da HashTable, ela cresce geometricamente; isto \u00e9, multiplicamos o tamanho por uma constante. Se voc\u00ea aumentar o tamanho aritmeticamente \u2013 somando um n\u00famero fixo de cada vez \u2013 o tempo m\u00e9dio por add \u00e9 linear. Voc\u00ea pode baixar minha implementa\u00e7\u00e3o de HashMap em http://thinkpython2.com/code/Map.py, mas lembre-se de que n\u00e3o h\u00e1 raz\u00e3o para us\u00e1-la; se quiser um mapa, basta usar um dicion\u00e1rio do Python. B.5 - Gloss\u00e1rio an\u00e1lise de algoritmos Forma de comparar algoritmos quanto \u00e0s suas exig\u00eancias de espa\u00e7o e/ou tempo de execu\u00e7\u00e3o. modelo de m\u00e1quina Representa\u00e7\u00e3o simplificada de um computador usada para descrever algoritmos. pior caso Entrada que faz um dado algoritmo rodar mais lentamente (ou exigir mais espa\u00e7o). termo principal Em um polin\u00f4mio, o termo com o expoente mais alto. ponto de desvio Tamanho do problema em que dois algoritmos exigem o mesmo tempo de execu\u00e7\u00e3o ou espa\u00e7o. ordem de crescimento Conjunto de fun\u00e7\u00f5es em que todas crescem em uma forma considerada equivalente para os prop\u00f3sitos da an\u00e1lise de algoritmos. Por exemplo, todas as fun\u00e7\u00f5es que crescem linearmente pertencem \u00e0 mesma ordem de crescimento. nota\u00e7\u00e3o Grande-O (Big-Oh notation) Nota\u00e7\u00e3o para representar uma ordem de crescimento; por exemplo, O(n) representa o conjunto de fun\u00e7\u00f5es que crescem linearmente. linear Algoritmo cujo tempo de execu\u00e7\u00e3o \u00e9 proporcional ao tamanho do problema, pelo menos para grandes tamanhos de problema. quadr\u00e1tico Algoritmo cujo tempo de execu\u00e7\u00e3o \u00e9 proporcional a n2, onde n \u00e9 uma medida de tamanho do problema. busca Problema de localizar um elemento de uma cole\u00e7\u00e3o (como uma lista ou dicion\u00e1rio) ou de decidir que n\u00e3o est\u00e1 presente. hashtable Estrutura de dados que representa uma cole\u00e7\u00e3o de pares chave-valor e executa buscas em tempo constante. [1] popen foi descartado, ou seja, devemos parar de us\u00e1-lo e come\u00e7ar a usar o m\u00f3dulo subprocess. Entretanto, para casos simples, eu considero subprocess mais complicado que o necess\u00e1rio. Ent\u00e3o vou continuar usando popen at\u00e9 que o removam. [2] Mas se fizerem uma pergunta como essa em uma entrevista, creio que a melhor resposta \u00e9 \u201cA forma mais r\u00e1pida de classificar um milh\u00e3o de n\u00fameros inteiros \u00e9 usar qualquer fun\u00e7\u00e3o de ordena\u00e7\u00e3o oferecida pela linguagem que estou usando. Se o desempenho \u00e9 bom o suficiente para a grande maioria das aplica\u00e7\u00f5es, mas a minha aplica\u00e7\u00e3o acabasse sendo lenta demais, eu usaria algum recurso para investigar onde o tempo est\u00e1 sendo gasto. Se parecesse que um algoritmo mais r\u00e1pido teria um efeito significativo sobre o desempenho, ent\u00e3o procuraria uma boa implementa\u00e7\u00e3o do tipo radix\u201d.","title":"Ap\u00eandice B: An\u00e1lise de algoritmos"},{"location":"B-analise-algorit/#apendice-b-analise-de-algoritmos","text":"Este ap\u00eandice \u00e9 um excerto editado de Think Complexity, por Allen B. Downey, tamb\u00e9m publicado pela O\u2019Reilly Media (2012). Depois de ler este livro aqui, pode ser uma boa ideia l\u00ea-lo tamb\u00e9m. An\u00e1lise de algoritmos \u00e9 um ramo da Ci\u00eancia da Computa\u00e7\u00e3o que estuda o desempenho de algoritmos, especialmente suas exig\u00eancias de tempo de execu\u00e7\u00e3o e requisitos de espa\u00e7o. Veja http://en.wikipedia.org/wiki/Analysis_of_algorithms. A meta pr\u00e1tica da an\u00e1lise de algoritmos \u00e9 prever o desempenho de algoritmos diferentes para guiar decis\u00f5es de projeto. Durante a campanha presidencial dos Estados Unidos de 2008, pediram ao candidato Barack Obama para fazer uma entrevista de emprego improvisada quando visitou a Google. O diretor executivo, Eric Schmidt, brincou, pedindo a ele \u201ca forma mais eficiente de classificar um milh\u00e3o de n\u00fameros inteiros de 32 bits\u201d. Aparentemente, Obama tinha sido alertado porque respondeu na hora: \u201cCreio que a ordena\u00e7\u00e3o por bolha (bubble sort) n\u00e3o seria a escolha certa\u201d. Veja http://bit.ly/1MpIwTf. Isso \u00e9 verdade: a ordena\u00e7\u00e3o por bolha \u00e9 conceitualmente simples, mas lenta para grandes conjuntos de dados. A resposta que Schmidt procurava provavelmente \u00e9 \u201cordena\u00e7\u00e3o radix\u201d (radix sort) (http://en.wikipedia.org/wiki/Radix_sort)[2]. A meta da an\u00e1lise de algoritmos \u00e9 fazer compara\u00e7\u00f5es significativas entre algoritmos, mas h\u00e1 alguns problemas: O desempenho relativo dos algoritmos pode depender de caracter\u00edsticas do hardware; ent\u00e3o um algoritmo pode ser mais r\u00e1pido na M\u00e1quina A, e outro na M\u00e1quina B. A solu\u00e7\u00e3o geral para este problema \u00e9 especificar um modelo de m\u00e1quina e analisar o n\u00famero de passos ou opera\u00e7\u00f5es que um algoritmo exige sob um modelo dado. O desempenho relativo pode depender dos detalhes do conjunto de dados. Por exemplo, alguns algoritmos de ordena\u00e7\u00e3o rodam mais r\u00e1pido se os dados j\u00e1 foram parcialmente ordenados; outros algoritmos rodam mais devagar neste caso. Uma forma comum de evitar este problema \u00e9 analisar o pior caso. \u00c0s vezes \u00e9 \u00fatil analisar o desempenho de casos m\u00e9dios, mas isso \u00e9 normalmente mais dif\u00edcil, e pode n\u00e3o ser \u00f3bvio qual conjunto de casos deve ser usado para a m\u00e9dia. O desempenho relativo tamb\u00e9m depende do tamanho do problema. Um algoritmo de ordena\u00e7\u00e3o que \u00e9 r\u00e1pido para pequenas listas pode ser lento para longas listas. A solu\u00e7\u00e3o habitual para este problema \u00e9 expressar o tempo de execu\u00e7\u00e3o (ou o n\u00famero de opera\u00e7\u00f5es) como uma fun\u00e7\u00e3o do tamanho de problema e fun\u00e7\u00f5es de grupo em categorias que dependem de sua velocidade de crescimento quando o tamanho de problema aumenta. Uma coisa boa sobre este tipo de compara\u00e7\u00e3o \u00e9 que ela \u00e9 pr\u00f3pria para a classifica\u00e7\u00e3o simples de algoritmos. Por exemplo, se souber que o tempo de execu\u00e7\u00e3o do algoritmo A tende a ser proporcional ao tamanho da entrada n, e o algoritmo B tende a ser proporcional a n2, ent\u00e3o espero que A seja mais r\u00e1pido que B, pelo menos para valores grandes de n. Esse tipo de an\u00e1lise tem algumas desvantagens, mas falaremos disso mais adiante.","title":"Ap\u00eandice B: An\u00e1lise de algoritmos"},{"location":"B-analise-algorit/#b1-ordem-de-crescimento","text":"Vamos supor que voc\u00ea analisou dois algoritmos e expressou seus tempos de execu\u00e7\u00e3o em rela\u00e7\u00e3o ao tamanho da entrada: o algoritmo A leva 100n+1 passos para resolver um problema com o tamanho n; o algoritmo B leva n2 + n + 1 passos. A tabela seguinte mostra o tempo de execu\u00e7\u00e3o desses algoritmos para tamanhos de problema diferentes: Tamanho da entrada Tempo de execu\u00e7\u00e3o do algoritmo A Tempo de execu\u00e7\u00e3o do algoritmo B 10 1 001 111 100 10 001 10 101 1 000 100 001 1 001 001 10 000 1 000 001 > 1010 Ao chegar em n=10, o algoritmo A parece bem ruim; ele \u00e9 quase dez vezes mais longo que o algoritmo B. No entanto, para n=100 eles s\u00e3o bem parecidos, e, para valores maiores, A \u00e9 muito melhor. A raz\u00e3o fundamental \u00e9 que para grandes valores de n, qualquer fun\u00e7\u00e3o que contenha um termo n2 ser\u00e1 mais r\u00e1pida que uma fun\u00e7\u00e3o cujo termo principal seja n. O termo principal \u00e9 o que tem o expoente mais alto. Para o algoritmo A, o termo principal tem um grande coeficiente, 100, que \u00e9 a raz\u00e3o de B ser melhor que A para um valor pequeno de n. Entretanto, apesar dos coeficientes, sempre haver\u00e1 algum valor de n em que an2 > bn, para valores de a e b. O mesmo argumento se aplica aos termos que n\u00e3o s\u00e3o principais. Mesmo se o tempo de execu\u00e7\u00e3o do algoritmo A fosse n+1000000, ainda seria melhor que o algoritmo B para um valor suficientemente grande de n. Em geral, esperamos que um algoritmo com um termo principal menor seja um algoritmo melhor para grandes problemas, mas, para problemas menores, pode haver um ponto de desvio onde outro algoritmo seja melhor. A posi\u00e7\u00e3o do ponto de desvio depende dos detalhes dos algoritmos, das entradas e do hardware; ent\u00e3o, ele \u00e9 normalmente ignorado para os prop\u00f3sitos da an\u00e1lise algor\u00edtmica. Por\u00e9m, isso n\u00e3o significa que voc\u00ea pode se esquecer dele. Se dois algoritmos tiverem o mesmo termo principal de ordem, \u00e9 dif\u00edcil dizer qual \u00e9 melhor; mais uma vez, a resposta depende dos detalhes. Assim, para a an\u00e1lise algor\u00edtmica, fun\u00e7\u00f5es com o mesmo termo principal s\u00e3o consideradas equivalentes, mesmo se tiverem coeficientes diferentes. Uma ordem de crescimento \u00e9 um conjunto de fun\u00e7\u00f5es cujo comportamento de crescimento \u00e9 considerado equivalente. Por exemplo, 2n, 100n e n+1 pertencem \u00e0 mesma ordem de crescimento, que se escreve O(n) em nota\u00e7\u00e3o Grande-O e muitas vezes \u00e9 chamada de linear, porque cada fun\u00e7\u00e3o no conjunto cresce linearmente em rela\u00e7\u00e3o a n. Todas as fun\u00e7\u00f5es com o termo principal n2 pertencem a O(n2); elas s\u00e3o chamadas de quadr\u00e1ticas. A tabela seguinte mostra algumas ordens de crescimento mais comuns na an\u00e1lise algor\u00edtmica, em ordem crescente de complexidade. Ordem de crescimento Nome O(1) constante O(logb n) logar\u00edtmica (para qualquer b) O(n) linear O(n logb n) log-linear O(n2) quadr\u00e1tica O(n3) c\u00fabica O(cn) exponencial (para qualquer c) Para os termos logar\u00edtmicos, a base do logaritmo n\u00e3o importa; a altera\u00e7\u00e3o de bases \u00e9 o equivalente da multiplica\u00e7\u00e3o por uma constante, o que n\u00e3o altera a ordem de crescimento. De forma similar, todas as fun\u00e7\u00f5es exponenciais pertencem \u00e0 mesma ordem de crescimento, apesar da base do expoente. As fun\u00e7\u00f5es exponenciais crescem muito rapidamente, ent\u00e3o os algoritmos exponenciais s\u00f3 s\u00e3o \u00fateis para pequenos problemas.","title":"B.1 - Ordem de crescimento"},{"location":"B-analise-algorit/#exercicio-b1","text":"Leia a p\u00e1gina da Wikip\u00e9dia sobre a nota\u00e7\u00e3o Grande-O (Big-Oh notation) em http://en.wikipedia.org/wiki/Big_O_notation e responda \u00e0s seguintes perguntas: 1. Qual \u00e9 a ordem de crescimento de n3 + n2? E de 1000000n3 + n2? Ou de n3 + 1000000n2? 2. Qual \u00e9 a ordem de crescimento de (n2 + n) . (n + 1)? Antes de come\u00e7ar a multiplicar, lembre-se de que voc\u00ea s\u00f3 precisa do termo principal. 3. Se f est\u00e1 em O(g), para alguma fun\u00e7\u00e3o n\u00e3o especificada g, o que podemos dizer de af+b? 4. Se f1 e f2 est\u00e3o em O(g), o que podemos dizer a respeito de f1 + f2? 5. Se f1 est\u00e1 em O(g) e f2 est\u00e1 em O(h), o que podemos dizer a respeito de f1 + f2? 6. Se f1 est\u00e1 em O(g) e f2 \u00e9 O(h), o que podemos dizer a respeito de f1 . f2? Programadores que se preocupam com o desempenho muitas vezes consideram esse tipo de an\u00e1lise dif\u00edcil de engolir. A raz\u00e3o para isso \u00e9: \u00e0s vezes os coeficientes e os termos n\u00e3o principais fazem muita diferen\u00e7a. Os detalhes do hardware, a linguagem de programa\u00e7\u00e3o e as caracter\u00edsticas da entrada fazem grande diferen\u00e7a. E para pequenos problemas, o comportamento assint\u00f3tico \u00e9 irrelevante. Por\u00e9m, se mantiver essas quest\u00f5es em mente, a an\u00e1lise algor\u00edtmica pode ser uma ferramenta \u00fatil. Pelo menos para grandes problemas, os \u201cmelhores\u201d algoritmos s\u00e3o normalmente melhores, e, \u00e0s vezes, muito melhores. A diferen\u00e7a entre dois algoritmos com a mesma ordem de crescimento \u00e9 normalmente um fator constante, mas a diferen\u00e7a entre um bom algoritmo e um algoritmo ruim \u00e9 ilimitada!","title":"Exerc\u00edcio B.1"},{"location":"B-analise-algorit/#b2-analise-de-operacoes-basicas-do-python","text":"No Python, a maior parte das opera\u00e7\u00f5es aritm\u00e9ticas tem um tempo constante; a multiplica\u00e7\u00e3o normalmente leva mais tempo que a adi\u00e7\u00e3o e a subtra\u00e7\u00e3o, e a divis\u00e3o leva at\u00e9 mais tempo, mas esses tempos de execu\u00e7\u00e3o n\u00e3o dependem da magnitude dos operandos. Os n\u00fameros inteiros muito grandes s\u00e3o uma exce\u00e7\u00e3o; nesse caso, o tempo de execu\u00e7\u00e3o aumenta com o n\u00famero de d\u00edgitos. Opera\u00e7\u00f5es de indexa\u00e7\u00e3o \u2013 ler ou escrever elementos em uma sequ\u00eancia ou dicion\u00e1rio \u2013 tamb\u00e9m t\u00eam tempo constante, n\u00e3o importa o tamanho da estrutura de dados. Um loop for que atravesse uma sequ\u00eancia ou dicion\u00e1rio \u00e9 normalmente linear, desde que todas as opera\u00e7\u00f5es no corpo do loop sejam de tempo constante. Por exemplo, somar os elementos de uma lista \u00e9 linear: total = 0 for x in t: total += x A fun\u00e7\u00e3o integrada sum tamb\u00e9m \u00e9 linear porque faz a mesma coisa, mas tende a ser mais r\u00e1pida porque \u00e9 uma implementa\u00e7\u00e3o mais eficiente; na linguagem da an\u00e1lise algor\u00edtmica, tem um coeficiente principal menor. Via de regra, se o corpo de um loop est\u00e1 em O(na), ent\u00e3o o loop inteiro est\u00e1 em O(na + 1). A exce\u00e7\u00e3o \u00e9 se voc\u00ea puder mostrar que o loop encerra depois de um n\u00famero constante de itera\u00e7\u00f5es. Se um loop \u00e9 executado k vezes, n\u00e3o importa o valor de n, ent\u00e3o o loop est\u00e1 em O(na), mesmo para valores grandes de k. A multiplica\u00e7\u00e3o por k n\u00e3o altera a ordem de crescimento, nem a divis\u00e3o. Ent\u00e3o, se o corpo de um loop est\u00e1 em O(na) e \u00e9 executado n/k vezes, o loop est\u00e1 em O(na + 1), mesmo para valores grandes de k. A maior parte das opera\u00e7\u00f5es de strings e tuplas s\u00e3o lineares, exceto a indexa\u00e7\u00e3o e len, que s\u00e3o de tempo constante. As fun\u00e7\u00f5es integradas min e max s\u00e3o lineares. O tempo de execu\u00e7\u00e3o de uma opera\u00e7\u00e3o de fatia \u00e9 proporcional ao comprimento da sa\u00edda, mas n\u00e3o depende do tamanho da entrada. A concatena\u00e7\u00e3o de strings \u00e9 linear; o tempo de execu\u00e7\u00e3o depende da soma dos comprimentos dos operandos. Todos os m\u00e9todos de string s\u00e3o lineares, mas se os comprimentos das strings forem limitados por uma constante \u2013 por exemplo, opera\u00e7\u00f5es em caracteres \u00fanicos \u2013 s\u00e3o consideradas de tempo constante. O m\u00e9todo de string join \u00e9 linear; o tempo de execu\u00e7\u00e3o depende do comprimento total das strings. A maior parte dos m\u00e9todos de lista s\u00e3o lineares, mas h\u00e1 algumas exce\u00e7\u00f5es: A soma de um elemento ao fim de uma lista \u00e9 de tempo constante em m\u00e9dia; quando o espa\u00e7o acaba, ela ocasionalmente \u00e9 copiada a uma posi\u00e7\u00e3o maior, mas o tempo total de opera\u00e7\u00f5es n \u00e9 O(n), portanto o tempo m\u00e9dio de cada opera\u00e7\u00e3o \u00e9 O(1). A remo\u00e7\u00e3o de um elemento do fim de uma lista \u00e9 de tempo constante. A ordena\u00e7\u00e3o \u00e9 O(n log n). A maior parte das opera\u00e7\u00f5es e m\u00e9todos de dicion\u00e1rio s\u00e3o de tempo constante, mas h\u00e1 algumas exce\u00e7\u00f5es: O tempo de execu\u00e7\u00e3o de update \u00e9 proporcional ao tamanho do dicion\u00e1rio passado como par\u00e2metro, n\u00e3o o dicion\u00e1rio que est\u00e1 sendo atualizado. keys, values e items s\u00e3o de tempo constante porque retornam iteradores. Por\u00e9m, se fizer um loop pelos iteradores, o loop ser\u00e1 linear. O desempenho de dicion\u00e1rios \u00e9 um dos milagres menores da ci\u00eancia da computa\u00e7\u00e3o. Vemos como funcionam em \u201cHashtables\u201d, na p\u00e1gina 302.","title":"B.2 - An\u00e1lise de opera\u00e7\u00f5es b\u00e1sicas do Python"},{"location":"B-analise-algorit/#exercicio-b2","text":"Leia a p\u00e1gina da Wikip\u00e9dia sobre algoritmos de ordena\u00e7\u00e3o em http://en.wikipedia.org/wiki/Sorting_algorithm e responda \u00e0s seguintes perguntas: 1. O que \u00e9 um \u201ctipo de compara\u00e7\u00e3o\u201d? Qual \u00e9 a melhor op\u00e7\u00e3o nos casos de pior cen\u00e1rio de ordem de crescimento para um tipo de compara\u00e7\u00e3o? Qual \u00e9 a melhor op\u00e7\u00e3o nos casos de pior cen\u00e1rio de ordem de crescimento para qualquer algoritmo de ordena\u00e7\u00e3o? 2. Qual \u00e9 a ordem de crescimento do tipo bolha, e por que Barack Obama acha que \u201cn\u00e3o \u00e9 a escolha certa\u201d? 3. Qual \u00e9 a ordem de crescimento do tipo radix? Quais s\u00e3o as precondi\u00e7\u00f5es necess\u00e1rias para us\u00e1-la? 4. O que \u00e9 um tipo est\u00e1vel e qual \u00e9 sua import\u00e2ncia na pr\u00e1tica? 5. Qual \u00e9 o pior algoritmo de ordena\u00e7\u00e3o (que tenha um nome)? 6. Que algoritmo de ordena\u00e7\u00e3o a biblioteca C usa? Que algoritmo de ordena\u00e7\u00e3o o Python usa? Esses algoritmos s\u00e3o est\u00e1veis? Voc\u00ea pode ter que pesquisar no Google para encontrar essas respostas. Muitos dos tipos de n\u00e3o compara\u00e7\u00e3o s\u00e3o lineares, ent\u00e3o, por que o Python usa um tipo de compara\u00e7\u00e3o O(n log n)?","title":"Exerc\u00edcio B.2"},{"location":"B-analise-algorit/#b3-analise-de-algoritmos-de-busca","text":"Uma busca \u00e9 um algoritmo que recebe uma cole\u00e7\u00e3o e um item de objetivo e determina se o objetivo est\u00e1 na cole\u00e7\u00e3o, muitas vezes retornando o \u00edndice do objetivo. O algoritmo de busca mais simples \u00e9 uma \u201cbusca linear\u201d, que atravessa os itens da cole\u00e7\u00e3o em ordem, parando se encontrar o objetivo. No pior caso, ele tem que atravessar a cole\u00e7\u00e3o inteira, ent\u00e3o o tempo de execu\u00e7\u00e3o \u00e9 linear. O operador in para sequ\u00eancias usa uma busca linear; assim como m\u00e9todos de string como find e count. Se os elementos da sequ\u00eancia estiverem em ordem, voc\u00ea pode usar uma busca por bisse\u00e7\u00e3o, que \u00e9 O(log n). A busca por bisse\u00e7\u00e3o \u00e9 semelhante ao algoritmo que voc\u00ea poderia usar para procurar uma palavra em um dicion\u00e1rio (um dicion\u00e1rio de papel, n\u00e3o a estrutura de dados). Em vez de come\u00e7ar no in\u00edcio e verificar cada item em ordem, voc\u00ea come\u00e7a com o item do meio e verifica se a palavra que est\u00e1 procurando vem antes ou depois. Se vier antes, ent\u00e3o procura na primeira metade da sequ\u00eancia. Se n\u00e3o, procura na segunda metade. Seja como for, voc\u00ea corta o n\u00famero de itens restantes pela metade. Se a sequ\u00eancia tiver um milh\u00e3o de itens, ser\u00e3o necess\u00e1rios cerca de 20 passos para encontrar a palavra ou concluir que n\u00e3o est\u00e1 l\u00e1. Ent\u00e3o \u00e9 aproximadamente 50 mil vezes mais r\u00e1pido que uma busca linear. A busca por bisse\u00e7\u00e3o pode ser muito mais r\u00e1pida que a busca linear, mas \u00e9 preciso que a sequ\u00eancia esteja em ordem, o que pode exigir trabalho extra. H\u00e1 outra estrutura de dados chamada hashtable, que \u00e9 at\u00e9 mais r\u00e1pida \u2013 voc\u00ea pode fazer uma busca em tempo constante \u2013 e ela n\u00e3o exige que os itens estejam ordenados. Os dicion\u00e1rios do Python s\u00e3o implementados usando hashtables e \u00e9 por isso a maior parte das opera\u00e7\u00f5es de dicion\u00e1rio, incluindo o operador in, s\u00e3o de tempo constante.","title":"B.3 - An\u00e1lise de algoritmos de busca"},{"location":"B-analise-algorit/#b4-hashtables","text":"Para explicar como hashtables funcionam e por que o seu desempenho \u00e9 t\u00e3o bom, come\u00e7o com uma implementa\u00e7\u00e3o simples de um mapa e vou melhor\u00e1-lo gradualmente at\u00e9 que seja uma hashtable. Uso o Python para demonstrar essas implementa\u00e7\u00f5es, mas, na vida real, eu n\u00e3o escreveria um c\u00f3digo como esse no Python; bastaria usar um dicion\u00e1rio! Assim, para o resto deste cap\u00edtulo, voc\u00ea tem que supor que os dicion\u00e1rios n\u00e3o existem e que quer implementar uma estrutura de dados que fa\u00e7a o mapa de chaves a valores. As opera\u00e7\u00f5es que precisa implementar s\u00e3o: add(k, v) Insere um novo item que mapeia a chave k ao valor v. Com um dicion\u00e1rio de Python, `d`, essa opera\u00e7\u00e3o \u00e9 escrita `d[k] = v`. get(k) Procura e devolve o valor que corresponde \u00e0 chave k. Com um dicion\u00e1rio de Python, `d`, esta opera\u00e7\u00e3o \u00e9 escrita `d[k]` ou `d.get(k)`. Por enquanto, vou supor que cada chave s\u00f3 apare\u00e7a uma vez. A implementa\u00e7\u00e3o mais simples desta interface usa uma lista de tuplas, onde cada tupla \u00e9 um par chave-valor: class LinearMap: def __init__(self): self.items = [] def add(self, k, v): self.items.append((k, v)) def get(self, k): for key, val in self.items: if key == k: return val raise KeyError add acrescenta uma tupla chave-valor \u00e0 lista de itens, o que tem tempo constante. get usa um loop for para buscar na lista: se encontrar a chave-alvo, retorna o valor correspondente; do contr\u00e1rio, exibe um KeyError. Ent\u00e3o get \u00e9 linear. Uma alternativa \u00e9 manter uma lista ordenada por chaves. Assim, get poderia usar uma busca por bisse\u00e7\u00e3o, que \u00e9 O(log n). Por\u00e9m, inserir um novo item no meio de uma lista \u00e9 linear, ent\u00e3o isso pode n\u00e3o ser a melhor op\u00e7\u00e3o. H\u00e1 outras estruturas de dados que podem implementar add e get em tempo logar\u00edtmico, mas isso n\u00e3o \u00e9 t\u00e3o bom como tempo constante, ent\u00e3o vamos continuar. Uma forma de melhorar LinearMap \u00e9 quebrar a lista de pares chave-valor em listas menores. Aqui est\u00e1 uma implementa\u00e7\u00e3o chamada BetterMap , que \u00e9 uma lista de cem LinearMaps. Como veremos em um segundo, a ordem de crescimento para get ainda \u00e9 linear, mas BetterMap \u00e9 um passo no caminho em dire\u00e7\u00e3o a hashtables: class BetterMap: def __init__(self, n=100): self.maps = [] for i in range(n): self.maps.append(LinearMap()) def find_map(self, k): index = hash(k) % len(self.maps) return self.maps[index] def add(self, k, v): m = self.find_map(k) m.add(k, v) def get(self, k): m = self.find_map(k) return m.get(k) __init__ cria uma lista de n LinearMaps. find_map \u00e9 usada por add e get para saber em qual mapa o novo item deve ir ou em qual mapa fazer a busca. find_map usa a fun\u00e7\u00e3o integrada hash, que recebe quase qualquer objeto do Python e retorna um n\u00famero inteiro. Uma limita\u00e7\u00e3o desta implementa\u00e7\u00e3o \u00e9 que ela s\u00f3 funciona com chaves hashable. Tipos mut\u00e1veis como listas e dicion\u00e1rios n\u00e3o s\u00e3o hashable. Objetos hashable considerados equivalentes retornam o mesmo valor hash, mas o oposto n\u00e3o \u00e9 necessariamente verdade: dois objetos com valores diferentes podem retornar o mesmo valor hash. find_map usa o operador m\u00f3dulo para manter os valores hash no intervalo de 0 a len(self.maps), ent\u00e3o o resultado \u00e9 um \u00edndice legal na lista. Naturalmente, isso significa que muitos valores hash diferentes ser\u00e3o reunidos no mesmo \u00edndice. Entretanto, se a fun\u00e7\u00e3o hash dispersar as coisas de forma consistente (que \u00e9 o que as fun\u00e7\u00f5es hash foram projetadas para fazer), ent\u00e3o esperamos ter n/100 itens por LinearMap . Como o tempo de execu\u00e7\u00e3o de LinearMap.get \u00e9 proporcional ao n\u00famero de itens, esperamos que BetterMap seja aproximadamente cem vezes mais r\u00e1pido que LinearMap . A ordem de crescimento ainda \u00e9 linear, mas o coeficiente principal \u00e9 menor. Isto \u00e9 bom, mas n\u00e3o t\u00e3o bom quanto uma hashtable. Aqui (finalmente) est\u00e1 a ideia crucial que faz hashtables serem r\u00e1pidas: se puder limitar o comprimento m\u00e1ximo de LinearMaps, LinearMap.get \u00e9 de tempo constante. Tudo o que voc\u00ea precisa fazer \u00e9 rastrear o n\u00famero de itens e quando o n\u00famero de itens por LinearMap exceder o limite, alterar o tamanho da hashtable acrescentando LinearMaps. Aqui est\u00e1 uma implementa\u00e7\u00e3o de uma hashtable: class HashMap: def __init__(self): self.maps = BetterMap(2) self.num = 0 def get(self, k): return self.maps.get(k) def add(self, k, v): if self.num == len(self.maps.maps): self.resize() self.maps.add(k, v) self.num += 1 def resize(self): new_maps = BetterMap(self.num * 2) for m in self.maps.maps: for k, v in m.items: new_maps.add(k, v) self.maps = new_maps Cada HashMap cont\u00e9m um BetterMap ; __init__ inicia com apenas dois LinearMaps e inicializa num, que monitora o n\u00famero de itens. get apenas despacha para BetterMap . O verdadeiro trabalho acontece em add, que verifica o n\u00famero de itens e o tamanho de BetterMap : se forem iguais, o n\u00famero m\u00e9dio de itens por LinearMap \u00e9 um, ent\u00e3o resize \u00e9 chamada. resize faz um novo BetterMap duas vezes maior que o anterior, e ent\u00e3o \u201credispersa\u201d os itens do mapa antigo no novo. A redispers\u00e3o \u00e9 necess\u00e1ria porque alterar o n\u00famero de LinearMaps muda o denominador do operador m\u00f3dulo em find_map . Isso significa que alguns objetos que costumavam ser dispersos no mesmo LinearMap ser\u00e3o separados (que \u00e9 o que quer\u00edamos, certo?). A redispers\u00e3o \u00e9 linear, ent\u00e3o resize \u00e9 linear, o que pode parecer ruim, j\u00e1 que prometi que add seria de tempo constante. Entretanto, lembre-se de que n\u00e3o temos que alterar o tamanho a cada vez, ent\u00e3o add normalmente \u00e9 de tempo constante e s\u00f3 ocasionalmente linear. O volume total de trabalho para executar add n vezes \u00e9 proporcional a n, ent\u00e3o o tempo m\u00e9dio de cada add \u00e9 de tempo constante! Para ver como isso funciona, pense como seria come\u00e7ar com uma HashTable vazia e inserir uma s\u00e9rie de itens. Come\u00e7amos com dois LinearMaps, ent\u00e3o as duas primeiras inser\u00e7\u00f5es s\u00e3o r\u00e1pidas (n\u00e3o \u00e9 necess\u00e1rio alterar o tamanho). Digamos que elas tomem uma unidade do trabalho cada uma. A pr\u00f3xima inser\u00e7\u00e3o exige uma altera\u00e7\u00e3o de tamanho, ent\u00e3o temos de redispersar os dois primeiros itens (vamos chamar isso de mais duas unidades de trabalho) e ent\u00e3o acrescentar o terceiro item (mais uma unidade). Acrescentar o pr\u00f3ximo item custa uma unidade, ent\u00e3o o total, por enquanto, \u00e9 de seis unidades de trabalho para quatro itens. O pr\u00f3ximo add custa cinco unidades, mas os tr\u00eas seguintes s\u00e3o s\u00f3 uma unidade cada um, ent\u00e3o o total \u00e9 de 14 unidades para as primeiras oito inser\u00e7\u00f5es. O pr\u00f3ximo add custa nove unidades, mas ent\u00e3o podemos inserir mais sete antes da pr\u00f3xima altera\u00e7\u00e3o de tamanho, ent\u00e3o o total \u00e9 de 30 unidades para as primeiras 16 inser\u00e7\u00f5es. Depois de 32 inser\u00e7\u00f5es, o custo total \u00e9 de 62 unidades, e espero que voc\u00ea esteja come\u00e7ando a ver um padr\u00e3o. Depois de n inser\u00e7\u00f5es, nas quais n \u00e9 uma pot\u00eancia de dois, o custo total \u00e9 de 2n-2 unidades, ent\u00e3o o trabalho m\u00e9dio por inser\u00e7\u00e3o \u00e9 um pouco menos de duas unidades. Quando n \u00e9 uma pot\u00eancia de dois, esse \u00e9 o melhor caso; para outros valores de n, o trabalho m\u00e9dio \u00e9 um pouco maior, mas isso n\u00e3o \u00e9 importante. O importante \u00e9 que seja O(1). A Figura 21.1 mostra graficamente como isso funciona. Cada bloco representa uma unidade de trabalho. As colunas mostram o trabalho total para cada inser\u00e7\u00e3o na ordem da esquerda para a direita: os primeiros dois adds custam uma unidade, o terceiro custa tr\u00eas unidades etc. Figura B.1 \u2013 O custo de inser\u00e7\u00f5es em uma hashtable. O trabalho extra de redispers\u00e3o aparece como uma sequ\u00eancia de torres cada vez mais altas com um aumento de espa\u00e7o entre elas. Agora, se derrubar as torres, espalhando o custo de alterar o tamanho por todas as inser\u00e7\u00f5es, poder\u00e1 ver graficamente que o custo total depois de n inser\u00e7\u00f5es \u00e9 de 2n \u2212 2. Uma caracter\u00edstica importante deste algoritmo \u00e9 que quando alteramos o tamanho da HashTable, ela cresce geometricamente; isto \u00e9, multiplicamos o tamanho por uma constante. Se voc\u00ea aumentar o tamanho aritmeticamente \u2013 somando um n\u00famero fixo de cada vez \u2013 o tempo m\u00e9dio por add \u00e9 linear. Voc\u00ea pode baixar minha implementa\u00e7\u00e3o de HashMap em http://thinkpython2.com/code/Map.py, mas lembre-se de que n\u00e3o h\u00e1 raz\u00e3o para us\u00e1-la; se quiser um mapa, basta usar um dicion\u00e1rio do Python.","title":"B.4 - Hashtables"},{"location":"B-analise-algorit/#b5-glossario","text":"an\u00e1lise de algoritmos Forma de comparar algoritmos quanto \u00e0s suas exig\u00eancias de espa\u00e7o e/ou tempo de execu\u00e7\u00e3o. modelo de m\u00e1quina Representa\u00e7\u00e3o simplificada de um computador usada para descrever algoritmos. pior caso Entrada que faz um dado algoritmo rodar mais lentamente (ou exigir mais espa\u00e7o). termo principal Em um polin\u00f4mio, o termo com o expoente mais alto. ponto de desvio Tamanho do problema em que dois algoritmos exigem o mesmo tempo de execu\u00e7\u00e3o ou espa\u00e7o. ordem de crescimento Conjunto de fun\u00e7\u00f5es em que todas crescem em uma forma considerada equivalente para os prop\u00f3sitos da an\u00e1lise de algoritmos. Por exemplo, todas as fun\u00e7\u00f5es que crescem linearmente pertencem \u00e0 mesma ordem de crescimento. nota\u00e7\u00e3o Grande-O (Big-Oh notation) Nota\u00e7\u00e3o para representar uma ordem de crescimento; por exemplo, O(n) representa o conjunto de fun\u00e7\u00f5es que crescem linearmente. linear Algoritmo cujo tempo de execu\u00e7\u00e3o \u00e9 proporcional ao tamanho do problema, pelo menos para grandes tamanhos de problema. quadr\u00e1tico Algoritmo cujo tempo de execu\u00e7\u00e3o \u00e9 proporcional a n2, onde n \u00e9 uma medida de tamanho do problema. busca Problema de localizar um elemento de uma cole\u00e7\u00e3o (como uma lista ou dicion\u00e1rio) ou de decidir que n\u00e3o est\u00e1 presente. hashtable Estrutura de dados que representa uma cole\u00e7\u00e3o de pares chave-valor e executa buscas em tempo constante. [1] popen foi descartado, ou seja, devemos parar de us\u00e1-lo e come\u00e7ar a usar o m\u00f3dulo subprocess. Entretanto, para casos simples, eu considero subprocess mais complicado que o necess\u00e1rio. Ent\u00e3o vou continuar usando popen at\u00e9 que o removam. [2] Mas se fizerem uma pergunta como essa em uma entrevista, creio que a melhor resposta \u00e9 \u201cA forma mais r\u00e1pida de classificar um milh\u00e3o de n\u00fameros inteiros \u00e9 usar qualquer fun\u00e7\u00e3o de ordena\u00e7\u00e3o oferecida pela linguagem que estou usando. Se o desempenho \u00e9 bom o suficiente para a grande maioria das aplica\u00e7\u00f5es, mas a minha aplica\u00e7\u00e3o acabasse sendo lenta demais, eu usaria algum recurso para investigar onde o tempo est\u00e1 sendo gasto. Se parecesse que um algoritmo mais r\u00e1pido teria um efeito significativo sobre o desempenho, ent\u00e3o procuraria uma boa implementa\u00e7\u00e3o do tipo radix\u201d.","title":"B.5 - Gloss\u00e1rio"},{"location":"C-colofao-autor/","text":"Colof\u00e3o O animal na capa de Pense em Python \u00e9 um papagaio-da-carolina, tamb\u00e9m conhecido como periquito-da-carolina (Conuropsis carolinensis). Este papagaio habitava o sudeste dos Estados Unidos e foi o \u00fanico papagaio continental a habitar regi\u00f5es acima do norte do M\u00e9xico. Um dia, vivia no norte, em locais t\u00e3o distantes quanto Nova Iorque e os Grandes Lagos, embora fosse encontrado principalmente na regi\u00e3o da Fl\u00f3rida \u00e0s Carolinas. O papagaio-da-carolina era quase todo verde com a cabe\u00e7a amarela e, na maturidade, tinha uma colora\u00e7\u00e3o laranja na testa e na face. Seu tamanho m\u00e9dio variava de 31 a 33 cm. Tinha uma voz alta, ruidosa e palrava constantemente enquanto se alimentava. Habitava troncos de \u00e1rvores ocos perto de brejos e barrancos. O papagaio-da-carolina era um animal muito greg\u00e1rio, que vivia em pequenos grupos os quais podiam chegar a v\u00e1rias centenas quando se alimentavam. Infelizmente, essas \u00e1reas de alimenta\u00e7\u00e3o muitas vezes eram as planta\u00e7\u00f5es de agricultores, que disparavam nos p\u00e1ssaros para mant\u00ea-los longe das plantas. A natureza social dos p\u00e1ssaros fazia com que eles voassem ao resgate de qualquer papagaio ferido, permitindo aos agricultores derrubar bandos inteiros de cada vez. Al\u00e9m disso, suas penas eram usadas para embelezar chap\u00e9us de senhoras, e alguns papagaios eram mantidos como mascotes. Uma combina\u00e7\u00e3o desses fatores levou o papagaio-da-carolina a tornar-se raro no fim dos anos 1800, e as doen\u00e7as de aves dom\u00e9sticas podem ter contribu\u00eddo para diminuir seu n\u00famero. Pelos anos 1920, a esp\u00e9cie estava extinta. Hoje, h\u00e1 mais de 700 esp\u00e9cimes de papagaios-da-carolina conservados em museus no mundo inteiro. Muitos dos animais nas capas de livros da O\u2019Reilly est\u00e3o em perigo de extin\u00e7\u00e3o; todos eles s\u00e3o importantes para o mundo. Para saber mais sobre como voc\u00ea pode ajudar, acesse animals.oreilly.com. A imagem da capa \u00e9 do livro Johnson\u2019s Natural History. Sobre o autor Allen Downey \u00e9 professor de Ci\u00eancia da Computa\u00e7\u00e3o no Olin College of Engineering. Ele j\u00e1 ensinou no Wellesley College, Colby College e na U.C. Berkeley. \u00c9 doutor em Ci\u00eancia da Computa\u00e7\u00e3o pela U.C. Berkeley e mestre e graduado pelo MIT.","title":"Colof\u00e3o"},{"location":"C-colofao-autor/#colofao","text":"O animal na capa de Pense em Python \u00e9 um papagaio-da-carolina, tamb\u00e9m conhecido como periquito-da-carolina (Conuropsis carolinensis). Este papagaio habitava o sudeste dos Estados Unidos e foi o \u00fanico papagaio continental a habitar regi\u00f5es acima do norte do M\u00e9xico. Um dia, vivia no norte, em locais t\u00e3o distantes quanto Nova Iorque e os Grandes Lagos, embora fosse encontrado principalmente na regi\u00e3o da Fl\u00f3rida \u00e0s Carolinas. O papagaio-da-carolina era quase todo verde com a cabe\u00e7a amarela e, na maturidade, tinha uma colora\u00e7\u00e3o laranja na testa e na face. Seu tamanho m\u00e9dio variava de 31 a 33 cm. Tinha uma voz alta, ruidosa e palrava constantemente enquanto se alimentava. Habitava troncos de \u00e1rvores ocos perto de brejos e barrancos. O papagaio-da-carolina era um animal muito greg\u00e1rio, que vivia em pequenos grupos os quais podiam chegar a v\u00e1rias centenas quando se alimentavam. Infelizmente, essas \u00e1reas de alimenta\u00e7\u00e3o muitas vezes eram as planta\u00e7\u00f5es de agricultores, que disparavam nos p\u00e1ssaros para mant\u00ea-los longe das plantas. A natureza social dos p\u00e1ssaros fazia com que eles voassem ao resgate de qualquer papagaio ferido, permitindo aos agricultores derrubar bandos inteiros de cada vez. Al\u00e9m disso, suas penas eram usadas para embelezar chap\u00e9us de senhoras, e alguns papagaios eram mantidos como mascotes. Uma combina\u00e7\u00e3o desses fatores levou o papagaio-da-carolina a tornar-se raro no fim dos anos 1800, e as doen\u00e7as de aves dom\u00e9sticas podem ter contribu\u00eddo para diminuir seu n\u00famero. Pelos anos 1920, a esp\u00e9cie estava extinta. Hoje, h\u00e1 mais de 700 esp\u00e9cimes de papagaios-da-carolina conservados em museus no mundo inteiro. Muitos dos animais nas capas de livros da O\u2019Reilly est\u00e3o em perigo de extin\u00e7\u00e3o; todos eles s\u00e3o importantes para o mundo. Para saber mais sobre como voc\u00ea pode ajudar, acesse animals.oreilly.com. A imagem da capa \u00e9 do livro Johnson\u2019s Natural History.","title":"Colof\u00e3o"},{"location":"C-colofao-autor/#sobre-o-autor","text":"Allen Downey \u00e9 professor de Ci\u00eancia da Computa\u00e7\u00e3o no Olin College of Engineering. Ele j\u00e1 ensinou no Wellesley College, Colby College e na U.C. Berkeley. \u00c9 doutor em Ci\u00eancia da Computa\u00e7\u00e3o pela U.C. Berkeley e mestre e graduado pelo MIT.","title":"Sobre o autor"}]}